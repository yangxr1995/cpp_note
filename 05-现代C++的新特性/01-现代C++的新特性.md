# C++11

## Template表达式内的空格
```cc
vector<list<int> > ; // 老版本的C++需要将> >添加空格
vector<list<int>> ;  // OK, c++11开始不会把 >> 识别为位移符号
``` 

## nullptr
nullptr是个新关键字。它被自动转换为各种pointer类型，但不会被转换为任何整数类型。
nullptr 取代 NULL，因为编译器无法区分 NULL 和 0
```cc
void f(int)
void f(void *)

f(0); // 调用f(int)
f(NULL); // 二义性
f(nullptr); // 调用f(void *)
```

## auto

C++11允许你声明一个变量或对象（object）而不需要指明其类型，只需说它是auto。例如：
```cc
auto i = 42;
double f();
auto j = f();
```
以 auto声明的变量，其类型会根据其初值被自动推导出来，因此一定需要一个初始化操作：
```cc
auto k; // err 需要初始化
```

## 一致性初始化（Uniform Initialization）与初值列（Initializer List）

在C++11之前，程序员，特别是初学者，很容易被这个问题混淆：如何初始化一个变量或对象。
初始化可因为小括号、大括号或赋值操作符（assignment operator）的出现而发生。

为此C++11引入了“一致性初始化”（uniform initialization）概念，意思是面对任何初始化动作，你可以使用相同语法，也就是使用大括号。

以下皆成立：
```cc
int values[] {1, 2, 3};
vector<string> s {
    "aa", "bb", "cc"
};

int i;   // 未初始化
int j{}; // 初始化为0
int *p;  // 未初始化
int *q{}; // 初始化为nullptr
```

为了支持“用户自定义类型之初值列”（initializer lists for user-defined types）概念，C++11 提供了 `class template std：：initializer_list＜＞`，

用来支持以一系列值（a list of values）进行初始化，或在“你想要处理一系列值（a list of values）”的任何地点进行初始化。例如：

```cc
#include <initializer_list>
#include <iostream>

using namespace std;

void print(initializer_list<int> value)
{
    for (auto i = value.begin(); i != value.end(); ++i)
        cout << *i << endl;
}

int main (int argc, char *argv[]) {
    print({1, 2, 3, 4});
    return 0;
}
```

```cc
class P {
    public:
        P(int, int);
        P(std::initializer_list<int>);
};

int main (int argc, char *argv[]) {
    P p(1, 2);     // P(int, int)
    P q{1 ,2};     // P(std::initializer_list)
    P r{1, 2, 3};  // P(std::initializer_list)
    P s = {1, 2};  // P(std::initializer_list)
    return 0;
}
```

## Range-Based for循环
C++11 引入了一种崭新的 for 循环形式，可以逐一迭代某个给定的区间、数组、集合（range，array，or collection）内的每一个元素。其他编程语言可能称此为 foreach循环。其一般性语法如下：
```cc
for (decl : coll) {
    statement
}
```
其中decl是给定之coll集合中的每个元素的声明；针对这些元素，给定的statement会被执行。
例如下面针对传入的初值列中的每个元素，调用给定的语句，于是在标准输出装置cout输出元素值：

```cc
for (int i : {1, 2, 3}) {
    cout << i << endl;
}

vector<int> vec;
...
// 这里“声明elem为一个reference”很重要，若不这么做，for循环中的语句会作用在元素的一份local copy身上（当然或许有时候你想要这样）。
for (auto &i : vec) { 
    cout << i << endl;
}
```

一般而言，如果coll提供成员函数begin（）和end（），那么一个range-based for循环声明为
```cc
for (decl : coll) {
    statement
}
```
便等同于
```cc
for (auto _pos = coll.begin(), _end = coll.end(); _pos != _end; ++_pos) {
    decl = _*pos;
    statement
}
```

或者如果不满足上述条件，那么也等同于以下使用一个全局性begin（）和end（）且两者都接受coll为实参：
```cc
for (auto _pos = begin(coll), _end = end(coll); _pos != _end; ++_pos) {
    decl = _*pos;
    statement
}
```

当元素在for循环中被初始化为decl，不得有任何显式类型转换（explicit type conversion）。因此下面的代码无法通过编译：
```cc
class A {
    public:
        explicit A(const std::string &s); // 强制编译器只能使用显示类型转换
        ...
};

std::vector<std::string> vs;
...
for (const A &elem : vs) { // ERROR: 无法隐式的将 string 转换为 A 对象 
    cout << elem << endl;
}
```

## explicit 
explicit 关键字主要用于禁止构造函数或转换运算符的隐式类型转换，强制要求开发者进行显式调用，从而避免意外的类型转换导致的逻辑错误或歧义。

 一、基本作用与设计目的
1. 防止隐式构造转换
当类的构造函数只有一个参数，或除第一个参数外其余参数均有默认值时，该构造函数可能被编译器用于隐式类型转换。explicit 会阻止这种隐式转换，要求必须显式调用构造函数。
示例对比：

```cc
// 无 explicit：允许隐式转换
class Implicit {
public:
    Implicit(int x) {}  // 隐式构造函数
};
Implicit obj = 10;      // 合法：编译器隐式调用 Implicit(10)

// 有 explicit：必须显式构造
class Explicit {
public:
    explicit Explicit(int x) {}  // 显式构造函数
};
// Explicit obj = 10;   // 错误：禁止隐式转换
Explicit obj(10);        // 合法：显式调用
```
2. 禁止隐式转换运算符（C++11 起）
explicit 还可修饰用户定义的转换运算符（如 operator bool()），防止类对象在赋值或条件判断中被隐式转换为其他类型。
示例：
```cc
class BoolWrapper {
public:
    explicit operator bool() const { return true; }
};
BoolWrapper wrapper;
// if (wrapper) {...}          // 错误：需显式转换
if (static_cast<bool>(wrapper)) {...} // 合法
```


explicit 修饰的函数，只能进行显示调用，不能隐式调用，

explicit 只能在类定义中修饰函数

C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 
```cc
struct A
{
    A(int) { }      // converting constructor
    A(int, int) { } // converting constructor (C++11)
    operator bool() const { return true; }
};
 
struct B
{
    explicit B(int) { }
    explicit B(int, int) { }
    explicit operator bool() const { return true; }
};
 
int main()
{
    A a1 = 1;      // OK: copy-initialization selects A::A(int)
    A a2(2);       // OK: direct-initialization selects A::A(int)
    A a3 {4, 5};   // OK: direct-list-initialization selects A::A(int, int)
    A a4 = {4, 5}; // OK: copy-list-initialization selects A::A(int, int)
    A a5 = (A)1;   // OK: explicit cast performs static_cast
    if (a1) { }    // OK: A::operator bool()
    bool na1 = a1; // OK: copy-initialization selects A::operator bool()
    bool na2 = static_cast<bool>(a1); // OK: static_cast performs direct-initialization
 
//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)
    B b2(2);       // OK: direct-initialization selects B::B(int)
    B b3 {4, 5};   // OK: direct-list-initialization selects B::B(int, int)
//  B b4 = {4, 5}; // error: copy-list-initialization does not consider B::B(int, int)
    B b5 = (B)1;   // OK: explicit cast performs static_cast
    if (b2) { }    // OK: B::operator bool()
//  bool nb1 = b2; // error: copy-initialization does not consider B::operator bool()
    bool nb2 = static_cast<bool>(b2); // OK: static_cast performs direct-initialization
 
    [](...){}(a4, a5, na1, na2, b5, nb2); // may suppress "unused variable" warnings
}
```

```cc
class P {
    public:
        P(int, int);
        explicit P(std::initializer_list<int>);
};

int main (int argc, char *argv[]) {
    P p(1, 2);     // P(int, int)
    P q{1 ,2};     // P(std::initializer_list)
    P r{1, 2, 3};  // P(std::initializer_list)
    // P s = {1, 2};  // Error 不能进行隐式转换
    return 0;
}
```

## Move语义和 右值引用
C++11的一个最重要的特性就是，支持move semantic（搬迁语义）。
用以避免非必要拷贝（copy）和临时对象（temporary）。

考虑以下代码
```cc
void createAndInsert(std::set<X> &coll)
{
    X x;
    ...
    coll.insert(x);
}
```

在这里我们将新对象插入集合（collection）中，后者提供一个成员函数可为传入的元素建立一份内部拷贝（internal copy）：

```cc
namespace std {
    template <typename T, ...> class set {
        public:
            insert(const T &v);
            ...
    };
}
```

这样的行为是有用的，因为集合（collection）提供value semantic及安插“临时对象”（temporary object）或“安插后会被使用或被改动的对象”的能力：

```cc
X x;
coll.insert(x);
coll.insert(x + x); // 1. 
                    // 创建一个匿名对象 X tmp = x + x
                    // 将匿名对象 tmp 安插到集合 coll中
                    // 由于coll会创建对象tmp的拷贝进行保存
                    // 函数返回后匿名对象tmp无用，所以被销毁

coll.insert(x);     // 2. 之后x不再使用。x相当于匿名对象
                    // 虽然x只有不被使用了，但是在调用insert时，还是创建了x的拷贝以加入集合
```

上面的代码的问题是，对于紧接着无用的对象仍然进行深拷贝

使用右值引用和move语义进行优化

```cc
X x;
coll.insert(x);             // 左值拷贝
coll.insert(x + x);         // 由于insert的参数是匿名对象，所以调用右值拷贝的insert
coll.insert(std::move(x));  // 将x转换为右值类型，以调用右值拷贝的insert
```

move 本身不进行搬运，而是进行类型转换，返回 `T &&` 的类型

当C++能区分左值拷贝和右值拷贝后，就可以定义不同处理逻辑的方法
```cc
class set {
    public:
        insert(const T &x); // 处理左值
        insert(T && x);     // 处理右值
};
```

在 `insert(T &&x)` 中，可以直接搬运 x的深层对象，不需要进行深拷贝。


### Rvalue和Lvalue Reference的重载规则

Rvalue和lvalue的重载规则（overloading rule）如下：
如果你只实现
```cc
void foo(X &)
```
而没有实现`void foo（X&&）`，foo（）可因lvalue但不能因rvalue被调用。

如果你实现
```cc
void foo(const X &)
```
而没有实现`void foo（X&&）`，foo（）可因lvalue也可因rvalue被调用。

如果你实现
```cc
void foo(X &)
void foo(X &&)
```
或

```cc
void foo(const X &)
void foo(X &&)
```

那么可以区分rvalue和lvalue调用。

 如果你实现

```cc
void foo(X&&)
```

但既没有实现`void foo（X&）`也没有实现`void foo（const X&）`，foo（）可因rvalue被调用，
但当你尝试以lvalue调用它，会触发编译错误。


### 返回Rvalue Reference

你不需要也不应该move（）返回值。
```cc
X foo()
{
    X x;
    ...
    return x;
}
```

保证有下列行为：
- 编译器会优先使用RVO
- 否则，如果X有一个move构造函数，X就被moved（搬移）。
- 否则，如果X有一个copy构造函数，X就被copied（复制）。
- 否则，报出一个编译期错误（compile-time error）。

也请注意，如果返回的是个local nonstatic对象，那么返回其rvalue reference是不对的：

是的，rvalue reference也是个reference，如果返回它而它指向（referring to） local对象，意味着你返回一个reference却指向一个不再存在的对象。是否对它使用std::move（）倒是无关紧要。

## noexcept
指明某个函数无法——或不打算——抛出异常
```cc
void foo() noexcept;
```
声明了foo（）不打算抛出异常。若有异常未在foo（）内被处理——亦即如果foo（）抛出异常——程序会被终止，然后std::terminate（）被调用并默认调用std::abort（）

## constexpr
constexpr可用来让表达式在编译期确定结果。例如:
```cc
constexpr int square(int x)
{
    return x * x;
}
int a[square(3)];
```

在C++11前，如下代码
```cc
std::numeric_limits<short>::max();
```
无法被用作一个常量，虽然他在功能上等同于宏 INT_MAX，
如今使用 constexpr 可以用它声明一个数组，并在编译器进行运算
```cc
std::array<float, std::numeric_limits<short>::max()> a;
```
## 变参模板

```cc
// 递归的终止函数
void print()
{
}

template <typename T, typename... Types>
void print(const T& firstArg, const Types&... args)
{
    std::cout << firstArg << endl;
    print(args...); // 递归打印剩余参数
}

int main (int argc, char *argv[]) {

    print(1, "hello", 3.0);

    return 0;
}
```

```cc
template <class... T>
void f(T... args)
{    
    cout << sizeof...(args) << endl; //打印变参的个数
}

f();        //0
f(1, 2);    //2
f(1, 2.5, "");    //3
```

## 模板别名

```cc
template <typename T>
using Vec = std::vector<T, MyAlloc<T>>;

Vec<int> coll;
// 相当于
Vec<int, MyAlloc<int>> coll;
```

## Lambda
C++11引入了lambda，允许inline函数的定义式被用作一个参数，或是一个local对象。

所谓lambda是一份功能定义式，可被定义于语句（statement）或表达式（expression）内部。因此你可以拿lambda当作inline函数使用。

lambda 语法
```cc
[捕获外部变量](形参列表) -> 返回值 {操作代码}

如果返回值不需要，->返回值可以省略
[捕获外部变量](形参列表) {操作代码}

捕获外部变量
[] : 不捕获任何变量
[=] : 已传值的方式捕获外部所有变量
[&] : 以传引用的方式捕获外部所有变量
[this] : 捕获外部this指针
[=, &a] : a使用引用方式捕获，其他变量使用传值方式捕获
[a, b] : a,b值传递捕获
```

### lambda 做了什么

lambda 本质上是定义一个类，这个类定义了 `operator()`

比如下面的lambda 
```cc
    auto f = [a, b](int c, int d) {
        return a + b + c + d;
    } ;
```
转换为类就是

```cc
class lambda_c {
    public:
        lambda_c(int a, int b): ma(a), mb(b) {}

        auto operator()(int c, int d) const {
            return ma + mb + c + d;
        }

    private:
        int ma;
        int mb;
};
```

注意 `operator()` 的 this 是 const，这会导致代码无法修改 a, b

```cc
    auto f = [a, b](int c, int d) {
        a = 1; // 错误
        b = 2; // 错误
        return a;
    } ;
```

原因是

```cc
class lambda_c {
    public:
        lambda_c(int a, int b): ma(a), mb(b) {}

        auto operator()(int c, int d) const {
            a = 1;    // 错误
            b = 2;    // 错误
            return a;
        }

    private:
        int ma;
        int mb;
};
```

这样修改

```cc
class lambda_c {
    public:
        lambda_c(int a, int b): ma(a), mb(b) {}

        auto operator()(int c, int d) const {
            a = 1;    // 错误
            b = 2;    // 错误
            return a;
        }

    private:
        mutable int ma;
        mutable int mb;
};
```

```cc
    auto f = [a, b](int c, int d) mutable {
        a = 1; // 错误
        b = 2; // 错误
        return a;
    } ;
```

## decltype 
decltype 可让编译器找出表达式（expression）类型。这其实就是常被要求的typeof的特性体现。只不过原有的typeof缺乏一致性又不完全，C++11才引入这么一个关键字。举个例子：
 
```cc
map<string, float> coll;
decltype(coll)::value_type p;
```

decltype的应用之一是声明返回类型（见下），另一个用途是在metaprogramming或用来传递一个lambda类型

### 新的函数声明语法
有时候，函数的返回类型取决于某个表达式对实参的处理。然而类似

```cc
// 这是错误语法，只是用于说明
template <typename T1, typename T2>
decltype(x+y) add(T1 x, T2 y);
```

在C++11之前是不可能的，因为返回式所使用的对象尚未被引入，或未在作用域内。

但是在C++11，你可以将一个函数的返回类型转而声明于参数列之后：

```cc
template <typename T1, typename T2>
auto add(T1 x, T2 y) -> decltype(x + y);
```


## 带域的枚举
C++11允许我们定义scoped enumeration——又称为 strong enumeration或enumeration class——这是C++enumeration value（或称enumerator）的一个较干净的实现。例如：

```cc
enum class Salutation : char {mr, ma, co, none};
```

重点在于，在enum之后指明关键字class。

Scoped enumeration有以下优点：
- 绝不会隐式转换至/自int。
- 如果数值（例如mr）不在enumeration被声明的作用域内，你必须改写为Salutation：：mr。
- 你可以明显定义低层类型（underlying type，本例是char）并因此获得一个保证大小（如果你略去这里的“：char”，默认类型是int）。
- 提前声明（forward declaration） enumeration type是可能的，那会消除“为了新的enu-merations value而重新编译”的必要——如果只有类型被使用的话。

注意，有了type trait std：：underlying_type，你可以核定（evaluate）一个enumeration type的低层类型

标准异常的差错状态值（error condition value）也是个scoped enumerator


















