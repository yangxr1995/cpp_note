
# 单个类的场景

## 访问限定符
- public: 公有的访问权限，在类外可以通过对象直接访问公有成员
- protected: 保护的访问权限，派生类中可以访问，在类外不能通过对象直接访问
- private: 私有的访问权限，在本类之外不能访问，比较敏感的数据设为private

## 构造函数
- 在对象分配完内存后自动调用，用于初始化对象
- 编译器提供默认构造函数
- 当用户提供构造函数后，编译器不会提供默认构造
- 构造函数可以重载
- 构造函数可以使用成员初始化列表
- 数据成员初始化顺序取决于定义顺序，而非初始化列表调用顺序

### 拷贝构造
- 拷贝构造的形式固定: 类名(const 类名 &)
- 拷贝构造的调用时机
  - 一个对象初始化另一个对象
  - 函数调用时，实参拷贝给形参
  - 函数返回对象(编译器会优化)

## 对象所占空间的大小
- 对象的大小与数据成员有关，与函数对象无关
- 对象大小默认需要考虑内存对齐

## 析构函数
- 对象生命周期结束时，自动调用
- 析构函数只有一个，不能重载

## 指向类成员的指针
### 基本概念与定义
指向类成员的指针是C++中用于访问类成员的特殊指针类型，其本质存储的是成员在类中的偏移量（而非绝对内存地址）。这种指针分为两类：

- **指向数据成员的指针**：如 `int stu::*p = &stu::age;`
- **指向成员函数的指针**：如 `void (stu::*p4)() = &stu::func;`

注意：没有指向成员函数的引用，只有指向成员函数的指针

### 定义格式
```cpp
// 数据成员指针
类型说明符 类名::*指针名 = &类名::成员名;

// 成员函数指针
返回值类型 (类名::*指针名)(参数列表) = &类名::成员函数名;
```

### 使用方式与底层原理
通过对象或对象指针访问成员指针时：

- 对象实例访问：`s.*p = 20;`
- 对象指针访问：`s->*p = 20;`

底层汇编代码显示（如用户提供的示例）：
- 成员指针存储的是偏移量（如 `age` 偏移 `0`，`name` 偏移 `4`）
- 访问时通过对象基地址 + 偏移量计算成员地址

### 示例
```c
class stu {
	public:
		int age;
		const char *name;
		char **pname;
		void func() { cout << "hello world" << endl; }
		static int a;
};

int stu::a = 10;

stu s;
s.age = 10;
int stu::*p = &stu::age;
// 将 int stu::* -> int stu::*
s.*p = 20;
// s.(*p) = 20; // 错误，s.的优先级应该更高
cout << s.*p << endl;

const char *stu::*p2 = &stu::name;
//const char stu::*p2 = &stu::name;
// 错误无法 const char * stu:: * -> const char stu:: *

s.*p2 = "hello";
cout << s.*p2 << endl;

char **stu::*p3 = &stu::pname;
// char **stu::* -> char **stu::*

void (stu::*p4)() = &stu::func;
// 将 void (stu::*)(void) -> void (stu::*)(void)
(s.*p4)();

int *p5 = &stu::a;
cout << "p5 " << *p5 << endl;


stu *s = new stu;

int stu::*p1 = &stu::age;
const char *stu::*p2 = &stu::name;
char **stu::*p3 = &stu::pname;
void (stu::*p4)() = &stu::func;
int *p5 = &stu::a;

(s->*p4)();

delete s;
```

指向类成员的指针是C++中用于访问类数据成员或成员函数的特殊指针类型，其本质是**偏移量**而非绝对地址，需结合具体对象实例使用。以下为关键点：

### 声明与初始化
- **数据成员指针**：  
`类型 类名::*指针名 = &类名::成员名`  
例如：  
```cpp
int stu::*p = &stu::age;
```
- **成员函数指针**：  
`返回值类型 (类名::*指针名)(参数表) = &类名::函数名`  
例如：  
```cpp
void (stu::*p4)() = &stu::func;
```
- **静态成员指针**：  
直接使用普通指针，因为静态成员属于类而非对象。  
例如：  
```cpp
int *p5 = &stu::a;
```

### 使用方式
- **通过对象访问**：  
`对象.*成员指针`  
例如：  
```cpp
s.*p = 20;
```
- **通过对象指针访问**：  
`对象指针->*成员指针`  
例如：  
```cpp
s->*p4();
```


- **底层实现**：  
汇编代码显示成员指针存储偏移量，通过对象地址与偏移量计算实际地址（如 `s.*p2` 对应地址运算）。
```asm
	int stu::*p = &stu::age;
  24:	mov	r3, #0
  28:	str	r3, [fp, #-32]	; 0xffffffe0

	char *stu::*p2 = &stu::name;
  40:	mov	r3, #4
  44:	str	r3, [fp, #-28]	; 0xffffffe4

	char **stu::*p3 = &stu::pname;
  5c:	mov	r3, #8
  60:	str	r3, [fp, #-24]	; 0xffffffe8


# 使用
	s.*p2 = "hello";
  48:	ldr	r3, [fp, #-28]	; 获得存放的偏移量值
  4c:	sub	r2, fp, #20     ; 获得s对象的地址
  50:	add	r3, r2, r3      ; s对象的地址加偏移量得到属性的地址
  54:	ldr	r2, [pc, #56]	; 获得 "hello"
  58:	str	r2, [r3]        ; 将"hello"的地址写入属性的内存空间
```

## 常方法
- **特点**：  
  `this` 指针类型为 `const stu *const this`，禁止修改非 `mutable` 成员，常用于提供只读接口。

常方法通过 `const` 修饰，其 `this` 指针为 `const stu *const this`，限制对成员变量的修改：

方便用户传入const类型的参数

### 应用场景：
- 实现只读接口
- 允许 `const` 对象调用方法

### 示例

- **重载规则**：  
  与非 `const` 方法构成重载。  

- 例如：  
```cpp
class stu {
	// 两个show构成函数重载 
	void show() {
		// this : stu * const this;
	}	
	void show() const  {
		// this : const stu * const this;
	}
};
```
## 静态成员
- 只能访问静态成员
- 无 `this` 指针，可直接通过类名调用
```c
class stu{
	public:
		static int a;
		// 静态成员方法，只能访问静态属性
		static void func() { a++;}
}
// 在编译时定义。静态属性属于类，不属于成员
int stu::a = 10;
```

总结:
- **静态属性**：  
类内声明，类外定义。  
例如：  
```cpp
int stu::a = 10;
```

- **静态方法**：  
无 `this` 指针，仅能访问静态成员。  
例如：  
```cpp
static void func() { a++; }
```
## 初始化列表
### 定义与语法
初始化列表用于在构造函数中直接初始化成员变量，语法为：
```cpp
构造函数(参数列表) : 成员1(初始值), 成员2(初始值) { ... }
```
### 核心特性
- **执行顺序**：按成员在类中的声明顺序初始化，而非初始化列表书写顺序
- **性能优势**：避免默认构造 + 赋值的额外开销（直接调用拷贝构造）
- **强制使用场景**：
  - 常量成员（`const`）
  - 引用成员
  - 无默认构造函数的类类型成员

### 与构造函数体的区别
- **初始化列表**：在对象内存分配后立即执行，属于初始化阶段
- **构造函数体**：在初始化阶段之后执行，属于赋值操作阶段

### 示例
初始化列表用于构造函数中直接初始化成员变量，避免默认构造与赋值的性能损耗，并支持常量/引用成员的初始化。

- **语法**：  
```cpp
构造函数(参数) : 成员1(值1), 成员2(值2) { ... }
```
例如：  
```cpp
stu(int a, int b, int c) : a(a, b), age(c) {}
```
- **顺序依赖**：  
  初始化顺序由成员在类中的声明顺序决定，与初始化列表书写顺序无关。
### 2. 应用场景
- **必须使用的情况**：  
  初始化 `const` 成员、引用成员或类类型成员（如 `A a` 需通过 `A(a, b)` 构造）。
- **性能优势**：  
  直接调用成员构造函数，避免默认构造+赋值的额外开销。

```c
class A {
	public:
	A(int a, int b)
		:a(a), b(b){
	}

	int a;
	int b;
};

class stu {
	public:
		stu(int a, int b, int c)
			:a(a, b), age(c) // A a(a, b); int age = c 
							 // 先调用初始化列表
							 // 初始化列表的执行顺序为成员定义顺序
		{
		}
		int age;
		A a;
};
```

