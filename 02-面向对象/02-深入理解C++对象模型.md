# 关于对象

## C++ 对象模型(The C++ Object Model)

### 不考虑继承

```cc
class Point {
public:
    Point( float xval );
    virtual ~ Point();
    float x() const;
    static int PointCount();
protected:
    virtual ostream&
    print( ostream & os ) const;
    float  x;
    static int   point   count;
};
```

在此模型中,Nonstatic data members被配置于每一个 class object之内, static data members则被存放在个别的 class object之外。Static 和 nonstatic function members也被放在个别的 class object之外。
Virtualfunctions则以两个步骤支持之:
1. 每一个 class 产生出一堆指向 virtual functions 的指针, 放在表格之中。这个表格被称为 virtual table (vtbl) 。
2. 每一个 class object被安插一个指针, 指向相关的 virtual table。通常这个指针被称为 vptr。vptr的设定(setting) 和重置(resetting) 都由每一个class 的 constructor、destructor和 copy assignment运算符自动完成 。每一个 class所关联的 type_info object(用以支持 runtime type identification, RTTI) 也经由 virtual table 被指出来,通常放在表格的第一个 slot。
下图说明C++对象模型如何应用于前面所说的 Point class身上。这个模型的主要优点在于它的空间和存取时间的效率；主要缺点则是，如果应用程序代码本身未曾改变, 但所用到的 class objects 的 nonstatic data members有所修改(可能是增加、移除或更改)，那么那些应用程序代码同样得重新编译。关于此点，前述的双表格模型就提供了较大的弹性，因为它多提供了一层间接性，不过它也因此付出了空间和执行效率两方面的代价。

                                                          ┌───────────►┌──────────────┐
                                                          │            │              │
                                                          │            │              │
                                                          │            └──────────────┘
         ┌───────────────┐            ┌────────────────┐  │            type_info for Point
         │ float_x       │            │             ───┼──┘             
         │ __vptr__Point─┼───────────►├────────────────┤               ┌────────────────┐
         └───────────────┘            │             ───┼──────────────►│Point::~Point() │
            Point pt;                 ├────────────────┤               └────────────────┘
                                      │             ───┼────────────┐  ┌───────────────────────┐
                                      └────────────────┘            └─►│Point::print(ostream &)│
                                    virtual table for Point            └───────────────────────┘

         ┌──────────────────────┐        ┌─────────────────────┐      ┌────────────────────┐
         │ static int           │        │ static int          │      │ Point::Ponit(float)│
         │ Point::_point_count()│        │ Point::PointCount() │      └────────────────────┘
         └──────────────────────┘        └─────────────────────┘      ┌──────────────────┐
                                                                      │ float Point::x() │
                                                                      └──────────────────┘

                                    C++ 对象模型



### 对象模型如何影响程序
不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加入新的程序代码”两个结果。例如下面这个函数，其中class X 定义了 一个 copy constructor、  一个 virtual destructor和一个 virtual functionfoo:
```cc
X foobar()
{
    X xx;
    x * px = new x;

    // foo() 是 一个 virtual function
    xx.foo();
    px->foo();

    delete px;
    return xx;
};
```

这个函数有可能在内部被转化为：
```cc
//可能的内部转换结果
//虚拟C++代码
void foobar( X &  result )
{
    //构造  result
    //   result 用来取代 local xx ...
    result.X::X();

    // 扩展 X * px = new X;
    px =   new( sizeof( X ) );
    if ( px != 0 )
        px->X::X();

    // 扩展 xx. foo() 但不使用 virtual 机制
    // 以  result 取代 xx
    foo( &result );
    // 使用 virtual 机制扩展 px-> foo()
    ( * px->vtbl[ 2 ] )( px )
    // 扩展 delete px;
    ( * px->vtbl[ 1 ] )( px );  // destructor
    delete( px );
    // 无须使用 named return statement
    // 无须摧毁 local object xx
    return;
};
```

## 程序范式

C++程序设计模型直接支持三种 programming paradigms(程序设计范式)

### 程序模型
程序模型(procedural model) 。就像C 一样, C++当然也支持它。字符串的处理就是一个例子，我们可以使用字符数组以及 str*函数族群(定义在标准的C函数库中)：
```cc
char boy[] = " Danny";
char *p_son;
…
p_son = new char[ strlen( boy ) + 1 ];
strcpy( p_son, boy );
…
if ( ! strcmp(p_son, boy ))
    take_to_disneyland( boy );
```

### 抽象数据类型模型
抽象数据类型模型(abstract data type model, ADT) 。此模型所谓的“抽象”是和一组表达式(public接口)一起提供的，那时其运算定义仍然隐而未明。例如下面的 String class:
```cc
String girl = " Anna";
String daughter;
……
// String:: operator=();
daughter = girl;
…
// String:: operator==();
if ( girl == daughter )
    take_to_disneyland( girl );
```
### 面向对象模型
面向对象模型(object-oriented model) 。在此模型中有一些彼此相关的类型，通过一个抽象的 base class(用以提供共同接口)被封装起来。
Library_materials class 就是一个例子, 真正的 subtypes例如 Book、Video、Compact_Disc、Puppet、Laptop等等都可以从那里派生而来:
```cc
void
check_in( Library_materials * pmat )
{
    if ( pmat->late() )
        pmat->fine();
    pmat->check_in();
    if ( Lender * plend = pmat->reserved() )
        pmat->notify( plend );
}
```

多态只会在指针或引用时才可能发生，直接用对象方法是静态绑定
```cc
// class Book : public Library   materials { …… };Book book;
// 喔欧, thing1 不是一个 Book!
// book 被裁切(sliced)了。
// 不过 thing1 仍保有 一个 Library   materials。
thing1 = book;
// 喔欧, 调用的是 Library   materials:: check   in()
thing1.check_in();

// 而不是通过 base class 的 pointer或 reference 来完成多态局面:

// OK: 现在 thing2 参考到 book
Library_materials &thing2 = book;

// OK: 现在引发的是 Book:: check_in()
thing2.check_in();
```

#### C++以下列方法支持多态：
1.经由 一组隐式的转化操作。例如把一个 derived class 指针转化为一个指向其 public base type 的指针:
```cc
shape * ps = new circle();
```
2. 经由 virtual function 机制:
```cc
ps-> rotate();
```
3. 经由 dynamic_cast 和 typeid运算符:
```cc
if ( circle * pc = dynamic_cast< circle* >( ps ) )
```

## 内存布局

```cc
class ZooAnimal {
    public:
        ZooAnimal();
        virtual ~ZooAnimal();
        virtual void rotate();
    protected:
        int loc;
        String name;
};
ZooAnimal za( " Zoey" );
ZooAnimal * pza = & za;
```

           1000
                 ┌──────────────────────┐
               ┌►│int loc               │
               │ │int String::len       │
               │ │int String::str       │
               │ │__vptr__ZooAnimal     │
               │ └──────────────────────┘
               │  ZooAnimal za("Zoey");
               │ ┌──────────────────────┐
               └─┤1000                  │
                 └──────────────────────┘
                  ZooAnimal *pza = &za;

### 加上多态后
```cc
class Bear : public ZooAnimal {
    public:
        Bear();
        ~Bear();
        void  rotate();
    protected:
        int dances;
        int cell;
};
```
               ┌─────────────────┐ 
               │int loc          │ ┌► ZooAnimal subobject
               │int String::len  │ │
               │int String::str  │ │
               │__vptr__ZooAnimal│ │
               │─────────────────│
               │int dances       │
               │int cell         │
               └─────────────────┘

## 总结
当一个 base class object 被直接初始化为 (或是被指定为) 一个 derived classobject 时, derived object就会被切割(sliced)以塞入较小的 base type 内存中, derivedtype将没有留下任何蛛丝马迹。多态于是不再呈现，而一个严格的编译器可以在编译时期解析一个“通过此 object而触发的 virtual function 调用操作”,因而回避 virtual机制。如果 virtual function 被定义为 inline, 则更有效率上的大收获。
总而言之，多态是一种威力强大的设计机制，允许你继一个抽象的 public 接口之后，封装相关的类型。我所举的 Library  materials体系就是一例。需要付出的代价就是额外的间接性———不论是在“内存的获得”或是在“类型的决断”上。C++通过 class 的 pointers和 references来支持多态, 这种程序设计风格就称为“面向对象”。

C++也支持具体的ADT程序风格,如今被称为 object-based(OB)。例如 Stringclass，一种非多态的数据类型。String class可以展示封装的非多态形式；它提供一个 public 接口和一个 private实现品，包括数据和算法，但是不支持类型的扩充。一个OB设计可能比一个对等的OO设计速度更快而且空间更紧凑。速度快是因为所有的函数调用操作都在编译时期解析完成，对象建构起来时不需要设置 virtual机制；空间紧凑则是因为每一个 class object不需要负担传统上为了支持 virtual 机制而需要的额外负荷。不过，OB 设计比较没有弹性。



# 构造函数语义学
implicit	：	     暗中的、隐式的(通常意指并非在程序源代码中出现的)     
explicit    ：显式的 (通常意指程序源代码中所出现的)
trivial      没有用的
nontrivial   有用的
memberwise  : 对每一个 member施以……
bitwise     :对每一个 bit施以……
semantics    语意

关于 C++，最常听到的一个抱怨就是，编译器背着程序员做了太多事情.
我要挖掘编译器对于“对象构造过程”的干涉，以及对于“程序形式”和“程序效率”上的冲击。

## 默认构造

C++ Annotated Reference Manual(ARM) [ELLIS90]中的 Section 12.1 告诉我们: “default constructors……在需要的时候被编译器产生出来”。关键字眼是“在需要的时候”。被谁需要?做什么事情?看看下面这段程序代码：
```cc
class Foo { public: int val; Foo * pnext; };
void foo   bar()
{
    // 喔欧: 程序要求 bar's members 都被清为 0。
    Foo bar;
    if ( bar. val 11 bar. pnext )
    // …… do something
    // ……
}
```

在这个例子中,正确的程序语意是要求 Foo有一个 default constructor,可以将它的两个 members初始化为0。
上面这段代码可曾符合ARM所说的“在需要的时候”?答案是 no。
其间的差别在于一个是程序的需要，  一是编译器的需要。程序如果有需要，那是程序员的责任；本例要承担责任的是设计 class Foo的人。
是的，上述程序片段并不会合成出一个 default constructor。


那么，什么时候才会合成出一个 default constructor 呢?当编译器需要它的时候！此外，被合成出来的 constructor只执行编译器所需的行动。
也就是说，即使有需要为 class Foo 合成一个 default constructor, 那个 constructor 也不会将两个 datamembers val和 pnext 初始化为0。
为了让上一段代码正确执行, class Foo 的设计者必须提供一个显式的 default constructor, 将两个 members适当地初始化。

### 带有 Default Constructor” 的 Member Class Object
如果一个 class没有任何 constructor, 但它内含一个 member object, 而后者有default constructor, 
那么编译器需要为该 class 合成出一个 default constructor。不过这个合成操作只有在constructor真正需要被调用时才会发生。

举个例子，在下面的程序片段中，编译器为 class Bar 合成一个 defaultconstructor:
```cc
class Foo { public: Foo(), Foo( int ) …… };
class Bar { public: Foo foo; char * str; }; // 译注: 不是继承, 是内含!
void foo   bar()
{
    Bar bar; // Bar:: foo 必须在此处初始化。
    // 译注: Bar:: foo 是 一个 member object, 而其 class Foo//      拥有 default constructor, 符合本小节主题。
    if ( str ) { } ……
}
```
被合成的 Bar default constructor内含必要的代码,能够调用 class Foo 的 defaultconstructor 来处理 member object Bar:: foo, 
但它并不产生任何代码来初始化Bar:: str。是的, 将 Bar:: foo 初始化是编译器的责任, 将 Bar:: str初始化则是程序员的责任。
被合成的 default constructor看起来可能像这样
```cc
// Bar 的 default constructor 可能会被这样合成
// 为 member foo 调用 class Foo 的 default constructor
inline
Bar:: Bar()
{
    // C++ 伪码
    foo. Foo:: Foo();
}
```
再一次请你注意，被合成的 default constructor只满足编译器的需要，而不是程序的需要。
为了让这个程序片段能够正确执行，字符指针 str也需要被初始化。让我们假设程序员经由下面的 default constructor提供了 str的初始化操作:
```cc
// 程序员定义的 default constructor
Bar:: Bar() { str = 0; }
```
编译器会扩张已存在的 constructors,在其中安插一些代码, 使得 usercode被执行之前, 先调用必要的 default constructors。
延续前一个例子, 扩张后的constructors可能像这样:
```cc
// 扩张后的 default constructor
// C++ 伪码
Bar:: Bar()
{
    foo. Foo:: Foo();                           // 附加上的 compiler code
    str = 0;                                   // explicit user code
}
```

如果有多个 class member objects都要求 constructor初始化操作,将如何? 
C++语言要求以“member objects 在 class中的声明顺序”来调用各个 constructors。
这一点由编译器完成，它为每一个 constructor安插程序代码，以“member声明顺序”调用每一个 member所关联的 default constructors。
这些代码将被安插在 explicituser code之前。
举个例子, 假设我们有以下三个 classes:
```cc
class Dopey                     { public: Dopey(); …… };
class Sneezy   { public: Sneezy( int );  Sneezy(); ……  };
class Bashful  { public: Bashful(); …… };
```
以及一个 class Snow   White:
```cc
class Snow_White {
    public:
        Dopey dopey;   // 译注: dopey、 sneezy 和 bashful 是三个 member objects
        Sneezy sneezy;
        Bashful bashful;
        // ……
    private:
        int mumble;
};
```
如果 Snow   White 没有定义 default constructor,就会有一个 nontrivial constructor被合成出来, 
依序调用 Dopey、Sneezy、Bashful 的 default constructors。
然而如果Snow   White 定义了下面这样的 default constructor:
```cc
// 程序员所写的 default constructor
Snow_White:: Snow_White() : sneezy( 1024 )
{
    mumble = 2048;
}
```
它会被扩张为：
```cc
// 编译器扩张后的 default constructor
// C++ 伪码
Snow_White:: Snow_White() : sneezy( 1024 )
{
    // 插入 member class object
    // 调用其 constructor
    dopey. Dopey:: Dopey();
    sneezy. Sneezy:: Sneezy(1024);
    bashful. Bashful:: Bashful();
    // explicit user code
    mumble = 2048;
}
```
### 带有 Default Constructor” 的 Base Class

类似的道理, 如果一个没有任何 constructors的 class派生自一个“带有 default constructor”的 base class, 
那么这个 derived class 的 default constructor 会被视为nontrivial,并因此需要被合成出来。
它将调用上一层 base classes的 default constructor(根据它们的声明顺序)。
对一个后继派生的 class 而言，这个合成的 constructor和一个“被显式提供的 default constructor”没有什么差异。

( 用户提供了任意构造函数，则编译器不会合成默认构造 )
如果设计者提供多个 constructors, 但其中都没有 default constructor呢? 
编译器会扩张现有的每一个 constructors, 将“用以调用所有必要之 default constructors”的程序代码加进去。
它不会合成一个新的 default constructor,因为其他“由 user所提供的 constructors”存在的缘故。
如果同时亦存在着“带有 default constructors”的 member class objects, 那些 default constructor也会被调用————在所有 base classconstructor都被调用之后。

### 带有一个 Virtual Function” 的 Class
另有两种情况, 也需要合成出 default constructor:
1. class声明 (或继承) 一个 virtual function。
2. class 派生自一个继承串链, 其中有一个或更多的 virtual base classes。

不管哪一种情况，由于缺乏由 user声明的 constructors，编译器会详细记录合成一个 default constructor的必要信息。以下面这个程序片段为例:
```cc
class widget {
    public:
    virtual void flip() = 0;
    // …
};
void flip( const Widget& widget ) { widget. flip(); }
// 假设 Bell 和 Whistle 都派生自 Widget
void foo()
{
    Bell b;
    Whistle w;
    flip( b );
    flip( w );
}
```
下面两个扩张行动会在编译期间发生：

1.  一个 virtual function table(在 cfront中被称为 vtbl)会被编译器产生出来,内放 class 的 virtual functions 地址。
2. 在每一个 class object中,  一个额外的 pointer member(也就是 vptr) 会被编译器合成出来，内含相关之 class vtbl的地址。

此外, widget. flip()的虚拟调用操作(virtual invocation)会被重新改写, 以使用widget的 vptr和 vtbl中的 flip()条目:
// widget. flip() 的虚拟调用操作(virtual invocation)的转变
( * widget. vptr[ 1 ] )( & widget )

其中：

- 表示 flip()在 virtual table中的固定索引;
- widget代表要交给“被调用的某个 flip()函数实例”的 this 指针。


为了让这个机制发挥功效，编译器必须为每一个 Widget(或其派生类的)object的 vptr 设定初值, 放置适当的 virtual table 地址。
对于 class 所定义的每一个constructor，编译器会安插一些代码来做这样的事情。
对于那些未声明任何 constructors的 classes, 编译器会为它们合成一个 default constructor, 以便正确地初始化每一个 class object 的 vptr。

### 带有一个 Virtual Base Class” 的 Class

Virtual base class的实现法在不同的编译器之间有极大的差异。
然而，每一种实现法的共同点在于必须使 virtual base class 在其每一个 derived class object中的位置，能够于执行期准备妥当。
例如在下面这段程序代码中：
```cc
class X { public: int i; };
class A : public virtual X { public: int j; };
class B : public virtual X { public: double d; };
class C : public A, public B   { public: int k; };
// 无法在编译时期决定(resolve) 出 pa->X::i 的位置
void foo( const A* pa ) { pa->i = 1024; }
main()
{
    foo( new A );
    foo( new C );
    // ……
}
```

编译器无法固定住 foo()之中“经由 pa 而存取的 X：：i”的实际偏移位置，因为 pa的真正类型可以改变。
编译器必须改变“执行存取操作”的那些代码，使X：：i可以延迟至执行期才决定下来。
某些编译器的做法是靠“在 derived class object 的每一个 virtual base classes中安插一个指针”完成。
所有“经由 reference 或 pointer来存取一个 virtual base class”的操作都可以通过相关指针完成。
在我的例子中, foo()可以被改写如下，以符合这样的实现策略：
```cc
//可能的编译器转变操作
void foo( const A* pa ) { pa->vbcX->i = 1024; }
```

其中  vbcX 表示编译器所产生的指针, 指向 virtual base class X。

正如你所揣测的那样，  vbcX(或编译器所做出的某个什么东西)是在 classobject 构造期间被完成的。
对于 class 所定义的每一个 constructor, 编译器会安插那些“允许每一个 virtual base class的执行期存取操作”的代码。
如果 class 没有声明任何 constructors, 编译器必须为它合成一个 default constructor。

### 总结
有4 种情况,会造成“编译器必须为未声明 constructor的 classes 合成一个default constructor”。
C++ Standard 把那些合成物称为 implicit nontrivial defaultconstructors。被合成出来的 constructor只能满足编译器(而非程序)的需要。
它之所以能够完成任务,是借着“调用 member object或 base class的 default constructor”或是“为每一个 object 初始化其 virtual function 机制或 virtual base class 机制”而完成的。

至于没有存在那4种情况而又没有声明任何 constructor的 classes，我们说它们拥有的是 implicit trivial default constructors, 它们实际上并不会被合成出来。
在合成的 default constructor中, 只有 base class subobjects 和 member classobjects 会被初始化。
所有其他的 nonstatic data member(如整数、整数指针、整数数组等等)都不会被初始化。
这些初始化操作对程序而言或许有需要，但对编译器则非必要。如果程序需要一个“把某指针设为0”的 default constructor,那么提供它的人应该是程序员。

C++新手一般有两个常见的误解：
1. 任何 class如果没有定义 default constructor, 就会被合成出一个来。
2. 编译器合成出来的 default constructor 会显式设定“class 内每一个 datamember的默认值”。
如你所见，没有一个是真的！

## 拷贝构造
有三种情况，会以一个 object的内容作为另一个 class object的初值。最明显的一种情况当然就是对一个 object做显式的初始化操作，像这样：
```cc
class x { …… };
x x;
// 显式地以一个 object 的内容作为另一个 class object 的初值
X xx = x;
```

另两种情况是当 object被当做参数交给某个函数时，例如：
```cc
extern void foo( X x );
void bar()
{
    x xx;
    //以xx 作为 foo()第一个参数的初值(隐式的初始化操作)
    foo( xx );
    // ……
}
```

以及当函数传回一个 class object时, 例如:
```cc
X foo_bar()
{
X xx;
// ……
return xx;
}
```
假设 class 设计者显式定义了一个 copy constructor(这是 一个 constructor, 有一个参数的类型是其 class type)，像下面这样：
```cc
// user-defined copy constructor 的实例
//可以是多参数形式，其第二参数及后继参数以一个默认值供应之。
X::X( const X& x );
Y::Y( const Y& y, int = 0 );
```
那么在大部分情况下，当一个 class object 以另一个同类实例作为初值，上述的constructor会被调用。这可能会导致一个临时性 class object的产生或导致程序代码的蜕变(或两者都有)

### Default Memberwise Initialization
如果 class 没有提供一个 explicit copy constructor又当如何? 
当 class object以“相同 class 的另一个 object”作为初值, 其内部是以所谓的 default memberwise initialization 手法完成的, 
也就是把每一个内建的或派生的 data member(例如一个指针或一个数组)的值，从某个 object拷贝一份到另一个 object身上。
不过它并不会拷贝其中的 member class object, 而是以递归的方式施行 memberwise initialization。例如, 考虑下面这个 class 声明:
```cc
class String {
    public:
    // … 没有 explicit copy constructor
    private:
    char * str;
    int len;
};
// 一个 String object 的 default memberwise initialization 发生在这种情况之下:
String noun( " book" );
String verb = noun;
// 其完成方式就好像个别设定每一个 members一样：
// 语意相等
verb. str = noun. str;
verb. len = noun. len; 
```

如果一个 String object被声明为另 一个 class 的 member, 像这样:
```cc
class Word {
    public:
        //……没有 explicit copy constructor
    private:
        int     occurs;
        String   word;  // 译注: String object成为 class Word的 一个 member!};
};
```

那么一个 Word object 的 default memberwise initialization 会拷贝其内建的 member occurs, 然后再于 String member object word 身上递归实施 memberwise initialization。

这样的操作实际上如何完成?

实际不会使用memberwise initialization，而是会合成Word的拷贝构造函数.

就像 default constructor一样,C++ Standard上说,如果 class 没有声明一个 copy constructor, 
就会有隐式的声明(implicitly declared) 或隐式的定义(implicitlydefined) 出现。
和以前一样, C++ Standard 把 copy constructor 区分为 trivial 和nontrivial 两种。只有 nontrivial 的实例才会被合成于程序之中。
决定一个 copyconstructor 是否为 trivial 的标准在于 class 是否展现出所谓的“bitwise copysemantics”。下一节我将说明“class 展现出 bitwise copy semantics”这句话是什么意思。

### Bitwise Copy Semantics(位逐次拷贝)
在下面的程序片段中：
```cc
# include " Word. h"
Word noun( " book" );
void foo()
{
    Word verb = noun;
    // ……
}
```

很明显 verb是根据 noun来初始化的。但是在尚未看过 class Word的声明之前，我们不可能预测这个初始化操作的程序行为。
如果 class Word 的设计者定义了一个copy constructor, verb的初始化操作会调用它。
但如果该 class 没有定义 explicit copyconstructor，那么是否会有一个编译器合成的实例被调用?
这就得视该 class是否展现“bitwise copy semantics”而定了。
举个例子, 已知下面的 class Word 声明:

```cc
// 以下声明展现了 bitwise copy semantics
class Word {
    public:
        Word( const char* );
        ~ Word() { delete [] str; }
        // ……
    private:
        int  cnt;
        char * str;
};
```

这种情况下并不需要合成出一个 default copy constructor,因为上述声明展现了“default copy semantics”,而 verb 的初始化操作也就不需要以一个函数调用收场。
然而, 如果 class Word 是这样声明的:
```cc
// 以下声明并未展现出 bitwise copy semantics
class Word {
    public:
        Word( const String& );
        ~ Word();
        // ……
    private:
        int  cnt;
        String str; // 因为需要调用str的拷贝构造函数，所以不能直接简单拷贝
};
```
其中 String声明了一个 explicit copy constructor:
```cc
class String {
public:
    String( const char * );
    String( const String& );
    ~ String();
    // ……
};
```

这种情况下,编译器必须合成出一个 copy constructor,以便调用 member class Stringobject的 copy constructor:
```cc
// 一个被合成出来的 copy constructor
// C++ 伪码
inline Word:: Word( const Word& wd )
{
    str. String:: String( wd. str );
    cnt = wd. cnt;
}
```

### 不要 Bitwise Copy Semantics!
什么时候一个 class不展现出“bitwise copy semantics”呢? 有4种情况:
1. 当 class 内含 一个 member object 而后者的 class 声明有 一个 copy constructor时(不论是被 class设计者显式地声明，就像前面的 String那样；或是被编译器合成, 像 class Word那样)。
2. 当 class 继承自一个 base class 而后者存在一个 copy constructor时(再次强调，不论是被显式声明或是被合成而得)。
3. 当 class 声明了一个或多个 virtual functions时。
4. 当 class 派生自一个继承串链, 其中有一个或多个 virtual base classes时。

在前两种情况中, 编译器必须将 member或 base class的“copy constructors调用操作”安插到被合成的 copy constructor中。
前一节 class Word的“合成而得的copy constructor”正足以说明情况1。情况3和4有点复杂，是我接下来要讨论的题目。

### 重新设定 Virtual Table的指针

回忆编译期间的两个程序扩张操作(只要有一个 class声明了一个或多个 virtualfunctions就会如此):
- 增加一个 virtual function table(vtbl),内含每一个有作用的 virtual function的地址。
-  一个指向 virtual function table的指针(vptr) , 安插在每 一个 class object内。

很显然，如果编译器对于每一个新产生的 class object的 vptr 不能成功而正确地设好其初值，将导致可怕的后果。
因此，当编译器导入一个 vptr到class之中时，该 class 就不再展现 bitwise semantics 了。现在, 编译器需要合成出一个 copyconstructor以求将 vptr适当地初始化, 下面是个例子。
首先, 我定义两个 classes, ZooAnimal和 Bear:
```cc
class ZooAnimal {
    public:
        ZooAnimal();
        virtual ~ZooAnimal();
        virtual void animate();
        virtual void draw();
        // …
    private:
        // ZooAnimal 的 animate() 和 draw()
        //所需要的数据
};

class Bear : public ZooAnimal {
    public:
        Bear();
                               void animate();       // 译注: 虽未明写 virtual, 但它其实是 virtual
                               void draw();          // 译注: 虽未明写 virtual, 但它其实是 virtual
        virtual void dance();
        // …
    private:
        // Bear 的 animate()、draw() 和 dance()
        //所需要的数据
};
```

```cc
Bear yogi;
Bear winnie = yogi;
```
yogi 会被 default Bear constructor初始化。而在 constructor中, yogi的 vptr被设定指向 Bear class 的 virtual table(靠编译器安插的代码完成) 。因此,把 yogi的 vptr值拷贝给 winnie的 vptr 是安全的。

         ┌───────────────┐
         │  vptr         ├─────┐
         ├───────────────┤     ├─► ┌────────────────┐
         │  ....         │     │   │                │
         └───────────────┘     │   │                │
            Bear yogi          │   │                │
                               │   │                │
         ┌───────────────┐     │   │                │
         │  vptr         ├─────┘   │                │
         ├───────────────┤         └────────────────┘
         │  ....         │           virtual table
         └───────────────┘             for Bear
            Bear winnie


当一个 base class object以其 derived class的 object内容做初始化操作时,其 vptr复制操作也必须保证安全，例如：
```cc
ZooAnimal franny = yogi; // 译注: 这会发生切割(sliced)行为。

// franny的 vptr不可以被设定指向 Bear class的 virtual table(但如果 yogi的 vptr被直接“bitwise copy”的话,就会导致此结果),否则当下面程序片段中的 draw()被调用而franny被传进去时, 就会“炸毁” (blow up)5:

void draw( const ZooAnimal& zoey ) { zoey. draw(); }
void foo() {
    // franny 的 vptr 指向 ZooAnimal 的 virtual table,
    // 而非 Bear 的 virtual table(它由 y ogi 的 vptr 指出)
    ZooAnimal franny = yogi;
    draw( y ogi );    // 调用 Bear:: draw()
    draw( franny );  // 调用 zooAnimal:: draw()
}
```
                                       ┌──────►┌──────────────────────┐
                                       │       │                      │
       ┌───────────────┐               │       │                      │
       │  vptr         ├───────────────┘       │                      │
       ├───────────────┤                       │                      │
       │  ....         │                       │                      │
       └───────────────┘                       └──────────────────────┘
           Bear yogi                            virtual table for Bear

                                        ┌─────►┌──────────────────────┐
                                        │      │                      │
        ┌───────────────┐               │      │                      │
        │  vptr         ├───────────────┘      │                      │
        ├───────────────┤                      │                      │
        │  ....         │                      │                      │
        └───────────────┘                      └──────────────────────┘
           ZooAnimal franny                     virtual table for ZooAnimal


也就是说, 合成出来的 ZooAnimal copy constructor会显式设定 object 的 vptr指向 ZooAnimal class的 virtual table,而不是直接从右手边的 class object 中将其 vptr现值拷贝过来。

#### 处理 Virtual Base Class Subobject

Virtual base class的存在需要特别处理。   
一个 class object如果以另  一个 object作为初值, 而后者有一个 virtual base class subobject, 那么也会使“bitwise copysemantics”失效。

每一个编译器对于虚拟继承的支持承诺，都代表必须让“derived class object中的 virtual base class subobject 位置”在执行期就准备妥当。
维护“位置的完整性”是编译器的责任。  “Bitwise copy semantics”可能会破坏这个位置, 所以编译器必须在它自己合成出来的 copy constructor中做出仲裁。

## 程序转化语意学

下一节将讨论编译器调用 copy constructor的策略,以及这些策略如何影响我们的程序

### 参数的初始化 (Argument Initialization)
```cc
xx x = arg; // 其中 xx代表形式参数(或返回值)而 arg代表真正的参数值。
// 因此，若已知这个函数：
void foo(X x0 );
// 下面这样的调用方式：
x xx;
// ……
foo( xx );
```

将会要求局部实例(local instance) x0以 memberwise 的方式将 xx当做初值。

在编译器实现技术上，有一种策略是导入所谓的临时性 object，并调用 copyconstructor将它初始化，然后将此临时性 object交给函数。

例如将前一段程序代码转换如下：
```cc
// C++ 伪码
//编译器产生出来的临时对象
x   temp0;
// 编译器对 copy constructor 的调用
temp0. X::X( xx );
//重新改写函数调用操作，以便使用上述的临时对象
foo(   temp0 );
```

然而这样的转换只做了一半功夫而已。你看出遗留问题了吗?
问题出在 foo()的声明上。临时性 object先以 class X的 copy constructor正确地设定了初值,然后再以 bitwise方式拷贝到x0这个局部实例中。
噢，真讨厌，foo()的声明因而也必须被转化,形式参数必须从原先的一个 class X object 改变为一个 class Xreference, 像这样:
```cc
void foo(X& x0 );
```

另一种实现方法是以“拷贝建构”(copy construct)的方式把实际参数直接建构在其应该的位置上，此位置视函数活动范围的不同，记录于程序堆栈中。
在函数返回之前,局部对象(local object)的 destructor(如果有定义的话)会被执行。
BorlandC++编译器就是使用此法，但它也提供一个编译选项，用以指定前一种做法，以便和其早期版本兼容。

### 返回值的初始化(Return Value Initialization)

已知下面这个函数定义：
```cc
x bar()
{
    x xx;
    // 处理 xx …
    return xx;
}
```

最后一个转化操作会重新改写函数，使它不传回任何值。根据这样的算法，bar()转换如下：
```cc
//函数转换
// 以反映出 copy constructor 的应用。
// C++ 伪码
void
bar(X&    result) // 译注: 加上一个额外参数
{
    X xx;

    // 编译器所产生的 default constructor 调用操作
    xx. x::x();

    //……处理 xx
    // 编译器所产生的 copy constructor 调用操作
    result. X::XX( xx );

    return;
}
```

### 在编译器层面做优化 (Optimization at the Compiler Level)
```cc
X bar()
{
    X xx;
    //……处理 xx
    return xx;
}
```

编译器把其中的 xx以  result取代:

```cc
void
bar( X &   result )
{
    // default constructor 被调用
    // C++ 伪码
    result. X::X();
    //……直接处理    result
    return;
}
```

这样的编译器优化操作, 有时候被称为 Named Return Value(NRV) 优化

### 成员们的初始化队伍(Member Initialization List)

在下列情况下,为了让你的程序能够被顺利编译,你必须使用 member initialization list:
1. 当初始化一个 reference member时;
2. 当初始化一个 const member 时;
3. 当调用一个 base class的 constructor, 而它拥有一组参数时;
4. 当调用一个 member class 的 constructor, 而它拥有一组参数时。

在这4种情况下，程序可以被正确编译并执行，但是效率不高。例如：
```cc
class Word {
    String   name;
    int      cnt; .
public:
    //没有错误，只不过太天真……
    Word() {
      name = 0;
      cnt = 0;
    }
};

```
在这里, Word constructor会先产生一个临时性的 String object, 然后将它初始化,之后以一个 assignment运算符将临时性 object指定给 name,随后再摧毁那个临时性object。
这是故意的吗?不大可能。编译器会产生一个警告吗?我不知道！以下是 constructor可能的内部扩张结果:
```cc
// C++ 伪码
Word:: Word( /* this pointer goes here */ )
{
    // 调用 String 的 default constructor
    name. String:: String();
    //产生临时性对象
    String temp = String( 0 );
    //“memberwise”地拷贝  name
    name. String:: operator=( temp );
    //摧毁临时性对象
    temp. String::~ String();
    cnt = 0;
}
```

对代码反复审查并修正，得到一个明显更有效率的实现方法：
```cc
//较佳的方式
Word::Word
 :name(0)
{
  cnt = 0;
}
它会被扩张成这个样子：
// c++ 伪码
Word:: Word( /* this pointer goes here */ )
{
// 调用 String( int ) constructor
  name. String:: String( 0 );
  cnt = 0;
}
```

顺带一提，陷阱最有可能发生在这种形式的 template code 中：

```cc
template < class type >
foo< type >:: foo( type t )
{
    //可能是(也可能不是)个好主意
    //视 type 的真正类型而定
    t = t;
}
```
这会引导某些程序员十分积极进取地坚持所有的 member 初始化操作必须在member initialization list中完成, 甚至即使是一个行为良好的 member, 如  cnt:
```cc
//坚持此种编码风格
Word:: Word()
:   cnt( 0 ),   name( 0 )
{ }
```

在这里我们不禁要提出一个合理的问题: member initialization list 中到底会发生什么事情?
许多C++新手对于 list的语法感到迷惑，他们误以为它是一组函数调用。当然它不是！

编译器会一一操作 initialization list, 以适当顺序在 constructor之内安插初始化操作,并且在任何 explicit user code之前。
例如,先前的 Word constructor被扩充为:
```cc
// C++ 伪码
Word:: Word( /* this pointer goes here */ )
{
    name.String::String( 0 );
    cnt = 0;
}
```

事实上，有一些微妙的地方要注意：list中的项目顺序是由 class中的 members声明顺序决定的，不是由 initialization list中的排列顺序决定的。
在本例的 Word class 中,  name 被声明于 cnt 之前，所以它的初始化也比较早。
“初始化顺序”和“initialization list中的项目排列顺序”之间的外观错乱, 会导致下面意想不到的危险：
```cc
class X {
    int i;
    int j;
public:
    //喔欧，你看出问题了吗? (译注)
    X( int val )
    : j( val ), i( j )
    { }
    …
};
```
译注：上述程序代码看起来像是要把j设初值为 val，再把i设初值为j。
问题在于, 由于声明顺序的缘故, initialization list中的i(j)其实比j(val)更早执行。
但因为j  一开始未有初值，所以i(j)的执行结果导致i无法预知其值。稍后我会列出一个完整的范例。

我建议你总是把一个 member的初始化操作和另一个放在一起(如果你真觉得必要的话),放在 constructor之内,像下面这样:
```cc
//比较受到喜爱的方式
X::X( int val )
: j( val )
{
    i = j;
}
```

另一个常见的问题是，你是否能够像下面这样，调用一个 member function以设定一个 member的初值:

```cc
// X:: xfoo()被调用, 这样好吗?
X::X( int val )
: i( xfoo( val ) ), j( val )
{ }
```

其中 xfoo()是X的一个 member function。
答案是 yes, 但是……唔……之所以加上“但是”，是因为我要给你一个忠告：
请使用“存在于 constructor体内的一个member”, 而不要使用“存在于 member initialization list中的 member”, 来为另  一个 member设定初值。
你并不知道 xfoo()对X object的依赖性有多高,如果你把xfoo()放在 constructor体内, 那么对于“到底是哪一个 member在 xfoo()执行时被设立初值”这件事，就可以确保不会发生模棱两可的情况。

Member function的使用是合法的(当然,我们必须不考虑它所用到的 members是否已初始化)，这是因为和此 object 相关的 this 指针已经被建构妥当，而constructor 大约被扩充为:
```cc
// C++ 伪码: constructor 被扩充后的结果
X::X( /* this pointer, */ int val )
{
    i = this-> xfoo( val );
    j = val;
}
```

最后, 如果一个 derived class member function 被调用, 其返回值被当做 baseclass constructor的一个参数, 将会如何:
```cc
// 调用 FooBar:: fval() 可以吗?
class FooBar : public X {                                      // 译注: base class 是 x
    int   fval;
public:
    int fval() { return   fval; } // 译注: derived class member functionFooBar( int val )

    FooBar(int val)
    :fval( val ), X( fval() )   // 译注: fval()作为 base class constructor 的参数
    { }
    …
};

```
你认为如何?这是一个好主意吗?下面是它可能的扩张结果：
```cc
// C++ 伪码
FooBar::FooBar( /* this pointer goes here */ )
{
    //喔欧：实在不是一个好主意
    X::X( this, this-> fval() );
    fval = val;
};

```
它的确不是一个好主意(后续数章对于 base class和 virtual base class 在 memberinitialization list中的初始化程序会有比较详细的说明) 。

简略地说，编译器会对 initialization list一一处理并可能重新排序，以反映出members的声明顺序。
它会安插一些代码到 constructor体内,并置于任何 explicit usercode之前。

# Data 语意学(The Semantics of Data)
C++对象模型尽量以空间优化和存取速度优化的考虑来表现 nonstatic datamembers，并且保持和C语言 struct 数据配置的兼容性。它把数据直接存放在每一个 class object之中。对于继承而来的 nonstatic data members(不管是 virtual还是nonvirtual base class)也是如此。不过并没有强制定义其间的排列顺序。至于 staticdata members, 则被放置在程序的一个 global data segment中, 不会影响个别的 classobject 的大小。在程序之中,不管该 class 被产生出多少个 objects(经由直接产生或间接派生) , static data members永远只存在一份实例(译注: 甚至即使该 class没有任何 object实例, 其 static data members也已存在) 。但是一个 template class的 static data members的行为稍有不同

每一个 class object 因此必须有足够的大小以容纳它所有的 nonstatic datamembers。有时候其值可能令你吃惊，因为它可能比你想象的还大，原因是：
1. 由编译器自动加上的额外 data members，用以支持某些语言特性(主要是各种 virtual特性)。
2. 因为 alignment(边界调整) 的需要。

## Data Member的布局(Data Member Layout)

已知下面一组 data members:

```cc
class Point3d {
    public:
        // ……
    private:
        float x;
        static List<Point3d*> *freeList;
        float y;
        static const int chunkSize = 250;
        float z;
};
```

Nonstatic data members 在 class object中的排列顺序将和其被声明的顺序一样,
任何中间介入的 static data members 如 freeList和chunkSize都不会被放进对象布局之中。
在上述例子里，每一个 Point3d对象是由三个 float组成的，顺序是x、y、z。static data members存放在程序的 data segment中,和个别的 class objects无关。

C++ Standard要求, 在同 一个 access section(也就是 private、public、protected等区段) 中, members的排列只需符合“较晚出现的 members 在 class object中有较高的地址”这一条件即可(请看C++ Standard 9.2 节)。
也就是说,各个 members并不一定得连续排列。什么东西可能会介于被声明的 members 之间呢? members的边界调整(alignment)可能就需要填补一些 bytes。
编译器还可能会合成一些内部使用的 data members，以支持整个对象模型。vptr就是这样的东西，目前所有的编译器都把它安插在每一个“内含 virtual function之class”的 object 内。vptr 会被放在什么位置呢?传统上它被放在所有显式声明的members的最后。不过如今也有一些编译器把 vptr放在一个 class object的最前端。C++Standard秉承先前所说的“对于布局所持的放任态度”，允许编译器把那些内

部产生出来的 members 自由地放在任何位置上，甚至放在那些被程序员声明出来的 members之间。
C++ Standard也允许编译器将多个 access sections之中的 data members 自由排列，不必在乎它们出现在 class声明中的顺序。也就是说，下面这样的声明：
```cc
class Point3d {
    public:
    // …
    private:
        float x;
        static List<Point3d*> *freeList;
    private:
        float y;
        static const int chunkSize = 250;
    private:
        float z;
};
```

## Data Member的存取

### Static Data Members
每一个 static data member只有一个实例,存放在程序的 data segment之中。
每次程序参阅(取用) static member时，就会被内部转化为对该唯一 extern实例的直接参考操作。例如：
```cc
// origin. chunkSize = 250;
Point3d::chunkSize = 250;

// pt->chunkSize = 250;
Point3d::chunkSize = 250;
```

如果chunkSize 是一个从复杂继承关系中继承而来的 member，又当如何?或许它是一个“virtual base class 的 virtual base class”  (或其他同等复杂的继承结构)的 member也说不定。哦,那无关紧要,程序之中对于 static members还是只有唯一一个实例，而其存取路径仍然是那么直接。

如果 static data member是经由函数调用，或其他某些语法而被存取呢?举个例子，如果我们写：
```cc
foobar(). chunkSize = 250;
```
调用 foobar()会发生什么事情? C++ Standard 明确要求 foobar()必须被求值(evaluated)，虽然其结果并无用处。下面是一种可能的转化：
```cc
foobar(). chunkSize = 250;

// evaluate expression, discarding result
(void) foobar();
Point3d. chunkSize = 250;
```
若取一个 static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向其 class member的指针,因为 static member并不内含在一个 class object之中。例如：
```cc
&Point3d::chunkSize;
```
会获得类型如下的内存地址：
```cc
const int*
```

如果有两个 classes, 每一个都声明了一个 static member freeList, 那么当它们都被放在程序的 data segment时，就会导致名称冲突。
编译器的解决方法是暗中对每一个 static data member编码 (这种手法有个很美的名称: name-mangling) ,以获得一个独一无二的程序识别代码。
有多少个编译器，就有多少种 name-mangling做法！通常不外乎是表格啦、文法措辞啦等。任何 name-mangling做法都有两个重点：
1.一个算法，推导出独一无二的名称。
2.万一编译系统(或环境工具)必须和使用者交谈，那些独一无二的名称可以轻易被推导回到原来的名称。

### Nonstatic Data Members
Nonstatic data members 直接存放在每一个 class object之中。除非经由显式的(explicit) 或隐式的(implicit) class object, 否则没有办法直接存取它们。只要程序员在一个 member function中直接处理一个 nonstatic data member, 所谓“implicitclass object”就会发生。例如下面这段代码:
```cc
Point3d
Point3d:: translate( const Point3d & pt) {
    x += pt. x;
    y += pt. y;
    z += pt. z;
}
```
表面上所看到的对于x、y、z的直接存取,事实上是经由一个“implicit class object”(由this指针表达)完成的。事实上这个函数的参数是：
```cc
// member function 的内部转化
Point3d
Point3d:: translate( Point3d* const this, const Point3d & pt) {
    this->x += pt. x;
    this->y += pt. y;
    this->z += pt. z;
}
```

每一个 nonstatic data member的偏移位置(offset) 在编译时期即可获知, 甚至如果 member属于一个 base class subobject(派生自单一或多重继承串链)也是一样的。因此, 存取一个 nonstatic data member, 其效率和存取一个C struct member或一个 nonderived class 的 member是一样的。
现在让我们看看虚拟继承。虚拟继承将为“经由 base class subobject 存取 classmembers”导入一层新的间接性，比如：
```cc
Point3d *pt3d;
pt3d-> x = 0.0
```
其执行效率在 x是一个 struct member、一个 class member、单一继承、多重继承的情况下都完全相同。但如果 x是一个 virtual base class 的 member,存取速度会稍慢一点。下一节我会验证“继承对于 member布局的影响”。在我们尚未进行到那里之前，请回忆本节一开始的一个问题：以两种方法存取x坐标，像这样：
```cc
origin.x = 0.0;
pt->x = 0.0;
```
“从 origin存取”和“从 pt存取”有什么重大的差异?答案是“当Point3d是一个derived class, 而其继承结构中有一个 virtual base class, 并且被存取的 member(如本例的x) 是一个从该 virtual base class 继承而来的 member”时, 就会有重大的差异。这时候我们不能够说 pt必然指向哪一种 class type(因此，我们也就不知道编译时期这个 member真正的 offset位置)，所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。但如果使用 origin，就不会有这些问题，其类型无疑是Point3d class, 而即使它继承自 virtual base class, members 的 offset位置也在编译时期就固定了。一个积极进取的编译器甚至可以静态地经由 origin就解决掉对x的存取。

### 继承与 Data Member

#### 单继承
```cc
class A {
    public:
        int a = 1;
};

class C : public A {
    public:
        int c = 3;
};

C c;
A *pa = c;

// pa 和 &c 的地址重叠
// 编译器可以直接 bitwise
```

#### 多继承
```cc

class A {
    public:
        int a = 1;
};

class B {
    public:
        int b = 2;
};

class C : public A, public B {
    public:
        int c = 3;
};

C c;
A *pa = &c;
B *pb = &c; // 第二个基类的地址和派生类对象的地址不重叠，编译器需要修改代码

B *pb = &c ? &c + sizeof(A) : 0;
```


#### 内存padding

```cc
class A {
    public:
        ... // 有 virtual
    public:
        int a = 1;
        char aa;
};

class B {
    public:
        ... // 有 virtual
        int b = 2;
        char bb;
};

class C : public A, public B {
    public:
        int c = 3;
};

cout << sizeof(C) << endl; // 28
```

                class A        class B           class C
               ┌────────┐      ┌────────┐        ┌──────────┐
               │vptr_A  │      │vptr_B  │        │ vptr_A   │
               │int a   │      │int b   │        │ int a    │
               │        │      │        │        │          │
               │char aa │      │char bb │        │ char aa  │
               │padding │      │padding │        │ padding  │
               └────────┘      └────────┘        ├──────────┤
                                                 │ vptr_B   │
                                                 │ int b    │
                                                 │          │
                                                 │ char bb  │
                                                 │ padding  │
                                                 ├──────────┤
                                                 │ int c    │
                                                 └──────────┘

#### 虚拟继承(Virtual Inheritance)

```cc
class Point2d {
    public:
        …
    protected:
        float  x,  y;
};

class Vertex : public virtual Point2d {
    public:
        …
    protected:
        Vertex * next;
};

class Point3d : public virtual Point2d {
    public:
        …
    protected:
        float  z;
};

class Vertex3d :
public Vertex, public Point3d
//译注：原书上一行的两个 classes 顺序相反。为与图3.5ab配合，故改之。
{
    public:
        …
    protected:
        float mumble;
};
```

                             ┌────────┐
                             │Point2d │  _x,_y
                             └───┬────┘
                      ┌──────────┴───────────┐
                ┌─────┴──┐              ┌────┴────┐
                │ Vertex │next          │ Point3d │ _z
                └─────┬──┘              └────┬────┘
                      └──────────┬───────────┘
                            ┌────┴─────┐
                            │ Vertex3d │ mumble
                            └──────────┘

如何能够存取 class的共享部分呢?
是在 virtual function table中放置 virtual base class 的 offset

实现出该方法, 将 virtual base class offset 和 virtual function entries混杂在一起。virtual function table 可经由正值或负值来索引。如果是正值,
很显然就是索引到 virtual functions; 如果是负值, 则是索引到 virtual base class
offsets。在这样的策略之下,Point3d的 operator+=运算符必须被转换为以下形式(为
了可读性，我没有做类型转换，同时我也没有先执行对效率有帮助的地址预先计算
操作)：

```cc
void
Point3d::
operator+=( const Point3d'& rhs )
{
 x += rhs.  x;
 y += rhs.  y;
 z += rhs.z;
}

// C++ 伪代码
(this + vptr_Point3d[-1])-> x +=(& rhs + rhs.vptr_Point3d[-1])-> x;
(this + vptr_Point3d[-1])-> y +=(& rhs + rhs.vptr_Point3d[-1])-> y;
z += rhs.z;
```

Derived class实例和 base class实例之间的转换操作，例如：
```cc
Point2d *p2d = pv3d;
```

在上述实现模型下将变成：
```cc
//虚拟 C++代码
Point2d *p2d = pv3d ? pv3d + pv3d->vptr_Point3d[-1] : 0;
```

                  class Point3d           ┌───────────────────────┐
          8字节◄┐┌─────────┐              │virtual base offset (8)│
                ││vptr   ──┼─────────────►├───────────────────────┤
                ││float z  │              │virtual func slot      │
                 ├─────────┤              └───────────────────────┘
                ││vptr   ──┼─────────────►┌───────────────────────┐
                ││float x  │              │virtual func slot      │
                ││float y  │              └───────────────────────┘
                ▼└─────────┘
              Point2d


                  class Vertex            ┌───────────────────────┐ 
          8字节◄┐┌─────────┐              │virtual base offset (8)│ 
                ││vptr   ──┼─────────────►├───────────────────────┤ 
                ││Vertex * │              │virtual func slot      │ 
                 ├─────────┤              └───────────────────────┘ 
                ││vptr   ──┼─────────────►┌───────────────────────┐ 
                ││float x  │              │virtual func slot      │ 
                ││float y  │              └───────────────────────┘ 
                ▼└─────────┘                                        
              Point2d                                               


                   class Vertex            ┌───────────────────────┐ 
                  ┌─────────────┐          │virtual base offset(20)│ 
      class Vertex│vptr   ──────┼─────────►├───────────────────────┤ 
                  │Vertex *     │          │virtual func slot      │ 
                  ├─────────────┤          └───────────────────────┘ 
     class Point3d│vptr   ──────┼──────┐
                  │float z      │      │   ┌───────────────────────┐
                  ├─────────────┤      │   │virtual base offset(12)│
                  │float mumble │      └──►├───────────────────────┤
                  ├─────────────┤          │virtual func slot      │
     class Point2d│vptr   ──────┼─────┐    └───────────────────────┘
                  │float x      │     └───►┌───────────────────────┐
                  │float y      │          │virtual func slot      │
                  └─────────────┘          └───────────────────────┘
  
                                          
                                          
## 指向 Data Members 的指针                                          

考虑下面的 Point3d声明。其中有一个 virtual function,一个 static data member,以及三个坐标值：
```cc
class Point3d {
    public:
        virtual ~Point3d();
        // …
    protected:
        static Point3d origin;
        float x, y, z;
};
```

那么，取某个坐标成员的地址，代表什么意思?例如，以下操作所得到的值代表什么：
```cc
& Point3d::z;
```
上述操作将得到z坐标在 class object中的偏移位置(offset)。最低限度其值将是x和y的大小总和, 因为C++语言要求同一个 access level中的 members的排列顺序应该和其声明顺序相同。


需要知道指向member的指针的定义和使用方法
```cc
class Point3d {
    public:
        virtual ~Point3d() {};
        // …
        static Point3d origin;
        float x = 1, y =2 , z = 3;
};
int main (int argc, char *argv[]) {

    float Point3d::*px = &Point3d::x;
    float Point3d::*py = &Point3d::y;
    float Point3d::*pz = &Point3d::z;
    cout << px << endl; // 1
    cout << py << endl; // 1
    cout << pz << endl; // 1

    Point3d p;

    cout << p.*px << endl; // 1
    cout << p.*py << endl; // 2
    cout << p.*pz << endl; // 3

    return 0;
}
```

# Function 语意学
```cc
  Point3d obj;  
  Point3d * ptr = & obj;
```
当将
```cc
obj. normalize();               
```
修改为
```cc
ptr-> normalize();
```
时, 会发生什么事? 其中的  normalize()定义如下
```cc
Point3d
normalize() const
{
    register float mag = magnitude();
    Point3d normal;
    normal.x =  x/mag;
    normal.y =  y/mag;
    normal.z =  z/mag;
    return normal;
}

float
Point3d:: magnitude() const
{
    return sqrt( x *  x +  y *  y +  z *  z);
}

```

答案是: 我不知道! C++支持三种类型的 member functions: static、nonstatic和 virtual，每一种类型被调用的方式都不相同。
其间差异正是下一节的主题。
不过，我们虽然不能够确定 normalize()和 magnitude()两函数是否为 virtual 或 nonvirtual,但可以确定它一定不是 static, 
原因有二:  (1) 它直接存取 nonstatic 数据,  (2)它被声明为 const。是的, static member functions 不可能做到这两点。

## Member的各种调用方式
### Nonstatic Member Functions(非静态成员函数)

C++的设计准则之 一就是: nonstatic member function 至少必须和一般的nonmember function有相同的效率。也就是说，如果我们要在以下两个函数之间做选择：
```cc
float magnitude3d( const Point3d *  this ) { ……  }
float Point3d::magnitude3d() const { ……  }
```
选择 member function 不应该带来什么额外负担。这是因为编译器内部已将“member函数实例”转换为对等的“nonmember函数实例”。


比如member function normalize 会被编译器转换为 nonmember function
```cc
Point3d
normalize() const
{
    register float mag = magnitude();
    Point3d normal;
    normal.x =  x/mag;
    normal.y =  y/mag;
    normal.z =  z/mag;
    return normal;
}
```

```cc
// 以下描述“named return value 函数”的内部转化
//使用 C++伪码
void
normalize_7Point3dFv( register const Point3d * const this,Point3d &   result)
{
    register float mag = this-> magnitude();
    // default constructor
    result.Point3d::Point3d();
    result.x = this->x/mag;
    result.y = this->y/mag;
    result.z = this->z/mag;
    return;
}
```

一个比较有效率的做法是直接建构“normal”值，像这样：
```cc
Point3d
Point3d::normalize() const
{
    register float mag = magnitude();
    return Point3d(  x/ mag,  y/ mag,  z/ mag );
}
```
它会被转化为以下的代码(再一次我假设 Point3d的 copy constructor已经声明好了，而NRV 的优化也已实施)：

```cc
//以下描述内部转化
//使用 C++伪码
void
normalize_7Point3dFv( register const Point3d * const this, Point3d & result)
{
    register float mag = this-> magnitude();
    //     result 用以取代返回值(return value)
    result.Point3d::Point3d(this->x/mag, this->y/mag, this->z/mag );
    return;
}
```
这可以节省 default constructor初始化所引起的额外负担。


### Virtual Member Functions(虚拟成员函数)

如果 normalize()是一个 virtual member function, 那么以下的调用:
```cc
ptr->normalize();
```

将会被内部转化为：
```cc
( * ptr-> vptr[ 1 ])( ptr );
```

对于以下调用：

```cc
// Point3d obj;
obj. normalize();
```
如果编译器把它转换为：
```cc
( * obj. vptr[ 1 ] )( & obj );
```
虽然语意正确，却没有必要。请回忆那些并不支持多态(polymorphism)的对象(1.3节) 。所以上述经由 obj 调用的函数实例只可以是 Point3d:: normalize()。  “经由一个 class object调用一个 virtual function”, 这种操作应该总是被编译器像对待一般nonstatic member function一样地加以决议(resolved) :
```cc
normalize_7Point3dFv( & obj );
```
这项优化工程的另一利益是, virtual function的一个 inline函数实例可以被扩展 (expanded)开来，因而提供极大的效率利益。

### Static Member Functions(静态成员函数)

如果 Point3d:: normalize()是一个 static member function, 以下两个调用操作:
```cc
obj.normalize();
ptr->normalize();
```
将被转换为一般的 nonmember函数调用，像这样：
```cc
// obj. normalize();
normalize_7Point3dSFv();
// ptr-> normalize();
normalize_7Point3dSFv();
```

以下是静态成员函数的主要特性：
- 它不能够直接存取其 class 中的 nonstatic members。
- 它不能够被声明为 const、volatile 或 virtual。
- 它不需要经由 class object才被调用——虽然大部分时候它是这样被调用的！

如果取一个 static member function的地址,获得的将是其在内存中的位置,也就是其地址。
由于 static member function 没有 this 指针, 所以其地址的类型并不是一个“指向 class member function的指针”, 而是一个“nonmember函数指针”。也就是说：

```cc
&Point3d::object_count();
```
会得到一个数值，类型是：

```cc
unsigned int (*)();
```

而不是：
```cc
unsigned int ( Point3d::* )();
```

Static member function 由于缺乏 this 指针, 因此差不多等同于 nonmember

###  Virtual Member Functions(虚拟成员函数)

#### 单继承
我们已经看过了 virtual function的一般实现模型: 每一个 class 有一个 virtualtable, 内含该 class之中有作用的 virtual function的地址, 然后每个 object 有一个vptr，指向 virtual table的所在。
在这一节中，我要走访一组可能的设计，然后以单  一继承、多重继承和虚拟继承等各种情况，从细部上探究这个模型。
为了支持 virtual function 机制，必须首先能够对于多态对象有某种形式的“执行期类型判断法(runtime type resolution)”。也就是说以下的调用操作将需要 ptr在执行期的某些相关信息，
```cc
ptr->z();
```
如此一来才能够找到并调用z()的适当实例。


```cc
class Point {
    public:
        virtual ~ Point();
        virtual Point& mult( float ) = 0;
        //……其他操作
        float x() const { return  x; }
        virtual float y() const { return 0; }
        virtual float z() const { return 0; }
        // ……
    protected:
        Point( float x = 0.0 );
        float  x;
};
```

                                   
                                   ┌──────────────┐
            ┌───────────┐          │         ─────┼─► type_info for Point
            │vptr     ──┼─────────►│         ─────┼─► Point::~Point()
            │           │          │         ─────┼─► pure_virtual_called()
            │float  x   │          │         ─────┼─► Point::y()
            └───────────┘          │         ─────┼─► Point::z()
             Point pt;             └──────────────┘
                                    virtual table class Point

            ┌───────────┐          ┌──────────────┐                        
            │vptr    ───┼───────┐  │         ─────┼─► type_info for Point2d  
            │float  x   │       └─►│         ─────┼─► Point2d::~Point2d()           
            ├───────────┤          │         ─────┼─► Point2d::mult()
            │float  y   │          │         ─────┼─► Point2::y()           
            └───────────┘          │         ─────┼─► Point::z()           
             Point2d pt2d;         └──────────────┘                        
                                    virtual table class Point2d

            ┌───────────┐          ┌──────────────┐                         
            │vptr    ───┼───────┐  │         ─────┼─► type_info for Point3d   
            │float  x   │       └─►│         ─────┼─► Point3d::~Point3d()            
            ├───────────┤          │         ─────┼─► Point3d::mult()
            │float  y   │          │         ─────┼─► Point2::y()            
            ├───────────┤          │         ─────┼─► Point3d::z()            
            │float  z   │          └──────────────┘                         
            └───────────┘           virtual table class Point3d             
             Point2d pt3d;
                
                virtual table 布局，单一继承的情况

```cc
Point *pp;
// ...
pp->mult(pp); // -->
(*pp->vptr_Point[2])(pp);
```

当一个 class派生自 Point时, 会发生什么事?
一共有三种可能性：
1. 它可以继承 base class所声明的 virtual functions的函数实例。正确地说是, 该函数实例的地址会被拷贝到 derived class 的 virtual table的相对应slot之中。
2. 它可以使用自己的函数实例。这表示它自己的函数实例地址必须放在对应的 slot之中。(可能重写虚函数)
3. 它可以加入一个新的 virtual function。这时候 virtual table 的尺寸会增大一个 slot，而新的函数实例地址会被放进该 slot之中。


现在，如果我有这样的式子：
```cc
ptr->z();
```
我如何有足够的知识在编译时期设定 virtual function的调用呢?
一般而言，在每次调用 z()时，我并不知道 ptr所指对象的真正类型。然而我知道, 经由 ptr可以存取到该对象的 virtual table。
虽然我不知道哪一个z()函数实例会被调用，但我知道每一个z()函数地址都被放在 slot 4中。
这些信息使得编译器可以将该调用转化为：
```cc
( * ptr-> vptr[4] ) ( ptr );
```
在这一转化中, vptr 表示编译器所安插的指针, 指向 virtual table; 4 表示z()被指派的 slot编号(关系到 Point体系的 virtual table)。唯一一个在执行期才能知道的东西是：slot 4所指的到底是哪一个z()函数实例?
在一个单一继承体系中，virtual function机制的行为十分良好，不但有效率而且很容易塑造出模型来。但是在多重继承和虚拟继承之中，对 virtual functions 的支持就没有那么美好了。

#### 多重继承下的 Virtual Functions
在多重继承中支持 virtual functions,其复杂度围绕在第二个及后继的 baseclasses身上，以及“必须在执行期调整 this 指针”这一点。

```cc
// class 体系,用来描述多重继承(MI) 情况下支持 virtual function 时的复杂度
class Base1 {
    public:
        Base1();
        virtual ~ Base1();
        virtual void speakClearly();
        virtual Base1 * clone() const;
    protected:
        float data;
};
class Base2 {
    public:
        Base2();
        virtual ~Base2();
        virtual void mumble();
        virtual Base2 * clone() const;
    protected:
        float data;
};
class Derived : public Base1, public Base2 {
    public:
        Derived();
        virtual ~ Derived();
        virtual Derived * clone() const;
        virtual void func();
    protected:
        float data;
};
```


首先，我把一个从 heap中配置而得的 Derived对象的地址，指定给一个Base2指针：
```cc
Base2 *pbase2 = new Derived;
// 新的 Derived对象的地址必须调整以指向其Base2 subobject。编译时期会产生以下的代码：
// 转移以支持第二个 base class
Derived * temp = new Derived;
Base2 *pbase2 = temp ? temp + sizeof( Base1 ) : 0;
```

当程序员要删除pbase2所指的对象时：
```cc
// 必须首先调用正确的 virtual destructor 函数实例
// 然后施行 delete 运算符。
//pbase2 可能需要调整，以指出完整对象的起始点
delete pbase2;
```
指针必须被再一次调整，以求再一次指向 Derived对象的起始处(推测它还指向Derived对象)。然而上述的 offset加法却不能够在编译时期直接设定，因为 pbase2所指的真正对象只有在执行期才能确定。
一般规则是, 经由指向“第二或后继之 base class”的指针(或 reference) 来调用 derived class virtual function。译注: 就像本例的:
```cc
Base2 *pbase2 = new Derived;
delete pbase2; // invoke derived class's destructor (virtual)
```

其所连带的必要的“this指针调整”操作，必须在执行期完成。也就是说，offset的大小，以及把 offset加到 this指针上头的那一小段程序代码，必须由编译器在某个地方插入。问题是，在哪个地方?

thunk 是一小段 assembly 代码, 用来以适当的 offset值调整 this 指针,  跳到 virtual function 去。例如, 经由一个Base2 指针调用Derived destructor, 其相关的 thunk 可能看起来是这个样子:
```cc
//虚拟 C++代码
pbase2_dtor_thunk:
    this += sizeof( base1 );
    Derived::~ Derived( this );
```

Thunk 技术允许 virtual table slot继续内含一个简单的指针。Slots中的地址可以直接指向 virtual function，也可以指向一个相关的 thunk(如果需要调整this 指针的话)。
于是，对于那些不需要调整this 指针的 virtual function而言,也就不需承载效率上的额外负担。
调整 this指针的第二个额外负担就是，由于两种不同的可能：
(1)经由 derivedclass(或第一个 base class) 调用
(2)经由第二个(或其后继) base class 调用,同一函数在 virtual table中可能需要多笔对应的 slots。例如:
```cc
Base1 *pbase1 = new Derived;
Base2 *pbase2 = new Derived;

delete pbase1;
delete pbase2;
```
虽然两个 delete 操作导致相同的 Derived destructor, 但它们需要两个不同的virtual table slots:

1. pbase1不需要调整 this指针(因为 Base1 是最左端 base class 之故, 它已经指向 Derived对象的起始处)。其 virtual table slot需放置真正的 destructor地址。
2. pbase2需要调整 this指针。其 virtual table slot需要相关的 thunk地址。


在多重继承之下, 一个 derived class 内含 n-1个额外的 virtual tables, n表示其上一层 base classes 的个数(因此, 单一继承将不会有额外的 virtual tables) 。
对于本例的 Derived 而言, 会有两个 virtual tables 被编译器产生出来:
1. 一个主要实例, 与 Base1(最左端 base class) 共享。
2. 一个次要实例, 与 Base2(第二个 base class) 有关。
针对每一个 virtual tables, Derived对象中有对应的 vptr。vptrs 将在 constructor(s)中被设立初值(经由编译器所产生出来的代码) 。
用以支持“一个 class 拥有多个 virtual tables”的传统方法是，将每一个 tables以外部对象的形式产生出来，并给予独一无二的名称。例如，Derived所关联的两个 tables可能有这样的名称：
```cc
vtbl_Derived;                //主要表格
vtbl_Base2_Derived;         //次要表格
```

如果Derived有新增的虚函数都是放到主表。

于是当你将一个 Derived 对象地址指定给一个 Base1 指针或 Derived 指针时,被处理的 virtual table 是主要表格 vtbl_Derived。
而当你将一个 Derived对象地址指定给一个Base2指针时, 被处理的 virtual table是次要表格 vtbl_Base2_Derived。


                                Base1 Virtual Table
                                ┌─────────┐
       ┌──────────┐             │        ─┼──► type_info for Base1
       │vptr_Base1├────────────►│        ─┼──► Base1::~Base1()
       │data_Base1│             │        ─┼──► Base1::speakClearly()
       └──────────┘             │        ─┼──► Base1::clone()
        Base1 b1;               └─────────┘
                                ┌─────────┐
       ┌──────────┐             │        ─┼──► type_info for Base2   
       │vptr_Base2├────────────►│        ─┼──► Base2::~Base2()       
       │data_Base2│             │        ─┼──► Base2::mumble() 
       └──────────┘             │        ─┼──► Base2::clone()        
        Base2 b2;               └─────────┘
                                Base2 Virtual Table


                                ┌──────────┐                                  
       ┌─────────────┐          │         ─┼──►type_info for Derived           
       │vptr_Base1 ──┼─────────►│         ─┼──►Derived::~Derived()               
       │data_Base1   │          │         ─┼──►Base1::speakClearly()         
       ├─────────────┤          │         ─┼──►Derived::clone()
       │vptr_Base2 ──┼────┐     │         ─┼──►Derived::func()
       │data_Base2   │    │     └──────────┘
       ├─────────────┤    │       Derived_main_vtb
       │data_Derived │    │      
       └─────────────┘    │     ┌──────────┐                                     
        Derived d;        │     │         ─┼──►type_info for Derived             
                          └────►│         ─┼──►thunk to Derived::~Derived()────────►Derived::~Derived()
                                │         ─┼──►Base2::mumble()                   
                                │         ─┼──►thunk to Derived::clone()   ────────►Derived::clone() 
                                └──────────┘                                     
                                  Derived_sub_vtb



有三种情况, 第二或后继的 base class会影响对 virtual functions的支持。
第一种情况是,通过一个“指向第二个 base class”的指针,调用 derivedclass virtual function。例如:
```cc
Base2 * ptr = new Derived;
// 调用 Derived::~ Derived
// ptr 必须被向后调整 sizeof( Basel)个 bytes
delete ptr;
```

从图4.2之中，你可以看到这个调用操作的重点：ptr指向 Derived对象中的Base2 subobject; 为了能够正确执行, ptr必须调整指向 Derived对象的起始处。

第二种情况是第一种情况的变化，通过一个“指向 derived class”的指针，调用第二个 base class中一个继承而来的 virtual function。
在此情况下, derived class指针必须再次调整,以指向第二个 base subobject。例如:
```cc

Derived * pder = new Derived;
// 调用 Base2:: mumble()
pder->mumble();
// pder 必须被向前调整 sizeof( Basel ) 个 bytes
```

第三种情况发生于一个语言扩充性质之下：允许一个 virtual function 的返回值类型有所变化, 可能是 base type, 也可能是 publicly derived type。
这一点可以经由Derived:: clone()函数实例来说明。clone 函数的 Derived版本传回一个 Derived class指针，默默地改写了它的两个 base class函数实例。
当我们通过“指向第二个 baseclass”的指针来调用 clone()时, this 指针的 offset 问题于是诞生了:

```cc
Base2 *pb 1 = new Derived;

// 调用 Derived* Derived:: clone()
// 返回值必须被调整, 以指向 Base2 subobject
Base2 *pb2 = pb1-> clone();
```

当进行pb1-> clone()时,pb1会被调整指向 Derived 对象的起始地址,于是 clone()的 Derived版会被调用；
它会传回一个指针，指向一个新的 Derived对象；该对象的地址在被指定给pb2之前,必须先经过调整,以指向 Base2 subobject。

#### 虚拟继承下的 Virtual Functions
考虑下面的 virtual base class 派生体系, 从 Point2d派生出 Point3d:
```cc

class Point2d {
    public:
        Point2d( float = 0.0, float = 0.0 );
        virtual ~Point2d();
        virtual void mumble();
        virtual float z();
        // …
    protected:
        float  _x,  _y;
};
class Point3d : public virtual Point2d {
    public:
        Point3d( float = 0.0, float = 0.0, float = 0.0 );
        ~Point3d();
        float z();
    protected:
        float  _z;
};
```

             ┌────────────────┐      ┌─────────┐
             │vptr_Point2d   ─┼──┐   │        ─┼───► type_info for Point2d
             │_x              │  └──►│        ─┼───► Point2d::~Point2d()
             │_y              │      │        ─┼───► Point2d::mumble()
             └────────────────┘      │        ─┼───► Point2d::z()
                 Point2d p2d         └─────────┘

                                     ┌─────────┐
                                     │    8    │     offset to virtual Base (8)
             ┌────────────────┐      │    0    │     0
             │vptr_Point3d   ─┼───┐  │        ─┼───► type_info for Point3d 
             │_z              │   └─►│        ─┼───► Point3d::~Point2d()   
             ├────────────────┤      │        ─┼───► Point2d::mumble()     
             │vptr_Point2d  ──┼───┐  │        ─┼───► Point3d::z()          
             │_x              │   │  └─────────┘
             │_y              │   │  ┌─────────┐
             └────────────────┘   │  │        ─┼───► type_info for Point3d  
              Point3d p3d         └─►│        ─┼───► Point3d::~Point2d()    
                                     │        ─┼───► Point2d::mumble()      
                                     │        ─┼───► Point3d::z()           
                                     └─────────┘


### 指向 Member Function 的指针
回顾一下,一个指向 member function的指针,其声明语法如下:
```cc
double            // return type
( Point::*          // class the function is member
pmf)              // name of pointer to member
();                // argument list
```

然后我们可以这样定义并初始化该指针：
```cc
double (Point::* coord)() = & Point::x;
```
也可以这样指定其值：
```cc
coord = & Point::y;
```

欲调用它，可以这么做：
```cc
( origin.* coord )();
```
或
```cc
( ptr->* coord)();
```
这些操作会被编译器转化为：
```cc
//虚拟 C++码
( coord )( & origin );
```
和
```cc
//虚拟 C++码
( coord )( ptr );
```

指向 member function的指针的声明语法,以及指向“member selection运算符”的指针，其作用是作为 this 指针的空间保留者。
这也就是为什么 static memberfunctions(没有 this指针) 的类型是“函数指针”, 而不是“指向 member function的指针”之故。


使用一个“member function 指针”, 如果并不用于 virtual function、多重继承、virtual base class等情况的话, 并不会比使用一个“nonmember function指针”的成本更高。
上述三种情况对于“member function指针”的类型以及调用都太过复杂。
事实上, 对于那些没有 virtual functions、virtual base class 或 multiple base classes的classes而言，编译器可以为它们提供相同的效率。

#### 支持“指向 Virtual Member Functions” 的指针

考虑下面的程序片段：

```cc
float (Point::* pmf)() = & Point::z;
Point * ptr = new Point3d;
```

pmf,  一个指向 member function的指针, 被设值为 Point::z()(一个 virtual function)的地址。ptr则被指定以一个Point3d对象。如果我们直接经由 ptr调用z()：
```cc
ptr->z();
```

被调用的是 Point3d::z()。但如果我们从 pmf间接调用z()呢?
```cc
( ptr->* pmf )();
```

仍然是Point3d：：z()被调用吗?也就是说，虚拟机制仍然能够在使用“指向 memberfunction之指针”的情况下运行吗?答案是 yes，问题是如何实现呢?

面对一个 virtual function，其地址在编译时期是未知的, 所能知道的仅是 virtual function在其相关之 virtual table 中的索引值。也就是说, 对一个 virtual member function取其地址, 所能获得的只是一个索引值


例如，假设我们有以下的 Point声明：
```cc
class Point
{
    public:
        virtual ~ Point();
        float x();
        float y();
        virtual float z();
        // …
};
```

然后取 destructor的地址:
```cc
& Point::~ Point;
```
得到的结果是1。取x()或y()的地址：
```cc
& Point::x();
& Point::y();
```

得到的则是函数在内存中的地址，因为它们不是 virtual。取z()的地址：
```cc
& Point::z();
```
得到的结果是2。通过 pmf来调用z()，会被内部转化为一个编译时期的式子， 一般形式如下：
```cc
( * ptr-> vptr[ (int) pmf ])( ptr );
```

对一个“指向 member function 的指针”评估求值(evaluated) , 会因为该值有两种意义而复杂化；其调用操作也将有别于常规调用操作。pmf的内部定义，也就是：
```cc
float (Point::* pmf)();
```

cfront如何识别该值是内存地址还是 virtual table索引呢?它用了以下技巧：
```cc
((( int ) pmf) & ~127 )
?                           // non-virtual invocation
( * pmf )( ptr )
:                           // virtual invocation
( * ptr-> vptr[ (int) pmf ]( ptr ) );
```

#### 在多重继承之下, 指向 Member Functions的指针

为了让指向 member functions 的指针也能够支持多重继承和虚拟继承，Stroustrup 设计了下面一个结构体 ([LIPP88]中有其原始内容) :
```cc
//一般结构，用以支持
// 在多重继承之下指向 member functions的指针
struct    mptr {
    int delta;
    int index;
    union {
        ptrtofunc faddr;
        int     v_offset;
    };
};
```

它们要表现什么呢? index 和 faddr 分别(不同时) 持有 virtual table 索引和nonvirtual member function 地址(为了方便, 当 index 不指向 virtual table时, 会被设为-1)。
在此模型之下，像这样的调用操作：
```cc
( ptr->* pmf )();
```

会变成：
```cc
( pmf. index < 0 )
? // non-virtual invocation
( * pmf. faddr )( ptr )
: // virtual invocation
( * ptr-> vptr[ pmf. index] (ptr) );
```

# 构造、析构、拷贝语意学

```cc
class Point {
    public:
        Point( float x = 0.0, float y = 0.0 )
        :  x( x ),  y( y ) { }

        // no destructor, copy constructor, or
        // copy operator defined ...

        virtual float z();
        // …
    protected:
        float  x,  y;
};
``` 

我并没有定义 一个 copy constructor、copy operator、destructor。我们的所有 members 都以数值来存储

除了每一个 class object多负担一个 vptr之外, virtual function 的导入也引发编译器对于我们的 Point class 产生膨胀作用:

我们所定义的 constructor被附加了一些代码， 以便将 vptr初始化。这些代码必须被附加在任何 base class constructors的调用之后,但必须在任何由使用者(程序员)供应的代码之前。例如，下面就是可能的附加结果(以 Point为例) :
```cc
//c++伪码： 内部膨胀
Point*
Point:: Point( Point * this,
float x, float y )
:  x(x),  y(y)
{
    // 设定 object 的 virtual table pointer(vptr)
    this->vptr_Point = vtbl_Point;
    // 扩展 member initialization list
    this->x = x;
    this->y = y;
    // 传回 this 对象
    return this;
}
```

- 合成一个 copy constructor 和一个 copy assignment operator, 而且其操作不再是 trivial(但 implicit destructor仍然是 trivial)。如果一个 Point object被初始化或以一个 derived class object 赋值, 那么以位为基础(bitwise)的操作可能对 vptr带来非法设定。
```cc
// C++ 伪码
// copy constructor 的内部合成
inline Point*
Point:: Point( Point * this, const Point & rhs )
{
    // 设定 object 的 virtual table pointer (vptr)
    this->vptr_Point = vtbl_Point;
    //将 rhs 坐标中的连续位拷贝到 this 对象,
    // 或是经由 member assignment 提供一个 member……
    return this;
}
```

为了方便，我把 foobar()再次列于此：

```cc
Point global;

Point foobar()
{
    Point local;
    Point * heap = new Point;
    * heap = local;
    // . . . stuff . ..
    delete heap;
    return local;
}
```

foobar()很有可能被转化为下面这样(2.3 节曾有过详细的讨论):

```cc
// C++ 伪码: foobar() 的转化,
// 用以支持 copy constructor

Point foobar( Point &   result )
{
    Point local;
    local. Point:: Point( 0.0, 0.0 );
    // heap 的部分与前相同……
    // copy constructor 的应用
    result. Point:: Point( local );
    // local 对象的 destructor 将在这里执行。
    // 调用 Point 定义的 destructor:
    local. Point::~ Point();

    return;
}

```


如果支持 named return value (NRV) 优化, 这个函数会进一步被转化为:
```cc
// C++ 伪码: foobar() 的转化,
// 以支持 named return value (NRV) 优化

Point foobar( Point &   result )
{
    result.Point::Point( 0.0, 0.0 );
    // heap 的部分与前相同……

    return;
}

```
## 构造语义
### 继承体系下的对象构造 
当我们定义一个 object如下：

```cc
T object;
```

实际上会发生什么事情?如果T有一个 constructor(不论是由 user提供或是由编译器合成的)，它会被调用。这很明显，比较不明显的是，constructor的调用真正伴随了什么?
Constructor可能内含大量的隐藏码, 因为编译器会扩充每一个 constructor, 扩充程度视 class T的继承体系而定。一般而言编译器所做的扩充操作大约如下：
1. 记录在 member initialization list 中的 data members 初始化操作会被放进constructor的函数本体, 并以 members的声明顺序为顺序。
2. 如果有一个 member并没有出现在 member initialization list之中, 但它有一个 default constructor, 那么该 default constructor必须被调用。
3. 在那之前, 如果 class object 有 virtual table pointer(s), 它(们)必须被设定初值, 指向适当的 virtual table(s)。
4. 在那之前,所有上一层的 base class constructors必须被调用,以 base class的声明顺序为顺序(与 member initialization list中的顺序没关联):
如果 base class 被列于 member initialization list中,那么任何显式指定的参数都应该传递过去。
如果 base class 没有被列于 member initialization list 中, 而它有default constructor(或 default memberwise copy constructor) , 那么就调用之。
如果 base class 是多重继承下的第二或后继的 base class, 那么 this 指针必须有所调整。
5. 在那之前, 所有 virtual base class constructors必须被调用, 从左到右,从最深到最浅：

如果 class 被列于 member initialization list中,那么如果有任何显式指定的参数，都应该传递过去。
若没有列于 list之中，而 class 有一个default constructor, 亦应该调用之。
此外, class 中的每一个 virtual base class subobject的偏移位置(offset)必须在执行期可被存取。
如果 class object 是最底层(most-derived) 的 class, 其 constructors可能被调用；某些用以支持这一行为的机制必须被放进来。


我再次以 Point为例,并为它增加一个 copy constructor、一个 copy operator、一个 virtual destructor, 如下所示:
```cc
class Point {
    public:
        Point( float x = 0.0, float y = 0.0 );
        Point( const Point& );                                          // 译注: copy constructor
        Point& operator=( const Point& );  // 译注: copy assignment operator
        virtual ~ Point();                                               // 译注: virtual destructor
        virtual float z() { return 0.0; }
        // ……
    protected:
        float  x,  y;
};
```

在我开始介绍并一步步走过以 Point为根源的继承体系之前，我要带你很快地看看 Line class的声明和扩充结果, 它由  begin和  end两个点构成:
```cc
class Line {
        Point   begin,   end;
    public:
        Line( float=0.0, float=0.0, float=0.0, float=0.0 );
        Line( const Point&, const Point& );
        draw();
        // ……
};
```

每一个 explicit constructor都会被扩充以调用其两个 member class objects 的constructors。如果我们定义 constructor如下:
```cc
Line:: Line( const Point & begin, const Point & end )
:   end( end ),   begin( begin )
{ }
```
它会被编译器扩充并转换为：
```cc
// C++ 伪码: Line constructor 的扩充
Line*
Line:: Line( Line * this,
const Point & begin, const Point & end )
{
    this->begin.Point::Point( begin );
    this->end.Point::Point( end );
    return this;
}
```

由于 Point声明了一个 copy constructor、  一个 copy operator,以及一个 destructor(本例为 virtual) , 所以 Line class 的 implicit copy constructor、copy operator 和destructor 都将有具体效用(nontrivial) 。
当程序员写下：
```cc
Line a;
```
时, implicit Line destructor会被合成出来(如果 Line派生自 Point, 那么合成出来的 destructor将会是 virtual。
然而由于 Line 只是内含 Point objects而非继承自 Point,所以被合成出来的 destructor只是 nontrivial 而已)。其中,它的 member class objects的 destructors会被调用(以其构造的相反顺序):
```cc
// C++ 伪码: 合成出来的 Line destructor
inline void
Line::~Line( Line * this )
{
    this->end.Point::~Point();
    this->begin.Point::~Point();
}
```

### 虚拟继承(Virtual Inheritance)

考虑下面这个虚拟继承(继承自我们的 Point)：
```cc
class Point3d : public virtual Point {
    public:
        Point3d( float x = 0.0, float y = 0.0, float z = 0.0 )
        : Point( x, y ),  z( z ) { }
        Point3d( const Point3d& rhs )
        : Point( rhs ),  z( rhs.  z ) { }
        ~Point3d();
        Point3d& operator=( const Point3d& );
        virtual float z() { return  z; }
        // ……
    protected:
        float  z;
};
```

constructor的函数本体因而必须条件式地测试传进来的参数, 然后决定调用或不调用相关的 virtual base class constructors。下面就是Point3d的 constructor扩充内容:
```cc
// C++ 伪码:
// 在 virtual base class 情况下的 constructor 扩充内容
Point3d*
Point3d::Point3d( Point3d * this, bool most_derived,float x, float y, float z )
{
    if ( most_derived != false )
        this-> Point:: Point( x, y );
    this->vptr_Point3d =  vtbl_Point3d;
    this->vptr_Point3d_Point = vtbl_Point3d_Point;
    this->_z = rhs._z;
    return this;
}

```

在更深层的继承情况下, 例如 Vertex3d, 调用Point3d和 Vertex的 constructor时, 总是会把most_derived 参数设为 false, 于是就压制了两个 constructors 中对Point constructor的调用操作。
```cc
// C++ 伪码:
// 在 virtual base class 情况下的 constructor 扩充内容
Vertex3d*
Vertex3d::Vertex3d( Vertex3d * this, bool most_derived,
float x, float y, float z )
{
    if ( most_derived != false )
        this-> Point:: Point( x, y );
    // 调用上一层 base classes
    // 设定    most   derived 为 false
    this->Point3d::Point3d( false, x, y, z );
    this->Vertex::Vertex( false, x, y );
    // 设定 vptrs
    // 安插 user code
    return this;
}
```

### vptr 初始化语意学(The Semantics of the vptr Initialization)

                    ┌─────┐
                    │Point│
                    └──┬──┘
                 ┌─────┴──────┐
                 ▼            ▼
             virtual       virtual
                 │            │
                 ▼            ▼
            ┌───────┐     ┌──────┐
            │Point3d│     │Vertex│
            └────┬──┘     └───┬──┘
                 ▼            ▼
              public       public
                 │            │
                 └─────┬──────┘
                       ▼
                   ┌────────┐
                   │Vertex3d│
                   └───┬────┘
                       ▼
                    public
                       │
                       ▼
                   ┌───────┐
                   │PVertex│
                   └───────┘


当我们定义一个PVertex object时, constructors的调用顺序是:

```cc
Point( x, y );
Point3d( x, y, z );
Vertex( x, y, z );
Vertex3d( x, y, z );
PVertex( x, y, z );
```

令每一个 base class constructor设定其对象的 vptr, 使它指向相关的 virtual table之后，构造中的对象就可以严格而正确地变成“构造过程中所幻化出来的每一个class”的对象。
也就是说,一个PVertex对象会先形成一个 Point对象、一个Point3d对象、一个 Vertex对象、一个 Vertex3d对象, 然后才成为一个PVertex对象。
在每一个 base class constructor中,对象可以与 constructor's class的完整对象做比较。对于对象而言，  “个体发生学”概括了“系统发生学”。constructor 的执行算法通常如下：
1. 在 derived class constructor中, “所有 virtual base classes”及“上一层base class”的 constructors会被调用。
2. 上述完成之后, 对象的 vptr(s)被初始化, 指向相关的 virtual table(s)。
3. 如果有 member initialization list的话, 将在 constructor体内扩展开来。这必须在 vptr被设定之后才做, 以免有一个 virtual member function 被调用。
4. 最后，执行程序员所提供的代码。

例如, 已知下面这个由程序员定义的PVertex constructor:
```cc
PVertex::PVertex( float x, float y, float z )
:   next( 0 ), Vertex3d( x, y, z ),
Point( x, y )
{
    if ( spyOn )
        cerr << " Within PVertex::PVertex()" ;
        << "size: " << size() << endl;
}
```

它很可能被扩展为：
```cc
// C++ 伪码:
// PVertex constructor 的扩展结果
PVertex*
PVertex::PVertex( PVertex* this,
bool most_derived,
float x, float y, float z )
{
    // 条件式地调用 virtual base constructor
    if ( most_derived != false )
        this->Point:: Point( x, y );

    //无条件地调用上一层 base
    this->Vertex3d::Vertex3d( x, y, z );

    //将相关的 vptr 初始化
    this->vptr_PVertex = vtbl_PVertex;
    this->vptr_Point_PVertex = vtbl_Point_PVertex;

    //程序员所写的代码
    if ( spyOn )
        cerr << " Within PVertex::PVertex()"
        << " size: "                       
        << (* this->vptr_PVertex[ 3 ]. faddr) (this)
        << endl;

    //传回被构造的对象
    return this;
}
```

### 对象复制语意学(Object Copy Semantics)

现在派生一个 Point3d class(请注意是虚拟继承) :
```cc
class Point3d : virtual public Point {
    public:
        Point3d( float x = 0.0, float y = 0.0, float z = 0.0 );
        // …
    protected:
        float  z;
};
```

如果我们没有为 Point3d定义一个 copy assignment operator, 编译器就必须合成一个(因为前述的第二项和第四项理由)。合成而得的东西可能看起来像这样：
```cc
// C++ 伪码: 被合成的 copy assignment operator
inline Point3d&
Point3d:: operator=( Point3d* const this, const Point3d &p )
{
    // 调用 base class 的函数实例
    this-> Point:: operator=( p );
    // memberwise copy the derived class members
    z = p.  z;
    return * this;
}


## 析构语意学        (Semantics of Destruction)

如果 class没有定义 destructor, 那么只有在 class 内含的 member object(抑或class自己的 base class) 拥有 destructor的情况下, 
编译器才会自动合成出一个来。否则，destructor被视为不需要，也就不需被合成(当然更不需要被调用)。


一个由程序员定义的destructor被扩展的方式类似 constructors被扩展的方式, 但顺序相反:
1. destructor的函数本体首先被执行。
2. 如果 class 拥有 member class objects, 而后者拥有 destructors, 那么它们会以其声明顺序的相反顺序被调用。
3. 如果 object内含一个 vptr, 现在被重新设定, 指向适当之 base class的 virtualtable。
4. 如果有任何直接的(上一层) nonvirtual base classes拥有 destructor, 它们会以其声明顺序的相反顺序被调用。
5. 如果有任何 virtual base classes拥有 destructor, 而目前讨论的这个 class是最尾端(most-derived)的 class，那么它们会以其原来的构造顺序的相反顺序被调用。

# 执行期语意学

##  对象的构造和析构

一般而言, constructor和 destructor的安插都如你所预期的那样:
```cc
// C++ 伪码
{
    Point point;
    // point. Point:: Point()  一般而言会被安插在这里
    // point. Point::~ Point() 一般而言会被安插在这里
}
```
如果一个区段(译注：以{}括起来的区域)或函数中有一个以上的离开点，情况会稍微混乱一些。
Destructor必须被放在每一个离开点(当时 object 还存活)之前，例如：

```cc
{
    Point point;
    // constructor 在这里行动
    switch( int( point. x() ) ) {
        case - 1 :
            // mumble;
            // destructor 在这里行动
            return;
        case 0 :
            // mumble;
            // destructor 在这里行动
            return;
        case 1 :
            // mumble;
            // destructor 在这里行动
            return;
        default :
            // mumble;
            // destructor 在这里行动
            return;
    }
    // destructor 在这里行动
}
```

在这个例子中, point的 destructor必须在 switch指令4个出口的 return操作前被生成出来。
另外也很有可能在这个区段的结束符号(右大括号)之前被生成出来——即使程序分析的结果发现绝不会进行到那里。
同样的道理，goto指令也可能需要许多个 destructor调用操作。例如下面的程序片段：
```cc
{
    if ( cache )
        //检查 cache;如果吻合就传回 1
        return 1；  //译注：原书少了这一行，应为作者笔误。
    Point xx;
    // xx 的 constructor 在这里行动
    while ( cvs. iter( xx ) )
        if ( xx == value )
            goto found;
    // xx 的 destructor 在这里行动
    return 0;
found:
    // cache item
    // xx 的 destructor 在这里行动
    return 1;
}

```
Destructor调用操作必须被放在最后两个 return指令之前，但是却不必被放在最初的 return之前，那当然是因为那时 object尚未被定义出来！
一般而言我们会把 object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的对象产生操作和摧毁操作。
以本例而言，如果我们在检查 cache之前就定义了 Point object，那就不够理想。
这个道理似乎非常明显，但许多 Pascal或C程序员使用C++的时候，仍然习惯把所有的 objects放在函数或某个区段的起始处。

### 全局对象 (Global Objects)

如果我们有以下程序片段：
```cc
Matrix identity;
main()
{
    // identity 必须在此处被初始化
    Matrix m1 = identity;
    …
    return 0;
}
```

C++保证,  一定会在 main()函数中第一次用到 identity之前, 把 identity构造出来,而在 main()函数结束之前把 identity摧毁掉。
像 identity这样的所谓 global object如果有 constructor和 destructor的话，我们说它需要静态的初始化操作和内存释放操作。

### 局部静态对象 (Local Static Objects)

假设我们有以下程序片段：

```cc
const Matrix&
identity() {
    static Matrix mat_identity;
    // ……
    return mat_identity;
}
```
Local static class object 保证了什么样的语意?
- mat_identity 的 constructor必须只能施行一次, 虽然上述函数可能会被调用多次。
- mat_identity 的 destructor 必须只能施行一次, 虽然上述函数可能会被调用多次。

编译器的策略之一就是，无条件地在程序起始(startup)时构造出对象来。
然而这会导致所有的 local static class objects都在程序起始时被初始化,即使它们所在的那个函数从不曾被调用过。
因此, 只在 identity()被调用时才把 mat_identity构造起来


下面是 cfront的输出(经过轻微的修润) :

```cc
//被产生出来的临时对象，作为戒护之用
static struct Matrix *  __0_F3 = 0;
// C++ 的 reference 在 C 中是以 pointer来代替的
// identity() 的名称会被 mangled

struct Matrix*
identity_Fv()
{
    //  1反映出语汇层面的设计，
    //使得 C++得以支持这样的代码：
    // int val;
    // int f() { int val;
    //                           return val + :: val; }
    //最后一行会变成：
    // ... return    lval + val;

    static struct Matrix    __1mat_identity;

    //如果临时性的保护对象已被设立，那就什么也别做。否则
    // (a) 调用 constructor: ct_6MatrixFv
    // (b)设定保护对象，使它指向目标对象
    __0_F3
    ? 0
    : ( ct_6MatrixFv( & __1mat_identity ),( __0_F3 = ( & __1mat_identity )));
    …
}
```

最后, destructor必须在“与 text program file有关联的静态内存释放函数(static deallocation function) ”中被有条件地调用:
```cc
char __std_stat_0_c_j()
{
    __0_F3
    ? _dt_6MatrixFv( __0_F3, 2 )
    : 0 ;
    …
}
```

### 对象数组(Array of Objects)


如果程序员提供一个或多个明显初值给一个由 class objects组成的数组，像下面这样，会如何：
```cc
Point knots[ 10 ] = {
    Point(),
    Point( 1.0, 1.0, 0.5 ),
    -1.0
};
```

很可能被转换为:
```cc
Point knots[ 10 ];

// C++ 伪码

//显式地初始化前 3 个元素
Point:: Point( & knots[0] );
Point:: Point( & knots[1], 1.0, 1.0, 0.5 );
Point:: Point( & knots[2], - 1.0, 0.0, 0.0 );

// 以 vec_new 初始化后的7个元素
vec_new( & knots+3, sizeof( Point ), 7, & Point:: Point, 0 );
```

在 cfront中, 我们使用一个被命名为 vec_new()的函数,产生出以 class objects构造而成的数组。
比较新近的编译器, 包括 Borland、Microsoft 和 Sun, 则是提供两个函数,一个用来处理“没有 virtual base class”的 class, 
另一个用来处理“内含 virtualbase class”的 class。后一个函数通常被称为 vec_vnew()。函数类型通常如下(当然在各平台上可能会有些许差异)：

```cc
void*
vec_new(
void * array,                                             //数组起始地址
size_t elem_size,                      // 每一个 class object的大小
int elem_count,                                          //数组中的元素个数
void (* constructor)( void* ),
void (* destructor)( void*, char )
}

```

## new 和 delete 运算符

运算符 new的使用，看起来似乎是个单一运算，像这样：

```cc
int * pi = new int( 5 );
```
但事实上它是由两个步骤完成的：
1.通过适当的 new运算符函数实例，配置所需的内存：
```cc
//调用函数库中的 new运算符
int * pi = new ( sizeof( int ) );
```
2.将配置得来的对象设立初值：
```cc
* pi = 5;
```

更进一步地说，初始化操作应该在内存配置成功(经由 new运算符)后才执行：
```cc
//new运算符的两个分离步骤
// given: int * pi = new int( 5 );

//重写声明
int * pi;
if ( pi = new ( sizeof( int ) ) )
    *pi =5；   //译注：成功了才初始化
```

delete 运算符的情况类似。当程序员写下：
```cc
delete pi;
```


时，如果 pi的值是0，C++语言会要求 delete运算符不要有操作。因此编译器必须为此调用构造一层保护膜：
```cc
if ( pi != 0 )
    delete( pi );
```
请注意 pi并不会因此被自动清除为0


以 constructor来配置一个 class object, 情况类似。例如:

```cc
Point3d * origin = new Point3d;
```

被转换为：

```cc
Point3d * origin;
// C++ 伪码
if ( origin =    new( sizeof( Point3d ) ) )
    origin = Point3d::Point3d( origin );
```
如果实现出 exception handling, 那么转换结果可能会更复杂些:
```cc
// C++ 伪码
if ( origin =    new( sizeof( Point3d ) ) ) {
    try {
        origin = Point3d::Point3d( origin );
    }
    catch( …… ) {
        // 调用 delete library function 以
        //释放因 new 而配置的内存
        delete( origin );
        // 将原来的 exception 上传
        throw;
    }
}
```

在这里, 如果以 new运算符配置 object, 而其 constructor抛出一个 exception,配置得来的内存就会被释放掉。然后 exception再被抛出去(上传)。
Destructor的应用极为类似。下面的式子：

```cc
delete origin;
```

会变成：
```cc
if ( origin != 0 ) {
    // C++ 伪码
    Point3d::~Point3d( origin );
    delete( origin );
}
```

如果在 exception handling 的情况下, destructor 应该被放在一个 try区段中。exception handler会调用 delete运算符, 然后再一次抛出该 exception。

一般的 library对于 new 运算符的实现操作都很直截了当，但有两个精巧之处值得斟酌(请注意, 以下版本并未考虑 exception handling) :
```cc
extern void*
operator new( size_t size)
{
    if ( size == 0 )
        size = 1;

    void * last_alloc;
    while ( !(last_alloc = malloc( size ) ) )
    {
        if (   new_handler )
            ( *  new_handler )();
        else
            return 0;
    }
    return last_alloc;
}

```
虽然这样写是合法的：

```cc
new T[ 0 ];
```

但语言要求每一次对 new 的调用都必须传回一个独一无二的指针。
解决此问题的传统方法是传回一个指针，指向一个默认为1-byte的内存区块(这就是为什么程序代、码中的 size被设为1的原因)。
这个实现技术的另一个有趣之处是，它允许使用者提供一个属于自己的 new handler()函数。这正是为什么每 一次循环都调用  new handler()之故。
new运算符实际上总是以标准的C malloc()完成，虽然并没有规定一定得这么做不可。相同情况，delete 运算符也总是以标准的C free()完成：

```cc
extern void
operator delete( void * ptr )
{
    if ( ptr )
        free( (char*) ptr );
}
```

### 针对数组的 new语意
因为 delete [] ptr 不需要用户指定数组长度，所以ptr需要记录数组长度
应该如何记录元素个数?一个明显的方法就是为 new []所传回的每一个内存区块配置一个额外的 word，然后把元素个数包藏在那个 word之中。


### Placement Operator new 的语意
有一个预先定义好的重载的(overloaded) new运算符, 称为 placement operatornew。它需要第二个参数，类型为void*。调用方式如下：
```cc
Point2w * ptw = new( arena ) Point2w;
```
其中 arena 指向内存中的一个区块,用以放置新产生出来的 Point2w object。

Placement new operator 所扩充的另一半是将 Point2w constructor 自动实施于arena所指的地址上：
```cc
// C++ 伪码
Point2w * ptw = ( Point2w* ) arena;
if ( ptw != 0 )
    ptw->Point2w::Point2w();
```

这正是使 placement operator new 威力如此强大的原因。这一份代码决定objects被放置在哪里; 编译系统保证 object的 constructor会施行于其上。
然而却有一个轻微的不良行为。你看得出来吗?下面是一个有问题的程序片段：
```cc
//让 arena 成为全局性定义
void fooBar() {
    Point2w *p2w = new( arena ) Point2w;
    // …… do it ……
    // . .. now manipulate a new object ...
    p2w = new ( arena ) Point2w;
}
```

如果 placement operator在原已存在的一个 object上构造新的 object,而该既存的 object有个 destructor, 这个 destructor并不会被调用。调用该 destructor的方法之一是将那个指针 delete掉。不过在此例中如果你像下面这样做，绝对是个错误：
```cc
//以下并不是实施 destructor 的正确方法
delete p2w;
p2w = new ( arena ) Point2w;
```

是的，delete运算符会发生作用，这的确是我们所期待的。但是它也会释放由p2w所指的内存，这却不是我们所希望的，因为下一个指令就要用到p2w了。因此，我们应该显式地调用 destructor并保留存储空间以便再使用¹：
```cc
// 施行 destructor 的正确方法
p2w->~Point2w;
p2w = new ( arena ) Point2w;
```


## 临时性对象 (Temporary Objects)

1.  **临时性对象的产生原因**：
    *   临时性对象常常由编译器**隐式地产生**，用来处理复杂的表达式、函数调用（尤其是按值返回）和类型转换。
    *   例如，在表达式 `if ( yy == xx.getValue() )` 中，编译器会将其转换为一系列步骤：
        *   调用 `xx.getValue()`，其返回值需要存储在一个临时性的 `class X` 对象中（例如 `temp1`）。
        *   这个临时性的 `X` 对象会调用其类型转换运算符 `operator Y()`，将自身转换为 `class Y` 对象，这个返回值又需要存储在一个临时性的 `class Y` 对象中（例如 `temp2`）。
        *   最后，`yy` 对象会调用其 `operator==()` 成员函数，并将临时对象 `temp2` 作为参数。这个运算符的返回值（一个 `bool` 或 `int`）可能也会存储在一个临时对象中（例如 `temp3`）。
    *   带有副作用的参数、单一表达式中的多重调用，或者 inline 函数中存在多个局部变量，都可能产生临时性对象。连锁的 inline 调用也可能导致编译器无法进行优化，从而产生临时对象.

2.  **临时性对象的生命周期与销毁规则**：
    *   **一般规则**：临时性对象通常在引起它产生的**完整表达式 (full-expression)** 求值过程中的**最后一个步骤**被销毁。
    *   **完整表达式**被定义为被包含的表达式中最外围的那个。例如，一个三元表达式 `? :` 或一个带有多个子表达式的逻辑表达式都是完整表达式。
    *   如果在完整表达式中，某个子表达式是**有条件地被求值**的（例如在 `s + t || u + v` 中，`u + v` 只在 `s + t` 为假时才求值），那么该子表达式产生的临时对象也只有在它被真正求值时才会被创建和销毁。

3.  **临时性对象的销毁规则例外情况**:
    *   绑定到引用：如果一个临时性对象被绑定到一个 **`const` 引用**上，那么该临时对象的生命周期会被**延长**。它会一直存在，直到被绑定的引用的生命周期结束，或者临时对象本身的生命范畴（scope）结束，以先到达者为准。例如 `const String & space = " ";` 会导致为字符串字面值 `" "` 创建的临时 `String` 对象一直存活到 `space` 引用超出作用域。

4.  **临时性对象与优化**:
    *   **Named Return Value (NRV) 优化**是一种重要的编译器优化，旨在消除函数按值返回时可能产生的临时对象。这种优化并非总是能被所有编译器实现，或者在函数结构复杂时难以施行。

5.  **特定场景下的临时对象**：
    *   **按值传递参数**在观念上会触发拷贝构造函数，对于 POD 类型实际上是简单的位拷贝。对于 ADT 类型，可能涉及临时对象的创建和拷贝。
    *   **按值返回对象**在观念上会触发拷贝构造函数，对于 POD 类型实际上是简单的位拷贝。对于 ADT 类型，可能涉及临时对象的创建，而 NRV 优化则试图消除这个临时对象。

总的来说，本书详细解释了临时性对象在 C++ 对象模型中的作用，它们是如何隐式产生的，它们的生命周期规则，以及编译器为优化（特别是 NRV 优化）所做的努力，同时也澄清了关于临时对象效率的一些误解。

# 站在对象模型的尖端

## 执行期类型识别(Runtime Type Identification, RTTI)
以下是该节讨论的主要内容：

*   **什么是 RTTI？** 
    - RTTI 是指**执行期类型识别 (Runtime Type Identification)**。它允许程序在执行期间查询**多态对象 (polymorphic object)** 的实际类型。
*   **RTTI 的主要用途：**
    *   **支持安全的向下转换 (Type-Safe Downcast)：** 在 RTTI 引入之前，C++ 缺乏一种机制来安全地将基类指针或引用转换为派生类指针或引用，而不会导致潜在的错误或内存损坏。RTTI 提供了 `dynamic_cast` 运算符来实现这一功能，它可以在执行期检查转换的合法性。
    *   **支持异常处理 (Exception Handling, EH)：** 异常处理机制需要在执行期确定被抛出 (thrown) 异常对象的实际类型，以便找到匹配的 `catch` 块。源材料提到，RTTI 是因为支持 EH 而获得的副产品。异常处理需要类型描述器 (type descriptor) 来表示异常对象的类型信息。
*   **哪些类型支持 RTTI？** 在 C++ 中，**只有具备多态性质的 class (polymorphic class)** 才支持 RTTI。一个 class 被认为是多态的，如果它包含继承而来或自身声明的虚函数 (virtual functions)**。
*   **RTTI 的实现机制：**
    *   编译器通常利用**虚指针 (vptr)** 来支持 RTTI。
    *   与 class 相关的 RTTI 对象（即 `type_info` 对象）的地址通常被存放在该 class 的**虚函数表 (virtual table)** 中，通常是**第一个槽位 (slot)**。
    *   对于多态类，每一个 class object 都已经有一个 vptr 指向其 virtual table。将 RTTI 信息放在 virtual table 中，意味着每个 class object 只需要**额外增加一个指针的空间开销**来支持 RTTI，因为 vptr 已经存在了。这个指向 `type_info` 对象的指针是由编译器静态设定的，而不是在执行期由构造函数设定的（与 vptr 不同）。
*   **关键的 RTTI 运算符：**
    *   **`dynamic_cast`：** 用于在执行期进行类型安全的向下转换。
        *   对于**指针**：如果转换是安全的（即基类指针确实指向目标派生类对象），它返回被适当转换过的指针；如果转换不安全，它返回 `0`。
        *   对于**引用**：如果转换不安全，由于引用不能为 `0`，`dynamic_cast` 会**抛出一个 `bad_cast` 异常**。
        *   其底层机制是获取指针所指向对象的执行期类型描述器（通过 vptr 和 virtual table）与目标类型的类型描述器进行比较，这通常通过调用 runtime library 函数来实现。因此，它比 `static_cast` 昂贵，但更安全
    *   **`typeid`：** 返回一个 `const type_info&` 对象，该对象描述给定表达式或类型的类型。
        *   可以用于比较两个类型是否相等。
        *   `typeid` 也可以用于**非多态类型**和**内建类型**（例如 `int` 或 `int*`），这对异常处理是必要的。但对于这些类型，相关的 `type_info` 对象是**静态取得**的，而不是在执行期取得。 

```cc
typedef type * ptype;
typedef fct * pfct;

simplify_conv_op( ptype pt )
{
    if ( pfct pf = dynamic_cast< pfct >( pt )) {
        // …… process pf
    }
    else { …… }
}
```

pfct的一个类型描述器会被编译器产生出来。由 pt所指向的 class object类型描述器必须在执行期通过 vptr取得。 下面就是可能的转换：
```cc
//取得 pt 的类型描述器
((type_info*) (pt-> vptr[ 0 ]))->type_descriptor;
```
type_info是C++ Standard所定义的类型描述器的 class 名称,该 class中放置着待索求的类型信息。virtual table 的第一个 slot 内含 typeinfo object 的地址;


程序执行中对一个 class 指针类型施以 dynamic   cast 运算符, 会获得 true 或false:
-  如果传回真正的地址，则表示这一 object 的动态类型被确认了，  一些与类型有关的操作现在可以施行于其上。
-  如果传回0，则表示没有指向任何 object，意味着应该以另一种逻辑施行于这个动态类型未确定的 object身上。
-  dynamic_cast 运算符也适用于 reference身上。然而对于一个 non-type-safe cast,其结果不会与施行于指针的情况相同。
    -  如果 reference 真正参考到适当的 derived class(包括下一层或下下一层,或下下下一层或……)，downcast会被执行而程序可以继续进行。
    -  如果 reference并不真正是某一种 derived class,那么,由于不能够传回0,因此抛出一个 bad   cast exception。

```cc
simplify_conv_op( const type & rt )
{
    try {
        fct & rf = dynamic_cast< fct& >( rt );
        // ……
    }
    catch( bad   cast ) {
        // …… mumble ……
    }
}

```

使用 typeid 运算符，就有可能以一个 reference 达到相同的执行期替代路线(runtime“alternative pathway” ) :
```cc
simplify_conv_op( const type & rt )
{
    if ( typeid( rt ) == typeid( fct ) )
    {
        fct & rf = static_cast< fct& >( rt );
        // ……
    }
    else { …… }
}

```

typeid运算符传回一个 const reference, 类型为 type_info。在先前测试中出现的equality(等号) 运算符, 其实是一个被 overloaded的函数:
```cc
bool
type_info::
operator==( const type_info& ) const;
```
如果两个 type_info objects相等, 这个 equality 运算符就传回 true。

type_info object由什么组成? C++ Standard(Section 18.5.1) 中对type_info的定义如下 (译注：你可以在Visual C++的 typeinfo. h中找到类似的定义) :
```cc
class type_info {
    public:
        virtual ~ type_info();
        bool operator==( const type_info& ) const;
        bool operator!=( const type_info& ) const;
        bool before( const type_info& ) const;
        const char* name() const;  // 译注: 传回 class 原始名称
    private:
        // prevent memberwise init and copy
        type_info( const type_info& );
        type_info& operator=(const type_info& );
        // data members
};
```

*   **`type_info` 类：** C++ Standard 定义了 `type_info` 类来表示类型信息。它包含用于比较类型（`operator==`, `operator!=`, `before`）以及获取类型名称 (`name()`) 的成员函数。一些编译器（如 Visual C++）可能提供额外的成员，如 `raw_name()`，用于获取编码后的类型名称。`type_info` 对象由编译器在需要时产生。
*   **开销：** 支持 RTTI 会带来额外的空间开销（每个多态对象一个指针，以及每个类型一个 `type_info` 对象）和执行期时间开销（`dynamic_cast` 和针对多态类型的 `typeid` 需要进行执行期类型查询和比较）。但这为类型安全和异常处理提供了必要的支持。


