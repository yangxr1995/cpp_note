[[toc]]

# 通用工具
## Pair Tuple
Pair 用于处理类型不同的两个值，常用于实现返回一个 value pair, 若容器元素是 key/value pair.
Tuple 是pair的延伸，可以接受任意个数的元素。

### Pair
Class pair 可将两个 value 视为一个单元。C++标准库内多处用到了这个 class。
尤其容器 map、multimap、unordered_map和 unordered_multimap就是使用 pair来管理其以key/value pair形式存在的元素.
任何函数如果需返回两个value，也需要用到pair，例如minmax（）.
Struct pair定义于＜utility＞。原则上你可以对`pair<>`执行create、copy/assign/swap及compare操作。
此外它还提供 first_type和 second_type类型定义式，用来表示第一value和第二value
为了让外部访问，Pair是struct，所以成员都是public

```cc
// pair有两个成员，类型分别为T1, T2
// 调用 T1 T2的默认构造来构造p
pair<T1, T2> p;

// 调用 T1 T2的拷贝构造来构造p
pair<T1, T2> p(val1, val2);

// 调用 T1 T2的右值拷贝构造来构造p
pair<T1, T2> p(rval1, rval2);

// pair的拷贝构造
pair<T1, T2> p(p2);
p = p2; // 赋值
p = rv; // 右值赋值

p.first; // 获得pair的第一个元素
p.second; // 获得pair的第二个元素

get<0>(p); // 等价于 p.first
get<1>(p); // 等价于 p.second

p1 == p2;
p1 < p2;
p1 > p2;
p1.swap(p2);
swap(p1, p2);

make_pair(val1, val2); // 便捷构造一个pair并返回
``` 

可以对pair使用tuple-like接口
```cc
typedef std::pair<int, float> intFloatPair;
intFloatPair p(42, 1.2);

std::get<0>(p);
std::get<1>(p);
std::tuple_size<intFloatPair>::value;      // 2
std::tuple_element<0, intFloatPair>::type; // int
std::tuple_element<1, intFloatPair>::type; // float 
```

### 使用 tuple 构造 pair
pair的构造函数有三种:
```cc
template <typename T1, typename T2>
struct pair {
    pair(const T1 &, const T2 &);

    template<typename U, typename V> pair(U &&, V &&);

    template<typename... Args1, typename... Args2>
    pair(piecewise_construct_t,
         tuple<Args1...> first_args,
         tuple<Args2...> second_args);
};
```
第三种构造函数需要详细解释:


在C++中，`std::pair`的`piecewise_construct`构造函数允许分段构造其两个成员变量，适用于成员类型需要多个参数构造的情况。
它接受一个`std::piecewise_construct_t`标签和两个`std::tuple`参数，分别用于构造`first`和`second`。

```cpp
#include <utility>
#include <string>
#include <vector>

int main() {
    // 使用piecewise_construct构造pair
    std::pair<std::string, std::vector<int>> p(
        std::piecewise_construct,
        std::make_tuple(5, 'a'),   // 构造string(5, 'a')
        std::make_tuple(3, 42)    // 构造vector<int>(3, 42)
    );
    // p.first = "aaaaa"
    // p.second = {42, 42, 42}
}
```

再看一个例子

```cc
class Foo {
    public:
    Foo(tuple<int, float>) {
        cout << "Foo::Foo(tuple)" << endl;
    }
    template <typename... Args>
    Foo (Args... args) {
        cout << "Foo::Foo(args...)" <<endl;
    }
};

tuple<int, float> t(1, 2,2);

// Foo f = t 
pair<int, Foo> p1(41, t);

// Foo f = args...
pair<int, Foo> p2(piecewise_construct, make_tuple(42), t);
```

程序输出
```bash
Foo::Foo(tuple)
Foo::Foo(args...)
```
也就是说在使用 piecewise_construct 时，会将 tuple 转换为 Args对pair的元素进行构造


#### make_pair
Template函数make_pair（）使你无须写出类型就能生成一个pair对象。举个例子，你不必这样写：
```cc
pair<int, char>(42, '@');
```
可以写成这样
```cc
make_pair(42, '@');
```
make_pair的声明如下，
```cc
namespace std {
    template <typename T1, typename T2>
    pair<T1, T2> make_pair (const T1 &x, const T2 &y) {
        return pair<T1, T2>(x, y);
    }

    template <typename T1, typename T2>
    pair<T1, T2> make_pair (T1 &&x, T2 &&y) {
        return pair<T1, T2>(x, y);
    }
}
```
其中返回值的细节和它们的类型V1和V2，取决于x和y的类型。
如果可能的话`make_pair（）`优先使用move语义，否则就使用copy语义。

以下是一些使用示例:
```cc
v f(std::pair<int, const char *>);
v g(std::pair<const int, std::string>);

foo() {
    f(std::make_pair(4, "aa"));
    g(std::make_pair(4, "aa"));   // 隐式类型转换 const char * -> string
}
```

如果你的选择是move semantic，只需使用`std::move（）`声明被传递的实参不再使用
```cc
string s, t;
auto p = make_pair(move(s), move(t));
... // s, t 不再使用
```

如果你的选择是 reference semantic，就必须使用 ref（），那会强迫形成一个 reference 类型，或使用 cref（）强迫形成一个constant reference类型
```cc
int i = 0;
auto p = std::make_pair(std::ref(i), std::ref(i));
++p.first;
++p.second;
cout << "i : " << i << endl;    // 2
```

你也可以使用定义于`<tuple>`内的tie()接口，抽取出pair的value：
```cc
pair<char, char> p = make_pair('x', 'y');

char c = 'a';
tie(std::ignore, c) = p;    // 从pair p 中提取第二个值，赋值给c
                            // p->first 被忽略， p->second 被赋值给c
cout << c << endl; // 'y'
```

### pair之间的比较
C++标准库提供了大家惯用的操作符。两个pair对象内的所有元素都相等，这两个pair对象才被视为相等（equal）
两个pair互相比较时，第一元素具有较高的优先级。所以如果两个pair的第一元素不相等，其比较结果就成为整个比较的结果。
如果first相等，才继续比较second，并把比较结果当作整体结果


## tuple(不定数组)
它扩展了pair的概念，拥有任意数量的元素，其中每个类型都可以被指定，或来自编译期推导。

```cc
namespace std {
    template <typename... Types>
    class tuple;
}
```

### Tuple的操作
#### make_tuple get<>
原则上，tuple接口十分直观：
- 通过声明，或使用便捷函数`make_tuple（）`，你可以创建一个tuple。
- 通过`get＜＞（） `function template，你可以访问tuple的元素。

```cc
auto t = make_tuple(1, 2.0, 'c');
cout << get<0>(t) << endl;
cout << get<1>(t) << endl;
cout << get<2>(t) << endl;

get<0>(t1) = get<0>(t2);
```

#### ref
借由特别的函数对象 `reference_wrapper＜＞` 及便捷函数 `ref（）` 和 `cref（）` ，

你可以影响`make_tuple（）`产生的类型，例如以下表达式产出的tuple带有一个reference指向变量或对象s：

```cc
string s;
auto p = make_tuple(ref(s)); // tuple<string &>
get<0>(p) = "my value"; // 修改 s
```
运用reference搭配 make_tuple（），就可以提取tuple的元素值，将某些变量值设给它们，例如以下例子：
```cc
std::tuple<int, float, std::string> t(1, 1,2, "aa");
int i;
float j;
string k;
// i, j, k 会被修改
std::make_tuple(std::ref(i), std::ref(j), std::ref(k)) = t;
``` 
如果想最方便地在tuple中使用reference，可选择`tie（）`，它可以建立一个内含reference的tuple：
```cc
tuple<int, float, string> p(1, '2', "str");

int i;
float f;
string s;
// i f s 会被修改
tie(i, f, s) = p;
```
使用tie（）时，std::ignore允许我们忽略tuple的某些元素，也就是我们可以用它来局部提取tuple的元素值：
```cc
tuple<int, float, string> p(1, '2', "str");

int i;
string s;
// i s 会被修改
tie(i, std::ignore, s) = p;
```

### Tuple 和初始序列
Tuple的构造被声明为 explicit，所以必须进行显示转换

```cc
void foo(tuple<Args...> t);

foo(42); // 错误不能隐式转换
foo(make_tuple(42)); // OK
```
使用init list 定义tuple时，会导致隐式类型转换而报错
```cc

tuple<int, double> t1(1, 2); // OK 老语法
tuple<int, double> t1{1, 2}; // OK 新语法
tuple<int, double> t3 = { 1, 2}; // ERROR, 
```

你不可以将初值列传至“期望获得一个tuple”的地方：
```cc
std::vector<std::tuple<int, float>> v {{1, 1,0}, {2, 2.0}}; // error

std::tuple<int, int> foo() {
    return {1, 2}; // error
}
```
注意上诉对于pair和容器（除array外）是行得通的
```cc
std::vector<std::pair<int, float>> v {{1, 1,0}, {2, 2.0}}; // ok
std::vector<std::vector<int>> v {{1, 1}, {2, 2}}; // ok

std::vector<int> foo() {
    return {1, 2}; // ok
}
```
但对于tuple必须显示类型转换，比如使用make_tuple
```cc
std::vector<std::tuple<int, float>> v {std::make_tuple(1, 1.0), std::make_tuple(2, 2.0)}; // ok

std::tuple<int, int> foo() {
    return std::make_tuple(1, 2); // ok
}
```
### 其他特性
有些辅助函数是特别为tuple而设计的，特别是为了支持泛型编程：
- `tuple_size＜tupletype＞`：value可获得元素个数。
- `tuple_element＜idx，tupletype＞`：type可取得第idx个元素的类型（也就是get（）返回值的类型）。
- `tuple_cat（）`可将多个tuple串接成一个tuple。

下面的例子示范了如何使用`tuple_size＜＞`和`tuple_element＜＞`

```cc
typename tuple<int, string> tuple_type;
tuple_size<tuple_type>::value; // 2
tuple_element<1, tuple_type>::type; // string
```

可以使用`tuple_cat（）`串接所有形式的tuple，甚至包括`pair＜＞`

```cc
int n;
// 获得 std::tuple<int, string, int &>
auto tt = tuple_cat(make_tuple(1, "hello"), 
                    tie(n));
```

### tuple的输入输出
tuple不支持 <<
需要自定义函数
```cc
#include <iostream>
#include <tuple>
#include <utility>
using namespace std;

template <typename TupleType, size_t... I>
void print_tuple_impl(const TupleType& t, std::index_sequence<I...>) {
    ((std::cout << std::get<I>(t) << " "), ...);
}

template <typename... Args>
ostream & operator<< (ostream &out, const std::tuple<Args...>&t) {
    print_tuple_impl(t, std::index_sequence_for<Args...>{});
    return out;
}

int main() {
    auto t1 = std::make_tuple(1, 2, 3);
    auto t2 = std::make_tuple(4.5, "hello", 6, true);

    cout << t1 << endl;
    cout << t2 << endl;

    return 0;
}
```

### pair 和 tuple的转换 
你可以拿一个pair作为初值，初始化一个双元素tuple，也可以将一个pair赋值给一个双元素tuple


## Type Trait和Type Utility

### Type Trait
所谓type trait，提供一种用来处理type属性（property of a type）的办法。它是个template，可在编译期根据一或多个template实参（通常也是type）产出一个type或value。

```cc
template<typename T>
void foo(const T &val)
    if (std::is_pointer<T>::value) {
        std::cout << "call for pointer" << std::endl;
    }
    else {
        std::cout << "call for value" << std::endl;
    }
}
```
is_pointer就是 type trait，用于检查T是否为指针，如果是 `std::is_pointer<T>::value` 为 true，否则为false

type trait 的另一个用处是处理共通类型。
```cc
template<typename T1, typename T2>
??? min(const T1 &a, const T2 &b); // 返回值应该使用 T1 还是T2 ?
```
运用type trait可以解决
```cc
template<typename T1, typename T2>
typename std::common_type<T1, T2>::type min(const T1 &a, const T2 &b); 
// common_type<T1, T2>::type会产生T1, T2的共通类型，比如
// T1为int, T2为float，共通类型为 int
// T1为string, T2为const char *，共通类型为 string
```

### Reference Wrapper（外覆器）
对于一个给定类型T，这个class提供ref（）用以隐式转换为 T&，一个cref（）用以隐式转换为 const T&，

这往往允许function template得以操作reference而不需要另写特化版本。
```cc
template <typename T>
void foo(T val);

int x;
foo (std::ref(x));  // 模板函数实例化 foo(int &), 传递参数为 x

int x
foo (std::cref(x)); // 模板函数实例化 foo(const int &), 传递参数为 x
```
### Function Type Wrapper（外覆器）

使用 function<> 可以将普通函数和lambda 转换为函数对象。
```cc
void foo(int a, int b)
{
    cout << a << "-- " << b << endl;
}

int main (int argc, char *argv[]) {

    vector<function<void (int, int)>> tasks;

    tasks.push_back([](int a, int b) {cout << a << b << endl;});
    tasks.push_back(foo);

    for (function<void (int, int)> pos : tasks) {
        pos(1, 2);
    }
    
    return 0;
}
```
使用member function时，`function<>` 的第一个形参必须为类
```cc
class A {
    public:
        void fun(int a, int b) const {
            cout << "A : " << a << b << endl;
        }
};

int main (int argc, char *argv[]) {

    function<void (const A&, int, int)> f;
    f = &A::fun;
    f(A(), 1, 2 );
}
```
# 标准模板库

## 组件
若干精心勾画的组件共同合作，构筑起STL的基础。这些组件中最关键的是容器、迭代器和算法。

- 容器（Container），用来管理某类对象的集合。每一种容器都有其优点和缺点，所以，为了应付不同的需求，STL准备了不同的容器类型。
- 迭代器（Iterator），用来在一个对象集合（collection of objects）内遍历元素。这个对象集合或许是个容器，或许是容器的一部分。迭代器的主要好处是，为所有各式各样的容器提供了一组很小的共通接口。例如其中一个操作是行进至集合内的下一元素。至于如何做到当然取决于集合的内部结构。不论这个集合是array或tree或hash table，此一行进动作都能成功，因为每一种容器都提供了自己的迭代器，而这些迭代器了解容器的内部结构，知道该做些什么。
- 算法（Algorithm），用来处理集合内的元素。它们可以出于不同的目的而查找、排序、修改、使用元素。通过迭代器的协助，我们只需撰写一次算法，就可以将它应用于任意容器，因为所有容器的迭代器都提供一致的接口。

你还可以提供一些特殊的辅助函数供算法调用，从而获取更佳的灵活性。这样你就可以一方面运用标准算法，一方面配合自己特殊或复杂的需求。

STL 的基本观念就是将数据和操作分离。数据由容器类加以管理，操作则由可定制（configurable）的算法定义之。

迭代器在两者之间充当黏合剂，使任何算法都可以和任何容器交互运作。


     ┌───────────┐
     │ Container ├──► Iterator ──┐ 
     └───────────┘               │    ┌───────────┐                      ┌───────────┐
                                 ├───►│ Algorithm ├─────► Iterator ─────►│ Container │
                                 │    └───────────┘                      └───────────┘
     ┌───────────┐               │
     │ Container │──► Iterator ──┘
     └───────────┘

STL将数据和算法分开对待，而不是合并考虑。从某种意义上说，STL的概念和面向对象编程（OOP）的最初思想是矛盾的。然而这么做有着很重要的因素。首先，你可以将各种容器与各种算法结合起来，在很小的框架（framework）内达到非常大的弹性。

STL的一个根本特性是，所有组件都可以针对任意类型（type）运作。顾名思义，所谓standard template library意味着其内的所有组件都是“可接受任意类型”的template，前提是这些类型必须能够执行必要的操作。因此STL成了泛型编程（generic programming）概念下的一个出色范例。容器和算法被泛化为可适用于任意type和class。

STL甚至提供更泛化的组件。借由特定的适配器（adapter）和函数对象（function ob-ject，functor），你可以补充、约束或定制算法以满足特别需求。

### 容器 
容器用来管理一大群元素。为了适应不同需要，STL提供了不同的容器，


    Sequence Containers                               Associative Containers                            Unordered Containers

      Array                                             Set/multiset                                      Unordered set/multiset
        ┌───┬───┬───┬───┬───┬───┬───┐                               ┌─────┐                                    ┌──────────────────────────────┐
        │   │   │   │   │   │   │   │                               │     │                                    │          ┌──────┐            │
        └───┴───┴───┴───┴───┴───┴───┘                               └──┬──┘                                    │          │      │            │
      Vector                                                   ┌───────┴───────┐                               │          └──────┘            │
        ┌───┬───┬───┬───┬───┬───┬───                           ▼               ▼                               │    ┌──────┐   ┌──────┐       │
        │   │   │   │   │   │   │   ───►                   ┌─────┐           ┌─────┐                           │    │      │   │      │       │
        └───┴───┴───┴───┴───┴───┴───                       │     │           │     │                           │    └──────┘   └──────┘       │
      Deque                                                └──┬──┘           └──┬──┘                           │             ┌──────┐         │
         ───┬───┬───┬───┬───┬───┬───                     ┌────┴────┐         ┌──┴───┐                          │             │      │         │
      ◄───  │   │   │   │   │   │   ───►                 ▼         ▼         ▼      ▼                          │             └──────┘         │
         ───┴───┴───┴───┴───┴───┴───                 ┌─────┐    ┌─────┐  ┌─────┐  ┌─────┐                      └──────────────────────────────┘
      List                                           │     │    │     │  │     │  │     │
         ┌───┐   ┌───┐   ┌───┐   ┌───┐               └─────┘    └─────┘  └─────┘  └─────┘
      ──►│   │──►│   │──►│   │──►│   ├──►
      ◄──└───┘◄──└───┘◄──└───┘◄──└───┘◄──               Map/multimap                                      Unordered Map/multimap                
      Forward list                                                  ┌─────┐                                    ┌──────────────────────────────┐ 
         ┌───┐   ┌───┐   ┌───┐   ┌───┐                              ├─────┤                                    │          ┌──────┐            │ 
      ──►│   │──►│   │──►│   │──►│   ├──►                           └──┬──┘                                    │          ├──────┤            │ 
         └───┘   └───┘   └───┘   └───┘                         ┌───────┴───────┐                               │          └──────┘            │ 
                                                               ▼               ▼                               │    ┌──────┐   ┌──────┐       │ 
                                                           ┌─────┐           ┌─────┐                           │    ├──────┤   ├──────┤       │ 
                                                           ├─────┤           ├─────┤                           │    └──────┘   └──────┘       │ 
                                                           └──┬──┘           └──┬──┘                           │             ┌──────┐         │ 
                                                         ┌────┴────┐         ┌──┴───┐                          │             ├──────┤         │ 
                                                         ▼         ▼         ▼      ▼                          │             └──────┘         │ 
                                                     ┌─────┐    ┌─────┐  ┌─────┐  ┌─────┐                      └──────────────────────────────┘ 
                                                     ├─────┤    ├─────┤  ├─────┤  ├─────┤                                                       
                                                     └─────┘    └─────┘  └─────┘  └─────┘ 
总的来说，容器可分为三大类：                                                              

- 序列式容器（Sequence container），这是一种有序（ordered）集合，其内每个元素均有确凿的位置——取决于插入时机和地点，与元素值无关。
  - 如果你以追加方式对一个集合置入6个元素，它们的排列次序将和置入次序一致。
  - STL提供了5个定义好的序列式容器：array、vector、deque、list和forward_list。
- 关联式容器（Associative container），这是一种已排序（sorted）集合，元素位置取决于其value（或key——如果元素是个key/value pair）和给定的某个排序准则。
  - 如果将6个元素置入这样的集合中，它们的值将决定它们的次序，和插入次序无关。
  - STL提供了4个关联式容器：set、multiset、map和multimap。
- 无序容器（Unordered （associative） container），这是一种无序集合（unordered collec-tion），其内每个元素的位置无关紧要，唯一重要的是某特定元素是否位于此集合内。
  - 元素值或其安插顺序，都不影响元素的位置，而且元素的位置有可能在容器生命中被改变。
  - 如果你放6个元素到这种集合内，它们的次序不明确，并且可能随时间而改变。
  - STL内含4个预定义的无序容器：unordered_set、unordered_multiset、unordered_map和unordered_multimap。

#### Sequence container
STL内部预先定义好了以下序列式容器：
- Array（其class名为array）
- Vector
- Deque
- List(singly/doubly linked)

##### Vector

Vector将其元素置于一个dynamic array中管理。它允许随机访问，也就是说，你可以利用索引直接访问任何一个元素。
在array尾部附加元素或移除元素都很快速，但是在array的中段或起始段安插元素就比较费时，因为安插点之后的所有元素都必须移动，以保持原本的相对次序。
```cc
#include <vector>
#include <iostream>
using namespace std;

int main (int argc, char *argv[]) {
    vector<int> v;
    for (int i = 0; i < 10; i++) {
        v.push_back(i);
    }
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << ' ';
    }
    cout << endl;
    return 0;
}
```
##### Deque
所谓deque，是“double-ended queue”的缩写。它是一个dynamic array，可以向两端发展，因此不论在尾部或头部安插元素都十分迅速。
在中间部分安插元素则比较费时，因为必须移动其他元素。
```cc
#include <iostream>
#include <deque>
using namespace std;

int main (int argc, char *argv[]) {
    deque<int> coll;
    for (int i = 0; i < 10; i++) {
        coll.push_front(i);
    }
    for (int i = 0; i < coll.size(); i++) {
        cout << coll[i] << ' ';
    }
    cout << endl;
    return 0;
}
```
##### Array
一个array对象乃是在某个固定大小的array （有时称为一个static array或C array）内管理元素。
因此，你不可以改变元素个数，只能改变元素值。你必须在建立时就指明其大小。
Array也允许随机访问，意思是你可以直接访问任何一个元素——只要你指定相应的索引。
```cc
#include <iostream>
#include <array>
using namespace std;

int main (int argc, char *argv[]) {
    array<string, 5> coll = {"aa", "bb"};
    for (int i = 0; i < coll.size(); i++) {
        cout << coll[i] << ' ';
    }
    cout << endl;
    return 0;
}
```
##### List
从历史角度看，我们只有一个list class。然而自C++11 开始，STL 竟提供了两个不同的list 容器：`class list＜＞` 和`class forward_list＜＞`。
因此， list 可能表示其中某个class，或者是个总体术语，代表上述两个 list class。
然而就某种程度来说，forward list 只不过是受到更多限制的list，现实中二者的差异并不怎么重要。
因此当我使用术语list，通常我指的是`class list＜＞`，它的能力往往超越`class forward_list＜＞`。
如果特别需要指出`class forward_list＜＞`，我会使用术语forward list。所以本节讨论的是寻常的list，是一开始就成为STL一部分的那个东西。
`list＜＞`由双向链表（doubly linked list）实现而成。这意味着list内的每个元素都以一部分内存指示其前导元素和后继元素。
List不提供随机访问，因此如果你要访问第10个元素，你必须沿着链表依次走过前9个元素。
不过，移动至下一个元素或前一个元素的行为，可以在常量时间内完成。因此一般的元素访问动作会花费线性时间，因为平均距离和元素数量成比例。
这比vector和deque提供的摊提式（amortized）常量时间，效率差很多。
List 的优势是：在任何位置上执行安插或删除动作都非常迅速，因为只需改变链接（link）就好。这表示在list中段处移动元素比在vector和deque快得多。
```cc
#include <iostream>
#include <list>
using namespace std;

int main (int argc, char *argv[]) {
    list<char> coll;
    for (char c = 'a'; c <= 'z'; c++) {
        coll.push_back(c);
    }
    for (auto elem : coll) {
        cout << elem << " ";
    }
    cout << endl;
    return 0;
}
```
##### Forward List
自C++11之后，C++标准库提供了另一个list容器：forward list。`forward_list＜＞`是一个由元素构成的单向（singly） linked list。
就像寻常 list那样，每个元素有自己一段内存，为了节省内存，它只指向下一元素。
因此，forward list原则上就是一个受限的list，不支持任何“后退移动”或“效率低下”的操作。基于这个原因，它不提供成员函数如push_back（）乃至size（）。
现实中，这个限制比乍听之下甚至更尴尬棘手。问题之一是，你无法查找某个元素然后删除它，或是在它的前面安插另一个元素。
因为，为了删除某个元素，你必须位于其前一元素的位置上，因为正是那个元素才能决定

#### Associative Container
关联式容器依据特定的排序准则，自动为其元素排序。
元素可以是任何类型的value，也可以是key/value pair，其中key可以是任何类型，映射至一个相关value，而value也可以是任意类型。排序准则以函数形式呈现，
用来比较value，或比较key/value中的key。默认情况下所有容器都以操作符＜进行比较，不过你也可以提供自己的比较函数，定义出不同的排序准则。
通常关联式容器由二叉树（binary tree）实现出来。在二叉树中，每个元素（节点）都有一个父节点和两个子节点；左子树的所有元素都比自己小，右子树的所有元素都比自己大。关联式容器的差别主要在于元素的种类以及处理重复元素时的方式（态度）。
关联式容器的主要优点是，它能很快找出一个具有某特定value的元素，因为它具备对数复杂度（logarithmic complexity），而任何循序式容器的复杂度是线性。因此，使用关联式容器，面对1 000个元素，平均而言你将有10次而不是500次比较动作。然而它的一个缺点是，你不能直接改动元素的value，因为那会破坏元素的自动排序。

下面是STL定义的关联式容器：
- Set 元素依据其value自动排序，每个元素只能出现一次，不允许重复。
- Multiset 和set的唯一差别是：元素可以重复。也就是multiset可包括多个“value相同”的元素。
- Map 每个元素都是key/value pair，其中key是排序准则的基准。每个key只能出现一次，不允许重复。Map也可被视为一种关联式数组（associative array），也就是“索引可为任意类型”的数组
- Multimap 和map的唯一差别是：元素可以重复，也就是multimap允许其元素拥有相同的key。Multimap可被当作字典（dictionary）使用。

所有关联式容器都有一个可供选择的template实参，指明排序准则；默认采用操作符＜。排序准则也被用来测试等同性（equivalence）：如果两个元素的value/key互不小于对方，则两者被视为重复。

你可以将set视为一种特殊的map：元素的value等同于key。实际产品中所有这些关联式容器通常都由二叉树（binary tree）实现而成。

##### Set Multiset 示例

```cc
#include <set>
#include <iostream>
#include <string>

using namespace std;

int main (int argc, char *argv[]) {
    multiset<string> ms = {"dd", "ee"};

    ms.insert("cc");
    ms.insert("bb");
    ms.insert("aa");

    for (string &pos : ms) {
        cout << pos << " ";
    }
    cout << endl;

    return 0;
}
```

##### Map Multimap 示例
```cc
#include <map>
#include <iostream>
#include <string>

using namespace std;

int main (int argc, char *argv[]) {
    map<int, string> coll;

    coll = {
        {2, "bb"},
        {4, "dd"},
        {1, "aa"},
        {3, "cc"},
    };

    for (auto &pos : coll) {
        cout << pos.second << " ";
    }
    cout << endl;

    return 0;
}
```

#### Unordered Container
在无序（unordered）容器中，元素没有明确的排列次序。也就是如果安插3个元素，当你迭代容器内的所有元素时会发现，它们的次序有各种可能。
如果安插第4个元素，先前3个元素的相对次序可能会被改变。
我们唯一关心的是，某个特定元素是否位于容器内。甚至如果你有2个这种容器，其内有着完全相同的元素，元素的排列次序也可能不同。试着想象它是个袋子（bag）。
无序（unordered）容器常以hash table实现出来），内部结构是一个“由linked list 组成”的array。
通过某个hash 函数的运算，确定元素落于这个array 的位置。Hash函数运算的目标是：让每个元素的落点（位置）有助于用户快速访问

                              ┌───┐
                              │   │
                              ├───┤    ┌───┐
    aaa                       │   │───►│aaa│
              ┌───────┐       ├───┤    └───┘
    bbb   ──► │hashfun│ ───►  │   │     
              └───────┘       ├───┤    ┌───┐    ┌───┐
    ccc                       │   ├───►│bbb│───►│ccc│
                              ├───┤    └───┘    └───┘
                              │   │
                              ├───┤
                              │   │
                                │
                                │
                                ▼


无序（unordered）容器的主要优点是，当你打算查找一个带某特定值的元素，其速度甚至可能快过关联式容器。
事实上无序容器提供的是摊提的常量复杂度（amortized constant complexity），前提是你有一个良好的hash函数。
然而提供一个良好的hash函数并非易事，你可能需要提供许多内存作为bucket。
根据关联式容器的分类法，STL定义出下面这些无序容器：

- Unordered set是无序元素的集合，其中每个元素只可出现一次。也就是不允许元素重复。
- Unordered multiset 和 unordered set 的唯一差别是它允许元素重复。也就是 unordered multiset可能内含多个有着相同value的元素。
- Unordered map的元素都是key/value pair。每个key只可出现一次，不允许重复。它也可以用作关联式数组（associative array），那是“索引可为任意类型”的array
- Unordered multimap和unordered map的唯一差别是允许重复。也就是unordered mul-timap可能内含多个“拥有相同key”的元素。它可以用作字典（dictionary）

所有这些无序容器的class都有若干可有可无的template实参，用来指明hash函数和等效准则，该准则被用来寻找某给定值，以便判断是否发生重复。默认的等效准则是操作符`==`。
你可以把unordered set视为一种特殊的unordered map，只不过其元素的value等同于key。现实中所有无序容器通常都使用hash table作为底层实现。

##### Unordered set/Multiset 

```cc
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

int main (int argc, char *argv[]) {
    unordered_multiset<string> coll = {
        "aa", "bb", "cc"
    };

    for (auto &elem : coll) {
        cout << elem << " ";
    }
    cout << endl;

    coll.insert( {"dd", "ee" } );

    for (auto &elem : coll) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```

##### unordered map/multimap

```cc
#include <iostream>
#include <string>
#include <unordered_map>
#include <utility>
using namespace std;

int main (int argc, char *argv[]) {
    unordered_map<string, int> coll = {
        {"aa", 1}, {"bb", 2}
    };

    for (pair<const string, int> &elem : coll) {
        // elem.first = .. ; // error 只能改动second
        elem.second += elem.second;
    }

    for (const auto &elem : coll) {
        cout << elem.first << " " << elem.second << endl;
    }

    return 0;
}
```
不论map或unordered map，都是key/value pair形成的集合，每个元素带着独一无二的key。
如此的集合也可被视为一个关联式数组（associative array），也就是“索引并非整数”的array。也因此，刚才说的那两个容器都提供了下标操作符[]。
考虑下面这个例子：
```cc
#include <unordered_map>
#include <iostream>
#include <string>

using namespace std;

int main (int argc, char *argv[]) {
    unordered_map<string, int> m;

    m["aa"] = 1;
    m["bb"] = 2;
    m["cc"];
    m["dd"] = 4;

    m["aa"] += 3;

    cout << m["aa"] + m["cc"] << endl;

    // 使用 at 访问不存在的元素，触发异常 out_of_range
    m.at("ee");

    return 0;
}
```

#### 其他容器
##### String
你可以把string当作一种STL容器。String很类似vector，但其元素都是字符

##### 寻常的C-Style Array
C++程序不再需要直接使用C-style array。Vector和array提供了寻常C-style array的所有特性，并具备更安全更方便的接口。

##### 用户自定义容器
现实中你可以给予任何“与容器相仿（container-like）的对象”一个相应的STL接口，使它得以迭代元素，或提供标准操作以运用元素内容。
例如你可以引入一个class用以表现目录（directory），而你能够迭代其中各文件，视它们为元素并操纵运用它们。

##### 容器适配器
除了以上数个根本的容器类，为满足特殊需求，C++标准库还提供了一些所谓的容器适配器，它们也是预定义的容器，提供的是一定限度的接口，用以应付特殊需求。
这些容器适配器都是根据基本容器实现而成，包括：
- Stack 名字足以说明一切。Stack容器对元素采取LIFO（后进先出）管理策略。
- Queue 对元素采取 FIFO （先进先出）管理策略。也就是说，它是个寻常的缓冲区（buffer）。
- Priority queue 其内的元素拥有各种优先权。所谓优先权乃是基于程序员提供的排序准则（默认为操作符＜）而定义。
  - 这种特殊容器的效果相当于这样一个缓冲区：“下一元素永远是容器中优先权最高的元素”。如果同时有多个元素具备最高优先权，则其次序无明确定义。

### 迭代器
迭代器是一个“可遍历STL容器全部或部分元素”的对象。迭代器用来表现容器中的某一个位置。基本操作如下：

- `Operator＊`返回当前位置上的元素值。如果该元素拥有成员，你可以通过迭代器直接以操作符-＞取用它们。
- `Operator++`令迭代器前进至下一元素。大多数迭代器还可使用`operator--`退至前一元素。
- `Operators==`和`!=`判断两个迭代器是否指向同一位置。
- `Operator=`对迭代器赋值（也就是指明迭代器所指向的元素的位置）。

迭代器是所谓的smart pointer，具有遍历复杂数据结构的能力，其内部运作机制取决于其所遍历的数据结构。

因此，每一种容器都必须提供自己的迭代器。事实上每一种容器的确都将其迭代器以嵌套（nested）方式定义于class内部。因此各种迭代器的接口虽然相同，类型却各自不同。

这直接引出了泛型程序设计的概念：所有操作都使用相同接口，纵使类型不同。因此，你可以使用template将泛型操作公式化，使之得以顺利运作那些“能够满足接口需求”的任何类型。

所有容器类都提供一些基本的成员函数，使我们得以取得迭代器并以之遍历所有元素。这些函数中最重要的是：
- begin()返回一个迭代器，指向容器起点，也就是第一元素（如果有的话）的位置。
- end()返回一个迭代器，指向容器终点。终点位于最末元素的下一位置，这样的迭代器又称作“逾尾（past-the-end）”迭代器。

#### Range-Based for循环vs.迭代器

```cc
for (elem : coll) {
    ...
}
```

被解释为
```cc
for (auto pos = coll.begin() , end = coll.end(); pos != end; ++pos) {
    elem = *pos;
    ...
}
```

#### 迭代器的种类
除了基本操作，迭代器还有其他能力。这些能力取决于容器的内部结构。STL总是只提供效率比较出色的操作，因此如果容器允许随机访问（例如vector或deque），它们的迭代器也必定能进行随机操作（例如直接让迭代器指向第5元素）。

根据能力的不同，迭代器被划分为五种不同类别。STL预先定义好的所有容器，其迭代器均属于以下三种分类：
- 前向迭代器（Forward iterator） 只能够以累加操作符（increment operator）向前迭代。Class forward_list的迭代器就属此类。
其他容器如unordered_set、unordered_multiset、unordered_map和unordered_multimap也都至少是此类别（但标准库其实为它们提供的是双向迭代器〔forward iterator〕
- 双向迭代器（Bidirectional iterator） 顾名思义它可以双向行进：以递增（increment）运算前进或以递减（decrement）运算后退。
list、set、multiset、map和multimap提供的迭代器都属此类。
- 随机访问迭代器（Random-access iterator） 它不但具备双向迭代器的所有属性，还具备随机访问能力。
更明确地说，它们提供了迭代器算术运算的必要操作符（和寻常指针的算术运算完全对应）。
你可以对迭代器增加或减少一个偏移量、计算两迭代器间的距离，或使用 ＜和 ＞之类的relational（相对关系）操作符进行比较。
vector、deque、array和string提供的迭代器都属此类。
除此之外，STL还定义了两个类别：
- 输入型迭代器（Input iterator）向前迭代时能够读取/处理value。Input stream迭代器就是这样一个例子
- 输出型迭代器（Output iterator）向前迭代时能够涂写value。Inserter和output stream迭代器都属此类。

### 算法
为了处理容器内的元素，STL提供了一些标准算法，包括查找、排序、拷贝、重新排序、修改、数值运算等基本而普遍的算法。

算法并非容器类的成员函数，而是一种搭配迭代器使用的全局函数。

在面向对象编程（OOP）概念里，数据与操作合为一体，在这里则被明确划分开来，再通过特定的接口彼此互动。

当然这需要付出代价：首先是用法有失直观，其次某些数据结构和算法之间并不兼容。更有甚者，某些容器和算法虽然勉强兼容却毫无用处（也许导致很糟的效率）。

因此，深入学习STL概念并了解其缺陷，显得十分重要，唯其如此方能取其利而避其害。

```cc
#include <algorithm>
#include <vector>
#include <iostream>

using namespace std;

int main (int argc, char *argv[]) {
    vector<int> coll = {2, 4, 5, 1, 5};

    vector<int>::iterator minpos = min_element(coll.begin(), coll.end());
    auto maxpos = max_element(coll.begin(), coll.end());

    cout << "min : " << *minpos << endl;
    cout << "max : " << *maxpos << endl;

    sort(coll.begin(), coll.end());

    auto pos4 = find(coll.begin(), coll.end(), 4);

    reverse(pos4, coll.end());

    for (auto & elem  : coll ) {
        cout << elem << " ";
    }
    cout << endl;

    return 0;
}
```
#### 区间
所有算法都是用来处理一或多个区间内的元素。这样的区间可以（但非必须）涵盖容器内的全部元素。

为了操作容器元素的某个子集，我们必须将区间首尾当作两个实参（argument）传给算法，而不是一口气把整个容器传递进去。

这样的接口灵活又危险。调用者必须确保经由两实参定义出来的区间是有效的（valid）。

所谓有效就是，从起点出发，逐一前进，能够到达终点。

也就是说，程序员自己必须确保两个迭代器隶属同一容器，而且前后的放置是正确的，否则结果难料，可能引起无穷循环，也可能访问到内存禁区。

就此而言，迭代器就像寻常指针一样危险。不过请注意，所谓“结果难料”（或说行为不明确〔undefined behavior〕）意味着任何STL实现均可自由选择合适的方式来处理此类错误。

稍后你会发现，确保区间有效并不像听起来那么简单。

所有算法处理的都是半开区间（half-open range）——包括起始元素的位置但不包括末尾元素的位置。

```cc
#include <algorithm>
#include <list>
#include <iostream>
using namespace std;

int main (int argc, char *argv[]) {
    list<int> coll;

    for (auto i = 20; i < 40; ++i) {
        coll.push_back(i);
    }

    // 没有3 ， 返回 coll.end()
    auto pos3 = find(coll.begin(), coll.end(), 3);

    // 因为 pos3 为 coll.end()
    // 所以 reverse 的区间为空，不进行翻转
    reverse(pos3, coll.end());

    auto pos25 = find(coll.begin(), coll.end(), 25);
    auto pos35 = find(coll.begin(), coll.end(), 35);

    cout << "max : " << *max_element(pos25, pos35) << endl;

    // 因为 pos 不是随机迭代器，所以不支持 pos35 + 1, 只能用 ++pos35
    cout << "min : " << *min_element(pos25, ++pos35) << endl;

    return 0;
}
```

本节的所有例子都可以正常运作的前提是，你知道pos25在pos35之前。否则[pos25，pos35）就不是个有效区间。

现在假设你并不知道元素25和元素35的前后关系，甚至连它们是否存在也心存疑虑。如果你手上是随机访问迭代器（random-access iterator），你可以使用operator＜进行检查：

如果你手上并非随机访问迭代器，那还真没什么直截了当的办法可以确定哪个迭代器在前。你只能在“起点和某个迭代器”之间，以及“该迭代器和终点”之间，寻找另外那个迭代器。

不是一口气在整个区间中查找两值，而是试着了解，哪个值先来到。例如：
```cc
    // 25 35
    pos25 = find(coll.begin(), coll.end(), 25);
    pos35 = find(pos25, coll.end(), 35);
    if (pos25 != coll.end() && pos35 != coll.end()) {

        cout << "max : " << *max_element(pos25, pos35) << endl;
        cout << "min : " << *min_element(pos25, pos35) << endl;
    }
    else {
        // 35 25
        pos35 = find(coll.begin(), pos25, 35);

        cout << "max : " << *max_element(pos35, pos25) << endl;
        cout << "min : " << *min_element(pos35, pos25) << endl;
    }
```
更好的写法
```cc
    auto pos = find_if(coll.begin(), coll.end(),
            [](int i) {
                return i == 25 || i == 35;
            });
    if (pos == coll.end()) {
        cout << "25 和 35 不存在";
    }
    else if (*pos == 25) {
        pos25 = pos;
        pos35 = find(++pos, coll.end(), 35);

        cout << "max : " << *max_element(pos25, pos35) << endl;
        cout << "min : " << *min_element(pos25, pos35) << endl;
    }
    else if (*pos == 35) {
        pos35 = pos;
        pos25 = find(++pos, coll.end(), 25);
        cout << "max : " << *max_element(pos35, pos25) << endl;
        cout << "min : " << *min_element(pos35, pos25) << endl;
    }
```
#### 多重区间
有数个算法可以（或说需要）同时处理多重区间。

通常你必须设定第一个区间的起点和终点，至于其他区间，只需设定起点即可，终点通常可由第一区间的元素数量推导出来。

例如以下程序片段中，equal（）从头开始逐一比较coll1和coll2的所有元素：

```cc
    if (equal(coll1.begin(), coll1.end(),   // first range
                coll2.begin())) {           // second range
        ..
    }
```
于是，coll2之中参与比较的元素数量，间接取决于coll1内的元素数量

这使我们收获一个重要心得：如果某个算法用来处理多重区间，那么当你调用它时，务必确保第二（以及其他）区间所拥有的元素个数至少和第一区间内的元素个数相同。

特别是执行涂写动作时，务必确保目标区间（destination range）够大。

下面这段程序会立即报错， 
```cc
    vector<int> coll1 = {1, 2, 3, 4};
    vector<int> coll2;

    copy(coll1.begin(), coll1.end(), coll2.begin());
```

vector虽然是动态数组，然而由于该算法执行的是覆写动作（overwrite）而非安插动作（insert），

所以目标区间必须拥有足够的元素被覆写, 意味着你会覆写coll2.end（）之后的任何东西

想要避免上述错误, 你可以
（1）确认目标区间内有足够的元素空间，
```cc
    coll2.resize(coll1.size());
```
或是
（2）采用insert iterator。Insert iterator

### 迭代器适配器
迭代器（Iterator）是一个纯抽象概念：任何东西，只要其行为类似迭代器，它就是一个迭代器。
因此，你可以撰写一些类（class）具备迭代器接口，但有着各不相同的行为。
C++标准库提供了数个预定义的特殊迭代器，亦即所谓迭代器适配器（iterator adapter）。它们不仅是辅助性质而已，它们赋予整个迭代器抽象概念更强大的威力。
以下数小节简介下面各种迭代器适配器（iterator adapter）：
- Insert iterator（安插型迭代器）
- Stream iterator（串流迭代器）
- Reverse iterator（逆向迭代器）
- Move iterator（搬移迭代器）

#### Insert Iterator
它可以使算法以安插（insert）方式而非覆写（overwrite）方式运作。使用它可以解决算法的“目标空间不足”问题。

Insert iterator内部将接口做了新的定义：
- 如果你对某个元素赋值（assign），会引发“对其所属集合的安插（insert）动作”。至于插入位置是在容器的最前或最后，或某特定位置上，要视三种不同的insert iterator而定。
- 单步前进（step forward）不会造成任何动静（是个no-op）。

```cc
#include <algorithm>
#include <deque>
#include <iterator>
#include <list>
#include <vector>
using namespace std;

int main (int argc, char *argv[]) {

    list<int> coll1 = {1, 2, 3 ,4, 5};

    vector<int> coll2;
    copy(coll1.begin(), coll1.end(), back_inserter(coll2));

    deque<int> coll3;
    copy(coll1.begin(), coll1.end(), front_inserter(coll3));

    vector<int> coll4;
    copy(coll1.begin(), coll1.end(), inserter(coll4, coll4.begin()));
    // coll4 : 1 2 3 4 5

    list<int> coll11 = {11, 22, 33,44, 55};
    copy(coll11.begin(), coll11.end(), inserter(coll4, coll4.begin()));
    // coll4: 11 22 33 44 55 1 2 3 4 5

    return 0;
}
```
此例运用了三种预定义的insert iterator：
- 1. Back inserter （安插于容器最末端） 其内部调用 push_back（），在容器末端插入元素
- 2. Front inserter（安插于容器最前端）其内部调用push_front（），将元素安插于容器最前端
  - Front inserter只能用于提供有push_front（）的容器，在C++标准库中这样的容器是deque、list和forward_list。
- 3. General inserter这种一般性的inserter，简称inserter，它的作用是在“初始化时接受之第二实参”所指位置的前方插入元素。

它内部调用成员函数insert(pos, val)，并以新值和新位置作为实参传入。所有STL容器都提供insert()成员函数

####  Stream Iterator（串流迭代器）
Stream iterator被用来读/写stream。
它们提供了必要的抽象性，使得来自键盘的输入像是个集合（collection），你能够从中读取内容。
同样道理，你也可以把一个算法的输出结果重新导向到某个文件或屏幕上。
```cc
#include <algorithm>
#include <string>
#include <iostream>
#include <iterator>
#include <vector>
using namespace std;

int main (int argc, char *argv[]) {

    vector<string> coll;

    copy(istream_iterator<string>(cin),
            istream_iterator<string>(),
            back_inserter(coll));

    sort(coll.begin(), coll.end());

    // unique_copy 不复制相邻的重复项
    unique_copy(coll.cbegin(), coll.cend(),
            ostream_iterator<string>(cout, "\n"));

    return 0;
}
```

```cc
    istream_iterator<string>(cin);
```
会产生一个可从“标准输入串流（standard input stream） cin”读取数据的stream iterator。
其中的template实参string表示这个stream iterator专司读取该种类型的元素。
这些元素通过一般的`operator>>`被读取进来。因此每当算法企图处理下一元素时，istream iterator就会将这种企图转化为以下行动：
```cc
    cin >> string
```
针对string而执行的input操作符通常读取以空白分隔的文字

```cc
    istream_iterator<string>();
```
会调用istream iterator的default构造函数，产生一个代表“串流结束符”（end-of-stream）的迭代器，这个东西代表的意义是：你不能再从中读取任何东西。

```cc
    ostream_iterator<string>(cout, "\n");
```
会产生一个output stream iterator，通过`operator<<`向cout写入string。

cout之后的第二实参（可有可无）被用作元素之间的分隔符。本例指定为一个换行符，因此每个元素都被打印于独立的一行。

#### Reverse Iterator（反向迭代器）
Reverse iterator会造成算法逆向操作，其内部将对increment（递增）操作符的调用转换为对decrement（递减）操作符的调用，反之亦然。
所有提供双向（bidirectional）或随机访问（random-access）迭代器的容器（也就是forward_list之外的所有序列式容器和所有关联式容器）
都可以通过它们的成员函数rbegin()和rend() 产生一个反向迭代器。
forward_list 和所有无序容器都没有提供回向迭代（backward-iteration）接口，即rbegin（）、rend（）等等。
原因是那些容器内部实现只是使用singly linked list串起所有元素。
```cc
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
using namespace std;

int main (int argc, char *argv[]) {
    vector<int> coll;

    for (int i = 0; i < 9; i++) {
        coll.push_back(i);
    }

    // 8 7 6 5 4 3 2 1 0
    copy(coll.crbegin(), coll.crend(), ostream_iterator<int>(cout, " "));
    cout << endl;
    
    return 0;
}
```

####  Move Iterator（搬移迭代器）
这种迭代器始自C++11，用来将任何“对低层元素（underlying element）的访问”转换为一个move操作。
也就是说，它们允许从一个容器移动元素至另一个容器，不论是在构造函数内或是在运用算法时。

###  更易型算法（Manipulating Algorithm）

#### 移除（Removing）元素

算法remove（）自某个区间删除元素。然而如果你用它来删除容器内的所有元素，其行为肯定会让你吃惊。例如：

```cc
#include <algorithm>
#include <iostream>
#include <iterator>
#include <list>
using namespace std;

int main (int argc, char *argv[]) {

    list<int> coll;

    for (int i = 1; i < 6; ++i) {
        coll.push_back(i);
        coll.push_front(i);
    }

    cout << "pre :\t";
    copy(coll.begin(), coll.end(),
            ostream_iterator<int>(cout, ", "));
    cout << endl;

    std::remove(coll.begin(), coll.end(), 3);

    cout << "post :\t";
    copy(coll.begin(), coll.end(),
            ostream_iterator<int>(cout, ", "));
    cout << endl;

    return 0;
}
```

输出
```bash
pre :   5, 4, 3, 2, 1, 1, 2, 3, 4, 5,
post :  5, 4, 2, 1, 1, 2, 4, 5, 4, 5,
```

```cc
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <pstl/glue_algorithm_defs.h>
#include <set>
#include <list>
using namespace std;

int main (int argc, char *argv[]) {
    list<int> l = {1, 2, 3, 4, 3};

    l.erase(std::remove(l.begin(), l.end(), 3), l.end());
    for (auto elem : l) {
        cout << elem << ' ';
    }
    cout << endl;

    set<int> s = {1, 2, 3, 4, 3};
    // std::remove(s.begin(), s.end(), 3); // 错误：尝试给只读位置赋值
                                        // set的元素是只读的，不能修改，因为元素若修改，那么set的结构也要改变
                                        // 所以set若要修改元素，必须先删除已有元素，再添加新元素
                                        // 所以remove无法给set
    s.erase(3);
    for (auto elem : s) {
        cout << elem << ' ';
    }
    cout << endl;
    
    return 0;
}
```

元素的次序改变了，有些元素被删除了。数值为 3的元素被其后的元素覆盖了。至于集合尾端那些未被覆盖的元素，原封不动

这个算法返回了一个新终点。你可以利用该终点获得新区间、缩减后的容器大小，或是获得被删除元素的个数
```cc
    auto end = std::remove(coll.begin(), coll.end(), 3);
    coll.erase(end, coll.end());  // 使用 list<int>::erase 而非 全局 erase
```
更简洁的写法
```cc
    coll.erase(remove(coll.begin(), coll.end(), 3), coll.end());
```
为何算法不自己调用erase（）呢？

这个问题正好点出STL为获取弹性而付出的代价。

通过“以迭代器为接口”，STL将数据结构和算法分离开来。

然而迭代器只不过是“容器内部某一位置”的抽象概念而已。

一般说来，迭代器对自己所属的容器一无所知。任何“以迭代器访问容器”的算法，都不得（无法）通过迭代器调用容器类所提供的任何成员函数。

这个设计导致一个重要结果：算法的操作对象不一定得是“容器内的全部元素”所形成的区间，而可以是那些元素的子集。

甚至算法可作用于一个“并未提供成员函数erase（）”的容器身上（array就是个例子）。所以，为了达成算法的最大弹性，不强求“迭代器必须了解其容器细节”还是很有道理的。

注意，通常并无必要删除那些“已被移除”的元素。以逻辑终点取代容器的实际终点，通常就足以应对现实情况。你可以拿这个逻辑终点搭配任何算法演出。


#### 更易Associative（关联式）和Unordered（无序）容器
更易型算法（指那些会移除〔remove〕、重排〔reorder〕、修改〔modify〕元素的算法）若用于关联式容器或无序容器，会出问题。
关联式和无序容器不能被当作操作目标，原因很简单：如果更易型算法用于关联式和无序容器身上，会改变某位置上的值，进而破坏容器本身对次序的维护

现在问题来了，如何从关联容器和无序容器中删除元素？好吧，很简单：调用它们的成员函数！每一种关联式容器和无序容器都提供

```cc
#include <set>
#include <iostream>
#include <algorithm>
#include <iterator>

using namespace std;

int main (int argc, char *argv[]) {
    set<int> coll = {3, 5 ,1 ,4 ,2};

    copy(coll.begin(), coll.end(), ostream_iterator<int>(cout, " "));
    cout << endl;

    // 目标元素不存在，返回0 nullptr
    // 存在返回被删除元素
    int num = coll.erase(3);

    cout << "remove num " << num << endl;

    copy(coll.begin(), coll.end(), ostream_iterator<int>(cout, " "));
    cout << endl;

    return 0;
}
```

###  算法vs.成员函数
就算我们符合种种条件，得以使用某个算法，那也未必就一定是好。容器本身可能提供功能相似而效能更佳的成员函数。

如果高效能是你的首要目标，你应该总是优先选用成员函数。

问题是你必须先知道，某个容器确实存在效能明显突出的成员函数。面对list却使用remove（）算法，决不会收到任何警告信息或报错通知。

然而如果你决定使用成员函数，一旦换用另一种容器，就不得不更改代码
```cc
#include <algorithm>
#include <list>
#include <iterator>
#include <iostream>
 
int main()
{
    std::list<int> l = {1, 100, 2, 3, 10, 1, 11, -1, 12};
 
    l.remove(1);
    l.remove_if([](int n){ return n > 10; });
 
    std::cout << "Finally, the list contains: ";
    std::copy(l.begin(), l.end(), std::ostream_iterator<int>(std::cout, ", "));
    std::cout << '\n';
}
```
### 以函数作为算法的实参

有些算法可以接受用户自定义的辅助性函数，借以提高弹性和能力。这些函数将被算法内部调用。
```cc
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

void print(int elem)
{
    cout << elem << " ";
}

int main (int argc, char *argv[]) {
    vector<int> coll;

    for (int i = 0; i < 9; i++) {
        coll.push_back(i);
    }

    for_each(coll.begin(), coll.end(), print);
    cout << endl;
    
    return 0;
}
```

另一个例子
```cc
#include <algorithm>
#include <iostream>
#include <iterator>
#include <set>
#include <vector>
using namespace std;

int square(int val)
{
    return val * val;
}

int main (int argc, char *argv[]) {
    set<int> coll1;
    vector<int> coll2;

    for (int i = 0; i < 9; i++) {
        coll1.insert(i);
    }

    transform(coll1.begin(), coll1.end(),
            std::back_inserter(coll2),
            square);

    copy(coll2.begin(), coll2.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
   
    return 0;
}
```

#### 判断式（Predicate）
Predicate（判断式）是一种特殊的辅助函数。所谓predicate，它会返回布尔值（Boolean），常被用来指定作为排序准则或查找准则。Predicate可能有一或两个操作数，视具体情形而定。

注意，并非任何返回布尔值的单参函数或双参函数都是合法的predicate。STL要求，面对相同的值，predicate必须得出相同结果。这条戒律使得那些“被调用时会改变自己内部状态”的函数出局。

Unary Predicate（单参判断式）

Unary predicate会检查唯一实参的某项特性。典型例子如下，用来查找第一个质数：
```cc
#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <vector>
using namespace std;

int square(int val)
{
    return val * val;
}

bool is_prime(int number)
{
    number = abs(number);

    if (number == 0 || number == 1) {
        return false;
    }

    int div;
    for (div = number/2 ;  number % div != 0 ; --div) {
        NULL;
    }

    return div == 1;

}

int main (int argc, char *argv[]) {
    vector<int> coll;

    for (int i = 10; i < 30; i++) {
        coll.push_back(i);
    }

    auto pos = find_if(coll.begin(), coll.end(),
            is_prime);
    if (pos != coll.end()) {
        cout << *pos << " is prime" << endl;
    }
    else {
        cout << "no prime found" << endl;
    }
  
    return 0;
}
```

Binary Predicate（双参判断式）

Binary predicate的典型用途是，比较两个实参的特定属性。例如，为了以你自己的原则对元素排序，你必须以一个简单的predicate形式提供这项原则。
如果元素本身不支持`operator＜`，或如果你想使用不同的排序原则，这就派上用场了。

```cc
bool personCmp(const person &p1, const person &p2) {
    return p1.name < p2.name;
}

sort(coll.begin(), coll.end(), personCmp);
```

### 使用lambda
Lambda始自C++11，是一种“在表达式或语句内指明函数行为”的定义式。
这导致你可以定义对象，用以描述函数行为，并将这些对象以“inline实参”形式传给算法作为predicate，或是作为其他用途。

```cc
transform(coll.begin(), coll.end(), 
    coll.begin(),
    [](int i) {
        return i*i;
    });
```

Lambda其实是个函数对象，好处是编译器可以将Lambda进行内联编译。

Lambda的局限
Lambda并非在每一方面都保持优势。让我们考虑使用lambda为关联式容器指出一个排序准则：
```cc
auto cmp = [] (const person &p1, const person &p2) {
    return p1.name < p2.name;
};

std::set<person, decltype(cmp)> coll(cmp);
```
由于 set 声明式需要指明lambda 类型，所以我们必须使用 decltype ，它会为一个lambda对象（上例的cmp）产出类型。
注意，你也必须把lambda对象传给coll的构造函数，否则coll会调用被传入的排序准则的default构造函数，而根据C++语言规则，lambda没有default构造函数也没有assignment操作符。
基于这些局限，“以class定义某个函数对象作为排序准则”说不定还比较直观些。

Lambda的另一个问题是，它们无法拥有“跨越多次调用”都能被保存下来的内部状态（internal state）。
如果你需要这样的状态，必须在外围作用域中声明一个对象或变量，将它（搭配某种capture）以by-reference方式传入lambda。
与此相比，函数对象允许你封装内部状态。

尽管如此，你还是可以使用lambda来为无序（unordered）容器指出一个hash函数或一个等效准则。

### 函数对象（Function Object）

传递给算法的“函数型实参”（functional argument）不一定得是函数，可以是行为类似函数的对象。这种对象称为函数对象（function object），或称为仿函数（functor）

函数对象相对于回调函数带来更复杂的代码，然而函数对象有其过人之处，比起寻常函数，它们有以下优点：

- 1. 函数对象是一种带状态（with state）的函数。“行为像 pointer”的对象我们称之为“smart pointer”，同样道理，“行为像function”的对象我们可以称之为“smart function”，
因为它们的能力超越了operator()。函数对象可拥有成员函数和成员变量，这意味着函数对象拥有状态（state）。
事实上，在同一时间点，相同类型的两个不同的函数对象所表述的相同机能（same functionality），可具备不同的状态。
另一个好处是，你可以在运行期初始化它们——当然必须在它们被使用（被调用）之前。

- 2. 每个函数对象有其自己的类型。寻常函数，唯有在其签名式（signature）不同时，才算类型不同。
而函数对象即使签名式相同，也可以有不同的类型。事实上由函数对象定义的每一个函数行为都有其自己的类型。
这对于“运用template实现泛型编程”乃是一个卓越的贡献，因为这么一来我们便可以将函数行为当作template参数来运用。
这使得不同类型的容器可以使用同类型的函数对象作为排序准则。也可确保你不会在“排序准则不同”的集合（collection）间赋值、合并或比较。
你甚至可以设计函数对象的继承体系，以此完成某些特别事情，例如在一个总体原则下确立某些特殊情况。

- 3. 函数对象通常比寻常函数速度快。就template概念而言，由于更多细节在编译期就已确定，所以通常可能进行更好的优化。
所以，传入一个函数对象（而非寻常函数）可能获得更好的执行效能。

#### Binder
使用特殊的function adapter（函数适配器），或所谓binder，将预定义的函数对象和其他数值结合为一体。

```cc
#include <algorithm>
#include <deque>
#include <functional>
#include <set>
#include <iterator>
#include <iostream>

using namespace std;
using namespace std::placeholders;

template <typename T>
void print_elemt(T &coll, const char *str)
{
    cout << str;
    for (auto elem : coll) {
        cout << elem << " ";
    }
    cout << endl;
}
 
int main (int argc, char *argv[]) {
    
    set<int, greater<int>> coll1 = {1, 2, 3, 4, 5};
    deque<int> coll2;

    print_elemt(coll1, "coll1 = ");

    transform(coll1.begin(), coll1.end(),
            back_inserter(coll2),
            bind(multiplies<int>(), _1, 10));

    print_elemt(coll2, "coll2 = ");

    replace_if(coll2.begin(), coll2.end(),
            bind(equal_to<int>(), _1, 10),
            40);

    print_elemt(coll2, "coll2 = ");

    coll2.erase(remove_if(coll2.begin(), coll2.end(),
                bind(logical_and<int>(), 
                    bind(greater_equal<int>(), _1, 20),
                    bind(less_equal<int>(), _1, 30)
                )));

    print_elemt(coll2, "coll2 = ");

    return 0;
}
```

```cc
    transform(coll1.begin(), coll1.end(),
            back_inserter(coll2),
            bind(multiplies<int>(), _1, 10));
```
将coll1的所有元素乘以10，然后以安插模式传送到coll2。
为了定义相应操作，我们用上了bind（），它允许你借由低层的函数对象和占位符（placeholder）合成高层的函数对象。
所谓占位符是“带有前缀下画线”的数值标识符（numeric identifier）。通过指定
```cc
            bind(multiplies<int>(), _1, 10)
```
便定义出一个函数对象，会将传入的第一实参乘以10。

你也可以使用这样一个函数对象将任何数值乘以10。例如以下语句会把990写至标准输出设备
```cc
auto f = bind(multiplies<int>(), _1, 10);
f(99);
```

注意，占位符（placeholder）有自己的命名空间：`std::placeholders`。
基于此，程序起始处有一个相应的using指示符，这才能够使用_1或_2作为binder的第一或第二参数。
如果没有使用任何using指示符，最后那个binder组合体就必须被明确地标示出来：
```cc
                bind(logical_and<int>(), 
                    bind(greater_equal<int>(), std::placeholders::_1, 20),
                    bind(less_equal<int>(), std::placeholders::_1, 30)
```

### 容器内的元素
容器内的元素必须符合某些条件，因为容器乃是以一种特别方式来操作它们。

####  容器元素的必要条件
STL的容器、迭代器、算法都是template，因此它们可以操作任何类型，都可以。
然而，由于某些加诸元素身上的操作，导致出现某些条件。STL容器元素必须满足以下三个基本要求：
- 1.元素必须可复制或可搬移（copyable or movable）。也就是说，元素类型必须隐式或显式提供一个copy或move构造函数。
- 2.元素必须可被assignment操作符加以搬移或赋值。容器和算法以新元素覆写旧元素时用的是assignment操作符。
- 3.元素必须可被一个析构函数销毁。当元素被移除（remove），容器会销毁该元素的内部拷贝。因此，析构函数一定不能是private。

此外，一如C++惯常的做法，析构函数一定不可抛出异常，否则世事难料。

这三个条件对任何class而言其实都是隐含成立的。如果某个class既没有为上述动作定义特殊版本，也没有定义任何特殊成员破坏这些动作的健全性，那么它自然而然也就满足了上述条件。

下面的条件也应当获得满足：
- 对序列式容器而言，元素的default构造函数必须可用。我们可以在没有给予任何初值的情况下创建一个非空容器，或增加容器的元素个数。这些元素都将以default构造函数完成，不需任何实参。
- 对于某些操作，必须定义操作符==以执行相等测试。如果你想查找元素，这一点特别重要。
- 在关联式容器中，元素必须定义出适用于排序准则的操作。默认情况下是操作符＜，它将被函数对象`less<>`调用。
- 无序容器应该为元素提供一个hash函数，和一个等同时测试准则（equivalence criterion）。

### Value语义vs.Reference语义
通常，所有容器都会建立元素拷贝（copy），返回的也是元素拷贝。这意味着容器内的元素与你放进去的东西相等（equal）但非同一（identical）。
如果你修改容器的元素，实际上改变的是拷贝而不是原件。
Value 被复制意味着 STL 容器所提供的是 value 语义。它们容纳的是你安插的对象值，而不是对象本身。
然而现实中你也许需要用到 reference 语义，让容器容纳元素的reference。

STL只支持value语义，不支持reference语义。这当然是利弊参半。好处是：
- 复制元素很简单。
- 使用reference时容易导致错误。你必须确保reference所指对象仍然健在，并须小心对付偶尔出现的环式指向（circular reference）状态。

缺点是：
- 复制元素可能会导致不良的效率；有时甚至无法复制。
- 无法在数个不同的容器中管理同一份对象。

现实中你同时需要两种做法。你不但需要一份独立（于原先对象）的拷贝（此乃value语义），也需要一份代表原数据、但能相应改变原值的拷贝（此乃reference语义）。
不幸的是，C++标准库不支持reference语义。不过我们可以利用value语义实现reference语义。
一个显而易见的方法是以pointer作为元素。然而寻常的pointer有些常见问题，例如它们指向的对象也许不复存在，pointer之间的“比较”行为也未必如你预期，
因为实际比较的是pointer而非其所指对象。所以使用寻常pointer作为容器元素，必须非常谨慎。
好一点的办法是使用某种smart pointer，那是一种对象，有着类似pointer的接口，但内部做了一些额外检查和处理。
事实上自TR1起，C++标准库提供了class shared_ptr，这是个“可以共享相同对象”的smart pointer。
此外，你可以使用`class std::reference_wrapper<>`让STL容器持有reference。

## STL内部的错误和异常
### 错误处理
STL的设计宗旨是效能优先，安全次之.
误用STL的方法有百千种，STL没有义务预防你的各种可能不慎。因此，在软件开发阶段使用“安全版本”的STL是个好主意。
第一个STL安全版本由Cay Horstmann开发（见[SafeSTL]），另一个例子是STLport


# 容器
本章详细讨论STL容器。首先对所有容器共通的能力和操作进行概览，然后详细讲解每一个容器，包括内部数据结构、各种操作和其效率表现。如果某些操作值得深究，我还会给出相应的实例。每个例子都展示容器的典型用法。本章还讨论一个有趣的问题：各种容器的使用时机。比较各种容器的能力、优点和缺点之后，你便会了解如何选择最符合需求的容器。

## 容器的共通能力
- 1. 所有容器提供的都是“value语义”而非“reference语义”。容器进行元素的安插动作时，内部实施的是copy和/或move动作，而不是管理元素的reference。
  - 如果你想要存放的对象不具有public copy构造函数，或如果你要的不是复制（如复制动作花费太多时间，或你要的是被多个容器共享的元素），
  - 那么你就只能使用move操作，要么容器元素就必须是pointer或“用以指向对象”的pointer object
- 2. 元素在容器内有其特定顺序。每一种容器都会提供若干“返回迭代器”的操作函数，这些迭代器可用来遍历各个元素。
  - 这是STL算法的关键接口。如果你在元素之间迭代多次，你会获得相同的次序，前提是不曾安插或删除元素。
  - 这甚至对无序（unordered）容器也适用——只要你不调用那种会增加或删除元素的操作，或强迫内部重整。
- 3. 各项操作并非绝对安全，也就是说它们并不会检查每一个可能发生的错误。
  - 调用者必须确保传给操作函数的实参符合条件。违反条件（例如使用非法索引）会导致不明确的行为，那就是说任何事情都有可能发生。
  - 通常STL自己不会抛出异常。

## 容器共通方法

C++standard 具体指定了一系列容器共通要求，适用于所有STL 容器。然而由于C++11带来了容器的多样化，因此可能出现若干例外；
某些容器也许并不满足所有这些总体性的容器条件，而又有其他一些操作是全体容器都提供的。
表7.1和表7.2列出了（几乎）所有容器共通的操作，其中的必要列表示某个操作是否为总体性容器条件（general container requirement）的一部分。
后续各小节分别探讨这些共通操作。

| 操作 | 必要 | 效果 |
| --------------- | --------------- | --------------- |
| ContType c  | 是 | Default构造函数，建立一个未含任何元素的空容器（array<>将获得默认元素） |
| ContType c(c2) | 是 | Copy构造函数，建立一个新容器成为c2的拷贝（复制所有元素) |
| ContType c=c2 | 是  | Copy构造函数，建立一个新容器成为c2的拷贝（复制所有元素) |
| ContType c(rv) | 是 | Move 构造函数，建立一个新容器，取rvalue rv的内容为初值（始自C+11；不适用于array<>） |
| ContType c=rv | 是  | Move 构造函数，建立一个新容器，取rvalue rv的内容为初值（始自C+11；不适用于array<>） |
| ContType c(beg,end) | -  | 建立一个容器，以[beg，end）区间内的所有元素拷贝为初值（不适用于array<>） |
| ContType c(initlist) | - | 建立一个容器，并以初值列initlist的拷贝为初值（始自C+11;不适用于array<>) |
| ContType c= initlist | - | 建立一个容器，并以初值列initlist的拷贝为初值（始自C++11) |
| c.~ContType() | 是 | 删除所有元素，释放内存（如果可能的话）|
| c.empty()  | 是 | 判断容器是否为空（相当于size（）=0，但可能更快） |
| c.size() | 是  | 返回容器中的元素数量（不适用于forward_list<>）  |
| c.max_size() | 是 | 返回元素的最大可能数量 |
| c1==c2 | 是 | 判断是否c1等于c2 |
| c1 != c2 | 是 | 判断是否c1不等于c2，相当于！（c1=c2）） |
| c1 < c2 | - | 判断是否c1小于c2（不适用于unordered容器） |
| c1 > c2 | - | 判断是否c1大于c2，相当于c2<c1（不适用于unordered容器) |
| c1 <= c2 | - | 判断是否c1小于等于c2，相当于！（c2<c1）（不适用于unordered容器) |
| c1 >= c2 | - | 判断是否c1大于等于c2，相当于！（c1<c2）（不适用于unordered容器) |
| c = c2 | 是 | 将c2的所有元素赋值给 |
| cc=rv | 是 | 将rvalue rv以 move assign 方式赋予c(始自C++11; 不适用于array<>) |
| c=initlist | - | 将初值列initlist中的所有元素赋值给c（始自C++11；不适用于array<>) |
| c1.swap(c2) | 是 | 置换c1和c2的数据 |
| swap(c1, c2) | 是 | 同上，是个全局函数  |
| c.begin() | 是 | 返回一个iterator，指向第一元素 |
| c.end() | 是 |  返回一个iterator，指向最末元素的下一位置 |
| c.cbegin() | 是 | 返回一个const iterator,指向第一元素（始自C++11) |
| c.cend() | 是 | 返回一个const iterator，指向最末元素的下一位置（始自C++11) |
| c.clear() | - | 移除所有元素，令容器为空；不适用于array<> |

### 初始化（Initialization）
每个容器类都提供了一个default构造函数、一个copy构造函数和一个析构函数。
你可以以某个已知区间的内容作为容器初值，自C++11起你也可以指定一个初值列（initializer list）。
针对初值列（initializer list）而写的构造函数，提供了一种“指明初值”的便捷办法，这对于常量容器的初始化特别有用：

```cc
vector<int> v = {1, 2, 3, 4};
unordered_set<string> s = {"111", "222"};
```

array<>容器对于初值列的使用存在某些特殊规则.

“针对某个给定区间”而写的构造函数，提供的是以来自“另一容器”或“C-style array”或“标准输入”的元素为初值的能力。
这个构造函数是个member template，所以不只容器不同，连元素类型都可以不同，前提是“来源端的元素类型”和“目标端的元素类型”之间必须存在一个自动转换机制。
举几个例子：
- 以另一容器的元素为初值，完成初始化动作：
```cc
list<int> l;
...
vector<float> f(l.begin(), l.end());
```
- 自C++11起你也可以在这种情况中使用一个move迭代器:
```cc
list<string> l;
...
vector<string> f(make_move_iteraotr(l.begin()),
                make_move_iteraotr(l.end());
// l容器不再使用
```
- 以某个寻常C-style array的元素为初值，完成初始化动作：
```cc
int carray[] = {1, 2, 3};
...
set<int> s(std::begin(carray), std::end(carray));
```
- 以标准输入设备完成初始化动作：
```cc
deque<int> c{std::istream_iterator<int>(std::cin), std::istream_iterator<int>()};
```
- 可以使用一个move构造函数将容器初始化（如果容器是array<>，这个构造函数已经备妥）：
```cc
vector<int> v;
...
vector<int> v2 = std::move(v);
```
于是新建容器将拥有“被指定为初值”的那个容器的元素，而被当作初值的那个容器的内容此后将不再明确。
这样的构造函数可显著提升效率，因为在容器内部，元素被搬移的方式将会是“调动某些pointer”而非“逐一复制元素”。
所以任何时候只要你不再需要某个容器，而它又将被复制，就该使用move构造函数。

### 赋值（Assignment）和swap()

当你对着容器赋予元素时，来源容器的所有元素被复制到目标容器内，后者原本的元素全被移除。所以，容器的赋值动作代价相对高昂。

自C++11起，你可以使用move assignment语义取代上述行为。
所有容器都提供move assignment操作符（array<>也已备妥它们），针对rvalue而声明，其内部行为只是将pointer （指向value 所在之内存）交换而已，并不复制所有value。
其实C++11并没有指明精确行为，只保证它拥有常量复杂度，而现实往往就是上述做法。
C++标准库仅仅指出，在一个move assignment之后，赋值操作的左侧容器将拥有右侧容器的所有元素。至于右侧容器的内容，此后将不明确（不保证任何事情）：
```cc
vector<int> v;
vector<int> v2;
...
v2 = std::move(v);
```
所以，基于效率考虑，如果赋值后右侧容器的内容不再被使用，你应该使用这种赋值法。


此外，自C++98开始，所有容器都提供成员函数swap()，用来置换两容器的内容。
事实上它只是置换若干内部pointer，它们被用来指向数据（如元素、分配器〔allocator〕、排序准则〔sorting criterion〕等等）。
所以swap()保证常量复杂度，不像copy assignment是线性复杂度。容器的迭代器和用以指向元素的reference，都“密切紧盯”被置换的元素。
因此swap()之后原本存在的迭代器和reference都仍然指向原先所指的元素，只不过那些元素如今位于另一个容器中了。

注意，array<>容器的swap()行为略有不同。
由于它无法只是内在置换pointer，所以其swap()拥有线性复杂度，而且原本存在的迭代器和reference在swap发生之后，指向的是同一容器中的不同元素。

### 与大小相关的操作函数（Size Operation）

所有容器都提供三个与大小相关的操作函数：
- 1. empty()是`size() == 0`的一个快捷形式。empty()的实现可能比`size()==0`更有效率，你应该尽可能使用它。
- 2. size()返回当前容器的元素数量。
- 3. max_size()返回容器所能容纳的最大元素数量。其值因实现版本的不同而异。例如vector通常保有一个内存区块的全部元素，

所以在PC上可能会有相关限定。max_size()通常返回索引类型的最大值。

### 比较（Comparison）
除了无序（unordered）容器，常用的比较操作符==、！=、＜、＜=、＞和＞=都依据以下三个规则被定义出来：
- 1.比较动作的两端（两个容器）必须属于同一类型。
- 2.如果两个容器的所有元素依序相等，那么这两个容器相等。操作符==被用来检查元素是否相等。
- 3.采用“字典式（lexicographical）比较”来判断某个容器是否小于另一容器.

无序（unordered）容器只定义操作符==和！=，当容器内的每一个元素在另一容器内有相等元素，这些操作就返回true。元素次序无关紧要，因为它们是无序容器。

由于无序容器没有提供操作符＜、＜=、＞和＞=，所以只有==和！=是容器共通条件。
在C++11之前，容器必须提供所有的比较操作符，但自C++11起有了一份所谓“选择性的容器条件”（optional container requirement）表，其中涵盖了上述四个比较操作符。

若要比较两个不同类型的容器，必须使用STL比较算法.

### 元素访问（Element Access）
所有容器都提供迭代器接口，意思是它支持range-based for循环。因此，自C++11开始，最容易访问所有元素的办法如下：
```cc
for (const auto & elem : coll) {
    cout << elem << endl;
}
```
如果想要涂改元素，就不要写出const：
```cc
for (auto & elem : coll) {
    elem = ...;
}
```

如果其他元素被删除，所有容器（除了vector和deque）都保证迭代器以及用以指向元素的reference继续保持有效。但对于vector，只有删除点之前的元素才保持有效。

如果你以 clear()移除所有元素，对vector、deque和string而言，任何由 end()或cend()返回的逾尾（past-the-end）迭代器都可能失效。

如果你安插元素，只有list、forward list和关联式容器保证原本的迭代器和用以指向元素的reference继续保持有效。
对vector而言，这份保证只有当安插动作不超出容量才成立。
至于无序（unordered）容器，上述保证对于reference一般是成立的，但对于迭代器则只有当“不发生rehashing”才成立，而只要安插后的最终元素总数小于bucket个数乘以最大负载系数，就不会发生rehashing。

## array
它包覆一个寻常的static C-style array并提供一个STL容器接口
观念上所谓array是指一系列元素，有着固定大小。因此你无法借由增加或移除元素而改变其大小。它只允许你替换元素值
它比寻常的array安全，而且效率并没有因此变差。

           ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
           │   │   │   │   │   │   │   │   │   │   │
           └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
               固定大小的数组

```cc
namespace {
    template <typename T, size_t N>
    class array;
}
```

Array的元素可属于任何被指明的类型T。
第二个template参数用来指出这个array在其生命期中拥有的元素个数。因此 size()的结果总是N。
Array并不支持（也就是不允许你指定）分配器（allocator）。

### 初始化

array<>是唯一一个“无任何东西被指定为初值时，会被预初始化（default initialized）”的容器。
这意味着对于基础类型，初值可能不明确，而不是0。例如：
```cc
array<int, 4> x; // 元素初始值不确定
```
你可以为它提供一个空白初值列（empty initializer list），这种情况下所有元素保证被初始化，于是对基础类型而言元素初值为0：
```cc
array<int, 4> x = {}; 
```
原因是虽然array<>似乎为初值列提供了一个构造函数，其实并没有。
反倒是array<>满足了聚合体（aggregate）的要求。
因此，甚至C++11之前你也可以在array被建立时以初值列来设定array：
```cc
array<int, 4> x = {1, 2, 3, 4}; 
```
如果初值列内没有足够元素，array的元素会经由其类型的default构造函数初始化。
这种情况下对基础类型而言，其元素保证被初始化为0。例如：
```cc
array<int, 4> x = {1, 2}; 
```
如果初值列内的元素个数多过array的大小，这样的表达式就不对：
```cc
array<int, 4> x = {1, 2, 3, 4, 5};  // error
```
由于没有提供针对初值列而写的构造函数或assignment操作符，因此“在array声明期间完成初始化”是使用初值列的唯一途径。
基于这个原因，你无法使用小括号语法指明初值（此不同于其他容器类型）：
```cc
array<int, 4> x({1, 2, 3, 4}); // error
vector<int> v({1, 2, 3, 4}); // ok
```

### swap（）和Move语义
就像所有其他容器一样，array<>提供swap()操作。因此你可以和一个相同类型的容器（元素类型和元素个数都相同）置换彼此的元素。
然而请注意，array<>不能仅仅置换其内部pointer。
基于这个原因，swap()拥有线性复杂度并带来以下影响：iterator和reference不会随着元素的置换而改变所指的容器。
所以置换之后，iterator和reference指向原本容器，但指向至不同的元素。

你可以采用array暗自（隐式）备妥的move语义。例如
```cc
array<int, 5> arr1, arr2;
...
arr1 = move(arr2);
```
### 大小（Size）
Array 大小为0是可能的，那就是个没有任何元素的 array。
这种情况下begin()和end()，cbegin() 和 cend()，以及相应的反向迭代器（reverse iterator）会释出同一 value。
然而front()和back()的返回值就不明确了：
```cc
array<int, 0> coll;
sort(coll.begin(), coll.end()); // ok 但无意义
coll[5] = elem;       // error
cout << coll.fron();  // error
```
### 建立/复制/销毁（Create，Copy，and Destroy）

| 操作 | 效果 |
| -------------- | --------------- |
| array<Elem, N> c | Default 构造函数，建立一个array 带有 default-initialized元素 |
| array<Elem, N> c(c2) | Copy构造函数，建立另一个array的同型拷贝（所有元素都被复制) |
| array<Elem, N> c=c2 | Copy构造函数，建立另一个array的同型拷贝（所有元素都被复制) |
| array<Elem,N> c(rv) | Move 构造函数，取 rvalue rv的内容建立一个新 array (始自C++11) |
| array<Elem, N> c= rv | Move 构造函数，取 rvalue rv的内容建立一个新 array (始自C+11) |
| array<Elem, N> c=initlist | 取初值列initlist的元素为初值，建立一个array |

### 非更易型操作（Nonmodifying Operation）
| 操作 | 结果 |
| -------------- | --------------- |
| c.empty() |  返回是否容器为空（相当于size（）==0但也许较快）|
| c.size() | 返回目前的元素个数  |
| c.max_size() | 返回元素个数之最大可能量 |
| c1==c2 | 返回c1是否等于c2（对每个元素调用== |
| c1 != c2 | 返回c1是否不等于c2（相当于！（c1==c2）） |
| c1 < c2 | 返回c1是否小于c2 |
| c1 > c2 | 返回c1是否大于c2（相当于c2<c1） |
| c1 <= c2 | 返回c1是否小于等于c2（相当于！（c2<c1）） |
| c1>=c2 | 返回c1是否大于等于c2（相当于！（c1<c2）） |


### 赋值（Assignment）

在assignment操作符之外，只可使用fill（）赋新值给每一个元素，或使用swap（）对另一个array置换元素值。
如果使用操作符=和swap（），两个array必须具备相同类型，意思是二者的元素类型和大小都必须相同。

| 操作 | 结果 |
| -------------- | --------------- |
| c = c2 | 将c2的所有元素赋值给c |
| c=v | 将rvalue rv以move assign方式赋值给c的每一个元素（始自C+11)  |
| c.fill(val) | 将val赋值给array c的每一个元素 |
| c1.swap(c2) | 置换c1和c2的数据 |
| swap(c1, c2) | 置换c1和c2的数据 |

### 元素访问（Element Access）

| 操作 | 结果 |
| -------------- | --------------- |
| `c[idx]` | 返回索引id所指的元素（不检查范围） |
| c.at(idx) | 返回索引idx所指的元素（如果idx超出范围就抛出range-error异常) |
| c.front() | 返回第一元素（不检查是否存在第一元素） |
| c.back() | 返回最末元素（不检查是否存在最末元素） |


对调用端而言，最重要的议题就是，这些操作函数是否执行了“范围检查”。
只有at（）执行“范围检查”。如果索引逾越范围，at（）会抛出一个out_of_range异常。其他函数都不做检查。
范围不正确（range error）会引发不明确行为。对于一个空array<>调用operator []、front（）和back（）总是会导致不明确行为。
然而请注意，只有声明其大小为0它才是空的：

所以，要么你就必须确保operator []所用的索引是合法的，要么就改用at()


### 迭代器相关函数（Iterator Function）
| 操作 | 效果 |
| -------------- | --------------- |
| c.begin() | 返回一个random-access iterator指向第一元素 |
| c.end() | 返回一个random-access iterator指向最末元素的下一位置 |
| c.cbegin() | 返回一个const random-access iterator指向第一元素（始自C+11) |
| c.cend() | 返回一个const random-access iterator指向最末元素的下一位置（始自C++11) |
| c.rbegin() | 返回一个反向的(reverse)iterator指向反向迭代的第一元素 |
| c.rend() | 返回一个反向的(reverse)iterator指向反向迭代的最末元素的下一位置 |
| c.crbegin() | 返回一个const reverse iterator指向反向迭代的第一元素（始自C+11) |
| c.crend() | 返回一个const reverse iterator指向反向迭代的最末元素的下一位置（始自C+11) |

Array提供的是随机访问（random-access）迭代器，因此原则上你可以对array运用任何STL算法。

这些迭代器的精确类型由实现决定。
然而对array而言，begin、cbegin、end和 cend返回的迭代器往往是寻常pointer，这很好，因为array内部使用一个C-style array存放元素，并使用寻常pointer提供random-access迭代器接口。
然而你不可依赖“迭代器是寻常pointer”这一事实。
举个例子，如果你用的是安全版STL（会检查区间差错和其他潜在问题），那么array的迭代器类型往往会是一个辅助class。9.2.6节第440页提出在“iterator被实现为pointer”和“iterator被实现为class”之间有一些令人头痛的差异。

只要array保持有效，其迭代器也就保持有效。然而不同于任何其他容器，swap()乃是将新值赋予iterator、reference和pointer指向的元素身上。


### 把array当成C-Style Array
就像对待class vector<>一样，C++标准库保证array<>的所有元素一定位于连续且相邻的内存内。于是你可以预期，对于array a的任何有效索引i，
```cc
&a[i] == &a[0] + i;
```
这一保证带来某些重要结果。它意味着，无论何处，只要你可以使用寻常的C-style array，你就可以使用array<>。
例如你可以使用array持有寻常的C-string（类型为char*或const char*）的数据：
```cc
array<char, 41> a;
strcpy(&a[0], "hello");
printf("%s", &a[0]);
```

然而，注意，如果想直接访问 array 的元素，你不一定要用表达式`&a[0]`，因为成员函数data（）也具备相同用途：
```cc
array<char, 41> a;
strcpy(a.data(), "hello");
printf("%s", a.data());
```
当然，以此种方式使用array<>，你必须小心谨慎（就像你使用寻常的 C-style array 和pointer时也总是必须小心谨慎）。
举个例子，你必须确保array的大小足够容纳被复制进来的数据，而且如果你把其中的内容当作一个C-string来看，你必须放置一个'\0'元素于尾端。
然而这个例子告诉你，无论何时，无论什么理由，当你需要一个元素类型为T的array （也许是为了一个既有的C程序库），
你可以使用array<>（或vector<>）并在任何需要寻常C-style接口的地方使用data（）。

注意，绝对不要以迭代器表现“第一元素的地址”。Class array<>的迭代器的真实类型取决于实现，有可能与寻常的pointer完全不同：
```cc
printf("%s", a.begin()); // error
printf("%s", a.data());  // ok
```

### 异常处理（Exception Handling）
Array只提供极少量逻辑差错（logical error）检查。
C++standard规定“可抛出异常”的成员函数只有at（），它可说是下标（subscript）操作符的安全版本.

那些被array调用的函数（也许由元素类型提供，也许由用户提供）对于异常处理并无特别保证
（由于你不能够安插或删除元素，所以异常只可能发生在你copy、move或assign元素值时）。
特别请注意，swap（）有可能抛出异常，因为它执行的是“元素逐次”（element-wise）的置换动作，而那有可能抛出异常。

### Tuple接口
Array提供tuple接口。
因此你可以用表达式`tuple_size<>::value`取得元素个数，用`tuple_element<>::type`取得某特定元素的类型，用get()取得某特定元素。例如：
```cc
typedef std::array<std::string, 5> FiveStrings;

FiveStrings a{"hello","nico","how","are","you"};

std::tuple_size<FiveStrings>::value     // 5
std::tuple_element<1,FiveStrings>::type // std::string
std::get<1>(a) // std:string("nico")
```

## vector

Vector模塑出一个dynamic array。它本身是“将元素置于dynamic array中加以管理”的一个抽象概念。

           ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───
           │   │   │   │   │   │   │   │   │   │  ───►
           └───┴───┴───┴───┴───┴───┴───┴───┴───┴───
               
```cc
namespace {
    template<typename T,
             typename Allocator = allocator<T>>
    class vector;
}
``` 
Vector 的元素可以是任意类型T。可有可无的第二个 template 参数用来定义内存模型。默认的内存模型是C++标准库提供的allocator。

### Vector的能力
Vector将元素复制到内部的dynamic array中。
元素之间总是存在一定的顺序，所以vector是一种有序集合（ordered collection）。
Vector支持随机访问，因此只要知道位置，你可以在常量时间内访问任何一个元素。
Vector提供随机访问迭代器，所以适用于任何STL算法。

如果你在末端附加或删除元素，vector的效率相当好。
但如果你在前端或中段安插或删除元素，效率就不怎么样了，因为作用点之后的每一个元素都必须移到另一位置，而每一次移动都得调用assignment操作符。

### 大小（Size）和容量（Capacity）
Vector优异效率的秘诀之一，就是分配出“较其容纳的元素”更多的内存。为了能够高效运用vector，你应该了解大小和容量之间的关系。

Vector提供用以操作大小的函数有size（）、empty（）和max_size（）。
另一个与大小有关的函数是capacity（），返回vector实际能够容纳的元素量。如果超越这个量，vector就有必要重新分配内部内存。

Vector的容量之所以重要，有两个原因：
- 1.一旦内存重新分配，vector元素相关的所有reference、pointer、iterator都会失效。
- 2.内存重新分配很耗时间。

所以，如果你的程序管理了“与vector元素相关”的reference、pointer或iterator，或如果程序的执行速度对你而言至关重要，那就必须考虑容量问题。

你可以使用reserve（）保留适当容量，避免重新分配内存。如此一来，只要保留的容量尚有富余，就不必担心reference失效。
```cc
vector<int> v;
v.reserve(80);  // 分配80个元素的容量
```

vector的容量概念和string类似，但是有一个大不同：
vector不能使用reserve（）缩减容量，这一点和strings不同。
调用reserve（）所给的实参如果小于当前vector的容量，不会引发任何效果。
此外，如何达到时间和空间的最佳效率，系由实现版本决定。
因此，具体实现版本中容量的增长幅度可能比你我料想的还大。
事实上，为了防止内存破碎，在许多实现方案中即使你不调用reserve（），当第一次安插元素时也会一口气分配整块内存（例如2K）。
如果你有一大堆vector，每个vector的实际元素寥寥无几，浪费的内存相当可观。

既然vector的容量不会缩减，我们便可确定，即使删除元素，其reference、pointer和iterator 也会继续有效，继续指向动作发生前的位置。
然而安插动作却可能使reference、pointer和iterator失效（因为安插可能导致vector重新分配）。

C++11引入一个vector新函数：一个不具强制力的要求，可以缩减容量以符合当前的元素个数。
```cc
v.shrink_to_fit();
```
这个要求不具强制力，以便为实现可能的特有优化保留回旋余地。因此你不能够期望之后的`v.capacity==v.size()`会获得true。

在C++11之前，有一个间接缩减vector容量的小窍门：两个vector交换内容后，两者的容量也会互换，因此下面的例子虽然保留了元素，却缩减了容量。
```cc

template <typename T>
void shrinkCapacity(vector<T> &v) {
    vector<T> tmp(v);
    v.swap(tmp);
}
// 或者
vector<int> (v).swap(v);
```
不过请注意，swap()之后原先所有的reference、pointer和iterator都换了指向对象；它们仍然指向原本位置。
换句话说，上述的shrinkCapacity()使所有reference、pointer和iterator失效。shrink_to_fit()同样如此。

### 构建、复制和销毁
| 操作 | 效果 |
| -------------- | --------------- |
| vector<Elem> c | Default构造函数，产生一个空vector,没有任何元素 |
| vector<Elem> c(c2) | Copy构造函数，建立c2的同型vector并成为c2的一份拷贝（所有元素都被复制） |
| vector<Elem>c = c2 | Copy构造函数，建立一个新的vector作为c2的拷贝(每个元素都被复制)|
| vector<Elem>c(rv) | Move构造函数，建立一个新的vector取rvalue rv的内容（始自C+11) |
| vector<Elem> c = rv | Move构造函数，建立一个新的vector, 取value rv的内容（始自C+11) |
| vector<Elem>c(n) | 利用元素的default构造函数生成一个大小为n的vector |
| vector<Elem> c(n,elem) | 建立一个大小为n的vector,每个元素值都是elem |
| vector<Elem> c(beg,end) |  建立一个vector,以区间[beg,end)作为元素初值|
| vector<Elem> c(initlist) | 建立一个vector,以初值列initlist的元素为初值（始自C++11) |
| vector<Elem>c=initlist | 建立一个vector,.以初值列initlist的元素为初值（始自C++11) |
| c.~vector() | 销毁所有元素，释放内存 |

### 非更易型操作

| 操作 | 效果 |
| -------------- | --------------- |
| c.empty() | 返回是否容器为空（相当于 size()==0 但也许较快） |
| c.size() | 返回目前的元素个数 |
| c.max_size() | 返回元素个数之最大可能量 |
| c.capacity() | 返回 “不进行空间重新分配” 条件下的元素最大容纳量 |
| c.reserve(num) | 如果容量不足，扩大之 |
| c.shrink_to_fit()|  要求降低容量，以符合元素个数|
| c1 == c2| 返回 c1 是否等于 c2（对每个元素调用 ==） |
| c1 != c2| 返回 c1 是否不等于 c2（相当于 !(c1==c2)） |
| c1 < c2| 返回 c1 是否小于 c2 |
| c1 > c2| 返回 c1 是否大于 c2（相当于 c2<c1） |
| c1 <= c2| 返回 c1 是否小于等于 c2（相当于 !(c2<c1)） |
| c1 >= c2| 返回 c1 是否大于等于 c2（相当于 !(c1<c2)） |

### 赋值
| 操作 | 效果 |
|---|---|
| `c = c2` | 将 `c2` 的全部元素赋值给 `c` |
| `c = rv` | 将右值 `rv` 的所有元素以 move assign 方式给予 `c`（始于 C++11）|
| `c = initlist` | 将初值列 `initlist` 的所有元素赋值给 `c`（始于 C++11）|
| `c.assign(n, elem)` | 复制 `n` 个 `elem`，赋值给 `c` |
| `c.assign(beg, end)` | 将区间 `[beg, end)` 内的元素赋值给 `c` |
| `c.assign(initlist)` | 将初值列 `initlist` 的所有元素赋值给 `c` |
| `c1.swap(c2)` | 置换 `c1` 和 `c2` 的数据 |
| `swap(c1, c2)` | 置换 `c1` 和 `c2` 的数据 |

### 元素访问（Element Access）
欲访问vector的所有元素，你必须使用range-based for循环、特定的操作函数或迭代器。
按C/C++惯例，第一元素的索引为0，最末元素的索引为`size()-1`。所以第n个元素的索引是n-1。
对于non-const vector，这些函数都返回元素的reference，也就是说，你可以使用这些操作函数更改元素内容.

| 操作 | 效果 |
|------|------|
| `c[idx]` | 返回索引 idx 所指的元素（不检查范围） |
| `c.at(idx)` | 返回索引 idx 所指的元素（如果 idx 超出范围就抛出 range-error 异常） |
| `c.front()` | 返回第一元素（不检查是否存在第一元素） |
| `c.back()` | 返回最末元素（不检查是否存在最末元素） |

对调用者来说，最重要的事莫过于搞清楚这些操作是否执行范围检查。
只有at（）会那么做。如果索引越界，at（）会抛出out_of_range异常。
其他函数都不做检查，如果发生越界错误，会引发不明确的行为。对一个空vector调用operator []、front（）和back（），也都会引发不明确行为：
```cc
vector<int> coll; //empty
coll[4] =  1; // error
cout << coll.front(); // error
```
所以，调用operator []时你必须心里有数，确保索引有效；调用front（）或back（）时必须确定容器不为空

### 迭代器相关函数（Iterator Function）
vector 提供了一些常规函数来获取迭代器，Vector 提供的是随机访问（random-access）迭代器。因此，理论上说，你可以把所有STL算法作用于vector身上。

迭代器的确切类型由实现决定。对vector而言，begin、cbegin、end和cend返回的往往是寻常pointer。
这是好的，因为vector内部结构通常就是个array，而寻常pointer也提供了随机访问迭代器的接口。
但你不能仰仗这个事实。例如也许有个STL安全版本对所有区间范围和其他潜在错误实施检查，那么其vector迭代器可能就是个辅助类而不是寻常pointer。

vector迭代器持续有效，除非发生两种情况：
- 使用者在一个较小索引位置上安插或移除元素.
- 由于容量变化而引起内存重新分配.

| 操作 | 效果 |
|------|------|
| c.begin() | 返回一个 random-access iterator 指向第一元素 |
| c.end() | 返回一个 random-access iterator 指向最末元素的下一位置 |
| c.cbegin() | 返回一个 const random-access iterator 指向第一元素（始自 C++11） |
| c.cend() | 返回一个 const random-access iterator 指向最末元素的下一位置（始自 C++11） |
| c.rbegin() | 返回一个反向的（reverse）iterator 指向反向迭代的第一元素 |
| c.rend() | 返回一个反向的（reverse）iterator 指向反向迭代的最末元素的下一位置 |
| c.crbegin() | 返回一个 const reverse iterator 指向反向迭代的第一元素（始自 C++11） |
| c.crend() | 返回一个 const reverse iterator 指向反向迭代的最末元素的下一位置（始自 C++11） |

### 安插和移除（Inserting and Removing）元素

| 操作 | 效果 |
|------|------|
| `c.push_back(elem)` | 附加一个 elem 的拷贝于末尾 |
| `c.pop_back()` | 移除最后一个元素，但是不返回它 |
| `c.insert(pos, elem)` | 在 iterator 位置 pos 之前方插入一个 elem 拷贝，并返回新元素的位置 |
| `c.insert(pos, n, elem)` | 在 iterator 位置 pos 之前方插入 n 个 elem 拷贝，并返回第一个新元素的位置（或返回 pos—— 如果没有新元素的话） |
| `c.insert(pos, beg, end)` | 在 iterator 位置 pos 之前方插入区间 [beg, end) 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 pos—— 如果没有新元素的话） |
| `c.insert(pos, initlist)` | 在 iterator 位置 pos 之前方插入初值列 initlist 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 pos—— 如果没有新元素的话；始自 C++11） |
| `c.emplace(pos, args...)` | 在 iterator 位置 pos 之前方插入一个以 args 为初值的元素，并返回新元素的位置（始自 C++11） |
| `c.emplace_back(args...)` | 附加一个以 args 为初值的元素于末尾，不返回任何东西（始自 C++11） |
| `c.erase(pos)` | 移除 iterator 位置 pos 上的元素，返回下一元素的位置 |
| `c.erase(beg, end)` | 移除 [beg, end) 区间内的所有元素，返回下一元素的位置 |
| `c.resize(num)` | 将元素数量改为 num（如果 size() 变大，多出来的新元素都需以 default 构造函数完成初始化） |
| `c.resize(num, elem)` | 将元素数量改为 num（如果 size() 变大，多出来的新元素都是 elem 的拷贝） |
| `c.clear()` | 移除所有元素，将容器清空 |

你必须保证传入的实参合法：
- 迭代器必须指向一个合法位置，
- 区间的起始位置不能在结束位置之后。

一如既往，当pop_back（）被调用时，确保容器不为空是程序员的责任。例如：
```cc
vector<int> coll;
coll.pop_back(); // err

if (!coll.empty()) {
    coll.pop_back(); // ok
}
```

然而，请注意，在多线程环境中你必须确保：在“检查容器是否为空”和pop_back（）动作之间coll不被改动.

关于效能，以下情况你可以预期安插动作和移除动作会比较快些：
- 在容器尾部安插或移除元素。
- 容量一开始就够大。
- 安插多个元素时，“调用一次”当然比“调用多次”来得快。

安插或移除元素，都会使“作用点”之后的各元素的reference、pointer和iterator失效。
如果安插动作甚至引发内存重新分配，那么该容器身上的所有reference、pointer和iterator都会失效。

Vector并未提供任何函数可以直接移除“与某值相等”的所有元素。这是算法发挥威力的时候。以下语句可将值为val的所有元素移除：
```cc
vector<int> coll;
...
coll.erase(remove(coll.begin(), coll.end(), val), 
           coll.end);
```
如果只是要移除“与某值相等”的第一个元素，可以这么做：
```cc
vector<int> coll;
vector<int>::iterator pos;
pos = find(coll.begin(), coll.end(), val);
if (pos != coll.end()) {
    coll.erase(pos);
}
```

### 将Vector当作C-Style Array使用
就像class array<>一样，C++标准库保证vector的元素必须分布于连续空间中。因此你可以确定，对于vector v中任意一个合法索引i，以下肯定为true：
```cc
&v[i] == &v[0] + i;
```
保证了这一点，就可推导出一系列重要结果。简单的说，任何地点只要你需要一个 dynamic array，你就可以使用 vector。
例如你可利用 vector 存放寻常的 C 字符串（类型为char*或const char*）：
```cc
vector<char> v;
v.resize(41);
strcpy(&v[0], "hello world");
printf("%s", &v[0]);
```
然而请注意，自C++11起，如果想直接访问vector的元素，不一定要用&a[0]，因为成员函数data（）也具备相同用途：
```cc
vector<char> v;
v.resize(41);
strcpy(v.data, "hello world");
printf("%s", v.data);
```
当然，以此种方式使用vector必须小心谨慎（就好像使用C-style array和pointer时，也总是必须小心谨慎）。
举个例子，你必须确保vector的大小足够容纳复制进来的数据，而且如果你把其中的内容当作一个C-string看，你必须放置一个'\0'元素在字符串尾端。
然而这个例子告诉你，无论何时，无论什么理由，当你需要一个元素类型为T的array（例如为了使用一个旧有的C程序库），可以使用vector<>并将第一元素的地址传入。


注意，千万不要把迭代器当作“第一元素的地址”来传递。Vector迭代器是由实现定义的，也许并不是个寻常pointer：
```cc
printf("%s", v.begin()); // error
printf("%s", v.data()); // ok
printf("%s", &v[0]); // ok
```
### 异常处理（Exception Handling
Vector只支持最低限度的逻辑差错检查。
Subscript（下标）操作符的安全版本at()是唯一被C++standard认可得以抛出异常的函数。
此外C++standard也规定，只有一般标准异常（例如内存不足时抛出bad_alloc）或用户自定义操作函数的异常，才可能发生。

如果vector调用的函数（元素类型提供的函数或用户提供的函数）抛出异常，C++标准库做出如下保证：
- 1.如果push_back安插元素时发生异常，函数将不产生效用。
- 2.如果元素的 copy/move 操作（包括构造函数和 assignment 操作符）不抛出异常，那么insert、emplace、emplace_back和push_back要么成功，要么不产生效用。
- 3.pop_back绝不会抛出任何异常。
- 4.如果元素的copy/move操作（包括构造函数和assignment操作符）不抛出异常，erase就不抛出异常。
- 5.swap和clear不抛出异常。
- 6.如果元素的copy/move操作（包括构造函数和assignment操作符）不抛出异常，那么所有操作不是成功，就是不产生效用。这类元素有可能是POD（plain old data，简朴的老式数据）。POD泛指那些无C++特性的类型，例如C struct便是。

所有这些保证都基于一个条件：析构函数不得抛出异常。

Vector使用实例

```cc
#include <vector>
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
    // 创建空的 string 类型 vector
    vector<string> sentence;

    // 预留空间存储 5 个元素（避免后续可能的重新分配）
    sentence.reserve(5);

    // 追加元素
    sentence.push_back("Hello,");   // Hello
    sentence.insert(sentence.end(), {"how", "are", "you", "?"}); // Hello how are you ?

    // 用空格分隔打印元素
    copy(sentence.cbegin(), sentence.cend(),
         ostream_iterator<string>(cout, " ")); // Hello how are you ?
    cout << endl;

    // 打印“技术数据”：最大尺寸、当前大小、容量
    cout << "  max_size(): " << sentence.max_size() << endl;
    cout << "  size():     " << sentence.size()     << endl;
    cout << "  capacity(): " << sentence.capacity() << endl;

    // 交换第二个和第四个元素
    swap(sentence[1], sentence[3]);  // Hello you are how ?

    // 在元素“?”前插入“always”
    sentence.insert(find(sentence.begin(), sentence.end(), "?"),
                    "always"); // Hello you are how always ?

    // 将“!”赋值给最后一个元素
    sentence.back() = "!";     // Hello you are how always !

    // 用空格分隔打印元素
    copy(sentence.cbegin(), sentence.cend(),
         ostream_iterator<string>(cout, " "));
    cout << endl;

    // 再次打印“技术数据”
    cout << "  max_size(): " << sentence.max_size() << endl;
    cout << "  size():     " << sentence.size()     << endl;
    cout << "  capacity(): " << sentence.capacity() << endl;

    // 删除最后两个元素
    sentence.pop_back();    // Hello you are how always
    sentence.pop_back();    // Hello you are how

    // 收缩容量（C++11 及以上支持）
    sentence.shrink_to_fit();

    // 再次打印“技术数据”
    cout << "  max_size(): " << sentence.max_size() << endl;
    cout << "  size():     " << sentence.size()     << endl;
    cout << "  capacity(): " << sentence.capacity() << endl;
}
```

运行结果
```bash
Hello, how are you ? 
  max_size(): 288230376151711743
  size():     5
  capacity(): 5
Hello, you are how always ! 
  max_size(): 288230376151711743
  size():     6
  capacity(): 10
  max_size(): 288230376151711743
  size():     4
  capacity(): 4
```

注意我说的是可能的输出。是的，max_size和capacity的结果由实现决定。
这个例子显示，当容量不足时此实现将容量扩充一倍，而被要求缩减时却不一定真的缩减。


### Class vector<bool>

C++标准库针对元素类型为bool的vector<>专门设计了一个特化版本，目的是获取一个优化的vector，使其耗用空间远小于以一般vector实现出来。
一般实现版本会为每个bool元素分配至少1 byte空间，而`vector<bool>`特化版的内部只使用1 bit存放一个元素，空间节省8倍。
不过这里有个小麻烦：C++的最小可定址值乃是以byte为单位，所以上述的vector特化版必须对reference和iterator做特殊处理。

因此，`vector<bool>`无法满足其他vector的所有规定，例如`vector<bool>::reference`并不是个真正的 lvalue，`vector<bool>::iterator`也不是个真正的随机访问迭代器。
所以某些 template 代码有可能适用于任何类型的 vector，唯独无法应付`vector<bool>`。
此外`vector<bool>`可能比一般 vector 慢一些，因为所有元素操作都必须转化为 bit 操作。不过`vector<bool>`的具体方案也是由实现决定，所以效能（包括速度和空间消耗）也可能各有差异。

注意，`vector<bool>`不仅是个特殊的bool版本，它还提供某些特殊的bit操作。你可以利用它们更方便地操作bit或flag。

由于`vector<bool>`的大小可动态改变，你还可以把它当成可动态改变大小的 bit-field。因此你可以任意添加或移除bit。
如果需要大小固定的bitfield，应当使用bitset而不是`vector<bool>`。


| 操作                | 效果                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c.flip()`          | 将所有 bool 元素值反相（negate），亦即对所有 bit 求补数      |
| `c[idx].flip()`     | 将索引 `idx` 所指的 bit 元素反相（对单一 bit 求补数）        |
| `c[idx] = val`      | 将索引 `idx` 所指的 bit 元素赋值为 `val`（赋值单一 bit）     |
| `c[idx1] = c[idx2]` | 将索引 `idx1` 所指的 bit 元素赋值为索引 `idx2` 所指的 bit 元素值 |


flip()用来取补数（complement）。
注意，你竟然可以对vector内的所有bit或单一bit调用flip（），后者很值得注意，因为也许你会以为让subscript操作符返回bool再对此基础类型调用flip()是不可能的。
然而`vector<bool>`运用了一个名为proxy的技巧：面对一个`vector<bool>`，subscript操作符（及其他返回单一bit的操作符）的返回类型实际上是个辅助类，一旦你要求返回值为bool，便会触发一个自动类型转换函数。
`vector<bool>`的相关声明如下：

```cc
namespace std {
    template <typename Allocator> class vector<bool,Allocator> {
    public:
        // auxiliary proxy type for element modifications:
        class reference {
            
        public:
            reference& operator= (const bool) noexcept;  // assignments
            reference& operator= (const reference&) noexcept;
            operator bool() const noexcept;  // automatic type conversion to bool
            void flip() noexcept;             // bit complement
        };

        // operations for element access return reference proxy instead of bool:
        reference operator[](size_type idx);
        reference at(size_type idx);
        reference front();
        reference back();
    };
}
```
你会发现，所有用于元素访问的函数，返回的都是reference类型。所以，可以这么写：

```cc
c.front().flip();
c[5] = c.back();
```

一如往常，为了避免不明确的行为，调用者必须确保第一、第六和最后一个元素存在。

只有`vector<bool>`的non-const容器才会用到其内部的proxy类型reference。
而用来处理元素的那些const成员函数，返回类型都是const_reference，那就是bool。

## Deque

容器deque（发音为“deck”）和vector非常相似。它也采用dynamic array来管理元素，提供随机访问，并有着和vector几乎一模一样的接口。
不同的是deque的dynamic array头尾都开放，因此能在头尾两端进行快速安插和删除.


           ───┬───┬───┬───┬───┬───┬───┬───┬───┬───
        ◄───  │   │   │   │   │   │   │   │   │  ───►
           ───┴───┴───┴───┴───┴───┴───┴───┴───┴───
 
为了提供这种能力，deque通常实现为一组独立区块（a bunch of individual blocks），第一区块朝某方向扩展，最末区块朝另一方向扩展:


          ┌────┐     ┌────┐     ┌────┐     ┌────┐
          │    │     │    │     │    │     │    │
          ├────┤     ├────┤     ├────┤     │ ▲  │
          │    │     │    │     │    │     │ │  │
          ├────┤     ├────┤     ├────┤     │ │  │
          │    │     │    │     │    │     │ │  │
     ◄─── ├────┤     ├────┤     ├────┤     ├────┤  ───►
          │  │ │     │    │     │    │     │    │
          │  │ │     ├────┤     ├────┤     ├────┤
          │  │ │     │    │     │    │     │    │
          │  │ │     ├────┤     ├────┤     ├────┤
          │  ▼ │     │    │     │    │     │    │
          └────┘     └────┘     └────┘     └────┘

其中，deque类型定义于命名空间std内的一个class template：
```cc
namespace {
    template <typename T, typename Allocator = allocator<T>>
    class deque;
}
```
和vector相同，这里的第一个template参数用来表明元素类型。第二个template实参可有可无，用来指定内存模型（memory model），默认为allocator.

### Deque的能力
Deque与vector相比，功能上的差异如下：
- 两端都能快速安插元素和移除元素（vector只在尾端逞威风）。这些操作可以在摊提的常量时间（amortized constant time）内完成。
- 访问元素时deque内部结构会多一个间接过程，所以元素的访问和迭代器的动作会稍稍慢一些。
- 迭代器需要在不同区块间跳转，所以必须是个smart pointer，不能是寻常pointer。
- 在内存区块大小有限制的系统中（例如PC系统），deque可以内含更多元素，因为它使用不止一块内存。因此deque的max_size()可能更大。
- Deque不支持对容量和内存重新分配时机的控制。特别要注意的是，除了头尾两端，在任何地点安插或删除元素都将导致指向deque元素的任何pointer、reference和iterator失效。不过，deque的内存重分配优于vector，因为其内部结构显示，deque不必在内存重新分配时复制所有元素。
- Deque会释放不再使用的内存区块。Deque的内存大小是可缩减的，但要不要这么做，以及如何做，由实现决定。

Deque的以下特性跟Vector差不多：
- 在中段安插、移除元素的速度相对较慢，因为所有元素都需移动以腾出或填补空间。
- 迭代器属于random-access iterator（随机访问迭代器）。

总之，以下情形最好采用deque：
- 你需要在两端安插和移除元素（这是deque的拿手好戏）。
- 无须指向（refer to）容器内的元素。
- 要求“不再使用的元素必须释放”（不过C++standard对此无任何保证）。

Vector和deque的接口几乎一样，所以如果你不需要什么特殊性质，两者都可试试。

### Deque的操作函数

#### Deque的构造和析构函数:
| 操作                          | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `deque<Elem> c`               | Default 构造函数，产生一个空 deque，没有任何元素             |
| `deque<Elem> c(c2)`           | Copy 构造函数，建立 `c2` 的同型 deque 并成为 `c2` 的一份拷贝（所有元素都被复制） |
| `deque<Elem> c = c2`          | Copy 构造函数，建立一个新的 deque 作为 `c2` 的拷贝（每个元素都被复制） |
| `deque<Elem> c(rv)`           | Move 构造函数，建立一个新的 deque，取 rvalue `rv` 的内容（始自 C++11） |
| `deque<Elem> c = rv`          | Move 构造函数，建立一个新的 deque，取 rvalue `rv` 的内容（始自 C++11） |
| `deque<Elem> c(n)`            | 利用元素的 default 构造函数生成一个大小为 `n` 的 deque       |
| `deque<Elem> c(n, elem)`      | 建立一个大小为 `n` 的 deque，每个元素值都是 `elem`           |
| `deque<Elem> c(beg, end)`     | 建立一个 deque，以区间 `[beg, end)` 作为元素初值             |
| `deque<Elem> c(initlist)`     | 建立一个 deque，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `deque<Elem> c = initlist`    | 建立一个 deque，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `c.~deque()`                  | 销毁所有元素，释放内存                                       |

Deque的各项操作只有以下两点和vector不同：
- 1.Deque不提供容量操作（capacity()和reserve()）。
- 2.Deque直接提供函数完成头部元素的安插和删除（push_front()和pop_front()）。

其他操作都相同，所以这里不重复，具体描述见第273页7.3.2节。

请注意，C++11添加了shrink_to_fit()，那是个不具强制力（nonbinding）的函数，负责缩小内部内存以匹配元素个数。
你可能会认为shrink_to_fit()对deque没意义，因为deque本就会释放不再用到的区块内存。
然而，deque内部用来存放“指向独立区块”的所有pointer的空间，通常不会被缩小，如果用了这个函数就有可能真的被缩小。


#### Deque的非更易型操作:
| 操作           | 效果                                                         |
| -------------- | ------------------------------------------------------------ |
| `c.empty()`    | 返回是否容器为空（相当于 `size()==0` 但也许较快）            |
| `c.size()`     | 返回目前的元素个数                                           |
| `c.max_size()` | 返回元素个数之最大可能量                                     |
| `c.shrink_to_fit()` | 要求降低容量，以符合元素个数（始自 C++11）|
| `c1 == c2`     | 返回 `c1` 是否等于 `c2`（对每个元素调用 `==`）                |
| `c1 != c2`     | 返回 `c1` 是否不等于 `c2`（相当于 `!(c1==c2)`）               |
| `c1 < c2`      | 返回 `c1` 是否小于 `c2`                                       |
| `c1 > c2`      | 返回 `c1` 是否大于 `c2`（相当于 `c2<c1`）                     |
| `c1 <= c2`     | 返回 `c1` 是否小于等于 `c2`（相当于 `!(c2<c1)`）              |
| `c1 >= c2`     | 返回 `c1` 是否大于等于 `c2`（相当于 `!(c1<c2)`）              |
| `c[idx]`       | 返回索引 `idx` 所指的元素（不检查范围）                       |
| `c.at(idx)`    | 返回索引 `idx` 所指的元素（如果 `idx` 超出范围就抛出 `range-error` 异常） |
| `c.front()`    | 返回第一元素（不检查是否存在第一元素）                       |
| `c.back()`     | 返回最末元素（不检查是否存在最末元素）                       |
| `c.begin()`    | 返回一个 `random-access iterator` 指向第一元素                |
| `c.end()`      | 返回一个 `random-access iterator` 指向最末元素的下一位置      |
| `c.cbegin()`   | 返回一个 `const random-access iterator` 指向第一元素（始自 C++11） |
| `c.cend()`     | 返回一个 `const random-access iterator` 指向最末元素的下一位置（始自 C++11） |
| `c.rbegin()`   | 返回一个反向的（`reverse`）`iterator` 指向反向迭代的第一元素  |
| `c.rend()`     | 返回一个反向的（`reverse`）`iterator` 指向反向迭代的最末元素的下一位置 |
| `c.crbegin()`  | 返回一个 `const reverse iterator` 指向反向迭代的第一元素（始自 C++11） |
| `c.crend()`    | 返回一个 `const reverse iterator` 指向反向迭代的最末元素的下一位置（始自 C++11） |

还有一些值得考虑的事情：
- 1.除了at()，没有任何成员函数会检查“索引或迭代器是否有效”。
- 2.元素的插入或删除可能导致内存重新分配，所以任何插入或删除动作都会使所有指向deque元素的pointer、reference和iterator失效。
  - 唯一例外是在头部或尾部插入元素，在那动作之后pointer和reference仍然有效（但iterator就没这么幸运）。


#### Deque的更易型操作:
| 操作                          | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `c = c2`                      | 将 `c2` 的全部元素赋值给 `c`                                 |
| `c = rv`                      | 将 rvalue `rv` 的所有元素以 move assign 方式给予 `c`（始自 C++11） |
| `c = initlist`                | 将初值列 `initlist` 的所有元素赋值给 `c`（始自 C++11）       |
| `c.assign(n, elem)`           | 复制 `n` 个 `elem`，赋值给 `c`                               |
| `c.assign(beg, end)`          | 将区间 `[beg, end)` 内的元素赋值给 `c`                       |
| `c.assign(initlist)`          | 将初值列 `initlist` 的所有元素赋值给 `c`                     |
| `c.swap(c2)`                  | 置换 `c` 和 `c2` 的数据                                      |
| `swap(c1, c2)`                | 置换 `c1` 和 `c2` 的数据                                      |
| `c.push_back(elem)`           | 附加一个 `elem` 的拷贝于末尾                                 |
| `c.pop_back()`                | 移除最后一个元素，但是不返回它                               |
| `c.push_front(elem)`          | 在头部插入 `elem` 的一个拷贝                                 |
| `c.pop_front()`               | 移除第一元素（但不返回）                                     |
| `c.insert(pos, elem)`         | 在 iterator 位置 `pos` 之前方插入一个 `elem` 拷贝，并返回新元素的位置 |
| `c.insert(pos, n, elem)`      | 在 iterator 位置 `pos` 之前方插入 `n` 个 `elem` 拷贝，并返回第一个新元素的位置（或返回 `pos`——如果没有新元素的话） |
| `c.insert(pos, beg, end)`     | 在 iterator 位置 `pos` 之前方插入区间 `[beg, end)` 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 `pos`——如果没有新元素的话） |
| `c.insert(pos, initlist)`     | 在 iterator 位置 `pos` 之前方插入初值列 `initlist` 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 `pos`——如果没有新元素的话；始自 C++11） |
| `c.emplace(pos, args...)`     | 在 iterator 位置 `pos` 之前方插入一个以 `args` 为初值的元素，并返回新元素的位置（始自 C++11） |
| `c.emplace_back(args...)`     | 附加一个以 `args` 为初值的元素于末尾，不返回任何东西（始自 C++11） |
| `c.emplace_front(args...)`    | 插入一个以 `args` 为初值的元素于起点，不返回任何东西（始自 C++11） |
| `c.erase(pos)`                | 移除 iterator 位置 `pos` 上的元素，返回下一元素的位置         |
| `c.erase(beg, end)`           | 移除 `[beg, end)` 区间内的所有元素，返回下一元素的位置         |
| `c.resize(num)`               | 将元素数量改为 `num`（如果 `size()` 变大，多出来的新元素都需以 default 构造函数完成初始化） |
| `c.resize(num, elem)`         | 将元素数量改为 `num`（如果 `size()` 变大，多出来的新元素都是 `elem` 的拷贝） |
| `c.clear()`                   | 移除所有元素，将容器清空                                     |


### 异常处理
原则上deque提供的异常处理和vector提供的一样。新增的操作函数push_front()和pop_front()分别对应于push_back()和pop_back()。
因此，C++标准库保证下列行为：
- 如果以push_back()或push_front()安插元素时发生异常，则该操作不带来任何效应。
- pop_back()和pop_front()不会抛出任何异常。


### Deque运用实例
```cc
// cont/deque1.cpp
#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <iterator>
using namespace std;

int main()
{
    // create empty deque of strings
    deque<string> coll;

    // insert several elements
    coll.assign(3, string("string"));  // string string string
    coll.push_back("last string");     // string string string "last string"
    coll.push_front("first string");   // "first string" string string string "last string"

    // print elements separated by newlines
    copy(coll.cbegin(), coll.cend(),
         ostream_iterator<string>(cout, "\n"));
    cout << endl;

    // remove first and last element
    coll.pop_front();   // string string string "last string"
    coll.pop_back();    // string string string 

    // insert ''another'' into every element but the first
    for (unsigned i = 1; i < coll.size(); ++i) {
        coll[i] = "another " + coll[i];   // string "another string" "another string" 
    }

    // change size to four elements
    coll.resize(4, "resized string");     // string "another string" "another string"  "resize string"

    // print elements separated by newlines
    copy(coll.cbegin(), coll.cend(),
         ostream_iterator<string>(cout, "\n"));
}
```

输出
```bash
first string
string
string
string
last string
string
another string
another string
resized string
```
## List
List（我说的是容器类list<>的一个实例）使用一个doubly linked list（双向串列）管理元素。按惯例，C++标准库并未明定实现方式，只是遵守list的名称、限制和规格。

             List                               
                ┌───┐   ┌───┐   ┌───┐   ┌───┐   
        ◄─── ──►│   │──►│   │──►│   │──►│   ├──► ───►
             ◄──└───┘◄──└───┘◄──└───┘◄──└───┘◄──

其中的list类型系定义于namespace std中，是个class template：
```cc
namespace {
    template <typename T, typename Allocator = allocator<T>>
    class list;
} 
```
List的元素可以是任何类型T。第二个template实参可有可无，用来指定内存模型。默认的内存模型是C++标准库提供的allocator。

### List的能力
List的内部结构完全迥异于array、vector或deque。
List对象自身提供了两个pointer，或称anchor（锚点），用来指向第一个和最末一个元素。
每个元素都有pointer指向前一个和下一个元素（或是指回anchor）。
如果想要安插新元素，只需操纵对应的pointer即可:

              ┌──────────┐                                              ┌──────────┐           
              │          │                                              │          │           
     ┌──────► └─┬──────┬─┘ ◄───────┐                           ┌──────► └─┬──────┬─┘ ◄───────┐ 
     │ ┌────────┘      └──────────┐│          List append      │ ┌────────┘      └──────────┐│ 
     │ │                          ││         ────────────►     │ │                          ││ 
     │ │ ┌───┐             ┌───┐  ││                           │ │ ┌───┐    ┌───┐    ┌───┐  ││ 
     │ └►│ 1 ├────────────►│ 2 │◄─┘│                           │ └►│ 1 ├───►│ 2 ├───►│ 3 │◄─┘│ 
     └───│   │◄────────────│   │───┘                           └───│   │◄───│   │◄───│   │───┘ 
         └───┘             └───┘                                   └───┘    └───┘    └───┘
                                                                                               
因此，list在几个主要方面与array、vector或deque不同：
- List不支持随机访问。如果你要访问第5个元素，就得顺着串链逐一爬过前4个元素。所以，在list中随机巡访任意元素是很缓慢的行为。
  - 然而你可以从两端开始航行整个list，所以访问第一个或最末一个元素的速度很快。
- 任何位置上（不只两端）执行元素的安插和移除都非常快，始终都是常量时间内完成，因为无须移动任何其他元素。实际上内部只是进行了一些pointer操作而已。
- 安插和删除动作并不会造成指向其他元素的各个pointer、reference和iterator失效。
- List对于异常的处理方式是：要么操作成功，要么什么都不发生。你绝不会陷入“只成功一半”这种进退维谷的尴尬境地。

List所提供的成员函数反映出它和array、vector以及deque的不同：
- List提供front()、push_front()和pop_front()、back()、push_back()和pop_back()等操作函数。
- 由于不支持随机访问，list既不提供subscript（下标）操作符，也不提供at()。
- List并未提供容量、空间重新分配等操作函数，因为全无必要。每个元素有自己的内存，在元素被删除前一直有效。
- List提供不少特殊成员函数，专门用于移动和移除元素。
  - 较之同名的STL通用算法，这些函数执行起来更快速，因为它们无须复制或搬移元素，只需调整若干pointer即可。


### List的操作
- 创建、复制和销毁（Create，Copy，and Destroy）
  - List的创建、复制和销毁动作，与每一个序列式（sequence）容器都相同。

- 非更易型操作（Nonmodifying Operation）
  - List也提供诸如“询问大小”和“两相比较”等一般性操作。

- 赋值（Assignment）
  - 和其他序列式（sequence）容器一样，list提供了一般常用的赋值动作。一如往常，安插函数和构造函数一一匹配，如此一来就有能力提供不同的初值来源（initialization source）


 List的构造函数和析构函数
| 操作 | 效果 |
| ---- | ---- |
| `list<Elem> c` | Default 构造函数，产生一个空 list，没有任何元素 |
| `list<Elem> c(c2)` | Copy 构造函数，建立 `c2` 的同型 list 并成为 `c2` 的一份拷贝（所有元素都被复制） |
| `list<Elem> c = c2` | Copy 构造函数，建立一个新的 list 作为 `c2` 的拷贝（每个元素都被复制） |
| `list<Elem> c(rv)` | Move 构造函数，建立一个新的 list，取 rvalue `rv` 的内容（始自 C++11） |
| `list<Elem> c = rv` | Move 构造函数，建立一个新的 list，取 rvalue `rv` 的内容（始自 C++11） |
| `list<Elem> c(n)` | 利用元素的 default 构造函数生成一个大小为 `n` 的 list |
| `list<Elem> c(n, elem)` | 建立一个大小为 `n` 的 list，每个元素值都是 `elem` |
| `list<Elem> c(beg, end)` | 建立一个 list，以区间 `[beg, end)` 作为元素初值 |
| `list<Elem> c(initlist)` | 建立一个 list，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `list<Elem> c = initlist` | 建立一个 list，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `c.~list()` | 销毁所有元素，释放内存 |

List的非更易型操作（Nonmodifying Operation）
| 操作 | 效果 |
| ---- | ---- |
| `c.empty()` | 返回是否容器为空（相当于 `size()==0` 但也许较快） |
| `c.size()` | 返回目前的元素个数 |
| `c.max_size()` | 返回元素个数之最大可能量 |
| `c1 == c2` | 返回 `c1` 是否等于 `c2`（对每个元素调用 `==`） |
| `c1 != c2` | 返回 `c1` 是否不等于 `c2`（相当于 `!(c1==c2)`） |
| `c1 < c2` | 返回 `c1` 是否小于 `c2` |
| `c1 > c2` | 返回 `c1` 是否大于 `c2`（相当于 `c2<c1`） |
| `c1 <= c2` | 返回 `c1` 是否小于等于 `c2`（相当于 `!(c2<c1)`） |
| `c1 >= c2` | 返回 `c1` 是否大于等于 `c2`（相当于 `!(c1<c2)`） |


#### 元素访问（Element Access）
欲访问list的所有元素，你必须使用range-based for循环、特定操作函数或迭代器。
List不支持随机访问，只有front（）和back（）能够直接访问元素

List的赋值（Assignment）操作
| 操作                     | 效果                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `c = c2`                 | 将 `c2` 的全部元素赋值给 `c`                                 |
| `c = rv`                 | 将 rvalue `rv` 的所有元素以 move assign 方式给予 `c`（始自 C++11） |
| `c = initlist`           | 将初值列 `initlist` 的所有元素赋值给 `c`（始自 C++11）       |
| `c.assign(n, elem)`      | 复制 `n` 个 `elem`，赋值给 `c`                               |
| `c.assign(beg, end)`     | 将区间 `[beg, end)` 内的元素赋值给 `c`                       |
| `c.assign(initlist)`     | 将初值列 `initlist` 的所有元素赋值给 `c`                     |
| `c1.swap(c2)`            | 置换 `c1` 和 `c2` 的数据                                      |
| `swap(c1, c2)`           | 置换 `c1` 和 `c2` 的数据                                      |

List元素的直接访问
| 操作          | 效果                                               |
| ------------- | -------------------------------------------------- |
| `c.front()`   | 返回第一元素（不检查是否存在第一元素）             |
| `c.back()`    | 返回最末元素（不检查是否存在最末元素）             |

一如既往，这些操作并不检查容器是否为空。对空容器执行任何操作都会导致不明确的行为。所以调用者必须确保容器至少含有一个元素。例如：
```cc
list<int> coll;
cout << coll.front(); // err

if (!coll.empty()) {
    cout << coll.front(); // ok
}
```
#### 迭代器相关函数（Iterator Function）

只有运用迭代器，才能够访问list中的各个元素。
然而由于list不能随机访问，这些迭代器只是双向（而非随机）迭代器。
所以凡是用到随机访问迭代器的算法（所有用来操作元素顺序的算法——特别是排序算法——都归此类）你都不能调用它们来处理list.
不过你可以拿list的特殊成员函数sort()取而代之.


| 操作         | 效果                                                         |
| ------------ | ------------------------------------------------------------ |
| `c.begin()`  | 返回一个 bidirectional iterator 指向第一元素                 |
| `c.end()`    | 返回一个 bidirectional iterator 指向最末元素的下一位置       |
| `c.cbegin()` | 返回一个 const bidirectional iterator 指向第一元素（始自 C++11） |
| `c.cend()`   | 返回一个 const bidirectional iterator 指向最末元素的下一位置（始自 C++11） |
| `c.rbegin()` | 返回一个反向的（reverse）iterator 指向反向迭代的第一元素     |
| `c.rend()`   | 返回一个反向的（reverse）iterator 指向反向迭代的最末元素的下一位置 |
| `c.crbegin()` | 返回一个 const reverse iterator 指向反向迭代的第一元素（始自 C++11） |
| `c.crend()`   | 返回一个 const reverse iterator 指向反向迭代的最末元素的下一位置（始自 C++11） |

#### 元素的安插和移除（Inserting and Removing）

| 操作                          | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `c.push_back(elem)`           | 附加一个 `elem` 的拷贝于末尾                                 |
| `c.pop_back()`                | 移除最后一个元素，但是不返回它                               |
| `c.push_front(elem)`          | 在头部插入 `elem` 的一个拷贝                                 |
| `c.pop_front()`               | 移除第一元素（但不返回）                                     |
| `c.insert(pos, elem)`         | 在 iterator 位置 `pos` 之前方插入一个 `elem` 拷贝，并返回新元素的位置 |
| `c.insert(pos, n, elem)`      | 在 iterator 位置 `pos` 之前方插入 `n` 个 `elem` 拷贝，并返回第一个新元素的位置（或返回 `pos`——如果没有新元素的话） |
| `c.insert(pos, beg, end)`     | 在 iterator 位置 `pos` 之前方插入区间 `[beg, end)` 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 `pos`——如果没有新元素的话） |
| `c.insert(pos, initlist)`     | 在 iterator 位置 `pos` 之前方插入初值列 `initlist` 内所有元素的一份拷贝，并返回第一个新元素的位置（或返回 `pos`——如果没有新元素的话；始自 C++11） |
| `c.emplace(pos, args...)`     | 在 iterator 位置 `pos` 之前方插入一个以 `args` 为初值的元素，并返回新元素的位置（始自 C++11） |
| `c.emplace_back(args...)`     | 附加一个以 `args` 为初值的元素于末尾，不返回任何东西（始自 C++11） |
| `c.emplace_front(args...)`    | 插入一个以 `args` 为初值的元素于起点，不返回任何东西（始自 C++11） |
| `c.erase(pos)`                | 移除 iterator 位置 `pos` 上的元素，返回下一元素的位置         |
| `c.erase(beg, end)`           | 移除 `[beg, end)` 区间内的所有元素，返回下一元素的位置         |
| `c.remove(val)`               | 移除所有其值为 `val` 的元素                                   |
| `c.remove_if(op)`             | 移除所有“`op(elem)` 结果为 `true`”的元素                     |
| `c.resize(num)`               | 将元素数量改为 `num`（如果 `size()` 变大，多出来的新元素都需以 default 构造函数完成初始化） |
| `c.resize(num, elem)`         | 将元素数量改为 `num`（如果 `size()` 变大，多出来的新元素都是 `elem` 的拷贝） |
| `c.clear()`                   | 移除所有元素，将容器清空                                     |

List提供deque的所有功能，还增加了适用于list的remove()和remove_if()算法特殊版本。

依STL惯例，你必须保证传入的实参合法：
- 迭代器必须指向一个合法位置，
- 区间的起始位置不能在结束位置之后。

处理多个元素的安插和移除时，对区间内的所有元素使用单一调用，会比多次调用更快速。

为了移除元素，list特别配备了remove()算法的特别版本。这些成员函数比remove（）算法的速度更快，因为它们只进行内部pointer操作，不改变元素。
所以，面对list，你应该调用成员函数remove()而不是像面对vector和deque那样调用STL算法。
如果想移除所有“带有某值”的元素，可以这么做:
```cc
list<int> coll;
...
// 删除所有值为val的元素
coll.remove(val);
```

然而，如果只是要移除第一个“带有某值”的元素，你必须使用讨论vector时提到的算法。

你可以使用remove_if()以求定义出元素的移除准则（removing criterion），做法是为该算法提供一个函数或函数对象。
remove_if()会将“造成该函数或函数对象返回true”的每一个元素移除。
下面便是一个例子，以单一语句移除“其值为偶数”的所有元素：
```cc
coll.remove_if([](int i) {
        return i % 2 == 0;
    });
```
这里用上了一个lambda找出应该被移除的元素。由于这个lambda返回的是“传入的元素是否为偶数”，所以整个语句会移除所有偶数元素。

以下操作函数不会造成“指向成员”的iterator和reference失效：insert()、emplace()、emplace...()、push_front()、push_back()、pop_front()、pop_back()及erase()。

#### Splice （接合）函数以及会改变元素次序的函数

Linked list的一大好处就是不论在任何位置，元素的安插和移除都只需要常量时间。
如果你有必要将若干元素从A容器转放到B容器，那么上述好处就更见其效了，因为你只需要重新定向某些指针即可:

            ┌───┐   ┌───┐   ┌───┐   ┌───┐                               ┌───┐   ┌───┐   ┌───┐   ┌───┐     
         ──►│   │──►│   │──►│   │──►│   ├──►                         ──►│   │──►│   │   │   │──►│   ├──►  
         ◄──└───┘◄──└───┘◄──└───┘◄──└───┘◄──                         ◄──└───┘◄──└┬──┘   └┬──┘◄──└───┘◄──  
                                                                                 ▼ ▲     ▼ ▲              
            ┌───┐   ┌───┐   ┌───┐   ┌───┐                               ┌───┐   ┌──┴┐   ┌──┴┐   ┌───┐     
         ──►│   │──►│   │──►│   │──►│   ├──►                         ──►│   │   │   │──►│   │   │   ├──►  
         ◄──└───┘◄──└───┘◄──└───┘◄──└───┘◄──                         ◄──└──┬┘   └───┘◄──└───┘   └──┬┘◄──  
                                                                         ▲ │                     ▲ │      
                                                                         │ └─────────────────────┘ │      
                                                                         └─────────────────────────┘

为了利用这个优势，list不仅提供remove()，还提供其他若干成员函数，用来改变元素和区间次序，或重新链接（relink）。
我们不仅可以调用这些函数移动单一list内的元素，也可以移动两个list之间的元素——只要list的类型一致即可。


### 异常处理（Exception Handling）
所有STL标准容器中，list对于异常安全性（exception safety）提供了最佳支持。
几乎所有操作都是不成功便成仁：要么成功，要么无效。
唯一不提供如此保证的是赋值运算和成员函数sort()，不过它们也有基本保证：异常发生时不会泄漏资源，也不会与容器恒常特性（invariant）发生冲突。
merge()、remove()、remove_if()和unique()提供的保证是有前提的，那就是元素间的比较动作（采用operator==或判断式〔predicate〕）不抛出异常。
用数据库术语来说，只要你不调用赋值操作或sort()，并保证元素相互比较时不抛出异常，那么list便可说是事务安全（transaction safe）。
表7.26列出了异常状况下提供特殊保证的所有操作函数。STL异常处理的一般性讨论，参见第248页6.12.2节。

List的特殊更易型操作
| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `c.unique()`                     | 如果存在若干相邻而数值相同的元素，就移除重复元素，只留一个   |
| `c.unique(op)`                   | 如果存在若干相邻元素都使 `op()` 的结果为`true`，则移除重复元素，只留一个 |
| `c.splice(pos, c2)`              | 将`c2`内的所有元素转移（move）到`c`之内、迭代器`pos`之前（`c`和`c2`可相同） |
| `c.splice(pos, c2, c2pos)`       | 将`c2`内的`c2pos`所指元素转移到`c`内的`pos`所指位置（`c`和`c2`可相同） |
| `c.splice(pos, c2, c2beg, c2end)` | 将`c2`内的`[c2beg, c2end)`区间内所有元素转移到`c`内的`pos`之前（`c`和`c2`可相同） |
| `c.sort()`                       | 以`operator<`为准则对所有元素排序                            |
| `c.sort(op)`                     | 以`op()`为准则对所有元素排序                                 |
| `c.merge(c2)`                    | 假设`c`和`c2`容器都包含`op()`准则下的已排序（sorted）元素，将`c2`的全部元素转移到`c`，并保证合并后的 list 仍为已排序 |
| `c.merge(c2, op)`                | 假设`c`和`c2`容器都包含已排序（sorted）元素，将`c2`的全部元素转移到`c`，并保证合并后的 list 在`op()`准则下仍为已排序 |
| `c.reverse()`                    | 将所有元素反序（reverse the order）                          |

List的各种操作在异常发生时提供的特殊保证
| 操作           | 保证                                                         |
| -------------- | ------------------------------------------------------------ |
| `push_back()`  | 要么成功，要么无任何作用（no effect）                        |
| `push_front()` | 要么成功，要么无任何作用（no effect）                        |
| `insert()`     | 要么成功，要么无任何作用（no effect）                        |
| `pop_back()`   | 不抛出异常                                                   |
| `pop_front()`  | 不抛出异常                                                   |
| `erase()`      | 不抛出异常                                                   |
| `clear()`      | 不抛出异常                                                   |
| `resize()`     | 要么成功，要么无任何作用（no effect）                        |
| `remove()`     | 只要元素比较动作不抛出异常，它就不抛出异常                   |
| `remove_if()`  | 只要判断式（predicate）不抛出异常，它就不抛出异常            |
| `unique()`     | 只要元素比较动作不抛出异常，它就不抛出异常                   |
| `splice()`     | 不抛出异常                                                   |
| `merge()`      | 只要元素比较时不抛出异常，它便保证“要么成功，要么无任何作用” |
| `reverse()`    | 不抛出异常                                                   |
| `swap()`       | 不抛出异常                                                   |


###  List运用实例

```cc
// cont/list1.cpp
#include <list>
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;

void printLists (const list<int>& l1, const list<int>& l2)
{
    cout << "list1: ";
    copy (l1.cbegin(), l1.cend(), ostream_iterator<int>(cout," "));
    cout << endl << "list2: ";
    copy (l2.cbegin(), l2.cend(), ostream_iterator<int>(cout," "));
    cout << endl << endl;
}

int main()
{
    // create two empty lists
    list<int> list1, list2;

    // fill both lists with elements
    for (int i=0; i<6; ++i) {
        list1.push_back(i);
        list2.push_front(i);
    }
    printLists(list1, list2);

    // insert all elements of list1 before the first element with value 3 of list2
    // - find() returns an iterator to the first element with value 3
    list2.splice(find(list2.begin(),list2.end(),    // destination position
                      3),
                  list1);                            // source list
    printLists(list1, list2);

    // move first element of list2 to the end
    list2.splice(list2.end(),                        // destination position
                 list2,                              // source list
                 list2.begin());                     // source position
    printLists(list1, list2);

    // sort second list, assign to list1 and remove duplicates
    list2.sort();
    list1 = list2;
    list2.unique();
    printLists(list1, list2);

    // merge both sorted lists into the first list
    list1.merge(list2);
    printLists(list1, list2);
}
```

运行结果
```bash
list1: 0 1 2 3 4 5 
list2: 5 4 3 2 1 0 
list1: 
list2: 5 4 0 1 2 3 4 5 3 2 1 0 
list1: 
list2: 4 0 1 2 3 4 5 3 2 1 0 5 
list1: 0 0 1 1 2 2 3 3 4 4 5 5 
list2: 0 1 2 3 4 5 
list1: 0 0 0 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 
list2: 
```

## Forward List
Forward list（class forward_list<>的一个实例）始于C++11，其内部以一个singly linked list管理元素。
一如往常，C++标准库并未明确指定实现方法，只要求它必须完全奉行forward list的名称、条件和规格。

          Forward list                       
        ┌┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   
        │├──►│   │──►│   │──►│   │──►│   ├──►NULL
        └┘   └───┘   └───┘   └───┘   └───┘   


```cc
namespace {
    template <typename T, typename Allocator = allocator<T>>
    class forward_list;
} 
```
它的元素类型可以是任意指定的T。可有可无的第二个template参数定义出内存模型。
默认的内存模型（memory model）是allocator，由C++标准库提供。

### Forward List的能力
观念上，forward list是一个行为受限的list（list的类型是class list<>），不能走回头路。凡是list没提供的功能，它也都不提供。
它的优点是内存用量较少，行动也略快速。
C++standard这样描述它:
我们希望forward_list和你自己手写的C-style singly linked list相较之下没有任何空间或时间上的额外开销。任何性质如果与这个目标相抵触，我们就放弃该性质。

相较于list，forward list有以下约束：
- Forward list只提供前向迭代器（forward iterator），而不是双向迭代器。因此它也不支持反向（reverse）迭代器，这意味着诸如reverse_iterator之类的类型以及诸如rbegin()、rend()、crbegin()和crend()之类的成员函数都不提供。
- Forward list不提供成员函数size()。这是“与手写的singly linked list相较下凡会造成空间或时间额外开销的性质都略去”的必然结果。
- Forward list没有指向最末元素的锚点（anchor）。基于这个原因，forward list不提供“用以处理最末元素”的成员函数如back()、push_back()和pop_back()。
- 对于所有“令元素被安插或删除于forward list的某特定位置上”的成员函数，forward list提供特殊版本。原因是你必须传递第一个被处理元素的前一位置，因为你必须在那里指定一个新的后继元素；然而由于forward list不允许回头（至少常量时间内不行），因此对于这些成员函数，你必须传递前一元素的位置。基于这一差异，这些成员函数的名称都带有一个后缀_after。例如insert_after()取代insert()，将新元素安插于第一实参所表示的元素之后；也就是说，它在那个位置上附加（append）一个元素。
- 基于同样原因，forward list提供before_begin()和cbefore_begin()，它们会产出第一元素之前的一个虚拟元素的位置（技术上说就是linked list的锚点〔anchor〕），可被用来让“名称带有后缀_after”的算法交换第一元素。

“不提供size()”这个决定可能会使你特别惊讶，因为size()是所有STL容器都应该提供的操作函数。
这其实是“与手写的singly linked list相较绝不造成空间或时间上的额外开销”这一设计目标的必然结果。
每次size()被调用，要么就计算大小（线性复杂度），要么就由forward_list对象提供一个额外数据栏（field）记录大小，并令它在每一个“会改变元素个数”的操作函数中被更新。
正如forward list的设计报告所言：“这么做会造成所有用户都必须支付的一项成本，不论他们是不是需要这个特性。”
因此，如果你需要知道大小，要么就在forward_list提供的能力之外自行追踪它，要么就改用list。

除了这些差异，forward list的行为就像个list：
- Forward list不提供随机访问。若要访问第5个元素，你必须循着link所形成的串链“航行”前4个元素。因此在一个forward list中访问某任意元素，速度相当慢。
- 在任何位置上安插和移除元素，速度都很快（前提是你指出了那个位置）。总是可以在常量时间内安插和删除某个元素，因为没有其他任何元素需要搬移，只有若干内部pointer会被涂改。
- 安插和移除元素不会造成“指向至其他元素”的pointer、reference和iterator失效。
- Forward list对待异常的态度是，几乎每一个操作要么成功，要么就不起作用（no-op）。因此，你不可能进入操作的中间状态（intermediate state）——也就是只成功一半的状态。
- Forward list提供许多特殊成员函数用于搬移和移除元素。这些成员函数是一般算法的快速版本，因为它们只是重定位（redirect） pointer，并不复制和搬移数值。然而只要涉及元素位置，你必须传给它们目标物的前一位置，而且使用名称带有后缀_after的成员函数。

### Forward List的操作
#### 创建、复制、销毁（Create，Copy，and Destroy）

Forward list 的创建、复制和销毁能力，与任何序列式（sequence）容器所提供的一样。

Forward List的构造函数和析构函数
| 操作                             | 效果                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `forward_list<Elem> c`           | Default 构造函数，产生一个空 forward list，没有任何元素      |
| `forward_list<Elem> c(c2)`       | Copy 构造函数，建立 `c2` 的同型 forward list 并成为 `c2` 的一份拷贝（所有元素都被复制） |
| `forward_list<Elem> c = c2`      | Copy 构造函数，建立一个新的 forward list 作为 `c2` 的拷贝（每个元素都被复制） |
| `forward_list<Elem> c(rv)`       | Move 构造函数，建立一个新的 forward list，取 rvalue `rv` 的内容（始自 C++11） |
| `forward_list<Elem> c = rv`      | Move 构造函数，建立一个新的 forward list，取 rvalue `rv` 的内容（始自 C++11） |
| `forward_list<Elem> c(n)`        | 利用元素的 default 构造函数生成一个大小为 `n` 的 forward list |
| `forward_list<Elem> c(n, elem)`  | 建立一个大小为 `n` 的 forward list，每个元素值都是 `elem`    |
| `forward_list<Elem> c(beg, end)` | 建立一个 forward list，以区间 `[beg, end)` 作为元素初值      |
| `forward_list<Elem> c(initlist)` | 建立一个 forward list，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `forward_list<Elem> c = initlist` | 建立一个 forward list，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `c.~forward_list()`              | 销毁所有元素，释放内存                                       |

#### 非更易型操作（Nonmodifying Operation）
Forward list提供常见的大小操作和比较操作，唯一例外是：forward list不提供size()。原因是它不存储元素的目前数量，亦无法在常量时间内算出它。此外也为了凸显size()是个费时的操作，所以不提供它。
如果你必须计算元素个数，可使用distance():

```cc
forward_list<int> coll;
cout << "coll.size() : " << std::distance(coll.begin(), coll.end()) << endl;
```

但是请注意，distance()具备的是线性复杂度。


Forward List的非更易型操作
| 操作           | 效果                                                         |
| -------------- | ------------------------------------------------------------ |
| `c.empty()`    | 判断容器是否为空                                             |
| `c.max_size()` | 返回元素的最大可能数量                                       |
| `c1 == c2`     | 返回 `c1` 是否等于 `c2`（对每个元素调用 `==`）                |
| `c1 != c2`     | 返回 `c1` 是否不等于 `c2`（相当于 `!(c1==c2)`）               |
| `c1 < c2`      | 返回 `c1` 是否小于 `c2`                                       |
| `c1 > c2`      | 返回 `c1` 是否大于 `c2`（相当于 `c2<c1`）                     |
| `c1 <= c2`     | 返回 `c1` 是否小于等于 `c2`（相当于 `!(c2<c1)`）              |
| `c1 >= c2`     | 返回 `c1` 是否大于等于 `c2`（相当于 `!(c1<c2)`）              |


#### 赋值（Assignment）
Forward list也提供序列式（sequence）容器通常都会有的赋值操作。
一如先前惯例，有一组用来安插元素的操作呼应了构造函数，提供不同的初值来源.

Forward List的赋值操作
| 操作                     | 效果                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `c = c2`                 | 将 `c2` 的全部元素赋值给 `c`                                 |
| `c = rv`                 | 将 rvalue `rv` 的所有元素以 move assign 方式给予 `c`（始自 C++11） |
| `c = initlist`           | 将初值列 `initlist` 的所有元素赋值给 `c`（始自 C++11）       |
| `c.assign(n, elem)`      | 复制 `n` 个 `elem`，赋值给 `c`                               |
| `c.assign(beg, end)`     | 将区间 `[beg, end)` 内的元素赋值给 `c`                       |
| `c.assign(initlist)`     | 将初值列 `initlist` 的所有元素赋值给 `c`                     |
| `c1.swap(c2)`            | 置换 `c1` 和 `c2` 的数据                                      |
| `swap(c1, c2)`           | 置换 `c1` 和 `c2` 的数据                                      |


#### 元素访问（Element Access）
欲访问forward list的所有元素，你必须使用range-based for循环、特定的操作函数或迭代器。
和list相比，你唯一能够直接访问的元素是第一元素（如果有的话）。
因此，只有front()被提供用来直接访问元素.

Forward List的“元素直接访问操作”
| 操作        | 效果                                   |
| ----------- | -------------------------------------- |
| `c.front()` | 返回第一元素（并不检查是否存在第一元素） |


一如既往，这些操作并不检查容器是否为空。如果容器真是空，front()会导致不明确的行为。
此外，在多线程环境中你需要同步机制（synchronization mechanism）用以确保“检查大小”和“访问元素”之间coll未曾被改动.

#### 迭代器相关函数（Iterator Function）

欲访问forward list的所有元素，你可以使用迭代器。然而，由于你只能以前行方向（forward order）遍历元素，所以这些迭代器是forward迭代器，不支持reverse迭代器.

因此，你无法调用那种需要用到双向（bidirectional）或随机（random-access）迭代器的算法——而所有“会大量改变元素次序”的算法，特别是sorting算法，都属此类。
因此，forward list为排序提供了特殊成员函数sort().

此外还提供了before_begin()和cbefore_begin()，产出更先于“第一元素”的一个虚拟元素位置。这是为了能够改动第一元素。

Forward List的迭代器操作函数
| 操作                | 效果                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c.begin()`         | 返回一个 bidirectional iterator 指向第一元素                 |
| `c.end()`           | 返回一个 bidirectional iterator 指向最末元素的下一位置       |
| `c.cbegin()`        | 返回一个 const bidirectional iterator 指向第一元素（始自 C++11） |
| `c.cend()`          | 返回一个 const bidirectional iterator 指向最末元素的下一位置（始自 C++11） |
| `c.before_begin()`  | 返回一个 forward iterator 指向第一元素的前一位置             |
| `c.cbefore_begin()` | 返回一个 const forward iterator 指向第一元素的前一位置       |

注意before_begin()和cbefore_begin()并不代表forward list的一个合法位置；
提领（dereferencing）这些位置会导致不明确行为。也就是说，以before_begin()为任何STL算法的第一实参都会导致运行期差错：

```cc
copy(fwlist.before_begin(), fwlist.end(), ...); // error
```
除了复制和赋值动作，对before_begin()返回值的合法操作只有++ ==和!=。

#### 元素的安插和移除元素（Inserting and Removing）

Forward List的安插和移除（Insert and Remove）操作函数
| 操作                          | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `c.push_front(elem)`          | 在头部插入 `elem` 的一个拷贝                                 |
| `c.pop_front()`               | 移除第一元素（但不返回）                                     |
| `c.insert_after(pos, elem)`   | 安插一个 `elem` 拷贝于 iterator 位置 `pos` 之后，返回新元素位置 |
| `c.insert_after(pos, n, elem)` | 安插 `n` 个 `elem` 拷贝于 iterator 位置 `pos` 之后，并返回第一个新元素的位置（或返回 `pos`，如果没有新元素的话） |
| `c.insert_after(pos, beg, end)` | 将 `[beg, end)` 区间的所有元素复制一份，安插于 iterator 位置 `pos` 之后，并返回第一个新元素的位置（或返回 `pos`，如果没有新元素的话） |
| `c.insert_after(pos, initlist)` | 将初值列 `initlist` 的所有元素复制一份，安插于 iterator 位置 `pos` 之后，并返回第一个新元素的位置（或返回 `pos`，如果没有新元素的话） |
| `c.emplace_after(pos, args...)` | 在 iterator 位置 `pos` 之后方插入一个以 `args` 为初值的元素，并返回新元素的位置（始自 C++11） |
| `c.emplace_front(args...)`    | 插入一个以 `args` 为初值的元素于起点，不返回任何东西（始自 C++11） |
| `c.erase_after(pos)`          | 移除 iterator 位置 `pos` 之后的元素，不返回任何东西           |
| `c.erase_after(beg, end)`     | 移除 `[beg, end)` 区间内的所有元素，不返回任何东西             |
| `c.remove(val)`               | 移除所有其值为 `val` 的元素                                   |
| `c.remove_if(op)`             | 移除所有“造成 `op(elem)` 结果为 `true`”的元素                 |
| `c.resize(num)`               | 将元素数量改为 `num`（如果 `size()` 变大，多出来的新元素都需以 default 构造函数完成初始化） |
| `c.resize(num, elem)`         | 将元素数量改为 `num`（如果 `size()` 变大，多出来的新元素都是 `elem` 的拷贝） |
| `c.clear()`                   | 移除所有元素，将容器清空                                     |

由于list的性质较一般，而forward list的性质较特殊，所以我们必须详细讨论二者。

首先，常见的一般性提示是适用的：
- 依STL惯例，你必须保证传入的实参合法：
  - 迭代器必须指向一个合法位置，
  - 区间的起始位置不能在结束位置之后。
- 处理多个元素的安插和移除时，对区间内的所有元素使用单一调用，会比多次调用更快速。

因此，和list一样，forward list也提供remove()算法的特殊版本。这些成员函数比remove()算法还快速，因为它们只操控内部pointer，不改变元素。

注意，面对forward list提供的所有安插、安放、抹除（insert，emplace，and erase）成员函数，你会有个疑问：
它们需要获得一个元素位置，而你打算在该位置上安插新元素或删除旧元素。但这就必须改动前导元素，因为必须更改前导元素的“指向下一元素”的pointer。
如果面对list，你只要回头走往前一个元素去改变它就可以了，但对于forward list，你无法回头。
因此成员函数的行为就和list有所不同，这个不同也反映在成员函数的名称上。
所有以_after为名称后缀的成员函数，会将新元素安插（或删除）于“给定元素”之后。

当你使用这些成员函数，并结合before_begin()（它可确保涵盖第一元素），一个典型的forward list元素访问动作如下：
```cc
forward_list<int> coll = {1, 2, 3};
coll.insert_after(coll.before_begin(), {77, 88, 99});
```
注意，调用_after成员函数并传入end()或cend()会导致不明确行为，
因为如果要在forward list的尾端附加一个新元素，你必须传入终端元素的位置（如果没有终端元素的话就传入before_begin()）:
```cc
coll.insert_after(coll.end(), 9999); // error
```

    before_begin()
         │                                                  ┌───┐   ┌───┐   ┌───┐
         │     begin()                                    ┌►│77 │──►│88 │──►│99 │─┐
         │      │                                         │ └───┘   └───┘   └───┘ │
         │      │                                         │    ┌──────────────────┘
         ▼      ▼                                         │    ▼
        ┌┐   ┌───┐   ┌───┐   ┌───┐                     ┌┐ │ ┌───┐   ┌───┐   ┌───┐    
        │├──►│ 1 │──►│ 2 │──►│ 3 │──►                  │├─┘ │ 1 │──►│ 2 │──►│ 3 │──► 
        └┘   └───┘   └───┘   └───┘                     └┘   └───┘   └───┘   └───┘    


#### 查找、移除或安插（Find and Remove or Insert）
手上握着一个singly linked list，你就只能勇往向前。
它的最大缺点是：当你尝试找出某元素，准备在那儿安插或删除，“找到的当下”代表“你已经过头了”，因为，欲在该处安插或删除元素，你必须改写该处的前一元素。
因此你的查找准则应该是“下一元素满足条件”的当时元素。例如：

```cc
#include <forward_list>
#include "print.hpp"
using namespace std;

int main()
{
    forward_list<int> list = { 1, 2, 3, 4, 5, 97, 98, 99 };

    // find the position before the first even element
    auto posBefore = list.before_begin();
    for (auto pos = list.begin(); pos != list.end(); ++pos, ++posBefore) {
        if (*pos % 2 == 0) {
            break;  // element found
        }
    }

    // and insert a new element in front of the first even element
    list.insert_after(posBefore, 42);
    PRINT_ELEMENTS(list);
}
```
在这里，迭代器pos遍历list以求找到特定的某元素，而posBefore则总是指向pos的前一位置，以便能够返回“正查找的那个元素的前一位置”。
程序输出如下：
```bash
1 42 2 3 4 5 97 98 99
```
如果这是一个你经常需要的动作，你可以定义自己的算法，找出“拥有特定值”或“满足某特定条件”的元素的前一位置：
```cc
template <typename InputIterator, typename Tp>
inline InputIterator
find_before(InputIterator first, InputIterator last, const Tp& val)
{
    if (first == last) {
        return first;
    }
    InputIterator next(first);
    ++next;
    while (next != last && !(*next == val)) {
        ++next;
        ++first;
    }
    return first;
}

template <typename InputIterator, typename Pred>
inline InputIterator
find_before_if(InputIterator first, InputIterator last, Pred pred)
{
    if (first == last) {
        return first;
    }
    InputIterator next(first);
    ++next;
    while (next != last && !pred(*next)) {
        ++next;
        ++first;
    }
    return first;
}
```
有了这些算法，你可以给个lambda找出所需位置
```cc
// find the position before the first even element
auto posBefore = find_before_if (list.before_begin(), list.end(),
                                 [] (int i) {
                                     return i%2==0;
                                 });
// and insert a new element in front of it
list.insert_after(posBefore,42);
```

你必须调用find_before_if()并给它before_begin()的返回位置，否则第一元素会被忽视。
为避免传给它begin()导致不明确行为，这个算法首先检查区间的起点是否等于终点。
Forward list若提供了相应的成员函数，那是最好，可惜并没有，以至于我们得自己写一个。

#### 接合函数（Splice Function）以及会改变元素次序的函数
和list 一样，forward list 有个优点，就是你可以在常量时间内移除和安插元素于任何位置上。
如果你从某容器移动元素到另一容器，这个优点更是加倍，因为它只需要重定位（redirect）若干内部pointer即可。
基于这个原因，forward list提供与list几乎相同的成员函数来接合（splice）或改变元素次序。
你可以调用它们将元素搬进single list内，或在两个list之间搬移——前提是这些list有相同类型。
与list唯一不同的是，splice_after()取代了splice()，因为传进去的是“splice所作用的元素位置”的前一元素位置。

| 操作 | 效果 |
| ---- | ---- |
| `c.unique()` | 移除重复而相邻的元素，只留一个 |
| `c.unique(op)` | 移除相邻而且都令 `op()` 结果为 `true` 的元素，只留一个 |
| `c.splice_after(pos, c2)` | 将 `c2` 内的所有元素转移（move）到 `c` 之内、迭代器 `pos` 之右（后） |
| `c.splice_after(pos, c2, c2pos)` | 将 `c2` 内的 `c2pos` 所指元素转移到 `c` 内的 `pos` 所指位置（`c` 和 `c2` 可以是同一容器） |
| `c.splice_after(pos, c2, c2beg, c2end)` | 将 `c2` 内的 `(c2beg, c2end]` 区间内（不含头尾）所有元素转移到 `c` 内的 `pos` 之后（`c` 和 `c2` 可以是同一容器） |
| `c.sort()` | 以 `operator<` 为准则对所有元素排序 |
| `c.sort(op)` | 以 `op()` 为准则对所有元素排序 |
| `c.merge(c2)` | 假设 `c` 和 `c2` 容器都包含已排序（sorted）元素，将 `c2` 的全部元素转移（move）到 `c`，并保证合并后的所有元素仍为已排序（sorted） |
| `c.merge(c2, op)` | 假设 `c` 和 `c2` 容器都包含 `op()` 准则下的已排序（sorted）元素，将 `c2` 的全部元素转移（move）到 `c`，并保证合并后的所有元素在 `op()` 准则下仍为已排序（sorted） |
| `c.reverse()` | 将所有元素反序（reverse the order） |

以下程序示范如何对forward list使用接合函数（splice function）。例中的forward list l1内的第一个“数值为3”的元素被搬移到l2内的第一个“数值为99”的元素的前方
```cc
#include <forward_list>
#include "print.hpp"
using namespace std;

int main()
{
    forward_list<int> l1 = { 1, 2, 3, 4, 5 };
    forward_list<int> l2 = { 97, 98, 99 };

    // find 3 in l1
    auto pos1 = l1.before_begin();
    for (auto pb1 = l1.begin(); pb1 != l1.end(); ++pb1, ++pos1) {
        if (*pb1 == 3) {
            break; // found
        }
    }

    // find 99 in l2
    auto pos2 = l2.before_begin();
    for (auto pb2 = l2.begin(); pb2 != l2.end(); ++pb2, ++pos2) {
        if (*pb2 == 99) {
            break; // found
        }
    }

    // 将l1链的pos1后一个元素剪切到pos2后
    l1.splice_after(pos2,  // 目的
            l1, pos1);     // 源

    copy(l1.begin(), l1.end(), ostream_iterator<int>(cout, " "));
    cout << endl;

    copy(l2.begin(), l2.end(), ostream_iterator<int>(cout, " "));
    cout << endl;
}
```


        l1            pos1         
        │              │                                                            ┌───────────────┐           
        ▼              ▼                                                            │               ▼           
        ┌┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐                   ┌┐   ┌───┐   ┌─┴─┐   ┌───┐   ┌───┐   ┌───┐ 
        │├──►│ 1 │──►│ 2 │──►│ 3 │──►│ 4 ├──►│ 5 │                   │├──►│ 1 │──►│ 2 │ ┌►│ 3 │   │ 4 ├──►│ 5 │ 
        └┘   └───┘   └───┘   └───┘   └───┘   └───┘                   └┘   └───┘   └───┘ │ └─┬─┘   └───┘   └───┘ 
                                                                                        │   │                   
        l2            pos2                                                          ┌───┘   ▼                   
        │              │                                             ┌┐   ┌───┐   ┌─┴─┐   ┌───┐                 
        ▼              ▼                                             │├──►│97 │──►│98 │   │99 │                 
        ┌┐   ┌───┐   ┌───┐   ┌───┐                                   └┘   └───┘   └───┘   └───┘                 
        │├──►│97 │──►│98 │──►│99 │                                                                              
        └┘   └───┘   └───┘   └───┘   

 
#### 异常处理（Exception Handling）
Forward list对于异常处理的态度和保证，与list完全相同，前提是有对应的成员函数可用。

#### Forward List运用实例

```cc
#include <forward_list>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <string>
using namespace std;

{
    void printLists(const string& s, const forward_list<int>& l1, const forward_list<int>& l2)
    cout << s << endl;
    cout << " list1: ";
    copy(l1.cbegin(), l1.cend(), ostream_iterator<int>(cout, " "));
    cout << endl << " list2: ";
    copy(l2.cbegin(), l2.cend(), ostream_iterator<int>(cout, " "));
    cout << endl;
}

int main()
{
    // create two forward lists
    forward_list<int> list1 = { 1, 2, 3, 4 };
    forward_list<int> list2 = { 77, 88, 99 };
    printLists("initial:", list1, list2);

    // insert six new element at the beginning of list2
    list2.insert_after(list2.before_begin(), 99);
    list2.push_front(10);
    list2.insert_after(list2.before_begin(), { 10, 11, 12, 13 });
    printLists("6 new elems:", list1, list2);

    // insert all elements of list2 at the beginning of list1
    list1.insert_after(list1.before_begin(),
                       list2.begin(), list2.end());
    printLists("list2 into list1:", list1, list2);

    // delete second element and elements after element with value 99
    list2.erase_after(list2.begin());
    list2.erase_after(find(list2.begin(), list2.end(), 99),
                      list2.end());
    printLists("delete 2nd and after 99:", list1, list2);

    // sort list1, assign it to list2. and remove duplicates
    list1.sort();
    list2 = list1;
    list2.unique();
    printLists("sorted and unique:", list1, list2);

    // merge both sorted lists into list1
    list1.merge(list2);
    printLists("merged:", list1, list2);
}
```
 
程序输出
```bash
initial:
 list1: 1 2 3 4 
 list2: 77 88 99 
6 new elems:
 list1: 1 2 3 4 
 list2: 10 11 12 13 10 99 77 88 99 
list2 into list1:
 list1: 10 11 12 13 10 99 77 88 99 1 2 3 4 
 list2: 10 11 12 13 10 99 77 88 99 
delete 2nd and after 99:
 list1: 10 11 12 13 10 99 77 88 99 1 2 3 4 
 list2: 10 12 13 10 99 77 88 99 
sorted and unique:
 list1: 1 2 3 4 10 10 11 12 13 77 88 99 99 
 list2: 1 2 3 4 10 11 12 13 77 88 99 
merged:
 list1: 1 1 2 2 3 3 4 4 10 10 10 11 11 12 12 13 13 77 77 88 88 99 99 99 99 
 list2: 
```
 
## Set和Multiset
Set和multiset会根据特定的排序准则，自动将元素排序。
两者不同之处在于multiset允许元素重复而set不允许
 

        set                                         multiset                                   
       ┌────────────────────────────────────┐      ┌────────────────────────────────────┐ 
       │                                    │      │                                    │ 
       │   ┌──┐    ┌──┐    ┌──┐    ┌──┐     │      │   ┌──┐    ┌──┐    ┌──┐    ┌──┐     │ 
       │   │1 │    │2 │    │3 │    │4 │     │      │   │1 │    │1 │    │4 │    │4 │     │ 
       │   └──┘    └──┘    └──┘    └──┘     │      │   └──┘    └──┘    └──┘    └──┘     │ 
       │                                    │      │                                    │ 
       └────────────────────────────────────┘      └────────────────────────────────────┘ 
                                                                                          
在这个头文件中，上述两个类型都被定义为命名空间std内的class template：
```cc
namespace {
    template <typename T, typename Compare = less<T>, typename Allocator = allocator<T>>
    class set;
    template <typename T, typename Compare = less<T>, typename Allocator = allocator<T>>
    class multiset;
}
```

只要是可依据某排序准则被比较（所谓comparable）的任意类型T都可以成为set或multiset的元素类型。
可有可无的第二个template实参用来定义排序准则。如果没有传入某个排序准则，就采用默认准则less——这是个函数对象，以operator＜对元素进行比较。
可有可无的第三实参用来定义内存模型。默认的内存模型是allocator，由C++标准库提供。

所谓“排序准则”，必须定义strict weak ordering，其意义如下：
- 1.必须是非对称的（antisymmetric）。
  - 对operator＜而言，如果x ＜ y为true，则y ＜ x为false。
  - 对判断式（predicate） op（）而言，如果op（x，y）为true，则op（y，x）为false。
- 2.必须是可传递的（transitive）。
  - 对operator＜而言，如果x ＜ y为true且y ＜ z为true，则x ＜ z为true。
  - 对判断式op（）而言，如果op（x，y）为true且op（y，z）为true，则op（x，z）为true。
- 3.必须是非自反的（irreflexive）。
  - 对operator＜而言，x ＜ x永远为false。
  - 对判断式op（）而言，op（x，x）永远为false。
- 4.必须有等效传递性（transitivity of equivalence）。大体意义是：如果a等于b且b等于c，那么a必然等于c。
  - 这意味着对于操作符＜，若！（a＜b）&&！（b＜a）为true且！（b＜c）&&！（c＜b）为true，那么！（a＜c）&&！（c＜a）亦为true。
  - 这也意味着对于判断式op（），若op（a，b）、op（b，a）、op（b，c）和op（c，b）都为false，那么op（a，c）和op（c，a）为false。

注意，这意味着你必须区分less和equal。一个像operator<= 这样的准则并不满足这个条件。
根据这些性质，排序准则也被用来检查等效性（equivalence）。也就是说，两个元素如果没有任何一个小于另一个（或如果op（x，y）和op（y，x）都取得false），则它们被视为重复。

Multiset的等效元素的次序是随机但稳定的（random but stable）。因此C++11保证安插和抹除（erasure）动作都会保存等效元素的相对次序。

### Set和Multiset的能力
和所有标准的关联式容器类似，set 和 multiset 通常以平衡二叉树完成——C++standard并未明定，但由set和multiset各项操作的复杂度可以得出这个结论。

自动排序的主要优点在于令二叉树于查找元素时拥有良好效能。其查找函数具有对数复杂度。在拥有1 000个元素的set或multiset中查找元素，二叉树查找动作（由成员函数执行）的平均时间为线性查找（由STL算法执行）的 1/50.
但是，自动排序造成set和multiset的一个重要限制：你不能直接改变元素值，因为这样会打乱原本正确的顺序。


             Set和Multiset的内部结构
                     ┌─────┐               
                     │  4  │               
                     └──┬──┘               
                ┌───────┴───────┐          
                ▼               ▼          
            ┌─────┐           ┌─────┐      
            │  2  │           │  6  │      
            └──┬──┘           └──┬──┘      
          ┌────┴────┐         ┌──┴───┐     
          ▼         ▼         ▼      ▼     
      ┌─────┐    ┌─────┐  ┌─────┐  ┌─────┐ 
      │  1  │    │  3  │  │  5  │  │  7  │ 
      └─────┘    └─────┘  └─────┘  └─────┘ 


因此，要改变元素值，必须先删除旧元素，再插入新元素。以下接口反映了这种行为：
- Set和multiset不提供任何操作函数可以直接访问元素。
- 通过迭代器进行元素间接访问，有一个限制：从迭代器的角度看，元素值是常量。


### Set和Multiset的操作函数
#### 创建、复制和销毁（Create，Copy，and Destroy）


有两种方式可以定义排序准则：

1. 以template参数定义之。例如：
```cc
set<int, greater<int>> coll;
```
这种情况下排序准则就是类型的一部分。于是类型系统确保“只有排序准则相同的容器才能被合并”。这是排序准则的通常指定法。
更精确地说，第二参数是排序准则的类型，实际的排序准则是容器所产生的函数对象。
为了产生它，容器的构造函数会调用“排序准则类型”的default构造函数。

2. 以构造函数参数定义之。这种情况下，同一个类型可以运用不同的排序准则，而排序准则的初始值或状态也可以不同。
如果运行期才获得排序准则，而且需要用到不同的排序准则（但数据类型必须相同），这一方式可派上用场。

如果用户没有提供特定的排序准则，就采用默认准则——函数对象less<>。less<>通过operator<对元素进行排序。

请注意，排序准则也被用来检验元素相等性。采用默认排序准则时，两元素的相等性检验如下：
```cc
if (! (elem1 < elem2 || elem2 < elem1) )
```
这样做有三个好处：
- 1.只需传递一个实参作为排序准则。
- 2.不必针对元素类型提供`operator==`。
- 3.可以对“相等性”有截然相反的定义（即使表达式中operator==的行为有所不同，也无关紧要）。不过当心造成混淆。

| 操作 | 效果 |
| ---- | ---- |
| `set c` | Default 构造函数，建立一个空 `set/multiset`，不含任何元素 |
| `set c(op)` | 建立一个空 `set/multiset`，以 `op` 为排序准则 |
| `set c(c2)` | Copy 构造函数，为相同类型之另一个 `set/multiset` 建立一份拷贝，所有元素均被复制 |
| `set c = c2` | Copy 构造函数，为相同类型之另一个 `set/multiset` 建立一份拷贝，所有元素均被复制 |
| `set c(rv)` | Move 构造函数，建立一个新的 `set/multiset`，有相同类型，取 rvalue `rv` 的内容（始自 C++11） |
| `set c = rv` | Move 构造函数，建立一个新的 `set/multiset`，有相同类型，取 rvalue `rv` 的内容（始自 C++11） |
| `set c(beg,end)` | 以区间 `[beg,end)` 内的元素为初值，建立一个 `set/multiset` |
| `set c(beg,end,op)` | 以区间 `[beg,end)` 内的元素为初值，并以 `op` 为排序准则，建立一个 `set/multiset` |
| `set c(inilist)` | 建立一个 `set/multiset`，以初值列 `inilist` 的元素为初值（始自 C++11） |
| `set c = inilist` | 建立一个 `set/multiset`，以初值列 `inilist` 的元素为初值（始自 C++11） |
| `c.~set()` | 销毁所有元素，释放内存 |

其中 `set` 可为下列形式：
| set | 效果 |
| ---- | ---- |
| `set<Elem>` | 一个 `set`，以 `less<>`（`operator<`）为排序准则 |
| `set<Elem,Op>` | 一个 `set`，以 `Op` 为排序准则 |
| `multiset<Elem>` | 一个 `multiset`，以 `less<>`（`operator<`）为排序准则 |
| `multiset<Elem,Op>` | 一个 `multiset`，以 `Op` 为排序准则 |

#### 非更易型操作
Set和multiset提供常见的非更易型操作，用来查询大小、相互比较

| 操作             | 效果                                                         |
| ---------------- | ------------------------------------------------------------ |
| `c.key_comp()`   | 返回“比较准则”（comparison criterion）                       |
| `c.value_comp()` | 返回针对 value 的“比较准则”（和 `key_comp()` 相同）          |
| `c.empty()`      | 返回是否容器为空（相当于 `size()==0` 但也许较快）            |
| `c.size()`       | 返回目前的元素个数                                           |
| `c.max_size()`   | 返回元素个数之最大可能量                                     |
| `c1 == c2`       | 返回 `c1` 是否等于 `c2`（对每个元素调用 `==`）               |
| `c1 != c2`       | 返回 `c1` 是否不等于 `c2`（相当于 `!(c1==c2)`）              |
| `c1 < c2`        | 返回 `c1` 是否小于 `c2`                                       |
| `c1 > c2`        | 返回 `c1` 是否大于 `c2`（相当于 `c2<c1`）                    |
| `c1 <= c2`       | 返回 `c1` 是否小于等于 `c2`（相当于 `!(c2<c1)`）             |
| `c1 >= c2`       | 返回 `c1` 是否大于等于 `c2`（相当于 `!(c1<c2)`）             |

元素比较动作只适用于类型相同的容器。换言之，元素和排序准则必须有相同的类型，否则编译期会产生类型方面的错误。
```cc
set<int> c1;
set<int, greater<int>> c2;
...
if (c1 == c2) // error
```
#### 特殊的查找函数（Special Search Operation）

| 操作                | 效果                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c.count(val)`      | 返回“元素值为`val`”的元素个数                                |
| `c.find(val)`       | 返回“元素值为`val`”的第一个元素，如果找不到就返回`end()`     |
| `c.lower_bound(val)` | 返回`val`的第一个可安插位置，也就是“元素值`>= val`”的第一个元素位置 |
| `c.upper_bound(val)` | 返回`val`的最后一个可安插位置，也就是“元素值`> val`”的第一个元素位置 |
| `c.equal_range(val)` | 返回`val`可被安插的第一个位置和最后一个位置，也就是“元素值`== val`”的元素区间 |

Set和multiset在元素快速查找方面有优化设计，所以提供了特殊的查找函数，这些函数是同名的STL算法的特殊版本。
面对set和multiset你应该优先采用这些优化算法，如此可获得对数复杂度，而非STL算法的线性复杂度。
举个例子，在1 000个元素中查找，平均10次比较之后便可得出结果，如果是线性复杂度，平均500次比较才能有结果.

成员函数find()查找出与实参值相同的第一个元素，并返回一个迭代器指向该位置。如果没找到这样的元素，就返回容器的end()。

lower_bound()和upper_bound()分别返回第一个和最后一个“元素可安插点”。
换言之，lower_bound()返回第一个“大于等于实参值”的元素位置，
upper_bound()返回第一个“大于实参值”的元素位置。
equal_range()则是将lower_bound()和upper_bound()的返回值做成一个pair返回，所以它返回的是“与实参值相等”的元素所形成的区间。
如果lower_bound()或“equal_range()的first值”等于“equal_range()的second值”或upper_bound()，则此set或multiset内不存在同值元素。
这是当然，同值区间中至少也得包含一个元素！

下面的例子说明了如何使用lower_bound()、upper_bound()和equal_range()：

```cc
#include <iostream>
#include <set>
using namespace std;

int main ()
{
    set<int> c;

    c.insert(1);
    c.insert(2);
    c.insert(4);
    c.insert(5);
    c.insert(6);

    cout << "lower_bound(3): " << *c.lower_bound(3) << endl;
    cout << "upper_bound(3): " << *c.upper_bound(3) << endl;
    cout << "equal_range(3): " << *c.equal_range(3).first << " "
         << *c.equal_range(3).second << endl;

    cout << endl;
    cout << "lower_bound(5): " << *c.lower_bound(5) << endl;
    cout << "upper_bound(5): " << *c.upper_bound(5) << endl;
    cout << "equal_range(5): " << *c.equal_range(5).first << " "
         << *c.equal_range(5).second << endl;
}
```

运行输出
```bash

lower_bound(3): 4
upper_bound(3): 4
equal_range(3): 4 4
lower_bound(5): 5
upper_bound(5): 6
equal_range(5): 5 6
```
上例如果使用multiset而不是set，程序输出相同。

#### 赋值（Assignment）
set和multiset只提供任何容器都提供的基本赋值操作.

这些操作函数中，赋值操作的两端容器必须具备相同类型。
尽管“比较准则”本身可能不同，但其类型必须相同。
如果准则不同，准则本身也会连同容器一并被赋值或交换。

| 操作          | 效果                                                         |
| ------------- | ------------------------------------------------------------ |
| `c = c2`      | 将 `c2` 的全部元素赋值给 `c`                                 |
| `c = rv`      | 将 rvalue `rv` 的所有元素以 move assign 方式给予 `c`（始自 C++11） |
| `c = initlist` | 将初值列 `initlist` 的所有元素赋值给 `c`（始自 C++11）       |
| `c1.swap(c2)` | 置换 `c1` 和 `c2` 的数据                                     |
| `swap(c1, c2)` | 置换 `c1` 和 `c2` 的数据                                     |

#### 迭代器相关函数（Iterator Function）
Set和multiset不提供元素直接访问，所以只能采取range-based for循环或采用迭代器。
Set和multiset提供了一些常见的迭代器函数:

| 操作          | 效果                                                         |
| ------------- | ------------------------------------------------------------ |
| `c.begin()`   | 返回一个 bidirectional iterator 指向第一元素                 |
| `c.end()`     | 返回一个 bidirectional iterator 指向最末元素的下一位置       |
| `c.cbegin()`  | 返回一个 const bidirectional iterator 指向第一元素（始自 C++11） |
| `c.cend()`    | 返回一个 const bidirectional iterator 指向最末元素的下一位置（始自 C++11） |
| `c.rbegin()`  | 返回一个反向的（reverse）iterator 指向反向迭代的第一元素     |
| `c.rend()`    | 返回一个反向的（reverse）iterator 指向反向迭代的最末元素的下一位置 |
| `c.crbegin()` | 返回一个 const reverse iterator 指向反向迭代的第一元素（始自 C++11） |
| `c.crend()`   | 返回一个 const reverse iterator 指向反向迭代的最末元素的下一位置（始自 C++11） |

和所有关联式容器类似，这里的迭代器是双向迭代器。
所以，对于那些“只能接受随机访问迭代器”的STL算法（如排序算法或随机乱序〔random shuffling〕算法），set和multiset就无福消受了。

更重要的是，从迭代器的角度看去，所有元素都被视为常量，这可确保元素不会被改动以至于打乱既有顺序。
然而这也使得你无法对set或multiset元素调用任何更易型算法（modifying algorithm）。
例如你不能对它们调用remove（），因为remove（）算法实际上是以其实参值覆盖被移除的元素。
欲移除set和multiset的元素，只能使用它们所提供的成员函数。


#### 元素的安插和移除（Inserting and Removing）

set和multiset的元素安插和删除函数:

| 操作                          | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `c.insert(val)`               | 安插一个 `val` 拷贝，返回新元素位置，不论是否成功——对 `set` 而言 |
| `c.insert(pos, val)`          | 安插一个 `val` 拷贝，返回新元素位置（`pos` 是个提示，指出安插动作的查找起点。若提示恰当可加快速度） |
| `c.insert(beg, end)`          | 将区间 `[beg, end)` 内所有元素的拷贝安插到 `c`（无返回值）   |
| `c.insert(initlist)`          | 安插初值列 `initlist` 内所有元素的一份拷贝（无返回值；始自 C++11） |
| `c.emplace(args...)`          | 安插一个以 `args` 为初值的元素，并返回新元素的位置，不论是否成功——对 `set` 而言（始自 C++11） |
| `c.emplace_hint(pos, args...)` | 安插一个以 `args` 为初值的元素，并返回新元素的位置（`pos` 是个提示，指出安插动作的查找起点。若提示恰当可加快速度） |
| `c.erase(val)`                | 移除“与 `val` 相等”的所有元素，返回被移除的元素个数          |
| `c.erase(pos)`                | 移除 iterator 位置 `pos` 上的元素，无返回值                  |
| `c.erase(beg, end)`           | 移除区间 `[beg, end)` 内的所有元素，无返回值                 |
| `c.clear()`                   | 移除所有元素，将容器清空                                     |

依STL惯例，你必须保证传入的实参合法：
- 迭代器必须指向一个合法位置，
- 区间的起始位置不能在结束位置之后。

处理多个元素的安插和移除时，对区间内的所有元素使用单一调用，会比多次调用更快速。

C++11保证，multiset的insert()、emplace()和erase()成员函数都会保存等值元素间的相对次序，插入的元素会被放在“既有的等值元素群”的末尾。

注意，用以安插元素的函数：insert()和emplace()，其返回类型不尽相同：

Set提供如下接口：
```cc
pair<iterator, bool> insert(const value_type& val);
iterator insert(const_iterator posHint, const value_type& val);

template <typename... Args>
pair<iterator, bool> emplace(Args&&... args);

template <typename... Args>
iterator emplace_hint(const_iterator posHint, Args&&... args);
```

Multiset提供如下接口：
```cc
iterator insert(const value_type& val);
iterator insert(const_iterator posHint, const value_type& val);

template <typename... Args>
iterator emplace(Args&&... args);

template <typename... Args>
iterator emplace_hint(const_iterator posHint, Args&&... args);
```

返回类型之所以不相同，原因是：multiset允许元素重复而set不允许。
因此，如果将某元素安插至set内，而该set已经内含同值元素，安插动作将告失败。所以set的返回类型是以pair组织起来的两个值:
- 1.pair结构中的second成员表示安插是否成功。
- 2.pair结构中的first成员表示新元素的位置，或现存的同值元素的位置。

其他任何情况下，此函数都返回新元素的位置（如果set已经内含同值元素，则返回同值元素的位置）。

以下例子把数值为3.3的元素安插到set c中，借此说明如何使用上述接口：
```cc
set<int> c;
...
if (c.insert(3).second) {
    cout << "3 is inserted" << endl;
}
else {
    cout << "3 is already exists" << endl;
}
```
如果你还想处理新位置或旧位置，代码得更复杂些：
```cc
auto status = c.insert(val);
if (status.second) {
    cout << val << " is inserted at" << endl;
}
else {
    cout << val << " is already exists at" << endl;
}
cout << distance(c.begin(), status.first) + 1 << endl;
```
注意，所有拥有“位置提示参数”的安插函数，其返回类型都一样，不论是set或multiset，这些函数都只返回一个迭代器。
这些函数的效果与“不带位置提示参数”的函数一样，只不过效率略有差异。
你可以传进一个迭代器，该位置将作为一个提示，用来提升效率。
事实上，如果被安插元素的位置恰好紧贴于提示位置之后，那么时间复杂度就会从“对数”一变而为“摊提常量（amortized constant）”。
和“单实参安插函数”不同的是，带有“额外提示位置”的若干安插函数都具有相同的返回类型，这就确保你至少有了一个通用型安插函数，在各种容器中有共同接口。
事实上，通用型安插迭代器（general inserter）就是靠这个接口的支持才得以实现。

若欲删除“与某值相等”的元素，只需调用erase()：

```cc
set<int> c;
...
c.erase(val);
```
和list不同的是，erase()并非取名为remove()。
是的，它的行为不同，它返回的是被删除元素的个数，在set身上其返回值非0即1。

如果multiset内含重复元素，你不能使用erase()来删除这些重复元素中的第一个。但你可以这么做：
```cc
multiset<int> c;
...
multiset<int>::iterator pos;
pos = c.find(val);
if (pos != c.end()) {
    c.erase(pos);
}
```

这里应该采用成员函数find()，而非STL算法find()，因为前者速度更快。
注意，在C++11之前，关联式容器的erase()函数不返回任何东西（返回类型为void），这是为了效率。
在一个关联式容器内查找元素并返回其后继者，可能会花不少时间，因为容器被实现为一个binary tree，这会大幅增加上述事情的复杂度.
也请注意，面对以迭代器为元素的set，调用erase()如今可能会造成歧义。为了这个因素，C++11提出修正，提供了重载函数erase（iterator）和erase（const_iterator）。
Multiset 的insert()、emplace()和erase()操作函数都会保留等价元素的相对次序。自C++11起，调用insert(val)或emplace(args...)，新元素保证会被安插于等价元素所形成的区间的末端。

### 异常处理（Exception Handling）
Set和multiset是“以节点（node）为基础”的容器。如果节点构建失败，容器仍保持原样。此外，由于析构函数通常并不抛出异常，所以节点的移除不可以失败。

然而，面对多重元素安插动作，“保持元素次序”这一条件会造成“异常抛出时必须完全回复原状”变得不切实际。
因此，只有“单一元素安插动作”才支持“要么成功要么无效”（commit-or-rollback）的操作原则。
此外，“多元素删除动作”总是“要么成功要么无效”的前提是：排序准则不抛出异常。如果排序准则之复制/赋值动作有可能抛出异常，swap（）也有可能抛出异常。

### Set和Multiset运用实例
```cc
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>
using namespace std;

int main()
{
    // type of the collection:
    // - no duplicates
    // - elements are integral values
    // - descending order
    set<int, greater<int>> coll1;

    // insert elements in random order using different member functions
    coll1.insert({4, 3, 5, 1, 6, 2});
    coll1.insert(5);

    // print all elements
    for (int elem : coll1) {
        cout << elem << ' ';
    }
    cout << endl;

    // insert 4 again and process return value
    auto status = coll1.insert(4);
    if (status.second) {
        cout << "4 inserted as element " 
             << distance(coll1.begin(), status.first) + 1 << endl;
    } else {
        cout << "4 already exists" << endl;
    }

    // assign elements to another set with ascending order
    set<int> coll2(coll1.cbegin(), coll1.cend());

    // print all elements of the copy using stream iterators
    copy(coll2.cbegin(), coll2.cend(),
         ostream_iterator<int>(cout, " "));
    cout << endl;

    // remove all elements up to element with value 3
    coll2.erase(coll2.begin(), coll2.find(3));

    // remove all elements with value 5
    int num;
    num = coll2.erase(5);
    cout << num << " element(s) removed" << endl;

    // print all elements
    copy(coll2.cbegin(), coll2.cend(),
         ostream_iterator<int>(cout, " "));
    cout << endl;

    return 0;
}
```
运行结果
```bash

6 5 4 3 2 1 
4 already exists
1 2 3 4 5 6 
1 element(s) removed
3 4 6 
```

### 运行期指定排序准则
无论是将排序准则作为第二个template实参传入，或是采用默认的排序准则less<>，通常你都会将排序准则定义为类型的一部分。
但有时必须在运行期处理排序准则，或者有时候你需要对同一种数据类型采用不同的排序准则。
此时你就需要一个“用来表现排序准则”的特殊类型，使你能够在运行期间才给定某个准则。以下程序说明了这种做法:
```cc
// cont/setcmp1.cpp
#include <iostream>
#include <set>
#include "print.hpp"  // 需自行实现，用于打印容器元素
using namespace std;

// type for runtime sorting criterion
class RuntimeCmp {
public:
    enum cmp_mode { normal, reverse };

private:
    cmp_mode mode;

public:
    // constructor for sorting criterion
    // - default criterion uses value normal
    RuntimeCmp(cmp_mode m = normal) : mode(m) {
    }

    // comparison of elements
    // - member function for any element type
    template <typename T>
    bool operator()(const T& t1, const T& t2) const {
        return mode == normal ? t1 < t2
                              : t2 < t1;
    }

    // comparison of sorting criteria
    bool operator==(const RuntimeCmp& rc) const {
        return mode == rc.mode;
    }
};

// type of a set that uses this sorting criterion
typedef set<int, RuntimeCmp> IntSet;

int main() {
    // create, fill, and print set with normal element order
    // - uses default sorting criterion
    IntSet coll1 = {4, 7, 5, 1, 6, 2, 5};
    PRINT_ELEMENTS(coll1, "coll1: ");

    // create sorting criterion with reverse element order
    RuntimeCmp reverse_order(RuntimeCmp::reverse);

    // create, fill, and print set with reverse element order
    IntSet coll2(reverse_order);
    coll2 = {4, 7, 5, 1, 6, 2, 5};
    PRINT_ELEMENTS(coll2, "coll2: ");

    // assign elements AND sorting criterion
    coll1 = coll2;
    coll1.insert(3);
    PRINT_ELEMENTS(coll1, "coll1: ");

    // just to make sure...
    if (coll1.value_comp() == coll2.value_comp()) {
        cout << "coll1 and coll2 have the same sorting criterion"
             << endl;
    } else {
        cout << "coll1 and coll2 have a different sorting criterion"
             << endl;
    }
}
```
程序输出
```bash
coll1: 1 2 4 5 6 7
coll2: 7 6 5 4 2 1
coll1: 7 6 5 4 3 2 1
coll1 and coll2 have the same sorting criterion
```

## Map和Multimap
Map和multimap将key/value pair当作元素进行管理。它们可根据key的排序准则自动为元素排序。Multimap允许重复元素，map不允许.


            Map                                                            Multimap
            ┌──────────────────────────────────────────────┐               ┌──────────────────────────────────────────────┐ 
            │  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐  │               │  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐  ┌───┬───┐  │ 
            │  │ 1 │   │  │ 2 │   │  │ 3 │   │  │ 4 │   │  │               │  │ 1 │   │  │ 1 │   │  │ 3 │   │  │ 4 │   │  │ 
            │  └───┴───┘  └───┴───┘  └───┴───┘  └───┴───┘  │               │  └───┴───┘  └───┴───┘  └───┴───┘  └───┴───┘  │ 
            └──────────────────────────────────────────────┘               └──────────────────────────────────────────────┘ 

map和multimap被定义为命名空间std内的class template：
```cc
namespace std {
    template <typename Key, typename T,
              typename Compare = less<Key>,
              typename Allocator = allocator<pair<const Key, T>>>
    class map;

    template <typename Key, typename T,
              typename Compare = less<Key>,
              typename Allocator = allocator<pair<const Key, T>>>
    class multimap;
}
```
第一个template实参将成为元素的key类型，第二个template实参将成为元素的value类型。Map和multimap的元素类型Key和T必须满足以下两个条件：
- 1.Key和value都必须是copyable（可复制的）或movable（可搬移的）。
- 2.对指定的排序准则而言，key必须是comparable（可比较的）。

注意，元素类型（value_type）是个pair<const Key, T>。

第三个template实参可有可无，用来定义排序准则。
和set一样，这个排序准则必须定义为strict weak ordering。
元素的次序由它们的key决定，和value无关。排序准则也可以用来检查相等性：如果两个元素的key彼此都不小于对方，两个元素被视为相等。

如果用户未传入某个排序准则，就使用默认的less<>排序准则——以operator<进行比较.

关于multimap，我们无法预测所有“拥有等价key”的元素的彼此次序，不过它们的次序是稳固不变的。C++11保证multimap的安插和抹除动作都会保留等价元素的相对次序。

第四个template实参也是可有可无，用来定义内存模型。默认的内存模型是allocator，由C++标准库提供。

### Map和Multimap的能力
和其他所有关联式容器一样，map/multimap通常以平衡二叉树完成。C++standard并未明定这一点，但是从map和multimap各项操作的复杂度自然可以得出这一结论。
通常set、multiset、map和multimap使用相同的内部结构，因此，你可以把set和multiset视为特殊的map和multimap，只不过set元素的value和key是同一对象。
因此，map和multimap拥有set和multiset的所有能力和所有操作。
当然，某些细微差异还是有的：首先，它们的元素是key/value pair，其次，map可作为关联式数组（associative array）来运用。


            Map/multimap                        
                        ┌─────┐                 
                        │  4  │
                        ├─────┤                 
                        │     │
                        └──┬──┘                 
                   ┌───────┴───────┐            
                   ▼               ▼            
               ┌─────┐           ┌─────┐        
               │  2  │           │  6  │
               ├─────┤           ├─────┤        
               │     │           │     │
               └──┬──┘           └──┬──┘        
             ┌────┴────┐         ┌──┴───┐       
             ▼         ▼         ▼      ▼       
         ┌─────┐    ┌─────┐  ┌─────┐  ┌─────┐   
         │  1  │    │  3  │  │  5  │  │  7  │
         ├─────┤    ├─────┤  ├─────┤  ├─────┤   
         │     │    │     │  │     │  │     │
         └─────┘    └─────┘  └─────┘  └─────┘   

Map和multimap会根据元素的key自动对元素排序。这么一来，根据已知的key查找某个元素时就能够有很好的效率，而根据已知value查找元素时，效率就很糟糕。
“自动排序”这一性质使得map和multimap身上有了一条重要限制：你不可以直接改变元素的key，因为这会破坏正确次序。
要修改元素的key，必须先移除拥有该key的元素，然后插入拥有新key/value的元素。
从迭代器的观点看，元素的key是常量。至于元素的value倒是可以直接修改，当然前提是value并非常量。

### Map和Multimap的操作函数
#### 创建、复制和销毁（Create，Copy，and Destroy）

map和multimap的创建、复制、销毁等各项操作
| 操作形式 | 效果 |
| ---- | ---- |
| `map c` | Default 构造函数，建立一个空 `map/multimap`，不含任何元素 |
| `map c(op)` | 建立一个空 `map/multimap`，以 `op` 为排序准则 |
| `map c(c2)` | Copy 构造函数，为相同类型之另一个 `map/multimap` 建立一份拷贝，所有元素均被复制 |
| `map c = c2` | Copy 构造函数，为相同类型之另一个 `map/multimap` 建立一份拷贝，所有元素均被复制 |
| `map c(rv)` | Move 构造函数，建立一个新的 `map/multimap`，有相同类型，取 rvalue `rv` 的内容（始自 C++11） |
| `map c = rv` | Move 构造函数，建立一个新的 `map/multimap`，有相同类型，取 rvalue `rv` 的内容（始自 C++11） |
| `map c(beg,end)` | 以区间 `[beg,end)` 内的元素为初值，建立一个 `map/multimap` |
| `map c(beg,end,op)` | 以区间 `[beg,end)` 内的元素为初值，并以 `op` 为排序准则，建立一个 `map/multimap` |
| `map c(initlist)` | 建立一个 `map/multimap`，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `map c = initlist` | 建立一个 `map/multimap`，以初值列 `initlist` 的元素为初值（始自 C++11） |
| `c.~map()` | 销毁所有元素，释放内存 |

map可为下列形式：
| `map` 具体形式 | 效果 |
| ---- | ---- |
| `map<Key,Val>` | 一个 `map`，以 `less<>`（`operator<`）为排序准则 |
| `map<Key,Val,Op>` | 一个 `map`，以 `Op` 为排序准则 |
| `multimap<Key,Val>` | 一个 `multimap`，以 `less<>`（`operator<`）为排序准则 |
| `multimap<Key,Val,Op>` | 一个 `multimap`，以 `Op` 为排序准则 |
两种方式可以定义排序准则：

1. 以template实参定义之。例如：
```cc
map<int, string, greater<int>> c;
```
这种情况下，排序准则就是类型的一部分。因此类型系统确保“只有排序准则相同的容器才能被合并”。这是比较常见的一种排序准则指定法。
更精确地说，第三参数是排序准则的类型。实际的排序准则是容器所产生的函数对象（function object）。
为了产生它，构造函数会调用“排序准则类型”的default构造函数。

2. 以构造函数参数定义之。
这种情况下，你可以有一个“排序准则类型”并为它指定不同的排序准则实例（也就是说，让该类型所产生的对象〔代表一个排序准则〕的初值或状态不同）。
如果运行期才能获得排序准则，而且程序需要用到不同的排序准则（但其类型必须相同），这一方式可派上用场。
典型例子是在运行期指定“以string为key”的排序准则。

如果用户没有指定任何排序准则，就采用默认准则——函数对象less<>。less<>通过operator<对元素排序。
再强调一次，排序准则也被用来检验同一容器内的两个元素的等价性（例如用来找出重复元素）。只有当比较两个容器时，才需要操作符==。

#### 非更易型操作（Nonmodifying Operation）
Map和multimap提供了若干常见的非更易型操作，用来查询大小、相互比较，

“元素比较”函数只能用于类型相同的容器身上，换言之，两个容器的key、value、排序准则都必须有相同的类型，否则编译期会产生类型方面的错误。例如：
```cc
map<int, string> c1;
map<int, string, greater<int>> c2;
...
if (c1 == c2) // err
```
| 操作             | 效果                                                         |
| ---------------- | ------------------------------------------------------------ |
| `c.key_comp()`   | 返回“比较准则”（comparison criterion）                       |
| `c.value_comp()` | 返回针对 value 的“比较准则”（那是个对象，用来在一个 key/value pair 中比较 key） |
| `c.empty()`      | 返回是否容器为空（相当于 `size()==0` 但也许较快）            |
| `c.size()`       | 返回目前的元素个数                                           |
| `c.max_size()`   | 返回元素个数之最大可能量                                     |
| `c1 == c2`       | 返回 `c1` 是否等于 `c2`（对每个元素调用 `==`）               |
| `c1 != c2`       | 返回 `c1` 是否不等于 `c2`（相当于 `!(c1==c2)`）              |
| `c1 < c2`        | 返回 `c1` 是否小于 `c2`                                       |
| `c1 > c2`        | 返回 `c1` 是否大于 `c2`（相当于 `c2<c1`）                    |
| `c1 <= c2`       | 返回 `c1` 是否小于等于 `c2`（相当于 `!(c2<c1)`）             |
| `c1 >= c2`       | 返回 `c1` 是否大于等于 `c2`（相当于 `!(c1<c2)`）             |

比较函数以“字典顺序”检查某个容器是否小于另一个容器。
如果要比较不同类型（拥有不同排序准则）的容器，你必须采用的STL比较算法（comparing algorithm）。

#### 特殊查找动作（Special Search Operation）
就像set和multiset一样，map和multimap也提供特殊查找函数，以便利用内部树状结构获取较好的效能，

| 操作                | 效果                                                         |
| ------------------- | ------------------------------------------------------------ |
| `c.count(val)`      | 返回“key 为 `val`”的元素个数                                 |
| `c.find(val)`       | 返回“key 为 `val`”的第一个元素，找不到就返回`end()`          |
| `c.lower_bound(val)` | 返回“key 为 `val`”之元素的第一个可安插位置，也就是“`key >= val`”的第一个元素位置 |
| `c.upper_bound(val)` | 返回“key 为 `val`”之元素的最后一个可安插位置，也就是“`key > val`”的第一个元素位置 |
| `c.equal_range(val)` | 返回“key 为 `val`”之元素的第一个可安插位置和最后一个可安插位置，也就是“`key == val`”的元素区间 |

成员函数find()用来查找第一个“拥有某key”的元素，并返回一个迭代器指向该位置。如果没找到这样的元素，就返回容器的end()。
你不能以find()查找拥有某特定value的元素，必须改用STL算法如find_if()，或干脆自行写一个循环（loop）。
下面这个例子便是利用一个简单循环对拥有特定value的所有元素进行某项操作：
```cc
multimap<string, int> c;
...
multimap<string, int>::iterator pos;
for (pos = c.begin(); pos != c.end(); ++pos) {
    if (pos->second == val) {
        do_something();
    }
}
```
如果你想利用这个循环来移除元素，请小心。很可能你会锯断你正坐着的树枝。

如果使用find_if()算法做类似的查找动作，会比写一个上述循环更复杂，因为你必须提供函数对象，将元素的value拿来和某个value比较。

至于lower_bound()、upper_bound()和equal_range()，其行为和set的相应函数十分相似，唯一的不同是：这里的元素是个key/value pair。

#### 赋值（Assignment）
Map和multimap只支持“所有容器都提供的基本赋值操作”，

 Map和Multimap的赋值操作:
| 操作          | 效果                                                         |
| ------------- | ------------------------------------------------------------ |
| `c = c2`      | 将 `c2` 的全部元素赋值给 `c`                                 |
| `c = rv`      | 将 rvalue `rv` 的所有元素以 move assign 方式给予 `c`（始自 C++11） |
| `c = initlist` | 将初值列 `initlist` 的所有元素赋值给 `c`（始自 C++11）       |
| `c1.swap(c2)` | 置换 `c1` 和 `c2` 的数据                                     |
| `swap(c1, c2)` | 置换 `c1` 和 `c2` 的数据                                     |

这些操作函数中，赋值动作的两端容器必须拥有相同类型。尽管“比较准则”本身可能不同，但其类型必须相同。
如果准则不同，准则本身也会随着容器被赋值（assigned）或交换（swapped）。

#### 迭代器函数和元素访问（Iterator Function and Element Access）
Map和multimap不支持元素直接访问，因此元素的访问通常是经由range-based for循环或迭代器进行。
不过有个例外：map提供at()以及subscript（下标）操作符可直接访问元素。

 Map和Multimap的迭代器相关操作:
| 操作          | 效果                                                         |
| ------------- | ------------------------------------------------------------ |
| `c.begin()`   | 返回一个 bidirectional iterator 指向第一元素                 |
| `c.end()`     | 返回一个 bidirectional iterator 指向最末元素的下一位置       |
| `c.cbegin()`  | 返回一个 const bidirectional iterator 指向第一元素（始自 C++11） |
| `c.cend()`    | 返回一个 const bidirectional iterator 指向最末元素的下一位置（始自 C++11） |
| `c.rbegin()`  | 返回一个反向的（reverse）iterator 指向反向迭代的第一元素     |
| `c.rend()`    | 返回一个反向的（reverse）iterator 指向反向迭代的最末元素的下一位置 |
| `c.crbegin()` | 返回一个 const reverse iterator 指向反向迭代的第一元素（始自 C++11） |
| `c.crend()`   | 返回一个 const reverse iterator 指向反向迭代的最末元素的下一位置（始自 C++11） |

和其他所有关联式容器一样，这里的迭代器是双向迭代器。
所以，对于只能接受随机访问迭代器的STL算法（例如排序算法或随机乱序〔random shuffling〕算法），map和multimap就无福消受了。

更重要的是，在map和multimap中，所有元素的key都被视为常量。因此，元素的实质类型是pair<const Key, T>。
这个限制是为了确保你不会因为变更元素的key 而破坏已排好的元素次序。
所以你不能针对map或multimap调用任何更易型算法（modifying algorithm）。
例如你不能对它们调用remove()，因为remove()算法实际上是将其实参值覆盖掉被移除的元素。
如果要移除map和multimap的元素，你只能使用它们所提供的成员函数。

下面示范使用range-based for循环访问map元素：
```cc
map<string, int> c;
for (auto &elem : c) {
    cout << "key : " << elem.first << " value :" << elem.second << endl;
}
```
其中的elem是个 reference，指向“容器coll中目前正被处理的元素”。
因此elem的类型是pair<const std::string, float>。表达式elem.first取得元素的key，而表达式elem.second取得元素的value。

另一个例子是以迭代器访问元素（C++11之前必须使用这种方法）：
```cc
map<string, int> c;
map<string, int>::iterator pos;
for (pos = c.begin(); pos != c.end(); ++pos) {
    cout << "key : " << pos->first << " value :" << pos->second << endl;
}
```
在这里，迭代器pos被用来迭代穿越整个由“以const string和float组成的pair”所构成的序列，你必须使用operator->访问每次访问的那个元素的key和value。

如果你尝试改变元素的key，会引发错误：
```cc
elem.first = "11"; // err
pos->first = "11"; // err
```
不过如果value本身的类型并非const，改变value没有问题：
```cc
elem.second = "11"; // err
pos->second = "11"; // err
```

如果你使用算法或lambda来操作map元素，你必须很明确地声明元素类型：
```cc
map<string, int> c;
...
for_each(c.begin(), c.end(), 
       [](pair<const string, int> &elem) {
           elem.second += 10;
       })
```
那么，可以不写：
```cc
pair<const string, int>
```
而改为
```cc
map<string, int>::value_type
```
或
```cc
decltype(c)::value_type
```
来声明元素类型。

如果你一定得改变元素的key，只有一条路：以一个“value相同”的新元素替换掉旧元素。下面是个泛化函数：
```cc
namespace MyLib {
    template <typename Cont>
    inline bool replace_key(Cont& c,
                            const typename Cont::key_type& old_key,
                            const typename Cont::key_type& new_key) {
        typename Cont::iterator pos;
        pos = c.find(old_key);
        if (pos != c.end()) {
            // insert new element with value of old element
            c.insert(typename Cont::value_type(new_key, pos->second));
            // remove old element
            c.erase(pos);
            return true;
        } else {
            // key not found
            return false;
        }
    }
}
```
关于成员函数insert()和erase()，见下一节的讨论。

这个泛型函数的用法很简单，把旧key和新key传递进去就行。例如：
```cc
map<string, int> c;
...
MyLib::replace_key(c, "old key", "new key");
```
如果你面对的是multimap，情况也一样。

注意，map提供了一种非常方便的手法，让你改变元素的key。只需如此这般：
```cc
c["new key"] = c["old key"];
c.erase("old key");
```

#### 元素安插和移除（Inserting and Removing）
Map和Multimap的元素安插和移除:
| 操作                     | 效果                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `c.insert(val)`          | 安插一个 `val` 拷贝，返回新元素位置，不论是否成功——对 `map` 而言 |
| `c.insert(pos, val)`     | 安插一个 `val` 拷贝，返回新元素位置（`pos` 是个提示，指出安插动作的查找起点。若提示恰当可加快速度） |
| `c.insert(beg, end)`     | 将区间 `[beg, end)` 内所有元素的拷贝安插到 `c`（无返回值）   |
| `c.insert(initlist)`     | 安插初值列 `initlist` 内所有元素的一份拷贝（无返回值；始自 C++11） |
| `c.emplace(args...)`     | 安插一个以 `args` 为初值的元素，并返回新元素的位置，不论是否成功——对 `map` 而言（始自 C++11） |
| `c.emplace_hint(pos, args...)` | 安插一个以 `args` 为初值的元素，并返回新元素的位置（`pos` 是个提示，指出安插动作的查找起点。若提示恰当可加快速度） |
| `c.erase(val)`           | 移除“与 `val` 相等”的所有元素，返回被移除的元素个数          |
| `c.erase(pos)`           | 移除 iterator 位置 `pos` 上的元素，无返回值                  |
| `c.erase(beg, end)`      | 移除区间 `[beg, end)` 内的所有元素，无返回值                 |
| `c.clear()`              | 移除所有元素，将容器清空                                     |

对于multimap，C++11保证insert()、emplace()和erase()都会保留等价元素的相对次序，而新增（被安插）的元素则一定被放在既有的等价元素（群）的末尾。

安插一个key/value pair时，你一定要记住，在map和multimap内部，key被视为常量。你要么得提供正确类型，要么得提供隐式或显式类型转换。

自C++11起，安插元素的最方便做法就是把它们以初值列（initializer list）的形式传进去，其中第一笔数据是key，第二笔数据是value：

```cc
map<string, int> c;
...
c.insert({"aa", 33});
```

有三种不同的方法可以将value传入map或multimap内：
- 1. 运用value_type。为了避免隐式类型转换，你可以利用value_type明白传递正确类型。value_type是容器本身提供的类型定义。例如：
```cc
map<string, int> c;
...
c.insert(map<string, int>::value_type("aa", 33));
```
或
```cc
c.insert(decltype(c)::value_type("aa", 33));
```
- 2. 运用pairM<>。另一个做法是直接运用pair<>。例如：
```cc
map<string, int> c;
...
// 使用隐式转换
c.insert(pair<string, int>("aa", 33));
// 不使用隐式转换
c.insert(pair<const string, int>("aa", 33));
```
上述第一个insert()语句内的类型并不正确，所以会被转换成真正的元素类型。为了做到这一点，insert()成员函数被定义为member template.

3. 运用make_pair()。C++11面世之前最方便的办法是运用make_pair()函数，它根据收到的两个实参构建出一个pair对象:
```cc
map<string, int> c;
...
c.insert(make_pair("aa", 33));
```
和上个做法一样，此处也是利用member template insert()执行必要的类型转换。下面是个简单例子，对map安插一个元素，然后检查是否成功：
```cc
map<string, int> c;
...
if (c.insert(make_pair("aa", 33)).second) {
    cout << "insert ok" << endl;
}
else {
    cout << "insert err : aa/33 is already exists" << endl;
}
```
注意，map提供operator[]和at()，作为便捷的元素安插和设定操作.

使用emplace()安插新元素，并且传值进去以便构建该新元素时，你必须传递两列实参进去：一列为了key，另一列为了元素。完成这件事的最方便做法如下：
```cc
map<string, complex<int>> c;
c.emplace(std::piecewise_construct, // 传递tuple元素作为参数
          make_tuple("hello"),      // 作为key的元素
          make_tuple(1, 2));        // 作为val的元素
```
欲移除“携带某个key”的元素，调用erase（）即可办到：
```cc
map<string, int> c;
...
c.erase(key);
```
这个erase()会返回被移除元素的个数。如果你处理的是map，erase()的返回值只可能是0或1。

如果multimap内含重复元素，你无法使用erase()删除重复元素中的第一个。但你可以这么做：
```cc
multimap<string, int> c;
...
auto pos = c.find(key);
if (pos != c.end()) {
    c.erase(pos);
}
```
这里应该采用成员函数find()，而非STL算法find()，因为前者速度更快。
然而你不能使用成员函数find()来移除“拥有某个value（而非某个key）”的元素。

移除元素时，当心发生意外状况。移除迭代器所指对象时，有一个很大的危险，比如：
```cc
map<string, int> c;
...
for (auto pos = c.begin() ; pos != c.end(); ++pos) {
    if (pos->second == value) {
        c.erase(pos);  // 运行时错误
    }
}
```
对pos所指元素调用erase()，会使pos不再成为coll的一个有效迭代器。
如果此后你未对pos重新设值就径直使用pos，前途未卜！事实上，只要一个++pos动作就会导致不明确行为。

C++11之后的解决方案很容易，因为erase()总是返回一个迭代器指向其后继元素：
```cc
for (auto pos = c.begin() ; pos != c.end(); ) {
    if (pos->second == value) {
        pos = c.erase(pos);  // 运行时错误
    }
    else {
        ++pos;
    }
}
```
不幸的是，在C++11之前，STL设计过程中否决了这种想法，因为万一用户并不需要这一特性，就会耗费不必要的执行时间。
下面是C++11面世之前移除“迭代器所指元素”的正确做法：
```cc
map<string, int> c;
map<string, int>::iterator pos;
...
for (pos = c.begin(); pos != c.end(); ) {
    if (pos->second == value) {
        c.erase(pos++);
    }
    else {
        ++pos;
    }
}
```
注意，pos++会将pos移向下一元素，但返回其原值（指向原位置）的一份拷贝。因此当erase()被调用，pos已经不再指向那个即将被移除的元素了。

也请注意，如果set使用迭代器作为元素，调用erase()有可能造成歧义。基于这个原因，C++11提供两个重载版本：erase（iterator）和erase（const_iterator）。

面对multimap，其所有的insert()、emplace()和erase()操作都保留等价元素的相对次序。
C++11保证，insert(val)或emplace(args...)一定会将元素安插在等价元素所形成的区间的末尾。


#### 将Map视为关联式数组（Associative Array）
通常，关联式容器并不提供元素的直接访问，你必须依靠迭代器。不过map是例外。
Non-const map提供了subscript（下标）操作符，支持元素的直接访问，C++11另外提供一个成员函数at（），可用于const和non-const map。

Map的直接元素访问操作
| 操作       | 效果                                                         |
| ---------- | ------------------------------------------------------------ |
| `c[key]`   | 安插一个带着 `key` 的元素——如果尚未存在于容器内。返回一个 reference 指向带着 `key` 的元素（only for nonconstant maps） |
| `c.at(key)` | 返回一个 reference 指向带着 `key` 的元素（始自 C++11）       |

at()会依据它收到的“元素的key”取得元素的value；如果不存在这样的元素则抛出out_of_range异常。

至于operator[]，其索引就是key。这意味着operator[]的索引可能属于任何类型，不一定是整数。如此的接口就是所谓的关联式数组（associative array）接口。

“operator[]的索引类型不必然是整数”并不是它和寻常array唯一不同之处。
如果你选择某key作为索引，容器内却没有相应元素，那么map会自动安插一个新元素，其value将被其类型的default构造函数初始化。
因此，你不可以指定一个“不具default构造函数”的value类型。注意，基础类型都有一个default构造函数，设立初值0。

关联式数组的行为方式可说是毁誉参半：

· 优点是你可以通过更方便的接口对map安插新元素。例如：
```cc
map<string, int> c;
c["otto"] = 1;
```
其中
```cc
c["otto"] = 1;
```
处理如下：
- 1.处理`coll["otto"]`：
  - 如果存在key为"otto"的元素，上式会返回元素的reference。
  - 如果没有任何元素的key是"otto"，上式便为map自动安插一个新元素，令其key为"otto"，其value则以default构造函数完成，并返回一个reference指向新元素。
- 2.将1赋值给value：
  - 接下来便是将1赋值给上述刚刚诞生的新元素。

这样，map之内就包含了一个key为"otto"的元素，其value为1。

缺点是你有可能不小心误置新元素。例如以下语句可能会做出意想不到的事情：
```cc
cout << c["cotto"] << endl;
```
它会安插一个key为"ottto"的新元素，然后打印其value，默认值是0。然而按道理它其实应该产生一条报错信息，告诉你你把"otto"拼写错了。

同时亦请注意，这种元素安插方式比惯常的map安插方式慢，原因是新元素必须先使用default构造函数将value初始化，而该初值马上又被真正的value覆盖。

### 异常处理（Exception Handling）
就异常处理而言，map和multimap的行为与set和multiset一样

### Map和Multimap运用实例
在Map/Multimap身上使用算法和Lambda
```cc
#include <map>
#include <string>
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    map<string, double> coll { {"tim", 9.9},
                               {"struppi", 11.77}
                             };

    // square the value of each element:
    for_each (coll.begin(), coll.end(),
              [] (pair<const string, double>& elem) {
                  elem.second *= elem.second;
              });

    // print each element:
    for_each (coll.begin(), coll.end(),
              [] (const map<string, double>::value_type& elem) {
                  cout << elem.first << ": " << elem.second << endl;
              });
}
```
一如所见，对于map，for_each()被调用两次：一次用来对每个元素计算平方，一次用来打印每个元素。
在第一次调用中，元素类型被明确声明了出来，而在第二次调用中，用的是value_type。
第一次调用中元素以by reference方式传递，使其value得以被改动；
第二次调用用的是一个const reference，避免产生非必要的拷贝。

### 将Map当作关联式数组（Associative Array）
下面这个例子将map当成一个关联式数组来使用。这个map用来反映股票行情。元素的key是股票名称，value是股票价格：
```cc
#include <map>
#include <string>
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    // create map / associative array
    // - keys are strings
    // - values are floats
    typedef map<string, float> StringFloatMap;

    StringFloatMap stocks;      // create empty container

    // insert some elements
    stocks["BASF"] = 369.50;
    stocks["VW"] = 413.50;
    stocks["Daimler"] = 819.00;
    stocks["BMW"] = 834.00;
    stocks["Siemens"] = 842.20;

    // print all elements
    StringFloatMap::iterator pos;
    cout << left;  // left-adjust values
    for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
        cout << "stock: " << setw(12) << pos->first
             << "price: " << pos->second << endl;
    }
    cout << endl;

    // boom (all prices doubled)
    for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
        pos->second *= 2;
    }

    // print all elements
    for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
        cout << "stock: " << setw(12) << pos->first
             << "price: " << pos->second << endl;
    }
    cout << endl;

    // rename key from "VW" to "Volkswagen"
    // - provided only by exchanging element
    stocks["Volkswagen"] = stocks["VW"];
    stocks.erase("VW");

    // print all elements
    for (pos = stocks.begin(); pos != stocks.end(); ++pos) {
        cout << "stock: " << setw(12) << pos->first
             << "price: " << pos->second << endl;
    }
}
```
程序输出
```bash
stock: BASF        price: 369.5
stock: BMW         price: 834
stock: Daimler     price: 819
stock: Siemens     price: 842.2
stock: VW          price: 413.5
stock: BASF        price: 739
stock: BMW         price: 1668
stock: Daimler     price: 1638
stock: Siemens     price: 1684.4
stock: VW          price: 827
stock: BASF        price: 739
stock: BMW         price: 1668
stock: Daimler     price: 1638
stock: Siemens     price: 1684.4
stock: Volkswagen  price: 827
```

### 将Multimap当作字典（Dictionary）
下面的例子展示了如何将multimap当成一个字典使用：
```cc
#include <map>
#include <string>
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
    // create multimap as string/string dictionary
    multimap<string, string> dict;

    // insert some elements in random order
    dict.insert({ {"day", "Tag"}, {"strange", "fremd"},
                  {"car", "Auto"}, {"smart", "elegant"},
                  {"trait", "Merkmal"}, {"strange", "seltsam"},
                  {"smart", "raffiniert"}, {"smart", "klug"},
                  {"clever", "raffiniert"} });

    // print all elements
    cout.setf(ios::left, ios::adjustfield);
    cout << ' ' << setw(10) << "english "
         << "german " << endl;
    cout << setfill('-') << setw(20) << ""
         << setfill(' ') << endl;
    for (const auto& elem : dict) {
        cout << ' ' << setw(10) << elem.first
             << elem.second << endl;
    }
    cout << endl;

    // print all values for key "smart"
    string word("smart");
    cout << word << ": " << endl;
    for (auto pos = dict.lower_bound(word);
         pos != dict.upper_bound(word);
         ++pos) {
        cout << "   " << pos->second << endl;
    }

    // print all keys for value "raffiniert"
    word = ("raffiniert");
    cout << word << ": " << endl;
    for (const auto& elem : dict) {
        if (elem.second == word) {
            cout << "   " << elem.first << endl;
        }
    }
}
```
程序输出
```bash

 english   german 
--------------------
 car       Auto
 clever    raffiniert
 day       Tag
 smart     elegant
 smart     raffiniert
 smart     klug
 strange   fremd
 strange   seltsam
 trait     Merkmal
smart: 
   elegant
   raffiniert
   klug
raffiniert: 
   clever
   smart
```

### 查找具有某特定Value的元素
下面的例子示范了如何使用全局的find_if()算法查找具有某特定value的元素（对比于查找某特定key）：
```cc
#include <map>
#include <iostream>
#include <algorithm>
#include <utility>
using namespace std;

int main()
{
    // map with floats as key and value
    // - initializing keys and values are automatically converted to float
    map<float, float> coll = { {1,7}, {2,4}, {3,2}, {4,3},
                               {5,6}, {6,1}, {7,3} };

    // search an element with key 3.0 (logarithmic complexity)
    auto posKey = coll.find(3.0);
    if (posKey != coll.end()) {
        cout << "key 3.0 found ("
             << posKey->first << ":"
             << posKey->second << ")" << endl;
    }

    // search an element with value 3.0 (linear complexity)
    auto posVal = find_if(coll.begin(), coll.end(),
                          [] (const pair<float,float>& elem) {
                              return elem.second == 3.0;
                          });
    if (posVal != coll.end()) {
        cout << "value 3.0 found ("
             << posVal->first << ":"
             << posVal->second << ")" << endl;
    }
}
```
程序输出
```bash
key 3.0 found (3:2)
value 3.0 found (4:3)
```
### 综合实例：运用Map、String并于运行期指定排序准则
这里再示范一个例子，针对高级程序员而非STL初学者。你可以把它视为展现STL威力与疑难的一个范例。更明确地说，这个例子展现了以下技巧：
- 如何使用map，包括使用关联式数组（associative array）接口。
- 如何撰写和使用函数对象（function object）。
- 如何在运行期定义排序准则（sorting criterion）。
- 如何在“大小写无关”的情况下比较字符串（string）

```cc
// cont/mapcmp1.cpp
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <algorithm>
#include <cctype>
using namespace std;

// function object to compare strings
// - allows you to set the comparison criterion at runtime
// - allows you to compare case insensitive
class RuntimeStringCmp {
public:
    // constants for the comparison criterion
    enum cmp_mode { normal, nocase };

private:
    // actual comparison mode
    const cmp_mode mode;

    // auxiliary function to compare case insensitive
    static bool nocase_compare(char c1, char c2) {
        return toupper(c1) < toupper(c2);
    }

public:
    // constructor: initializes the comparison criterion
    RuntimeStringCmp(cmp_mode m = normal) : mode(m) {
    }

    // the comparison
    bool operator()(const string& s1, const string& s2) const {
        if (mode == normal) {
            return s1 < s2;
        } else {
            return lexicographical_compare(s1.begin(), s1.end(),
                                           s2.begin(), s2.end(),
                                           nocase_compare);
        }
    }
};

// container type:
// - map with
//   - string keys
//   - string values
//   - the special comparison object type
typedef map<string, string, RuntimeStringCmp> StringStringMap;

// function that fills and prints such containers
void fillAndPrint(StringStringMap& coll);

int main()
{
    // create a container with the default comparison criterion
    StringStringMap coll1;
    fillAndPrint(coll1);

    // create an object for case-insensitive comparisons
    RuntimeStringCmp ignorecase(RuntimeStringCmp::nocase);

    // create a container with the case-insensitive comparisons criterion
    StringStringMap coll2(ignorecase);
    fillAndPrint(coll2);
}

void fillAndPrint(StringStringMap& coll)
{
    // insert elements in random order
    coll["Deutschland"] = "Germany";
    coll["deutch"] = "German";
    coll["Haken"] = "snag";
    coll["arbeiten"] = "work";
    coll["Hund"] = "dog";
    coll["gehen"] = "go";
    coll["Unternehmen"] = "enterprise";
    coll["unternehmen"] = "undertake";
    coll["gehen"] = "walk";
    coll["Bestatter"] = "undertaker";

    // print elements
    cout.setf(ios::left, ios::adjustfield);
    for (const auto& elem : coll) {
        cout << setw(15) << elem.first << " "
             << elem.second << endl;
    }
    cout << endl;
}
```
程序输出
```bash

Bestatter       undertaker
Deutschland     Germany
Haken           snag
Hund            dog
Unternehmen     enterprise
arbeiten        work
deutch          German
gehen           walk
unternehmen     undertake
arbeiten        work
Bestatter       undertaker
deutch          German
Deutschland     Germany
gehen           walk
Haken           snag
Hund            dog
Unternehmen     undertake
```

## 无序容器（Unordered Container）
C++标准库称呼unordered容器为unordered associative容器。然而当我指称它们时，我只说unordered容器。
如果我说associative容器，我指的是旧式associative容器，也就是自C++98开始提供并被实现为binary tree的那些：set、multiset、map和multimap。


        Unordered set/multiset                                        Unordered Map/multimap                 
             ┌──────────────────────────────┐                              ┌──────────────────────────────┐  
             │          ┌──────┐            │                              │          ┌──────┐            │  
             │          │      │            │                              │          ├──────┤            │  
             │          └──────┘            │                              │          └──────┘            │  
             │    ┌──────┐   ┌──────┐       │                              │    ┌──────┐   ┌──────┐       │  
             │    │      │   │      │       │                              │    ├──────┤   ├──────┤       │  
             │    └──────┘   └──────┘       │                              │    └──────┘   └──────┘       │  
             │             ┌──────┐         │                              │             ┌──────┐         │  
             │             │      │         │                              │             ├──────┤         │  
             │             └──────┘         │                              │             └──────┘         │  
             └──────────────────────────────┘                              └──────────────────────────────┘  
                                              

概念上，unordered 容器以一种随意顺序包含你安插进去的所有元素。
也就是说，你可以把这个容器想成一个袋子（bag）：你可以放元素进去，但当你打开袋子对所有元素做某些事，你是以一种随机的次序来访问它们。
所以，相比于（multi）set和（multi）map，这里不需要排序准则；相比于sequence容器，你没有语义可用来放元素到某个特定位置。

就像各个associative容器那样，这里的个别class也互不相同：
- Unordered set和multiset存放的是某特定类型的个别value，而unordered map和multimap存放的元素都是key/value pair，其中key被用来作为“存放和查找某特定元素（包含相应的value）”的依据。
- Unordered set和map都不允许元素重复，而unordered multiset和multimap都允许。

在那里，上述四种类型分别被定义为namespace std内的class template：

```cc
namespace std {
    template <typename T,
              typename Hash = hash<T>,
              typename EqPred = equal_to<T>,
              typename Allocator = allocator<T>>
    class unordered_set;

    template <typename T,
              typename Hash = hash<T>,
              typename EqPred = equal_to<T>,
              typename Allocator = allocator<T>>
    class unordered_multiset;

    template <typename Key, typename T,
              typename Hash = hash<T>,
              typename EqPred = equal_to<T>,
              typename Allocator = allocator<pair<const Key, T>>>
    class unordered_map;

    template <typename Key, typename T,
              typename Hash = hash<T>,
              typename EqPred = equal_to<T>,
              typename Allocator = allocator<pair<const Key, T>>>
    class unordered_multimap;
}
```
一个unordered set或unordered multiset的元素类型，可以是任意指派的T，只要它是可比的（comparable）。

对于unordered map和unordered multimap，
第一个template参数是元素的key类型，
第二个template参数是元素的value类型。

一个unordered map或unordered multimap的元素可拥有任何类型的Key和T，只要它们满足以下两个条件：
- 1.Key和value都必须可被复制或可被搬移（copyable or movable）。
- 2.Key必须可被“等价准则”拿来比较（comparable with the equivalence criterion）。

注意，元素类型（value_type）是个pair<const Key,T>。

可有可无的第二或第三template参数用来定义hash function。如果没有指明使用哪个hash function，就使用默认的hash<>，
这是个function object，定义于＜functional＞，可用于所有整数类型、浮点数类型、pointer、string及若干特殊类型。
至于其他value类型，你必须传入你自己的hash function，

可有可无的第三或第四template参数用来定义等价准则（equivalence criterion）：这是一个predicate（判断式），用来查找元素。
它用来判断“两个value是否相等”。如果没有指定，就使用默认的equal_to<>，它会以operator==比较两个元素.

可有可无的第四或第五template参数用来定义内存模型。默认的内存模型（memory model）是allocator，由C++标准库提供。

### Unordered容器的能力
所有标准化unordered container class都以hash table为基础。
- 这些hash table使用chaining做法，于是一个hash code将被关联至一个linked list.
- 上述那些linked list是单链或双链，取决于实现。C++standard只保证它们的iterator“至少”是forward iterator。
- 关于rehashing（重新散列），有各式各样的实现策略：
  - 传统做法是，在单一insert或erase动作出现时，有时会发生一次内部数据重新组织。
  - 所谓递进式（incremental hashing）做法是，渐进改变bucket或slot的数量，这对即时（real-time）环境特别有用，因为在其中“突然放大hash table”的代价也许太高。

Unordered容器允许上述二种策略。

                              ┌───┐
                              │   │
                              ├───┤    ┌───┐
                              │   │───►│   │
              ┌───────┐       ├───┤    └───┘
              │hashfun│ ───►  │   │     
              └───────┘       ├───┤    ┌───┐    ┌───┐
                              │   ├───►│   │───►│   │
                              ├───┤    └───┘    └───┘
                              │   │
                              ├───┤
                              │   │
                                │
                                │
                                ▼

显示了unordered set或unordered multiset的典型内部布局，依据C++标准库给予的最低保证。
对于每个将被存放的value，hash function会把它映射至hash table内某个bucket （slot）中。
每个bucket管理一个单向linked list，内含所有“会造成hash function产出相同数值”的元素。

                              ┌───┐
                              │   │
                              ├───┤    ┌─┬─┐
                              │   │───►│ │ │
              ┌───────┐       ├───┤    └─┴─┘
              │hashfun│ ───►  │   │     
              └───────┘       ├───┤    ┌─┬─┐    ┌─┬─┐
                              │   ├───►│ │ │───►│ │ │
                              ├───┤    └─┴─┘    └─┴─┘
                              │   │
                              ├───┤
                              │   │
                                │
                                │
                                ▼

显示了unordered map或unordered multimap的典型内部布局，依据C++标准库给予的最低保证。
对于每个将被存放的元素（一个key/value pair），hash function会把key映射至hash table内的某个bucket （slot）中。
每个bucket管理一个单向linked list，内含所有“会造成hash function产出相同数值”的元素。

内部使用hash table，其主要优点是，它惊人的运行期行为。
假设拥有良好的hashing策略，并且有良好的实现，你可以保证在安插、删除、查找元素时获得摊提常量时间

Unordered容器的几乎所有操作——包括拷贝构造和赋值，元素的安插和寻找，以及等价比较——的预期行为，都取决于hash function的质量。
如果hash function对不同的元素竟产生相等数值（当一个允许元素重复的unordered容器带有等价的value或key，这也会发生），
hash table的任何操作都会导致低下的执行效率。这个缺点不完全是由于数据结构本身，也因为客户对此没有足够的意识。

Unordered容器比起寻常的associative容器，也有若干缺点：
- Unordered容器不提供operator＜、＞、＜=和＞=用以安排布置（order）这些容器的多重实例（multiple instance）。然而提供了==和！=（自从C++11）。
- 不提供lower_bound()和upper_bound()。
- 由于iterator只保证至少是个forward iterator，因此反向iterator包括rbegin()、rend()、crbegin()和crend()都不提供，你不能够使用那种要求获得bidirectional iterator的算法（或说至少这么做不具移植性）。
- 于元素的（key） value具体关系到元素的位置——这里指的是bucket entry——你不可以直接改动元素的（key） value。因此，很像associative容器那样，欲改动一个元素的value，你必须先移除拥有旧value的元素，然后安插一个拥有新value的新元素。这个接口反映出以下行为：
  - Unordered容器不提供“直接元素访问操作”。
  - 通过iterator进行的间接访问有其束缚：从iterator的角度观之，元素的（key） value是常量。

身为一个程序员，你可以指定若干会影响hash table行为的参数：
- 你可以指定bucket的最小数量。
- 你可以（并且有时候必须）提供你自己的hash function。
- 你可以（并且有时候必须）提供你自己的等价准则：它必须是个predicate（判断式），用来在bucket list的所有数据项中找出准确的元素。
- 你可以指定一个最大负载系数，一旦超过就会自动rehashing。
- 你可以强迫rehashing。

但是你不能够影响以下行为：
- 成长系数（growth factor），那是“自动rehashing”时用来成长或缩小list of buckets的系数。
- 最小负载系数（minimum load factor），用来强制进行rehashing（当容器中的元素个数缩减）。

注意，rehashing只可能发生在以下调用之后：insert()、rehash()、reserve()或clear()。

这是以下保证的自然结果：
erase()绝不会造成指向元素的iterator、reference和pointer失效。
因此，如果你删除数百个元素，bucket的大小并不会改变。
但如果你在那之后安插一个元素，bucket的大小就有可能缩小。

也请注意，在那些支持等价 key的容器内，也就是说在unordered multiset和 multimap 内，带有等价 key 的元素将会被相邻排列（当你逐一迭代容器的元素时）。
Rehashing以及其他“可能于内部改变元素次序”的操作，都会维持“带有等价key”的元素的相对次序。

### 创建和控制Unordered容器
Hash table是颇为复杂的数据结构。也因此，你有许多ability可以定义或查询它们的行为。

#### 创建、复制和销毁（Create，Copy，and Destroy）

Unordered容器的构造函数和析构函数:
| 操作 | 效果 |
| ---- | ---- |
| `Unord c` | Default 构造函数，建立一个 empty unordered 容器，不含任何元素 |
| `Unord c(bnum)` | 建立一个 empty unordered 容器，内部使用至少 `bnum` 个 bucket |
| `Unord c(bnum,hf)` | 建立一个 empty unordered 容器，内部使用至少 `bnum` 个 bucket 并以 `hf` 作为 hash function |
| `Unord c(bnum,hf,cmp)` | 建立一个 empty unordered 容器，内部使用至少 `bnum` 个 bucket，以 `hf` 为 hash function，并以 `cmp` 作为 predicate 用来鉴定等价 value |
| `Unord c(c2)` | Copy 构造函数，建立某个 unordered 容器的拷贝，类型相同（所有元素都被复制一份） |
| `Unord c = c2` | Copy 构造函数，建立某个 unordered 容器的拷贝，类型相同（所有元素都被复制一份） |
| `Unord c(rv)` | Move constructor: creates an unordered container, taking the contents of the rvalue `rv` (since C++11) |
| `Unord c = rv` | Move constructor: creates an unordered container, taking the contents of the rvalue `rv` (since C++11) |
| `Unord c(beg,end)` | 建立一个 unordered 容器，以区间 `[beg,end)` 内的元素为初值 |
| `Unord c(beg,end,bnum)` | 建立一个 unordered 容器，以区间 `[beg,end)` 内的元素为初值，内部使用至少 `bnum` 个 bucket |
| `Unord c(beg,end,bnum,hf)` | 建立一个 unordered 容器，以区间 `[beg,end)` 内的元素为初值，内部使用至少 `bnum` 个 bucket，以 `hf` 为 hash function |
| `Unord c(beg,end,bnum,hf,cmp)` | 建立一个 unordered 容器，以区间 `[beg,end)` 内的元素为初值，内部使用至少 `bnum` 个 bucket，以 `hf` 为 hash function，并以 `cmp` 作为 predicate 用来鉴定等价 value |
| `Unord c(initlist)` | 建立一个 unordered 容器，以初值列 `initlist` 中的元素为初值 |
| `Unord c = initlist` | 建立一个 unordered 容器，以初值列 `initlist` 中的元素为初值 |
| `c.~Unord()` | 销毁所有元素并释放内存 |

Unordered容器Unord的所有可能类型:
| `Unord` 具体类型 | 效果 |
| ---- | ---- |
| `unordered_set<Elem>` | 一个 unordered set，使用 `hash<>` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_set<Elem,Hash>` | 一个 unordered set，使用 `Hash` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_set<Elem,Hash,Cmp>` | 一个 unordered set，使用 `Hash` 作为默认的 hash 函数，使用 `Cmp` 作为默认的比较函数 |
| `unordered_multiset<Elem>` | 一个 unordered multiset，使用 `hash<>` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_multiset<Elem,Hash>` | 一个 unordered multiset，使用 `Hash` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_multiset<Elem,Hash,Cmp>` | 一个 unordered multiset，使用 `Hash` 作为默认的 hash 函数，使用 `Cmp` 作为默认的比较函数 |
| `unordered_map<Key,T>` | 一个 unordered map，使用 `hash<>` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_map<Key,T,Hash>` | 一个 unordered map，使用 `Hash` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_map<Key,T,Hash,Cmp>` | 一个 unordered map，使用 `Hash` 作为默认的 hash 函数，使用 `Cmp` 作为默认的比较函数 |
| `unordered_multimap<Key,T>` | 一个 unordered multimap，使用 `hash<>` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_multimap<Key,T,Hash>` | 一个 unordered multimap，使用 `Hash` 作为默认的 hash 函数，使用 `equal_to<>`（`operator ==`）作为默认的比较函数 |
| `unordered_multimap<Key,T,Hash,Cmp>` | 一个 unordered multimap，使用 `Hash` 作为默认的 hash 函数，使用 `Cmp` 作为默认的比较函数 | 

关于构建，有很多种实参传递形式。一方面，你可以传递众多value成为初始元素：
- 来自一个相同类型的既有容器（copy constructor）。
- 来自一个区间[begin，end）的所有元素。
- 来自一个初值列内的所有元素。

另一方面，你可以传递若干实参，用来影响unordered容器的行为：
- Hash函数（不是作为template实参，就是作为构造函数实参）。
- 等价准则（equivalence criterion）（不是作为template实参，就是作为构造函数实参）。
- Bucket的最初数量（作为构造函数实参）。

注意，你不可以指定最大负载系数（maximum load factor）成为类型的一部分，或是通过一个构造函数实参指定它，虽然这是你可能经常想要初始设定的东西。
欲指定最大负载系数，你必须在构建后立刻调用一个成员函数：
```cc
unordered_set<string> c;
c.max_load_factor(0.7);
```
传递给max_load_factor()的实参必须是个float。通常0.7～0.8是速度和内存消耗量之间一个不错的折中。
注意，默认的最大负载系数是1.0，意思是通常碰撞（collision）会在rehash之前发生。基于此，如果你很重视速度，应该总是明确地设置最大负载系数。

#### 布局操作（Layout Operation）
Unordered容器也提供了一些用来查询及影响内部布局的操作函数。

Unordered容器的布局操作:
| 操作                     | 效果                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `c.hash_function()`      | 返回 hash 函数                                               |
| `c.key_eq()`             | 返回“相等性判断式”（equivalence predicate）                  |
| `c.bucket_count()`       | 返回当前的 bucket 个数                                       |
| `c.max_bucket_count()`   | 返回 bucket 的最大可能数量                                   |
| `c.load_factor()`        | 返回当前的负载系数（load factor）                            |
| `c.max_load_factor()`    | 返回当前的最大负载系数（maximum load factor）                |
| `c.max_load_factor(val)` | 设定最大负载系数（maximum load factor）为 `val`               |
| `c.rehash(bnum)`         | 将容器 rehash，使其 bucket 个数至少为 `bnum`                  |
| `c.reserve(num)`         | 将容器 rehash，使其空间至少可拥有 `num` 个元素（始自 C++11） |

除了max_load_factor()，成员函数rehash()和reserve()也很重要。
它们提供“rehash一个unordered容器（也就是改变bucket个数）”的功能，但有略微不同的接口：
最初TR1只提供rehash()，它要求为hash table提供bucket的大小至少是“传入的大小”。
问题是，以此接口，你仍然必须考虑最大负载系数。如果最大负载系数是0.7而你打算准备100个元素，你必须将100除以0.7，以此计算“只要没超过100个元素就一定不会引发rehashing”的大小。
也就是说，你必须传入143给rehash()以避免在最高达到100个元素的情况下出现进一步rehashing。
如果使用reserve()，这一计算是内部进行的，所以你可以仅仅传递hash table应该筹备的元素个数：

```cc
c.rehash(100); // 准备 100/max_load_factor() 个元素
c.reserve(100); // 准备100个元素
```

利用bucket_count()，你可以查询unordered容器目前拥有的bucket个数。
这个值可被用于若干“提供了bucket接口”的成员函数，你可借此检阅一个unordered容器的精确内部状态。

#### 提供你自己的Hash函数
所有hash table都需要一个hash函数，把你放进去的元素的value映射至某个相关的bucket。
它的目标是，两个相等的value总是导致相同的bucket索引，而不同的value理应导致不同的bucket索引。对于任何范围的（被传入的） value，hash函数应该提供良好的hash value分布。
Hash函数必须是个函数，或function object，它接受一个元素类型下的value作为参数，并返回一个类型为std::size_t的value。
因此，bucket的当前数量并未被考虑。将其返回值映射至合法的bucket索引范围内，是由容器内部完成。
因此，你的目标是提供一个函数，可把不同的元素值均匀映射至区间[0，size_t）内。
下面示范如何提供你自己的hash函数：
```cc
#include <functional>

class Customer {
    ...
};

class CustomerHash {
public:
    std::size_t operator()(const Customer& c) const {
        return ...; // 原代码省略具体返回逻辑，可按实际实现哈希计算
    }
};

std::unordered_set<Customer, CustomerHash> custset;
```
在这里，CustomerHash是一个function object，为class Customer定义出hash函数。

如果不愿意传递一个function object成为容器类型的一部分，你也可以传递一个hash函数作为构造函数实参。
然而请注意，hash函数相应的template类型也必须对应设妥：
```cc
std::size_t customer_hash_func(const Customer &c) {
    return ...;
}
std::unordered_set<Customer, std::size_t(*)(const Customer &)>
     custset(20, customer_hash_func);
```
在这里，customer_hash_func()被传递为构造函数第二实参，其类型为“一个pointer，指向某函数，该函数接受一个Customer并返回一个std::size_t”，作为第二template实参。
如果没有给予特殊的hash函数，默认的hash函数是hash<>，那是＜functional＞提供的一个function object，
可对付常见类型：包括所有整数类型、所有浮点数类型、pointer、string，以及若干特殊类型。
这些之外的其他类型，你就必须提供你自己的hash函数。

提供一个好的hash函数，说来容易做来难。就像搭便车一样，你可以使用默认的hash函数来完成你自己的hash函数。
一个天真的做法是，单纯把那些数据栏“由默认之hash函数产生”的所有hash value加起来。举个例子：
```cc
class CustomerHash {
    public:
    std::size_t operator() (const Customer &c) const {
        return std::hash<string>()(c.fname) +
               std::hash<string>()(c.lname) +
               std::hash<long>()(c.no);
    }
};
```

这里，返回的hash value只不过是Customer的数据栏fname、lname和no的hash value总和。
如果预定义的所有hash函数对这些数据栏的类型以及所给予的值都能运作良好，那么三个值的总和必然也在[0，std::size_t）范围内。

然而专家认为，这仍然是个粗劣的hash函数。提供一个良好的hash函数可能是十分棘手的事，似乎不如想象中那么轻松。
一个较好的做法如下，使用由Boost提供的hash函数和一个便利接口：
```cc
#include <functional>

// from boost (functional/hash):
// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html
template <typename T>
inline void hash_combine (std::size_t& seed, const T& val)
{
    seed ^= std::hash<T>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// auxiliary generic functions to create a hash value using a seed
template <typename T>
inline void hash_val (std::size_t& seed, const T& val)
{
    hash_combine(seed, val);
}

template <typename T, typename... Types>
inline void hash_val (std::size_t& seed,
                      const T& val, const Types&... args)
{
    hash_combine(seed, val);
    hash_val(seed, args...);
}

// auxiliary generic function to create a hash value out of a heterogeneous list of arguments
template <typename... Types>
inline std::size_t hash_val (const Types&... args)
{
    std::size_t seed = 0;
    hash_val (seed, args...);
    return seed;
}
```
这里实现出一个辅助函数hash_val()，使用variadic template，允许调用时给予任意数量、任意类型的元素，然后逐一个别处理（计算） hash value。例如：
```cc
class CustomerHash {
    public:
        std::size_t operator() (const Customer &c) const {
            return hash_val(c.fname, c.lname, c.no);
        }
};
```
在其内部，hash_combine()会被调用。若干实验证明，它是“一般性hash函数”的优秀候选.
当hash函数的输入值有特殊约束，你可能会特别想要提供你专属的特殊hash函数。不论什么情况，若要验证你自己的hash函数的效果，可使用bucket接口.

#### 提供你自己的等价准则（Equivalence Criterion）
作为 unordered 容器类型的第三或第四template 参数，你可以传递等价准则（equivalence criterion），那应该是个predicate（判断式），用以找出同一个bucket内的相等value。
默认使用的是equal_to<>，它以operator==进行比较。
基于此，提供合法等价准则的最方便做法就是为你自己的类型提供operator==（如果它没被预定义为成员函数或全局函数）。例如：
```cc
class Customer {
    ...
};
bool operator==(const Customer &c1, const Customer &c2) {
    ...
}
unordered_multiset<Customer, CustomerHash> custset;
unordered_map<Customer, String, CustomerHash> custset;
```
然而，你也可以提供你自己的等价准则，例如：
```cc
#include <functional>

class Customer {
    ...
};

class CustomerEqual {
    public:
        bool operator() (const Customer &1, Customer &c2) const {
            return ...;
        }
};

unordered_set<Customer, CustomerHash, CustomerEqual> custset;
unordered_multimap<Customer, String, CustomerHash, CustomerEqual> custmap;
```
这里针对类型Customer定义了一个function object，你必须在其中实现operator()使它能够比较两个元素（对map而言是两个key）并返回一个bool值指示它们是否相等。
再说一次，你也可以使用lambda指定等价准则.

只要value在当前的等价准则下被视为相等，它们也应该在当前的hash函数下产出相同的hash value。
基于这个原因，一个unordered容器如果被实例化时带有一个非默认的等价准则，通常也需要一个非默认的hash函数。

### Unordered容器的其他操作
Unordered容器的其余操作，或多或少和其他associative容器相同。

#### 非更易型操作（Nonmodifying Operation）

Unordered容器的非更易型操作:
| 操作      | 效果 |
| --------- | ---- |
| `c.empty()`   | 返回是否容器为空（相当于 `size()==0` 但也许较快） |
| `c.size()`    | 返回目前的元素个数 |
| `c.max_size()`| 返回元素个数之最大可能量 |
| `c1 == c2`    | 判断是否 `c1` 等于 `c2` |
| `c1 != c2`    | 判断是否 `c1` 不等于 `c2`。等同于 `!(c1==c2)` |

再次注意，对比较而言，unordered容器只提供操作符==和!=。在最坏情况下，他们有可能提供二次复杂度（quadratic complexity）。

#### 特殊的查找操作（Special Search Operation）
Unordered容器对于快速查找元素有着优化设计。为了从这种行为中得利，这种容器提供特殊的查找函数。这些函数是寻常算法的特殊版本，有着相同名称。
你应该总是选择这些针对unordered容器的优化版本以达到常量时间复杂度，而不是寻常算法的线性复杂度，前提是hash value均匀分布。
举个例子，在一个拥有1 000个元素的集合中查找，平均只需1次比较动作，而不是associative容器的10次，也不是sequence容器的500次.

Unordered容器的特殊查找操作:
| 操作                | 效果                                                                 |
| ------------------- | -------------------------------------------------------------------- |
| `c.count(val)`      | 返回 “元素值为`val`” 的元素个数                                       |
| `c.find(val)`       | 返回 “元素值为`val`” 的第一个元素，如果找不到就返回尾后迭代器（原表述“返回`val`” 应为笔误，通常是返回尾后标识 ，结合容器查找逻辑修正 ） |
| `c.equal_range(val)`| 返回`val`可被安插的第一个位置和最后一个位置，也就是 “元素值`==val`” 的元素区间 | 

#### Assignment
Unordered容器的赋值操作:
| 操作                | 效果                                                                 |
| ------------------- | -------------------------------------------------------------------- |
| `c = c2`            | 将 `c2` 的全部元素赋值给 `c`                                           |
| `c = rv`            | 将 rvalue `rv` 的所有元素以 move assign 方式给予 `c`（始自 C++11）      |
| `c = initlist`      | 将初值列 `initlist` 的所有元素赋值给 `c`（始自 C++11）                 |
| `c1.swap(c2)`       | 置换 `c1` 和 `c2` 的数据                                              |
| `swap(c1, c2)`      | 置换 `c1` 和 `c2` 的数据                                              | 

这些操作的左右两端容器必须有相同类型，更明确地说是其 hash function 的类型以及equivalence criterion （等价准则）必须相同——即使hash函数本身可能不同。
如果hash函数不同，它们将能够被赋值或交换（assigned or swapped）。

#### 迭代器相关函数和元素访问
Unordered容器并不允许“直接元素访问”，所以你必须使用range-based for循环或iterator。
由于这些iterator只保证是forward iterator，不支持bidirectional iterator或random-access iterator。
因此，你不能够在“只为bidirec-tional iterator或random-access iterator而提供”的算法中使用它们，那些算法往往是针对sort-ing或random shuffling的。

对于unordered （multi）set，从iterator的角度观之，所有元素都被视为const。
对于un-ordered （multi）map，所有元素的key都被视为const。这是必要的，确保你无法（不会）因为改变元素的value而危及元素位置。
虽然元素之间“无定序”（no specific order），但value会在当前hash函数的作用下决定其所属的bucket位置。
基于这个因素，你不可以为元素调用任何更易型（modifying）算法。例如你不可以调用算法remove（），因为它的移除动作是“以后继元素覆盖掉被移除元素”。
如果真想要在unordered set/multiset内移除元素，你唯一可使用的是容器提供的成员函数。

Unordered容器的迭代器操作:
| 操作          | 效果                                                         |
| ------------- | ------------------------------------------------------------ |
| `c.begin()`   | 返回一个 forward iterator 指向第一元素                       |
| `c.end()`     | 返回一个 forward iterator 指向最末元素的下一位置             |
| `c.cbegin()`  | 返回一个 const forward iterator 指向第一元素（始自 C++11）    |
| `c.cend()`    | 返回一个 const forward iterator 指向最末元素的下一位置（始自 C++11） |
| `c.rbegin()`  | 返回一个反向的（reverse）iterator 指向反向迭代的第一元素      |
| `c.rend()`    | 返回一个反向的（reverse）iterator 指向反向迭代的最末元素的下一位置 |
| `c.crbegin()` | 返回一个 const reverse iterator 指向反向迭代的第一元素（始自 C++11） |
| `c.crend()`   | 返回一个 const reverse iterator 指向反向迭代的最末元素的下一位置（始自 C++11） |

与 map/multimap 对应，unordered map/multimap 的元素类型是pair<const Key，T>，意味着你需要first和second才能访问一个元素的key和value:
```cc
unordered_map<string, float> coll;
...
for (auto &elem : coll) {
    cout << "key : " << elem.first << " value : " << elem.second << endl;
}
...
for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
    cout << "key : " << pos->first << " value : " << pos->second << endl;
}
```
尝试改变key值会导致错误：
```cc
elem.first = "aa"; //err
pos->first = "aa"; //err
```
改变元素的value就没问题，只要elem是个non-const reference且value的类型不是const：
```cc
elem.second = 11.1;
pos->second = 11.1;
```
如果你使用算法和lambda来操作map内的元素，你必须明确声明元素类型：
```cc
unordered_map<string, float> coll;
...
for_each(coll.begin(), coll.end(), 
     [](pair<const std::string, int> &elem) {
         elem.second += 10;
     })
```
代替写成
```cc
pair<const std::string, int>
```
你也可以写成
```cc
unordered_map<std::string, int>::value_type
```
或
```cc
decltype(coll)::value_type
```

若要改变元素的key，只有一个选择：必须以一个新元素替换旧元素，二者有相同的value。

注意，unordered map也可用作associative array，所以你可以使用下标操作符（subscript operator）来处理元素。

也请注意，存在一个额外的iterator接口，可用来遍历一个unordered容器的bucket。

#### 安插和移除元素（Inserting and Removing Element）

| 操作 | 效果 |
| ---- | ---- |
| `c.insert(val)` | 安插一个 `val` 拷贝，返回新元素位置，不论是否成功——对 unordered container 而言 |
| `c.insert(pos, val)` | 安插一个 `val` 拷贝，返回新元素位置（`pos` 是个提示，指出安插动作的查找起点。若提示恰当可加快速度） |
| `c.insert(beg, end)` | 将区间 `[beg, end)` 内所有元素的拷贝安插到 `c`（无返回值） |
| `c.insert(initlist)` | 安插初值列 `initlist` 内所有元素的一份拷贝（无返回值；始自 C++11） |
| `c.emplace(args...)` | 安插一个以 `args` 为初值的元素，并返回新元素的位置，不论是否成功——对 unordered container 而言（始自 C++11） |
| `c.emplace_hint(pos, args...)` | 安插一个以 `args` 为初值的元素，并返回新元素的位置（`pos` 是个提示，指出安插动作的查找起点。若提示恰当可加快速度） |
| `c.erase(val)` | 移除“与 `val` 相等”的所有元素，返回被移除的元素个数 |
| `c.erase(pos)` | 移除 iterator 位置 `pos` 上的元素，无返回值 |
| `c.erase(beg, end)` | 移除区间 `[beg, end)` 内的所有元素，无返回值 |
| `c.clear()` | 移除所有元素，将容器清空 |

依STL惯例，你必须保证传入的实参合法：
- （1）迭代器必须指向一个合法位置，
- （2）区间的起始位置不能在结束位置之后。

一般而言，抹除（erasing）函数并不会令“指向至其他元素”的iterator和reference失效。
然而成员函数insert()和emplace()有可能令所有iterator失效，当rehashing发生，尽管指向至元素的reference将总是保持有效。
Rehashing之所以发生，是由于一次安插动作造成最终的元素个数大于等于bucket数量乘以最大负载系数（也就是说，当最大负载系数提供的保证被打破）。
insert()和emplace()成员函数不会影响指向容器元素的reference的有效性。

处理多个元素的安插和移除时，对区间内的所有元素使用单一调用，会比多次调用更快速。然而请注意，“异常保证”在“多重元素操作函数”中会降低.

注意，安插函数insert()和emplace()的返回类型差别如下：

- Unordered set提供以下接口：
```cc
pair<iterator, bool> insert(const value_type& val);
iterator insert(iterator posHint, const value_type& val);

template <typename... Args>
pair<iterator, bool> emplace(Args&&... args);
template <typename... Args>
iterator emplace_hint(const_iterator posHint, Args&&... args);

```
- Unordered multiset提供以下接口:
```cc
iterator insert(const value_type& val);
iterator insert(iterator posHint, const value_type& val);

template <typename... Args>
iterator emplace(Args&&... args);
template <typename... Args>
iterator emplace_hint(const_iterator posHint, Args&&... args);
```

返回类型不同，起因于unordered multiset/multimap允许元素重复，而unordered set/map不允许。
因此，对一个unordered set而言，安插元素可能失败（如果容器已含相同value的元素）。
于是，set返回的是被包裹在pair结构内的两个value：
- 1.pair结构的second成员表示安插是否成功。
- 2.pair结构的first成员表示新插元素的位置或既有元素的位置。

这些函数返回新元素的位置或既有元素的位置——如果unordered set已内含一个带有相同value的元素。

对于unordered map/multimap，若欲安插一个key/value pair，你必须牢记在心，其内部把key视为const。
你提供的若非准确的类型，就必须存在隐式或显式类型转换。

自C++11开始，安插元素的最方便方法就是把它们放进一个初值列（initializer list），其中第一项是key，而第二项是value：
```cc
unordered_map<string, float> coll;
...
coll.insert({"aa", 33.3});
```
另外，还有三种办法可将一个value放进一个unordered map/multimap中，这些已在map/multimap中介绍过:
- 1.使用value_type：
```cc
std::unordered_map<std::string, float> coll1;
...
coll1.insert(std::unordered_map<std::string, float>::value_type("otto", 22.3));
coll1.insert(decltype(coll1)::value_type("otto", 22.3));
```
- 2. 使用pair<>：
```cc
std::unordered_map<std::string, float> coll2;
...
coll2.insert(std::pair<std::string, float>("otto", 22.3));
coll2.insert(std::pair<const std::string, float>("otto", 22.3));
```
- 3. 使用 make_pair()
```cc
std::unordered_map<std::string, float> coll3;
...
coll3.insert(std::make_pair("otto", 22.3));
```
下面是个简单例子，安插元素到unordered map内，并检查是否成功：

```cc
unordered_map<string, float> coll;
...
if (coll.insert(make_pair("aa", 33.3)).second) {
    cout << "insert ok" << endl;
}
else {
    cout << "insert err, elem is already exists" << endl;
}
```
再请注意，当使用emplace()安插新元素（你得传递数值用以构建新元素）时，必须传递两列实参：一个用于key，另一个用于元素（的value）。最方便的写法是这样：
```cc
unordered_map<string, std::complex<float>> m;
m.emplace(std::piecewise_construct,   // 使用tuple传递参数
          make_tuple("hello"),        // key
          make_tuple(33.3, 11,1));    // value
```

请注意，unordered map还提供另一个方便方式，以subscript（下标）操作符安插和设定元素.

若欲移除带有某个value的元素，只需调用erase()：
```cc
unordered_set<int> coll;
...
coll.erase(val);
```

这个成员函数的名称不同于list的remove()，其行为也不相同，返回的是被移除元素的个数。如果由unordered map调用之，它只返回0或1。
如果一个unordered multiset/multimap内含重复元素，且你只想移除其中的第一个元素，不可以使用erase()。应该这么做：
```cc
unordered_multimap<key, T> coll;
...
auto pos = coll.find(val);
if (pos != coll.end()) {
    coll.erase(pos);
}
```
在这儿你应该使用成员函数find()，它比算法find()快速.

当你打算移除元素，小心不要锯断你正坐着的树枝。

### Bucket接口
我们有可能通过一个特定的bucket接口访问个别bucket，用以曝露整个hash table的内部状态。

| 操作                | 效果                                                                 |
| ------------------- | -------------------------------------------------------------------- |
| `c.bucket_count()`  | 返回当前的 bucket 个数                                               |
| `c.bucket(val)`     | 返回 `val` 将（或可能）被找到的那个 bucket 的编号                     |
| `c.bucket_size(bucketidx)` | 返回第 `bucketidx` 个 bucket 所含的元素个数                         |
| `c.begin(bucketidx)` | 返回一个 forward iterator，指向第 `bucketidx` 个 bucket 中的第一元素   |
| `c.end(bucketidx)`   | 返回一个 forward iterator，指向第 `bucketidx` 个 bucket 中的最末元素的下一位置 |
| `c.cbegin(bucketidx)` | 返回一个 const forward iterator，指向第 `bucketidx` 个 bucket 中的第一元素 |
| `c.cend(bucketidx)`   | 返回一个 const forward iterator，指向第 `bucketidx` 个 bucket 中的最末元素的下一位置 |

### 使用Unordered Map作为Associative Array
| 操作       | 效果                                                         |
| ---------- | ------------------------------------------------------------ |
| `c[key]`   | 安插一个带着 `key` 的元素——如果尚未存在于容器内。返回一个 reference 指向带着 `key` 的元素（仅适用于非 const 的 unordered maps） |
| `c.at(key)` | 返回一个 reference 指向带着 `key` 的元素（始自 C++11）        |

就像map一样，unordered map也提供一个subscript（下标）操作符用来直接元素访问，还提供一个相应的成员函数at()

at()会根据它所收到的key产出对应元素的value，如果该元素不存在则会抛出一个类型为out_of_range的异常。

对于操作符[]，其索引也就是用来识别元素的key。这意味着操作符[]的索引可能是任何类型，而非只是整数类型。这样的接口，也就是所谓的associative array接口。

关于操作符[]，索引类型并不是它和寻常C-style array的唯一不同。请注意，你不能给出错误的索引；
如果你指定某个key为索引，却找不到对应的元素，就会有一个新元素被自动安插到map内。
该新元素的value将由其类型的default构造函数初始化。
因此，欲使用这一特性，你就不能指定一个没有default构造函数的value类型。
注意，所有基础类型都提供有一个default构造函数，将初值设为0.

### 异常处理（Exception Handling）
Unordered容器是一种以节点为基础（node-based）的容器，所以，构建节点一旦失败，不过就是使容器回到原先状态而已。
然而由于“可能发生rehashing”，下列保证适用于所有unordered容器：
- “单元素安插”拥有commit-or-rollback（要么成功要么无效）行为，前提是hash函数和“等价准则”不抛出异常。而如果它们不抛出异常，它们要么成功，要么就“无作用”。
- erase()不抛出异常，前提是hash函数和“等价准则”不抛出异常——那正是默认使用之函数的情况。
- 没有任何clear()函数会抛出异常。
- 没有任何swap()函数会抛出异常，前提是hash的“copy构造函数”或“copy assignment操作符”或“等价比较函数”不抛出异常。
- rehash()有着commit-or-rollback（要么成功要么无效）行为，前提是hash函数和“等价比较函数”不抛出异常。而如果它们不抛出异常，它们要么成功，要么“无作用”。

### Unordered容器的运用实例
下列程序示范了unordered容器的基本能力，采用的是unordered set：

```cc
// cont/unordset1.cpp
#include <unordered_set>
#include <numeric>
#include "print.hpp"
using namespace std;

int main()
{
    // create and initialize unordered set
    unordered_set<int> coll = { 1,2,3,5,7,11,13,17,19,77 };

    // print elements
    // elements are in arbitrary order
    PRINT_ELEMENTS(coll);

    // insert some additional elements
    // might cause rehashing and create different order
    coll.insert({ -7,17,33,-11,17,19,1,13 });
    PRINT_ELEMENTS(coll);

    // remove element with specific value
    coll.erase(33);

    // insert sum of all existing values
    coll.insert(accumulate(coll.begin(), coll.end(), 0));
    PRINT_ELEMENTS(coll);

    // check if value 19 is in the set
    if (coll.find(19) != coll.end()) {
        cout << "19 is available" << endl;
    }

    // remove all negative values
    unordered_set<int>::iterator pos;
    for (pos = coll.begin(); pos != coll.end(); ) {
        if (*pos < 0) {
            pos = coll.erase(pos);
        }
        else {
            ++pos;
        }
    }
    PRINT_ELEMENTS(coll);
}
```

如果你只是安插、抹除、查找（insert，erase，and find）带有某特定value的元素，unordered容器会提供最佳运行期行为，因为所有这些操作都有摊提（amortized）常量复杂度。
然而你不可对元素次序有任何假设。例如，这个程序可能有以下输出：
```bash
77 11 1 13 2 3 5 17 7 19
-11 1 2 3 -7 5 7 77 33 11 13 17 19
-11 1 2 3 -7 5 7 77 11 13 17 19 137
19 is available
1 2 3 5 7 77 11 13 17 19 137
```
至于其他任何事情——例如累加容器内所有元素的value或找出并移除所有负值——都必须遍历所有元素（不论是借由iterator直接进行，或使用一个range-based for循环间接进行）。
如果使用unordered multiset而不是unordered set，就允许元素重复。例如以下程序：
```cc
#include <unordered_set>
#include "print.hpp"
using namespace std;

int main()
{
    // create and initialize, expand, and print unordered_multiset
    unordered_multiset<int> coll = { 1,2,3,5,7,11,13,17,19,77 };
    coll.insert({ -7,17,33,-11,17,19,1,13 });
    PRINT_ELEMENTS(coll);

    // remove all elements with specific value
    coll.erase(17);

    // remove one of the elements with specific value
    auto pos = coll.find(13);
    if (pos != coll.end()) {
        coll.erase(pos);
    }
    PRINT_ELEMENTS(coll);
}
```

### 提供你自己的Hash函数和等价准则

下面的程序展示了如何为类型Customer定义及指定一个hash函数和一个等价准则。该类型用作一个unordered set的元素类型：
```cc
#include <unordered_set>
#include <string>
#include <iostream>
#include "hashval.hpp"
#include "print.hpp"

using namespace std;

class Customer {
private:
    string fname;
    string lname;
    long no;
public:
    Customer(const string& fn, const string& ln, long n)
        : fname(fn), lname(ln), no(n) {}
    friend ostream& operator<<(ostream& strm, const Customer& c) {
        return strm << "[" << c.fname << "," << c.lname << ","
                    << c.no << "]";
    }
    friend class CustomerHash;
    friend class CustomerEqual;
};

class CustomerHash {
public:
    std::size_t operator()(const Customer& c) const {
        return hash_val(c.fname, c.lname, c.no);
    }
};

class CustomerEqual {
public:
    bool operator()(const Customer& c1, const Customer& c2) const {
        return c1.no == c2.no;
    }
};

int main() {
    // unordered set with own hash function and equivalence criterion
    unordered_set<Customer, CustomerHash, CustomerEqual> custset;

    custset.insert(Customer("nico", "josuttis", 42));
    PRINT_ELEMENTS(custset);
}
```
程序输出如下：
```bash
[nico,josuttis,42]
```
这里的辅助函数hash_val()可处理任意数量、任意类型的元素，曾在前面现过。

如你所见，等价函数所核算的value，并非一定得和hash函数所核算的value相同。
然而先前我也说过，应该有这样的保证：“被等价准则判定为相等”的value，应该要能够获得相同的hash value（那也就是间接假设customer的No.是独一无二的）。

如果不指定等价函数，custset的声明式应该如下：
```cc
unordered_set<Customer, CustomerHash> custset;
```
而operator==将会被用作等价准则，你必须为Customer定义这个操作符。
你也可以使用一个寻常函数作为hash函数。但这么一来你必须传递此函数，作为构造函数实参，意思是你也必须传递bucket的初始量，并指定对应的function pointer作为第二template参数

### 使用Lambda作为Hash函数和等价准则
你甚至可以使用lambda具体指定hash函数和/或等价准则。例如：
```cc
#include <string>
#include <iostream>
#include <unordered_set>
#include "hashval.hpp"
#include "print.hpp"

using namespace std;

class Customer {
private:
    string fname;
    string lname;
    long no;
public:
    Customer(const string& fn, const string& ln, long n)
        : fname(fn), lname(ln), no(n) {}
    string firstname() const {
        return fname;
    }
    string lastname() const {
        return lname;
    }
    long number() const {
        return no;
    }
    friend ostream& operator<<(ostream& strm, const Customer& c) {
        return strm << "[" << c.fname << "," << c.lname << ","
                    << c.no << "]";
    }
};

int main() {
    // lambda for user-defined hash function
    auto hash = [](const Customer& c) {
        return hash_val(c.firstname(), c.lastname(), c.number());
    };

    // lambda for user-defined equality criterion
    auto eq = [](const Customer& c1, const Customer& c2) {
        return c1.number() == c2.number();
    };

    // create unordered set with user-defined behavior
    unordered_set<Customer, decltype(hash), decltype(eq)> custset(10, hash, eq);

    custset.insert(Customer("nico", "josuttis", 42));
    PRINT_ELEMENTS(custset);
}
```

注意，你必须使用decltype产生lambda类型，使得以传递它作为 unordered容器声明式的template实参。
原因是lambda并不存在default构造函数和assignment操作符。
因此，你也必须将lambda传给构造函数。而由于它们被设计为第二和第三实参，因此这种情况下你必须指明最初的bucket大小，本例为10。

### Bucket接口使用实例

下面的例子示范了bucket接口的应用，用来检阅一个unordered容器的内部状态。
在printHashTableState()内，整个状态，包括unordered容器的详细布局，被打印了出来：
```cc
#include <iostream>
#include <iomanip>
#include <utility>
#include <iterator>
#include <typeinfo>

// generic output for pairs (map elements)
template <typename T1, typename T2>
std::ostream& operator << (std::ostream& strm, const std::pair<T1,T2>& p)
{
    return strm << "[" << p.first << "," << p.second << "]";
}

template <typename T>
void printHashTableState (const T& cont)
{
    // basic layout data:
    std::cout << "size:                 " << cont.size() << "\n";
    std::cout << "buckets:              " << cont.bucket_count() << "\n";
    std::cout << "load factor:          " << cont.load_factor() << "\n";
    std::cout << "max load factor:      " << cont.max_load_factor() << "\n";

    // iterator category:
    if (typeid(typename std::iterator_traits<typename T::iterator>::iterator_category)
        == typeid(std::bidirectional_iterator_tag)) {
        std::cout << "chaining style:  doubly-linked" << "\n";
    }
    else {
        std::cout << "chaining style:  singly-linked" << "\n";
    }

    // elements per bucket:
    std::cout << "elements per bucket:" << "\n";
    for (auto idx=0; idx != cont.bucket_count(); ++idx) {
        std::cout << " b[" << std::setw(2) << idx << "]: ";
        for (auto pos=cont.begin(idx); pos != cont.end(idx); ++pos) {
            std::cout << *pos << " ";
        }
        std::cout << "\n";
    }
    std::cout << std::endl;
}

#include <unordered_set>
#include <iostream>
#include <initializer_list>  // 为初始化列表支持（虽然可能编译器自动包含，但显式更规范）
#include "buckets.hpp"

int main()
{
    // create and initialize an unordered set
    std::unordered_set<int> intset = { 1,2,3,5,7,11,13,17,19 };
    printHashTableState(intset);

    // insert some additional values (might cause rehashing)
    intset.insert({ -7,17,33,4 });  // 注意：原代码这里 4 后面的 “}” 是中文符号，实际应是英文，已修正
    printHashTableState(intset);
}
```

下面这个程序是bucket接口应用的另一个例子，建立一个“以string value映射至另一个string value”的字典:
```cc
#include <unordered_map>
#include <string>
#include <iostream>
#include <utility>
#include "buckets.hpp"
using namespace std;

int main()
{
    // create and initialize an unordered multimap as dictionary
    unordered_multimap<string, string> dict = {
        {"day", "Tag"},
        {"strange", "fremd"},
        {"car", "Auto"},
        {"smart", "elegant"},
        {"trait", "Merkmal"},
        {"strange", "seltsam"}
    };
    printHashTableState(dict);

    // insert some additional values (might cause rehashing)
    dict.insert({
        {"smart", "raffiniert"},
        {"smart", "klug"},
        {"clever", "raffiniert"}
    });
    printHashTableState(dict);

    // modify maximum load factor (might cause rehashing)
    dict.max_load_factor(0.7);
    printHashTableState(dict);
}
```
注意，任何情况下，rehashing都会保留（维护）等价元素的相对次序。然而，等价元素的次序有可能不匹配它们的安插次序。

## 其他STL容器
STL是个框架，除了提供标准容器，也允许你使用其他数据结构作为容器。
你可以使用string或寻常array作为 STL容器，也可以自行撰写特殊容器满足特殊需求。
如果你自行撰写容器，仍可从诸如排序、合并等算法中受益。
这样的框架正是“开放-封闭”（Open Closed）守则——开放以允许扩展，封闭以谢绝修改——的极佳范例。

下面是使你的容器“STL化”的三种不同方法：
- 1. The invasive approach （侵入式做法）。直接提供 STL 容器所需接口。特别是诸如begin()和end()之类的常用函数。这种做法需以某种特定方式编写容器，所以是侵入式的。
- 2. The noninvasive approach （非侵入式做法）。撰写或提供特殊迭代器，作为算法和特殊容器间的接口。这一做法是非侵入式的，它所需要的只是“遍历容器所有元素”的能力——这是任何容器都能以某种形式展现的能力。
- 3. The wrapper approach （包裹法）。将上述两种方法加以组合，我们可以写一个包裹类（wrapper class）来包装任何数据结构，并显露出与STL容器相似的接口。

本小节首先将string视为标准容器来讨论，当作侵入式做法的一个例子，然后再以非侵入式做法讨论重要的标准容器：寻常的C-style array。当然你也可以使用包裹法来访问array的数据。

任何STL容器都应该能够以不同的分配器（allocator）加以参数化。C++标准库提供了一些特殊函数和类，帮助你撰写分配器并对付尚未初始化的内存。

### String作为一种STL容器
C++标准库的string class，是“以侵入式做法编写STL容器”的一个好例子。
String可被视为“以字符为元素”的一种容器；字符构成序列，你可以在该序列来回移动遍历。
因此，标准的string class提供了STL容器接口。String也提供成员函数begin()和end()，返回随机访问迭代器，可用来遍历整个string。
同时，为了支持迭代器和迭代器适配器，string也提供若干操作函数如push_back()，用以支持back inserter。

从STL角度思考，string的处理有点不寻常，因为你通常将string当作一个对象来处理（可以传递、复制或设定string）。
但如果要对单个字符进行处理，采用STL算法将大有助益。例如可以采用istream迭代器读取字符，或转换string内的字符（例如转成大写或小写）。
此外，通过STL算法，可以对string采取特殊的比较规则——标准string接口并不提供这种能力。

### C-Style Array作为一种STL容器
你可以把寻常的 C-style array 当成 STL 容器使用，但这种 array 并不是 class，所以不提供begin()和end()等成员函数，也不允许存在任何成员函数。
这里，我们只能采用非侵入式做法或包裹法。

采取非侵入式做法很简单，你只需要对象，它能够借由STL迭代器接口遍历array的所有元素。
事实上这样的对象早就恭候多时，就是寻常的pointer。
STL设计之初就决定让迭代器拥有和寻常pointer一样的接口，于是你可以将寻常pointer当成迭代器来使用。
这又一次展示了纯抽象的泛化概念：任何东西只要“行为类似迭代器”就是一种迭代器。事实上pointer正是一个随机访问迭代器。
以下例子示范了如何以C-style array作为STL容器（始自C++11）：

```cc
#include <iterator>
#include <vector>
#include <iostream>

int main()
{
    int vals[] = { 33, 67, -4, 13, 5, 2 };

    // use begin() and end() for ordinary C arrays
    std::vector<int> v(std::begin(vals), std::end(vals));

    // use global begin() and end() for containers:
    std::copy(std::begin(v), std::end(v),
              std::ostream_iterator<int>(std::cout, " "));
    std::cout << std::endl;
}
```

这里我们使用了一个定义于`<iterator>`的辅助函数，以及任何一个“允许针对寻常C-style array 使用全局性begin()和end()”的容器头文件。
如你所见，对于任何寻常的 C-style array vals，std::begin()和std::end()产出对应的起点和终点（可被STL框架使用）：
```cc
int vals[] = {1, 2, 3};
std::begin(vals); // vals
std::end(vals);   // vals + sizeof(vals)/sizeof(*vals)
```
这些函数有重载版本，所以你可以把它们用在STL容器或任何提供begin()和end()成员函数的class：
```cc
vector<int> v;
std::begin(v); // v.begin()
std::end(v);   // v.end()
```
在C++11之前，你必须传递raw pointer给算法，因为彼时的begin()和end()无全局版本。例如：
```cc
#include <iostream>
#include <algorithm>
#include <functional>
#include <iterator>
using namespace std;

int main()
{
    int coll[] = { 5, 6, 2, 4, 1, 3 };

    // square all elements
    transform (coll, coll+6,      // first source
               coll,              // second source
               coll,              // destination
               multiplies<int>());// operation

    // sort beginning with the second element
    sort (coll+1, coll+6);

    // print all elements
    copy (coll, coll+6,
          ostream_iterator<int>(cout," "));
    cout << endl;
}
```
千万注意，一定要传递array的正确尾部位置，这里是coll+6。记住，一定要确保区间尾端是最末元素的下一位置。

## 实现Reference语义
通常，STL容器提供的是“value语义”而非“reference语义”，后者构建了元素的内部拷贝，任何操作返回的也是这些拷贝。
总之，要在STL容器中用到“reference语义”（不论是因为元素的复制代价太大，或因为需要在不同集合中共用同一个元素），就要采用smart pointer class，避免可能的差错。
此外，使用reference wrapper也可行。

### 使用Shared Pointer

C++标准库提供了许多smart pointer class。如果你打算在不同的容器之间共享对象，class shared_ptr<>是适当的选择。以此目的来使用它，看起来如下：
```cc
#include <iostream>
#include <string>
#include <set>
#include <deque>
#include <algorithm>
#include <memory>

class Item {
private:
    std::string name;
    float price;
public:
    Item(const std::string& n, float p = 0) : name(n), price(p) {}
    std::string getName() const {
        return name;
    }
    void setName(const std::string& n) {
        name = n;
    }
    float getPrice() const {
        return price;
    }
    float setPrice(float p) {
        price = p;
        return price;
    }
};

template <typename Coll>
void printItems(const std::string& msg, const Coll& coll) {
    std::cout << msg << std::endl;
    for (const auto& elem : coll) {
        std::cout << "  " << elem->getName() << ": "
                  << elem->getPrice() << std::endl;
    }
}

int main() {
    using namespace std;

    // two different collections sharing items
    typedef shared_ptr<Item> ItemPtr;
    set<ItemPtr> allItems;
    deque<ItemPtr> bestsellers;

    // insert objects into the collections
    // - bestsellers are in both collections
    bestsellers = { ItemPtr(new Item("Kong Yize", 20.10)),
                    ItemPtr(new Item("A Midsummer Night's Dream", 14.99)),
                    ItemPtr(new Item("The Maltese Falcon", 9.88)) };
    allItems = { ItemPtr(new Item("Water", 0.44)),
                 ItemPtr(new Item("Pizza", 2.22)) };
    allItems.insert(bestsellers.begin(), bestsellers.end());

    // print contents of both collections
    printItems("bestsellers:", bestsellers);
    printItems("all:", allItems);
    cout << endl;

    // double price of bestsellers
    for_each(bestsellers.begin(), bestsellers.end(),
             [](shared_ptr<Item>& elem) {
                 elem->setPrice(elem->getPrice() * 2);
             });

    // replace second bestseller by first item with name "Pizza"
    bestsellers[1] = *(find_if(allItems.begin(), allItems.end(),
                               [](shared_ptr<Item> elem) {
                                   return elem->getName() == "Pizza";
                               }));

    // set price of first bestseller
    bestsellers[0]->setPrice(44.77);

    // print contents of both collections
    printItems("bestsellers:", bestsellers);
    printItems("all:", allItems);
}
```
程序输出
```bash
bestsellers:
  Kong Yize: 20.1
  A Midsummer Night's Dream: 14.99
  The Maltese Falcon: 9.88
all:
  Kong Yize: 20.1
  Water: 0.44
  A Midsummer Night's Dream: 14.99
  The Maltese Falcon: 9.88
  Pizza: 2.22
bestsellers:
  Kong Yize: 44.77
  Pizza: 2.22
  The Maltese Falcon: 19.76
all:
  Kong Yize: 44.77
  Water: 0.44
  A Midsummer Night's Dream: 29.98
  The Maltese Falcon: 19.76
  Pizza: 2.22
```
注意，使用shared_ptr<>会让事情变复杂。
例如，面对set使用find()，会找出拥有相等value的元素，现在比较的却是内部（由new返回）的pointer：
```cc
allItems.find(ItemPtr(new Item("Pizza", 2.22))); // error
```
所以，这里必须使用find_if()算法。

如果你调用一个辅助函数，将容器内的一个元素（一个ItemPtr）存储于某处，它所指向的那个value将持续有效，纵使容器被销毁，或其所有元素被移除。

### 使用Reference Wrapper
假设保证“只要容器存在，被指向的元素一定存在”，那就可以换一种方法：使用 class reference_wrapper<>。
以下是可能的，采用前一例引入的 class Item：
```cc
    std::vector<std::reference_wrapper<Item>> books;  // elements are references

    Item f("Faust", 12.99);
    books.push_back(f);    // insert book by reference

    // print books:
    for (const auto& book : books) {
        std::cout << book.get().getName() << ": "
                  << book.get().getPrice() << std::endl;
    }

    f.setPrice(9.99);  // modify book outside the containers
    std::cout << books[0].get().getPrice() << std::endl;  // print price of first book

    // print books using type of the elements (no get() necessary):
    for (const Item& book : books) {
        std::cout << book.getName() << ": " << book.getPrice() << std::endl;
    }
```
这种做法的优点是不需要pointer语法。然而这也是个风险，因为此处使用reference并非显而易见。

注意，以下声明不可行：
```cc
vector<Item &> books;
```
也请注意，class reference_wrapper<>提供一个转换操作符，转换为T&，如此一来range-based for循环就可以被声明为处理“类型为Item&”的元素。
然而，欲以第一元素直接调用某个成员函数，get()是必要的。

程序输出如下
```bash
Faust: 12.99
9.99
Faust: 9.99
```
## 各种容器的使用时机
C++标准库提供各具特色的不同容器。问题是：该如何选择最佳的容器类型？
下表做了一番概述，但其中有些描述可能不一定实际。
例如，如果你需要处理的元素数量很少，可以忽略复杂度，因为线性算法通常对元素本身的处理过程比较快，这种情况下，“线性复杂度搭配快速的元素处理”要比“对数复杂度搭配缓慢的元素处理”来得划算。

以下规则作为下表的补充，可能对你有所帮助：
- 默认情况下应该使用vector。Vector的内部结构最简单，并允许随机访问，所以数据的访问十分方便灵活，数据的处理也够快。
- 如果经常要在序列头部和尾部安插和移除元素，应该采用deque。如果你希望元素被移除时，容器能够自动缩减内部内存用量，那么也该采用deque。
  - 此外，由于vector通常采用一个内存区块来存放元素，而deque采用多个区块，所以后者可内含更多元素。
- 如果需要经常在容器中段执行元素的安插、移除和移动，可考虑使用list。List提供特殊的成员函数，可以在常量时间内将元素从A容器转移到B容器。
  - 但由于list不支持随机访问，所以如果只知道list的头部却要造访list的中段元素，效能会大打折扣。

和所有“以节点为基础”的容器相似，只要元素仍是容器的一部分，
list 就不会令指向那些元素的迭代器失效。
Vector则不然，一旦超过其容量，它的所有iterator、pointer和reference都会失效；
执行安插或移除动作时，也会令一部分iterator、pointer和reference失效。
至于deque，当它的大小改变，所有iterator、pointer和reference都会失效。
- 如果你要的容器对异常的处理使得“每次操作若不成功便无任何作用”，那么应该选用list（但是不调用其assignment操作符和sort()；
  - 而且如果元素比较过程中会抛出异常，就不要调用merge()、remove()、remove_if()和unique()），
  - 或选用 associative/unordered 容器（但是不调用多元素安插动作，而且如果比较准则〔comparison criterion〕的复制/赋值动作可能抛出异常，就不要调用swap（）或erase（））。
- 如果你经常需要根据某个准则查找元素，应当使用“依据该准则进行hash”的unordered set或multiset。
  - 然而，hash容器内是无序的，所以如果你必须依赖元素的次序（order），应该使用set或multiset，它们根据查找准则（search criterion）对元素排序。
- 如果想处理key/value pair，请采用unordered （multi）map。如果元素次序很重要，可采用（multi）map。
- 如果需要关联式数组（associative array），应采用unordered map。如果元素次序很重要，可采用map。
- 如果需要字典结构，应采用 unordered multimap。如果元素次序很重要，可采用 mul-timap。

STL容器能力一览表
|              | Array              | Vector                     | Deque                      | List                      | Forward List             | Associative Container                  | Unordered Container                    |
|--------------|--------------------|----------------------------|----------------------------|---------------------------|--------------------------|----------------------------------------|----------------------------------------|
| 始自         | TR1                | C++98                      | C++98                      | C++98                     | C++11                    | C++98                                  | TR1                                    |
| 典型内部结构  | Static array       | Dynamic array              | Array of arrays            | Doubly linked list        | Singly linked list       | Binary tree                            | Hash table                             |
| 元素形式      | Value              | Value                      | Value                      | Value                     | Value                    | Set: value<br>Map: key/value          | Set: value<br>Map: key/value          |
| 元素可重复    | 是                 | 是                         | 是                         | 是                        | 是                       | Multiset 或 multimap 可以              | Multiset 或 multimap 可以              |
| 迭代器类型    | 随机访问           | 随机访问                   | 随机访问                   | 双向                      | 单向（向前）             | 双向，key 为常量                       | 单向，key 为常量                       |
| 扩/缩        | 不可               | 一端可                     | 两端可                     | 各处皆可                  | 各处皆可                 | 各处皆可                               | 各处皆可                               |
| 随机访问      | 是                 | 是                         | 是                         | 否                        | 否                       | 否                                     | 几乎是                                 |
| 元素查找      | 慢                 | 慢                         | 慢                         | 很慢                      | 很慢                     | 快                                     | 很快                                   |
| 安插/移除致 iterator 失效 | — | 重新分配时 | 总如此 | 绝不会 | 绝不会 | 绝不会 | Rehashing 时会 |
| 安插/移除致 pointer、reference 失效 | — | 重新分配时 | 总如此 | 绝不会 | 绝不会 | 绝不会 | 绝不会 |
| 允许保留内存  | —                  | 是                         | 否                         | —                         | —                        | —                                      | 是（bucket）                           |
| 释放被移除元素之内存 | — | shrink_to_fit() 才可以 | 有时候 | 总如此 | 总如此 | 总如此 | 有时候 |
| 事务安全（要么成功要么无效） | 否 | 尾端 push/pop | 头尾两端 push/pop | 所有安插和移除 | 所有安插和移除 | 单元素安插及所有移除动作（但是 hashing 和 comparing 不能抛出异常） | 单元素安插及所有移除动作（但是 hashing 和 comparing 不能抛出异常） |


有个问题比较棘手：
如何根据两个不同的排序准则对元素排序？
例如存放元素时，你希望采用客户提供的排序准则，查找元素时，希望使用另一个排序准则。
这和数据库的情况相同，你需要在数种不同的排序准则下进行快速访问。
这时候你可能需要两个set或两个map，各自拥有不同的排序准则，但共用相同元素。
注意，两个集合共用相同的元素乃是一项特殊技术，

关联式容器拥有自动排序能力，并不意味着它们在排序方面的执行效能更高。
事实上，由于关联式容器每安插一个新元素都要进行一次排序，速度反而不及序列式容器经常采用的手法：先安插所有元素，然后调用排序算法进行一次完全排序。

下面两个简单的程序分别使用不同的容器，从标准输入设备读取string、排序，然后打印所有元素（去掉重复字符串）：

- 1.使用set：
```cc
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <set>
using namespace std;

int main()
{
    // create a string set
    // - initialized by all words from standard input
    set<string> coll((istream_iterator<string>(cin)),
                     istream_iterator<string>());

    // print all elements
    copy(coll.cbegin(), coll.cend(),
         ostream_iterator<string>(cout, "\n"));
}
```
- 2.使用vector：
```cc
// cont/sortvec.cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <vector>
using namespace std;

int main()
{
    // create a string vector
    // - initialized by all words from standard input
    vector<string> coll((istream_iterator<string>(cin)),
                        istream_iterator<string>());

    // sort elements
    sort(coll.begin(), coll.end());

    // print all elements ignoring subsequent duplicates
    unique_copy(coll.cbegin(), coll.cend(),
                ostream_iterator<string>(cout, "\n"));
}
```

我在我的系统上使用大约 350 000 个字符串测试这两个程序，发现 vector 版本快 10%左右。如果使用reserve()，vector 版本还可以再快将近 5%。
如果允许元素重复（改用multiset取代set，调用copy()取代unique_copy()），则情况发生剧烈变化：vector版本领先超过40%！
然而在另一个系统上vector版本却慢大约50%。这些比较虽然不具代表性，至少证实了一点：多试试各种不同的元素处理方法是值得的。

现实中预测哪种容器最好，往往相当困难。STL的一大优点就是你可以轻而易举地尝试各种版本。
主要工作——各种数据结构和算法——已经就位，你只需依照对自己最有利的方式将它们组合运用就行了。

# 细探STL容器成员
本章详细讨论STL容器提供的一切操作函数。类型和成员一律按功能分组。
针对每一种类型定义和操作，本节描述其签名式（signature）、行为、提供者（容器）。
可能的容器包括array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。
后续各节中container指的是“支持该成员”的容器类型。

## 容器内的类型
container::value_type
- 元素类型。
- 用于（unordered） set和multiset时是常量。
- 用于（unordered） map和multimap时是pair ＜const key-type， mapped-type＞。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::reference
- 元素的引用类型（reference type）。
- 典型定义：container：：value_type&。
- 在vector＜bool＞中其实是个辅助类（见7.3.6节第282页）。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::const_reference
- 只读元素（read-only element）的引用类型（reference type）。
- 典型定义：const container：：value_type&。
- 在vector＜bool＞中是bool。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered map、unordered multimap和string。

container::iterator
- 迭代器类型。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::const_iterator
- 只读（read-only）迭代器的类型。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::reverse_iterator
- 反向迭代器类型。
- 提供者：array、vector、deque、list、set、multiset、map、multimap和string。

container::const_reverse_iterator
- 只读（read-only）反向迭代器的类型。
- 提供者：array、vector、deque、list、set、multiset、map、multimap和string。

container::pointer
- 指针（用以指向元素）的类型。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::const_pointer
- 只读（read-only）指针（用以指向元素）的类型。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::size_type
- 无正负号整数类型，用于表示容器大小。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::difference_type
- 带正负号的整数类型，用以定义距离。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::key_type
- 用以定义关联式和无序（associative and unordered）容器的元素的key类型。
- 用于（unordered） set和multiset时，相当于value_type。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

container::mapped_type
- 用以定义关联式和无序（associative and unordered）容器的元素的value类型。
- 提供者：map、multimap、unordered map和unordered multimap。

container::key_compare
- 关联式（associative）容器内的“比较准则”的类型。
- 提供者：set、multiset、map和multimap。

container::value_compare
- 整个元素之“比较准则”（comparison criterion）的类型。
- 用于set和multiset时，相当于key_compare。
- 在map和multimap中，它是“比较准则”的辅助类，仅比较两元素的key。
- 提供者：set、multiset、map和multimap。

container::hasher
- 无序（unordered）容器内的hashing函数的类型。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::key_equal
- 无序（unordered）容器内的“相等判断式”（equality predicate）的类型。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::local_iterator
- 无序（unordered）容器内的bucket迭代器的类型。
- 始自C++11。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::const_local_iterator
- 无序（unordered）容器内的bucket只读迭代器的类型。
- 始自C++11。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

此外，所有容器（array除外）都提供allocator_type类型.

## 创建、复制和销毁（Create，Copy，and Destroy）
容器提供下列构造函数和析构函数，大多数构造函数允许你传入一个分配器（allocator）作为一个附加实参。

container::container ()
- Default构造函数。
- 建立一个新的空容器。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

explicit container::container (const CompFunc& cmpPred)
- 以cmpPred为排序准则建立一个空容器
- 排序准则必须定义一个strict weak ordering
- 提供者：set、multiset、map和multimap。

explicit container::container (size_type bnum)
explicit container::container (size_type bnum,const Hasher& hasher)
explicit container::container (size_type bnum,const Hasher& hasher,const KeyEqual& eqPred)
- 建立一个新的空容器，带有至少bnum个bucket， hasher用作hashing函数， eqPred用作“鉴定数值相等”的准则（criterion to identify equal value）。
- 如果没有传入eqPred，就使用容器类型默认的“等值准则”（equivalence criterion）（详见7.9.2节第366页）。
- 如果没有传入hasher，就使用容器类型默认的hashing函数（详见7.9.2节第363页）。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::container (initializer-list)
- 建立一个新容器，以initializer-list内的元素为初值。
- 对于array，这个操作是隐式定义的（见7.2.1节第262页）。
- 始自C++11。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

container::container (initializer-list,const CompFunc& cmpPred)
- 建立一个容器，排序准则为cmpPred，以initializer-list内的元素为初值。
- 排序准则必须定义一个strict weak ordering（见7.7节第314页）。
- 始自C++11。
- 提供者：set、multiset、map和multimap。

container::container (initializer-list,size_type bnum)
container::container (initializer-list,size_type bnum,const Hasher& hasher)
container::container (initializer-list,size_type bnum,const Hasher& hasher,const KeyEqual& eqPred)
- 建立一个容器，带有至少bnum个bucket，hasher用作hashing函数，eqPred用作“鉴定数值相等”的准则，以initializer-list内的元素为初值。
- 如果没有传入eqPred，就使用容器类型默认的“等值准则”（equivalence criterion）（详见7.9.2节第366页）。
- 如果传入hasher，就使用容器类型默认的hashing函数（详见7.9.2节第363页）。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::container (const container& c)
- Copy构造函数。
- 建立既有容器c的一个新拷贝。
- 针对c中的每一个元素调用copy构造函数。
- 对于array，这个操作是隐式定义的。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

container::container (container&& c)
- Move构造函数。
- 建立一个新容器，以既有容器c的元素为初值。
- 经此调用后，c仍然有效，但其内含却“不确定”（unspecified）。
- 对于array，这个操作是隐式定义的。
- 始自C++11。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

explicit container::container (size_type num)
- 建立一个容器，可含num个元素。
- 元素由其default构造函数创建。
- 提供者：vector、deque、list和forward list。

container::container (size_type num,const T& value)
- 建立一个容器，可含num个元素。
- 所有元素都是value的拷贝。
- T是元素类型。
- 对于string，value并非pass by reference。
- 提供者：vector、deque、list、forward list和string。

container::container (InputIterator beg,InputIterator end)
- 建立一个容器，以区间[beg，end）内的所有元素为初值。
- 此函数是个member template（见3.2节第34页）。因此，只要源区间的元素类型可转换为容器元素类型，此函数即可派上用场。
- 7.1.2节第256页有一个例子，并且讨论了“由于它是个member template”而带来的问题。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::container (InputIterator beg,InputIterator end,const CompFunc& cmpPred)
- 产生一个排序准则为cmpPred的容器，并以区间[beg，end）内的所有元素为初值。
- 此函数是个member template（见3.2节第34页）。因此，只要源区间的元素类型可转换为容器元素类型，此函数即可派上用场。
- 排序准则必须定义一个strict weak ordering（见7.7节第314页）。
- 提供者：set、multiset、map和multimap。

container::container (InputIterator beg,InputIterator end,size_type bnum)
container::container (InputIterator beg,InputIterator end,size_type bnum,const Hasher& hasher)
container::container (InputIterator beg,InputIterator end,size_type bnum,const Hasher& hasher,const KeyEqual& eqPred)
- 建立一个容器，带有至少bnum个bucket，hasher用作hashing函数，eqPred用作“鉴定数值相等”的准则，以区间[beg，end）内的所有元素为初值。
- 如果没有传入eqPred，就使用容器类型默认的“等值准则”（equivalence criterion）（详见7.9.2节第366页）。
- 如果没有传入hasher，就使用容器类型默认的hashing函数（详见7.9.2节第363页）。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::~container ()
- 析构函数。
- 移除所有元素，并释放内存。
- 对每个元素调用其析构函数。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

## 非更易型操作（Nonmodifying Operation）
### 大小相关操作（Size Operation）
bool container::empty () const
- 检验容器是否为空（空表示没有元素）。
- 相当于begin（）==end（），但可能更快。
- 复杂度：常量时间。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

size_type container::size () const
- 返回现有元素的数量。
- 欲检查容器是否为空（即不含元素）应使用empty（），因为empty（）可能更快。
- 复杂度：常量时间。
- 提供者：array、vector、deque、list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

size_type container::max_size () const
- 返回容器可内含的最大元素个数。
- 这是一个与实现技术相关的值，可能取决于容器的内存模型。更明确地说，由于vector通常使用单一内存区段（memory segment），所以vector的这个值往往小于其他容器。
- 复杂度：常量时间。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

### 元素比较（Comparison Operation）
bool operator== (const container& c1,const container& c2)
bool operator!= (const container& c1,const container& c2)
- 返回两个容器相等或不等。
- 两个容器如果拥有相同数量的元素，且元素内容相同（亦即对应之两两元素施以operator==都导致true）便是相等。但unordered 容器还包括必须“相等的元素有着相同的次序”。
- 复杂度：一般而言是线性（linear）。但unordered容器有可能最坏情况下是二次（quadratic）。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

bool operator ＜ (const container& c1,const container& c2)
bool operator ＜= (const container& c1,const container& c2)
bool operator ＞ (const container& c1,const container& c2)
bool operator ＞= (const container& c1,const container& c2)
- 返回两个同型容器的比较结果。
- 检验某容器是否小于另一容器，用的是字典顺序式的比较（见11.5.4节第548页对算法lexicographical_compare（）的描述）。
- 复杂度：线性（linear）。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap和string。

### Associative和Unordered容器特有的非更易型操作
这些函数利用关联式容器的元素排序性质，带来更好的性能。事实上，它们提供的是对数复杂度，而不是线性。例如在1 000个元素中进行查找，所需的比较动作平均不超过10次

size_type container::count (const T& value) const
- 返回与value相等的元素个数。
- 这是11.5.1节第524页所讨论的count（）算法的特殊版本。
- T是被排序值的类型：
  - 在set和multiset中，T是元素类型。
  - 在map和multimap中，T是key的类型。
- 复杂度：线性。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

iterator container::find (const T& value)
const_iterator container::find (const T& value) const
- 返回第一个“其值等于value”的元素的位置。
- 如果找不到这样的元素就返回end（）。
- 这是11.5.3节第528页所讨论的find（）算法的特殊版本。
- T是被排序值的类型：
  - 在set和multiset中，T是元素类型。
  - 在map和multimap中，T是key的类型。
- 复杂度：对associative容器而言是对数（logarithmic），对unordered容器而言是常量——前提是用上了一个良好的hash函数。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

iterator container::lower_bound (const T& value)
const_iterator container::lower_bound (const T& value) const
- 返回一个iterator指向“根据排序准则，可安插value拷贝”的第一个位置。
- 如果找不到这样的元素就返回end（）。
- 返回之iterator指向“其值大于等于value”之第一个元素（有可能是end（））。
- 这是11.10.1节第611页所讨论的lower_bound（）算法的特殊版本。
- T是被排序值的类型：
- 在set和multiset中，T是元素类型。
- 在map和multimap中，T是key的类型。
- 复杂度：对数（logarithmic）。
- 提供者：set、multiset、map和multimap。

iterator container::upper_bound (const T& value)
const_iterator container::upper_bound (const T& value) const
- 返回一个iterator，指向“根据排序准则，可安插value拷贝”的最后一个位置。
- 如果找不到这样的元素就返回end（）。
- 返回之iterator指向“其值大于value”之第一个元素（有可能是end（））。
- 这是11.10.1节第611页所讨论的upper_bound（）算法的特殊版本。
- T是被排序值的类型：
  - 在set和multiset中，T是元素类型。
  - 在map和multimap中，T是key的类型。
- 复杂度：对数（logarithmic）。
- 提供者：set、multiset、map和multimap。

pair＜iterator,iterator＞ container::equal_range (const T& value)
pair＜const_iterator,const_iterator＞container::equal_range (const T& value) const
- 返回一对iterator，指向“根据排序准则，可安插value拷贝”之第一个位置和最后一个位置。
- 返回的区间内的元素，其值皆等于value。
- 相当于：
```cc
make_pair<lower_bound(value), upper_bound(value)>
```
- 这是11.10.1节第613页所讨论的equal_range（）算法的特殊版本。
- T是被排序值的类型：
  - 在set和multiset中，T是元素类型。
  - 在map和multimap中，T是key的类型。
- 复杂度：对数（logarithmic）。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

## 赋值（Assignment）
container& container::operator= (const container& c)
- 这是一个copy assignment操作符。
- 将c的所有元素赋值给现有容器，亦即以c的元素替换所有现有元素。
- 这个操作符会针对被覆写（overwritten）的元素调用其assignment操作符，针对被附加（appended）的元素调用其copy构造函数，针对被移除（removed）的元素调用其析构函数。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

container& container::operator= (container&& c)
- 这是一个move assignment操作符。
- 将c的所有元素搬移给*this，亦即以c的元素替换所有现有元素。
- 调用之后，c仍然有效，但内容不明确（不保证）。
- 始自C++11。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container& container::operator= (initializer-list)
- 将initializer-list的所有元素赋值给现有容器，亦即以传入的元素的拷贝替换所有现有元素。
- 这个操作符会针对被覆写（overwritten）的元素调用其assignment操作符，针对被附加（appended）的元素调用其copy构造函数，针对被移除（removed）的元素调用其析构函数。
- 始自C++11。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

void container::assign (initializer-list)
- 将initializer-list的所有元素赋值给现有容器，亦即以传入的元素的拷贝替换所有现有元素。
- 始自C++11。
- 提供者：vector、deque、list、forward list和string。

void array::fill (const T& value)
- 将value赋值给所有元素，亦即以value的拷贝替换所有现有元素。
- 始自C++11。
- 提供者：array。

void container::assign (size_type num,const T& value)
- 赋值num个value，亦即以num个value拷贝替换掉所有现有元素。
- T必须是元素类型。
- 提供者：vector、deque、list、forward list和string。

void container::assign (InputIterator beg,InputIterator end)
- 赋值[beg，end）区间内的所有元素，亦即以[beg，end）内的元素拷贝替换掉所有现有元素。
- 此函数为一个member template（见3.2节第34页）。因此，只要源区间的元素类型可转换为容器的元素类型，此函数即可派上用场。
- 提供者：vector、deque、list、forward list和string。

void container::swap (container& c)
void swap (container& c1, container& c2)
- 和c交换内容；或是交换c1和c2的内容。
- 上述两个操作都互换：
  - 容器的元素。
  - 排序准则、相等性准则、hash函数对象——如果有的话。所有指向元素的reference、pointer和iterator，都会交换其容器，因为它们此后仍然指向相同（被交换后的）元素。
- Array内部不能够只是交换pointer。因此，swap（）带有线性复杂度，而完成之后iterator和reference指向原本的容器，但是不同的元素。
- 对于associative容器，只要“比较准则”进行复制或赋值时不抛出异常，本函数就不抛出异常。对于unordered容器，只有当“相等判断式”或hash函数对象抛出异常，本函数才会抛出异常。对于其他所有容器，本函数一律不抛出异常。
- 复杂度：一般而言是常量。对array则是线性。
- 基于其复杂度，当你不再需要被赋值的对象（assigned object），你应该宁可使用swap（）不使用copy assignment操作（见7.1.2节第258页）。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

## 元素直接访问（Direct Element Access）

reference container::at (size_type idx)
const_reference container::at (size_type idx) const
- 返回索引idx所代表的元素（第一个元素的索引为0）。
- 如果传入一个无效索引（小于0或大于等于size（）），会导致out_of_range异常。
- 后续的改动或内存重新分配，可能会导致这里所返回的reference失效。
- 如果调用者保证idx合法有效，那么最好使用速度更快的operator []。
- 提供者：array、vector、deque和string。

T& map::operator at (const key_type& key)
const T& map::operator at (const key_type& key) const
- 返回map之中key所对应的value。
- 如果没有任何元素的key等于key，会抛出out_of_range异常。
- 始自C++11。
- 提供者：map和unordered map。

reference container::operator [] (size_type idx)
const_reference container::operator [] (size_type idx) const
- 两者都返回索引idx所代表的元素（第一个元素的索引为0）。
- 如果传入一个无效索引（小于0或大于等于size（）），会导致不确定的行为。所以调用者必须确保索引有效，否则应该使用at（）。
- 后续的改动或内存重新分配，可能会导致这里所返回的reference失效。
- 提供者：array、vector、deque和string。

T& map::operator [] (const key_type& key)
T& map::operator [] (key_type&& key)
- 关联式数组（associative array）的operator []。
- 在map中，会返回key所对应的value。
- 如果不存在“key为key”的元素，本操作会自动创建一个新元素，其key由key而来（复制或搬移），其value则由value类型之default构造函数给予。不存在所谓的无效索引（只是会带来意外的行为）。详见6.2.4节第185页和7.8.3节第344页。
- 对于第二形式，key的状态此后变得不确定（这个形式针对“key尚未存在”提供了move语义）。
- 上述第一形式相当于：
- 上述第二形式始自C++11。
- 提供者：map和unordered map。

reference container::front ()
const_reference container::front () const
- 两者都返回第一个元素（第一个元素的索引为0）。
- 调用者必须确保容器内拥有元素（size（）＞0），否则会导致不明确的行为。
- 对string的支持始自C++11。
- 提供者：array、vector、deque、list、forward list和string。

reference container::back ()
const_reference container::back () const
- 两者都返回最后一个元素（其索引为size（）-1）。
- 调用者必须确保容器内拥有元素（size（）＞0），否则会导致不明确的行为。
- 对string的支持始自C++11。
- 提供者：array、vector、deque、list和string。

T* container::data ()
const T* container::data () const
- 两者都返回一个带着所有元素的C-style array（或说一个pointer指向第一元素）。
- 本函数用来将一个标准库array的所有元素传递给一个C-style array。
- String只有第二形式。
- 对array和vector的支持始自C++11。
- 提供者：array、vector和string。

## “产出迭代器”之各项操作
本节各个成员函数都会返回迭代器（iterator），凭借这些iterator你可以遍历容器的所有元素。下表列出了各种容器所提供的迭代器种类.

| 容器                  | 迭代器种类（Iterator Category） |
| --------------------- | -------------------------------- |
| Array                 | 随机访问                        |
| Vector                | 随机访问                        |
| Deque                 | 随机访问                        |
| List                  | 双向                            |
| Forward list          | 前向                            |
| Set                   | 双向，元素为常量                |
| Multiset              | 双向，元素为常量                |
| Map                   | 双向，key 为常量                |
| Multimap              | 双向，key 为常量                |
| Unordered set         | 前向，元素为常量                |
| Unordered multiset    | 前向，元素为常量                |
| Unordered map         | 前向，key 为常量                |
| Unordered multimap    | 前向，key 为常量                |
| String                | 随机访问                        |

iterator container::begin ()
const_iterator container::begin () const
const_iterator container::cbegin () const
- 返回一个iterator，指向容器起始处（第一元素的位置）。
- 如果容器为空，此操作相当于container：：end（）或container：：cend（）。
- Unordered容器也提供带有数值实参的begin（）和cbegin（），用以提供bucket接口（详见8.9.3节第429页）。
- cbegin（）始自C++11。
- 提供者：array、vector、deque、list、forward list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

iterator container::end ()
const_iterator container::end () const
const_iterator container::cend () const
- 返回一个iterator，指向容器尾端（最后元素的下一位置）。
- 如果容器为空，则此动作相当于container：：begin（）或container：：cbegin（）。
- Unordered容器也提供带有数值实参的end（）和cend（），用以提供bucket接口（详见8.9.3节第430页）。
- cend（）始自C++11。
- 提供者：array、vector、deque、listforward, list、set、multiset、map、multimap、un-ordered set、unordered multiset、unordered map、unordered multimap和string。

reverse_iterator container::rbegin ()
const_reverse_iterator container::rbegin () const
const_reverse_iterator container::crbegin () const
- 返回一个反向iterator，指向反向迭代的起点（此起点也就是正向之最末一个元素）。
- 如果容器为空，则此动作相当于container：：rend（）或container：：crend（）。
- 关于反向iterator，详见9.4.1节第448页。
- crbegin（）始自C++11。
- 提供者：array、vector、deque、list、set、multiset、map、multimap和string。

reverse_iterator container::rend ()
const_reverse_iterator container::rend () const
const_reverse_iterator container::crend () const
- 返回一个反向iterator，指向反向迭代的终点（此终点也就是正向之第一元素之更前方）。
- 如果容器为空，则此动作相当于container：：rbegin（）或container：：crbegin（）。
- 关于反向iterator，详见9.4.1节第448页。
- crend（）始自C++11。
- 提供者：array、vector、deque、list、set、multiset、map、multimap和string。

## 安插和移除（Inserting and Removing）元素
### 安插单一元素（Inserting Single Element）
iterator container::insert (const T& value)
iterator container::insert (T&& value)
pair＜iterator,bool＞ container::insert (const T& value)
pair＜iterator,bool＞ container::insert (T&& value)
- 在associative或unordered容器中安插value。
- 第一和第三形式会复制value。
- 第二和第四形式会搬移value放进容器中，所以此后value的值将不再明确（unspecified）。
- 容器如果允许元素重复，亦即（unordered） multiset和multimap，采用第一和第二形式。它们返回新元素的位置。自C++11起，新安插的元素保证被放置于既有的等值元素的尾端。
- 容器如果不允许元素重复，亦即（unordered） set和map，采用第二和第四形式。如果安插不成功（因为已经存在一个元素有着相同的value或相同的key），它们返回既有元素的位置和一个false。如果安插成功，它们返回新元素的位置和一个true。
- T是容器的元素类型，对（unordered） map和multimap而言那是一个key/value pair。
- 对于map、multimap、unordered map和unordered multimap，带有move语义的上述形式是个member template（见3.2节第34页）。因此，value的类型只要能转换为容器的value类型（key/value pair）就可以。之所以引入这个性质是为了允许你传入两个string使得第一个可被转换为一个constant string（那是key type）。
- 函数如果不成功，不会带来任何影响——前提是unordered 容器的hash 函数不抛出异常。
- 对于所有容器，“指向既有元素”的所有reference都仍然有效。对于associative容器，所有“指向既有元素”的iterator都仍然有效。对于unordered容器，所有“指向既有元素”的iterator也都有效的前提是：没有发生rehashing（当最终元素量等于或大于bucket个数乘以最大负载系数，就会发生rehashing）。
- 第二和第四形式始自C++11。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

iterator container::emplace (args)
pair＜iterator,bool＞ container::emplace (args)
- 在associative或unordered容器中安插新元素，以args为初值。
- 容器如果允许元素重复，亦即ordered/unordered的multiset和multimap，采用第一形式。它们返回新元素的位置。新安插的元素保证被放置于既有的等值元素的尾端。
- 容器如果不允许元素重复，亦即ordered/unordered的set和map，采用第二形式。如果安插不成功（因为已经存在一个元素有着相同的value或相同的key），它们返回既有元素的位置和一个false。如果安插成功，它们返回新元素的位置和一个true。
- 函数如果不成功，不会带来任何影响——前提是unordered 容器的hash 函数不抛出异常。
- 对于所有容器，“指向既有元素”的所有reference都仍然有效。对于associative容器，所有“指向既有元素”的iterator都仍然有效。对于unordered容器，所有“指向既有元素”的iterator也都有效的前提是：没有发生rehashing（当最终元素量等于或大于bucket个数乘以最大负载系数，就会发生rehashing）。
- 注意，对于sequence容器，相同形式也是可能的，其中第一实参被视为新元素的安插位置（见8.7.1节第414页）。
- 注意，为了emplace（安放）新的key/value pair进入（unordered） map和multimap中，你必须使用逐块式构建（piecewise construction；详见7.8.2节第342页）。
- 始自C++11。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

iterator container::insert (const_iterator pos,const T& value)
iterator container::insert (const_iterator pos,T&& value)
- 在iterator pos位置上安插value。
- 第一形式会复制value。
- 第二形式会搬移value放进容器中，所以此后value的值将不再明确（unspecified）。
- 返回新元素的位置。
- 容器如果不允许元素重复，例如set、map、unordered set和unordered map，而又已经存在一个元素有着和value相同的key，那么调用将无作用，返回的是既有元素的位置。
- 对于associative和unordered容器， pos只作为一个提示，指向“安插时必要的查找动作”的起始建议位置。如果value刚好可安插于pos位置上，则此函数具有“摊提之常量时间”复杂度，否则具有对数复杂度。
- 对于vector，这个操作可能导致指向其他元素的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于deque，这个操作会导致指向其他元素的iterator和reference失效。
- T是容器元素的类型，在（unordered） map和multimap中它是一个key/value pair。
- 对于map、multimap、unordered map和unordered multimap，带有move语义的第二形式是个member template（见3.2节第34页）。因此，value的类型只要能转换为容器的value类型（key/value pair）就可以。之所以引入这个性质是为了允许你传入两个string使得第一个可被转换为一个constant string（那是key type）。
- 对于string，value采用pass by value。
- 对于vector和deque，如果元素的copy/move操作（构造函数和赋值操作符）不抛出异常，则此函数万一失败也不会带来任何影响。对于unordered容器，如果hash函数不抛出异常，则此函数万一失败也不会带来任何影响。对于所有其他标准容器，此函数万一失败也不会带来任何影响。
- 第二形式始自C++11。在此之前用的是iterator类型而不是const_iterator。
- 提供者：vector、deque、list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

iterator container::emplace (const_iterator pos, args)
- 在容器的iterator位置pos上安插新元素，以args为初值。
- 返回新元素的位置。
- 对于vector，这个操作可能导致指向其他元素的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于deque，这个操作会导致指向其他元素的iterator和reference失效。
- T是容器元素的类型。
- 对于vector和deque，只要元素的copy操作（copy构造函数和assignment操作符）不抛出异常，这个函数要么就成功，要么就全无影响。对于其他所有标准容器，这个函数要么就成功，要么就全无影响。
- 相同形式也可能存在于associative容器中，新元素将被安插于pos之前一位置（见8.7.1节第412页）。
- 这个函数要么就成功，要么就全无影响，前提是unordered容器的hash函数不抛出异常。
- 始自C++11。
- 提供者：vector、deque和list。

iterator container::emplace_hint (const_iterator pos, args)
- 在容器的iterator位置pos上安插新元素，以args为初值。
- 返回新元素的位置。
- 容器如果不允许元素重复，例如set、map、unordered set和unordered map，而又已经存在一个元素有着和value相同的key，那么调用将无作用，返回的是既有元素的位置。
- 位置pos只作为提示使用，指向“安插时必要的查找动作”的起始点。如果新元素刚好可安插于pos位置上，则此函数具有“摊提之常量时间”复杂度，否则具有对数复杂度。
- T是容器元素的类型，在（unordered） map和multimap中它是一个key/value pair。
- 此函数万一失败也不会带来任何影响，前提是（对unordered容器而言） hash函数不抛出异常。
- 始自C++11。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

void container::push_front (const T& value)
void container::push_front (T&& value)
- 安插value使成为第一个元素。
- 第一形式会复制value。
- 第二形式始自C++11，会搬移value放进容器中，此后value的值不再明确（unspecified）。
- T是容器的元素类型。
- 两个形式都相当于insert（begin（），value）。
- 对于deque，此操作会造成“指向其他元素”的iterator失效，而“指向其他元素”的reference仍保持有效。
- 此函数若失败不会带来任何影响。[1]
- 提供者：deque、list和forward list。

void container::emplace_front (args)
- 安插一个新的第一元素，由实参列（argument list） args初始化。
- 因此，容器的元素类型必须带有一个可被调用的（callable）构造函数接受args。
- 对于deque，此操作会造成“指向其他元素”的iterator失效，而“指向其他元素”的reference仍保持有效。
- 此函数若失败不会带来任何影响。
- 始自C++11。
- 提供者：deque、list和forward list。

void container::push_back (const T& value)
void container::push_back (T&& value)
- 追加value，使成为新的最末元素。
- 第一形式会复制value。
- 第二形式始自C++11，会搬移value放进容器中，此后value的值不再明确（unspecified）。
- T是容器的元素类型。
- 两个形式都相当于insert（end（），value）。
- 对于vector，这个操作可能导致“指向其他元素”的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于 deque，这个操作会导致“指向其他元素”的 iterator 失效，“指向其他元素”的reference则仍然有效。
- 对于string，value采用pass by value。
- 对于vector和deque，如果元素的copy/move构造函数不抛出异常，则此函数万一失败也不会带来任何影响。对于list，此函数万一失败也不会带来任何影响。
- 提供者：vector、deque、list和string。

void container::emplace_back (args)
- 追加一个新的最末元素，它由实参列（argument list） args初始化。
- 因此，容器的元素类型必须带有一个可被调用的（callable）构造函数接受args。
- 对于vector，这个操作可能导致“指向其他元素”的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于 deque，这个操作会导致“指向其他元素”的 iterator 失效，“指向其他元素”的reference则仍然有效。
- 此函数要么就成功，要么就无任何影响，前提是，对于vector和deque，其copy/move构造函数不抛出异常。
- 始自C++11。
- 提供者：vector、deque和list。

### 安插多重元素（Inserting Multiple Elements）
void container::insert (initializer-list)
- 将initializer-list内的元素的拷贝插入一个associative容器内。
- 对于所有容器，“指向既有元素”的所有reference都仍然有效。对于associative容器，所有“指向既有元素”的iterator都仍然有效。对于unordered容器，所有“指向既有元素”的iterator也都有效的前提是：没有发生rehashing（当最终元素量等于或大于bucket个数乘以最大负载系数，就会发生rehashing）。
- 始自C++11。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

iterator container::insert (const_iterator pos, initializer-list)
- 在iterator pos位置上安插initializer-list中的元素的拷贝。
- 返回第一个被安插元素的位置，或返回pos——如果initializer-list为空。
- 对于vector，这个操作可能导致“指向其他元素”的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于deque，这个操作会导致“指向其他元素”的iterator和reference失效。
- 对于list，此函数万一失败也不会带来任何影响。
- 始自C++11。
- 提供者：vector、deque、list和string。

iterator container::insert (const_iterator pos,size_type num,const T& value)
- 在iterator pos的位置上安插num个value拷贝。
- 返回第一个被安插元素的位置，或返回pos——如果num==0（在C++11之前，不返回任何东西）。
- 对于vector，这个操作可能导致“指向其他元素”的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于deque，这个操作会导致“指向其他元素”的iterator和reference失效。
- T是容器的元素类型。对map和multimap而言它是key/value pair。
- 对于string，value采用pass by value。
- 对于vector和deque，如果元素的copy/move操作（构造函数和assignment操作符）不抛出异常，则此函数万一失败也不会带来任何影响。对于list，此函数万一失败也不会带来任何影响。
- 在C++11之前，用的是iterator类型而不是const_iterator，且返回类型为void。
- 提供者：vector、deque、list和string。

void container::insert (InputIterator beg,InputIterator end)
- 将区间[beg，end）内所有元素的拷贝安插到associative容器内。
- 此函数是个member template（见3.2节第34页），因此，只要源区间的元素可转换为容器元素的类型，本函数就可派上用场。
- 对于所有容器，“指向既有元素”的reference仍然有效。对于associative容器，所有“指向既有元素”的iterator 都仍然有效。对于unordered 容器，所有“指向既有元素”的iterator也都有效的前提是：没有发生rehashing（当最终元素量等于或大于bucket个数乘以最大负载系数，就会发生rehashing）。
- 此函数要么就成功，要么就无任何影响，前提是，unordered容器的hash函数不抛出异常。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。

iterator container::insert (const_iterator pos、InputIterator beg,InputIterator end)
- 将区间[beg，end）内所有元素的拷贝安插于迭代器pos所指的位置上。
- 返回第一个被安插元素的位置，或返回pos——如果beg==end（在C++11之前，不返回任何东西）。
- 此函数是个member template（见3.2节第34页），因此，只要源区间的元素可转换为容器元素的类型，本函数就可派上用场。
- 对于vector，这个操作可能导致“指向其他元素”的iterator和reference失效——如果“重分配”发生的话（当最终的元素数量超过原本容量的话就会发生重分配）。
- 对于vector和deque，这个操作可能导致“指向其他元素”的iterator和reference失效。
- 对于list，此函数万一失败也不会带来任何影响。
- 在C++11之前，用的是iterator类型而不是const_iterator，且返回类型为void。
- 提供者：vector、deque、list和string。

### 移除元素（Removing Element）
size_type container::erase (const T& value)
- 从associative容器中移除所有和value相等的元素。
- 返回被移除的元素个数。
- 调用被移除元素的析构函数。
- T是被排序值（sorted value）的类型：
- 在（unordered） set和multiset中，T是元素类型。
- 在（unordered） map和multimap中，T是key的类型。
- 此函数不会造成指向其他元素的iterator和reference失效。
- 此函数有可能抛出异常，如果比较测试或hash函数抛出异常的话。
- 提供者：set、multiset、map、multimap、unordered set、unordered multiset、unordered map和unordered multimap。
- （forward） list的remove（）提供相同功能（见8.8.1节第420页）。其他容器可使用remove（）算法（见11.7.1节第575页）。

iterator container::erase (const_iterator pos)
- 将iterator pos所指位置上的元素移除。
- 返回后继元素的位置（或返回end（））。
- 调用被移除元素的析构函数。
- 注意，调用者必须确保iterator pos有效。例如：
- 对于vector和deque，此操作可能造成“指向其他元素”的iterator和reference无效。对于所有其他容器，“指向其他元素”的iterator和reference永远保持有效。
- 对于vector、deque和list，此函数不抛出异常。对于associative和unordered容器，如果hash函数或“比较测试”抛出异常，此函数有可能抛出异常。
- 在C++11之前，返回类型是void（对于associative容器）且使用iterator而非const_iterator。
- 对于以iterator为元素的set，自C++11起调用erase（）有可能形成歧义（ambiguous）。因此C++11修正为：提供重载版本，分别是erase（iterator）和erase（const_iterator）。
- 提供者：vector、deque、list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

iterator container::erase (const_iterator beg,const_iterator end)
- 移除区间[beg，end）内的所有元素。
- 返回最后一个被移除元素的位置（或返回end（））。
- 一如区间惯例，始于beg（含）而终于end（不含）的所有元素都被移除。
- 调用被移除元素的析构函数。
- 调用者必须确保beg和end形成一个有效序列，并且该序列是容器的一部分。
- 对于vector和deque，此操作可能造成“指向其他元素”的iterator和reference无效。对于所有其他容器，“指向其他元素”的iterator和reference永远保持有效。
- 对于vector、deque和list，此函数不抛出异常。对于associative和unordered容器，如果hash函数或“比较测试”抛出异常，此函数有可能抛出异常。
- 在C++11之前，返回类型是void（对于associative容器）且使用iterator而非const_iterator。
- 提供者：vector、deque、list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

void container::pop_front ()
- 移除容器的第一元素。
- 相当于：
```cc
container.erase(container.begin());
```
或者对forward list而言相当于：
```cc
container.erase_after(container.before_begin());
```
- 如果容器是空的，会导致不明确的行为。因此调用者必须确保容器至少有一个元素，也就是！empty（）。
- 此函数不抛出异常。
- “指向其他元素”的iterator和reference都保持有效。
- 提供者：deque、list和forward list。

void container::pop_back ()
- 移除容器的最末元素。
- 相当于：
```cc
container.erase(prev(container.end()));
```
- 如果容器是空的，会导致不明确的行为。因此调用者必须确保容器至少有一个元素，也就是！empty（）。
- 此函数不抛出异常。
- “指向其他元素”的iterator和reference都保持有效。
- 对string而言，始自C++11。
- 提供者：vector、deque、list和string。

void container::clear ()
- 移除所有元素，将容器清空。
- 调用被移除元素的析构函数。
- “指向容器内元素”的所有iterator和reference都失效。
- 对于vector、deque和string，它甚至会令任何past-the-end-iterator失效——那是由end（）或cend（）返回的东西。
- 此函数不抛出异常（在C++11之前，对于vector和deque，如果copy构造函数或assign-ment操作符抛出异常，此函数也会抛出异常）。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

### 重设大小（Resizing）
void container::resize (size_type num)
void container::resize (size_type num,const T& value)
- 将容器大小改为num。
- 如果size（）原本就是num，则两者皆无效。
- 如果num大于size（），则在容器尾端附加额外元素。第一形式通过default构造函数来构建新元素，第二形式以value的拷贝作为新元素。
- 如果num小于size（），则移除尾端元素，获得新的大小。每个被移除元素的析构函数都会被调用。
- 对于vector和deque，这些函数可能造成“指向其他元素”的iterator和reference无效。对于所有其他容器，“指向其他元素”的iterator和reference永远保持有效。
- 对于vector和deque，这些函数要么成功，要么无效，前提是元素的构造函数和assign-ment操作符不抛出异常。对于list和forward list，如果失败不会带来任何影响。
- 在C++11之前，value是以by value方式传递。
- 对于string，value是以by value方式传递。
- 提供者：vector、deque、list、forward list和string。

## List和Forward List的特殊成员函数
### 特殊成员函数（针对List和Forward List）
void list::remove (const T& value)
void list::remove_if (UnaryPredicate op)
- remove（）移除所有带value值的元素。
- remove_if（）移除所有“令单参判断式
```cc
op(elem)
```
产出true”的元素。
- 注意，op不应在函数调用过程中改变状态（state），详见10.1.4节第483页。
- 两个形式都会调用被移除元素的析构函数。
- 留下的元素保持原先次序（stable〔稳定的〕）。
- 这是remove（）算法的特殊版本，该算法详见11.7.1节第575页。
- T是容器元素的类型。
- 进一步的细节和示例，见7.5.2节第294页。
- 只有当元素的比较动作抛出异常，这些函数才可能抛出异常。
- 提供者：list和forward list。

void list::unique ()
void list::unique (BinaryPredicate op)
- 移除（forward） list内相邻而重复的元素，使每一个元素都不同于下一个元素。
- 第一形式会将所有“和前一元素相等”的元素移除。
- 第二形式的意义是：任何一个元素elem，如果其前一元素是e，而elem和e造成双参判断式（binary predicate）
```cc
op(elem, e)
```
获得true，那么就移除elem。换言之，这个判断式并非拿元素和其目前的前一紧临元素
比较，而是拿元素和其未被移除的前一元素比较。
- 注意，op不应在函数调用过程中改变状态（state），详见10.1.4节第483页。
- 两个形式都会调用被移除元素的析构函数。
- 这是11.7.2节第578页的unique（）算法的特别版本。
- 如果“元素比较动作”中不抛出异常，这些函数亦不抛出异常。
- 提供者：list和forward list。

void list::splice (const_iterator pos, list& source)
void list::splice (const_iterator pos, list&& source)
- 将source的所有元素搬移到*this，并将它们安插到iterator pos所指位置。
- 调用之后，source被清空。
- 如果source和*this相同，会导致不明确的行为。所以调用端必须确定source和*this是不同的list。欲移动同一个list内的元素，应该使用稍后提及的其他splice（）形式。
- 调用者必须确定pos是*this的一个有效位置；否则会导致不明确的行为。
- “指向 source 的元素”的所有 pointer、iterator 和 reference 仍然有效。此后它们属于this。
- 此函数不抛出异常。
- 第二形式始自C++11。在C++11之前，用的是iterator而非const_iterator。
- 提供者：list。

void list::splice (const_iterator pos, list& source,const_iterator sourcePos)
void list::splice (const_iterator pos, list&& source,const_iterator sourcePos)
- 从source list中，将位于sourcePos位置上的元素搬移至*this，并安插于iterator pos所指位置。
- source和*this可以相同。这种情况下，元素将在list内部被搬移。
- 如果source和*this不是同一个list，在此操作之后，其元素个数少1。
- 调用者必须确保pos是*this的一个有效位置，且sourcePos是source的一个有效迭代器，而且sourcePos不是source.end（）；否则会导致不明确的行为。
- “指向 source 的元素”的所有 pointer、iterator 和 reference 仍然有效。此后它们属于this。
- 此函数不抛出异常。
- 第二形式始自C++11。在C++11之前，用的是iterator而非const_iterator。
- 提供者：list。

void list::splice (const_iterator pos, list& source,const_iterator sourceBeg,const_iterator sourceEnd)
void list::splice (const_iterator pos, list&& source,const_iterator sourceBeg,const_iterator sourceEnd)
- 从source list中，将[sourceBeg，sourceEnd）区间内的所有元素搬移到*this，并安插于iter-ator pos所指位置。
- source和*this可以相同。这种情况下，pos不得为被移动区间的一部分，而元素将在list内部移动。
- 如果source和*this不是同一个list，在此操作之后，其元素个数将减少。
- 调用者必须确保pos是*this的一个有效位置，且sourceBeg和sourceEnd形成一个有效区间，该区间是source的一部分；否则会导致不明确的行为。
- “指向 source 的元素”的所有 pointer、iterator 和 reference 仍然有效。此后它们属于this。
- 此函数不抛出异常。
- 第二形式始自C++11。在C++11之前，用的是iterator而非const_iterator。
- 提供者：list。

void list::sort ()
void list::sort (CompFunc cmpPred)
- 对list内的所有元素排序。
- 第一形式以operator＜对list的所有元素进行排序。
- 第二形式调用cmpPred比较两元素，以此对list中的所有元素排序：
```cc
op(elem1, elem2)
```
- Value相同的元素，其顺序保持不变（除非有异常抛出）。
- 这是11.9.1节第596页所讨论的sort（）和stable_sort（）算法的特殊版本。
- 提供者：list和forward list。

void list::merge (list& source)
void list::merge (list&& source)
void list::merge (list& source,CompFunc cmpPred)
void list::merge (list&& source,CompFunc cmpPred)
- 将（forward） list source内的所有元素并入*this。
- 调用后source变成空。
- 前两个形式采用operator＜作为排序准则。
- 后两个形式采用cmpPred作为可选的排序准则，以此比较两元素的大小：
- 诸元素如果含有相等内容，它们的次序保持不变（stable）。
- 如果*this和source在排序准则operator＜或cmpPred之下已排好序（sorted），则新产生的（forward） list也将会是已排好序，而且*this内的相等元素会优先于source内的相等元素。严格地说，C++standard要求两个（forward） list必须已排好序，但实际上对未排序的list进行merge动作也是可能的，不过使用前最好先确认一下。
- 这是11.10.2节第614页所讨论的merge（）算法的特殊版本。
- 只要元素的比较动作不抛出异常，此函数万一失败也不会造成任何影响。
- 提供者：list和forward list。

void list::reverse ()
- 将（forward） list内的元素次序颠倒。
- 这是11.8.1节第583页所讨论的reverse（）算法的特殊版本。
- 此函数不抛出异常。
- 提供者：list和forward list。

### 特殊成员函数（只针对Forward List）
iterator forwardlist::before_begin ()
const_iterator forwardlist::before_begin () const
const_iterator forwardlist::cbefore_begin () const
- 返回一个iterator，指向第一元素之前一个位置。
- 由于在forward list中你无法回向迭代（iterate backward），这个成员函数允许你获得一个“可用来插入一个新的第一元素，或用来删除第一元素”的位置。
- 提供者：forward list。

iterator forwardlist::insert_after (const_iterator pos,const T& value)
iterator forwardlist::insert_after (const_iterator pos,T&& value)
- 就在iterator pos所指位置上安插value。
- 第一形式会复制value。
- 第二形式会搬移value放进容器内，此后value的状态不再明确。
- 返回新元素的位置。
- 函数要么成功，要么无任何影响。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

iterator forwardlist::emplace_after (const_iterator pos, args)
- 在iterator pos所指位置上安插一个新元素，以args为初值。
- 返回新元素的位置。
- 函数要么成功，要么无任何影响。[2]
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

iterator forwardlist::insert_after (const_iterator pos、size_type num,const T& value)
- 在iterator pos所指位置上安插num个value的拷贝。
- 返回最后被安插的那个元素的位置。如果num==0就返回pos。
- 函数要么成功，要么无任何影响。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

iterator forwardlist::insert_after (const_iterator pos, initializer-list)
- 在iterator pos所指位置上安插initializer-list的元素拷贝。
- 返回最后被安插的那个元素的位置。如果initializer-list是空的，就返回pos。
- 函数要么成功，要么无任何影响。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

iterator forwardlist::insert_after (const_iterator pos,InputIterator beg,InputIterator end)
- 在iterator pos所指位置上安插[beg，end）的所有元素的拷贝。
- 返回最后被安插的那个元素的位置。如果beg==end，就返回pos。
- 这是一个member template（见3.2节第34页）。因此，源区间的元素可以是任何类型，只要能够转换为容器的元素类型就行。
- 函数要么成功，要么无任何影响。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

iterator forwardlist::erase_after (const_iterator pos)
- 移除iterator pos所指位置之后的所有元素。
- 返回后继元素的位置（或返回end（））。
- 调用被移除元素的析构函数。
- 调用被移除元素的析构函数。
- “指向其他元素”的iterator和reference仍然保持有效。
- 调用者必须确保iterator pos有效。
- 此函数不抛出异常。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

void forwardlist::erase_after (const_iterator beg,const_iterator end)
- 移除（beg，end）区间内的元素。注意，这不是个半开区间，因为它排除了beg和end。例如：
```cc
coll.erase(coll.before_begin(), coll.end()) // 删除所有元素
```
- 返回end。
- 调用被移除元素的析构函数。
- 调用者必须确保beg和end定义出容器内的一个有效区间（valid range）。
- 此函数不抛出异常。
- 指向其他元素的iterator和reference仍然保持有效。
- 提供者：forward list。

void forwardlist::splice_after (const_iterator pos, forwardlist& source)
void forwardlist::splice_after (const_iterator pos, forwardlist&& source)
- 将source的所有元素搬移至*this，并在iterator pos位置上安插它们。
- 在此调用后，source成空。
- 如果source和*this是同一个容器，则行为不明确。因此，调用者必须确保source是另一个list。如果想要在同一个list中搬移元素，必须使用稍后显示的splice_after（）形式。
- 调用者必须确保pos是*this的一个有效位置；若否，行为将不明确。
- “指向source的成员”的pointer、iterator和reference仍然有效。此后它们属于this。
- 此函数不抛出异常。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

void forwardlist::splice_after (const_iterator pos,forwardlist& source,const_iterator sourcePos)
void forwardlist::splice_after (const_iterator pos,forwardlist&& source,const_iterator sourcePos)
- 将list source的sourcePos位置上的元素搬移到*this，将它安插到iterator pos所指位置。
- source和*this可以是同一个容器。如果这样，元素就是在自家容器内搬移。
- 如果source是另一个list，它的元素将在此操作完成后少一个。
- 调用者必须确保pos是*this的一个有效位置，sourcePos是source的一个有效iterator，而且sourcePos不是source.end（）；否则此操作的行为将不明确。
- “指向source的成员”的pointer、iterator和reference仍然有效。此后它们属于this。
- 此函数不抛出异常。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

void forwardlist::splice_after (const_iterator pos, forwardlist& source,const_iterator sourceBeg,const_iterator sourceEnd)
void forwardlist::splice_after (const_iterator pos, forwardlist&& source,const_iterator sourceBeg,const_iterator sourceEnd)
- 将list source的（sourceBeg，sourceEnd）区间内的元素搬移到*this，将它们安插在iteratorpos位置上。注意，最后两个实参不是半开区间，因为它排除了beg也排除了end。以下调用会将coll2的所有元素搬移到coll的起点：
```cc
coll.splice_after(coll.before_begin(), coll2, coll2.before_begin(), coll2.end());
```
- source和*this可以是同一个容器。这样的话，pos不可以落在被搬移区间内，而元素就在同一个list内被搬移。
- 如果source是另一个list，此操作之后它将内含较少元素。
- 调用者必须确保pos是*this的一个有效位置，sourceBeg和sourceEnd定义出source内的一个有效区间；否则此操作的行为将不明确。
- “指向source的成员”的pointer、iterator和reference仍然有效。此后它们属于this。
- 此函数不抛出异常。
- 传入容器的end（）或cend（）作为pos，会导致不明确的行为。
- 提供者：forward list。

## 容器的策略接口（Policy Interface）
### 非更易型策略函数（Nonmodifying Policy Function）
size_type container::capacity () const
- 返回重分配内存之前所能容纳的最多元素个数。
- 提供者：vector和string。

value_compare container::value_comp () const
- 返回一个被用作“比较准则”（comparison criterion）的对象。
- 在set和multiset中相当于key_comp（）。
- 在map和multimap中，它是一个辅助类，被用作“比较准则”（comparison criterion），用来比较key/value pair中的key。
- 提供者：set、multiset、map和multimap。

key_compare container::key_comp () const
- 返回associative容器的“比较准则”。
- 提供者：set、multiset、map和multimap。

key_equal container::key_eq () const
- 返回unordered容器的“相等性比较准则”（equivalence criterion）。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

hasher container::hash_function () const
- 返回unordered容器的hash函数。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

float container::load_factor () const
- 返回unordered容器当前的每个bucket的平均元素个数。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

float container::max_load_factor () const
- 返回unordered容器的“最大负载系数”。容器会自动rehash（增加必要的bucket数量）以保持其负载系数低于或等于此值。
- 注意，默认值为1.0，通常应该改变之（见7.9.2节第362页）。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

### 更易型策略函数（Modifying Policy Function）
void container::reserve (size_type num)
- 内部保留若干内存，至少够容纳num个元素。
- 对于vector，这个调用只能增加容量（capacity）。因此，如果num小于或等于当前的真实容量，它没有效用。若要缩减 vector 的容量，请看第 428 页的shrink_to_fit（）以及7.3.1节第272页的例子。
- 对于unordered容器：
  - 这个调用等价于rehash（ceil（num/max_load_factor）） （ceil（）会获得“不小于其实参”之最小整数值）。
  - 这个操作会令iterator失效，会改变元素之间的次序，会改变元素被置于哪个bucket内。这个操作不会令“指向元素”的pointer或reference失效。
- 对于string，num可有可无（默认为0）。如果num小于实际容量，这个调用将会是个不被绑定（nonbinding）的缩减请求。
- 这个操作可能造成“指向元素”的 iterator 和（针对 vector 和 string 的） reference 和pointer失效。然而它保证，一旦被调用，安插过程中将不会发生重分配（reallocation），直到有个安插动作造成容器大小超越num。因此，reserve（）可以增加速度并帮助保持reference、pointer和iterator的有效性（详见7.3.1节第271页）。
- 如果num＞max_size（）就抛出length_error（见4.3.1节第43页），如果内存分配失败就抛出一个相应的异常。
- 自C++11起，能够作用于unordered容器。
- 提供者：vector、unordered set、unordered multiset、unordered map、unordered multimap和string。

void container::shrink_to_fit ()
- 缩减内部内存，使刚好吻合实际的元素数量。
- 此调用是一个“非必被绑定”请求（nonbinding request），意思是实现可忽略这个调用，以便有回旋空间允许“实现专属之优化”。因此，不保证此后capacity（）==size（）必为true。
- 这个操作有可能造成指向元素的reference、pointer和iterator失效。
- 始自C++11。C++11之前若欲缩减vector容量，7.3.1节第272页有一个例子。
- 提供者：vector、deque和string。

void container::rehash (size_type bnum)
- 改变unordered容器的bucket数量，令其至少为bnum。
- 此操作会令iterator失效，会改变元素之间的次序，会改变元素落于哪个bucket内。这个操作不会令（指向元素）的pointer或reference失效。
- 如果有个异常被抛出，此操作将不带来任何影响（除非是容器的hash函数或比较函数抛出的）。
- 对于unordered multiset和multimap，rehashing会保存相等元素之间的相关次序。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

void container::max_load_factor (float loadFactor)
- 设定unordered容器的最大负载系数为loadFactor。
- loadFactor只是个提示，如此一来实现便能自由地根据其内部的布局哲学调整该值。
- 此操作可能造成rehashing，那会造成iterator失效，改变元素之间的次序，改变元素落于哪个bucket内。这个操作不会令“指向元素”的pointer或reference失效。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

### Unordered容器的Bucket相关接口
size_type container::bucket_count () const
- 返回unordered容器的当前bucket数量。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

size_type container::max_bucket_count () const
- 返回unordered容器的最大可能的bucket数量。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

size_type container::bucket (const key_type key) const
- 返回一个bucket编号，该bucket是“带有与key等价的key”的元素落脚处（如果那样的元素存在的话）。
- 返回值必在区间[0，bucket_count（））内。
- 如果bucket_count（）是0，返回值不明确。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

size_type container::bucket_size (size_type bucketIdx) const
- 返回编号为bucketIdx的bucket内的元素数量。
- 如果bucketIdx不是区间[0，bucket_count（））内的一个有效索引，此操作的结果不明确。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

local_iterator container::begin (size_type bucketIdx)
const_local_iterator container::begin (size_type bucketIdx) const
const_local_iterator container::cbegin (size_type bucketIdx) const
- 所有三个形式都返回一个iterator，指向编号为bucketIdx的bucket内的所有元素的起点（第一元素的位置）。
- 如果编号为bucketIdx的 bucket 为空，此调用相当于container：：end（bucketIdx） 或container：：cend（bucketIdx）。
- 如果bucketIdx不是区间[0，bucket_count（））内的一个有效索引，操作结果不可预测。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

local_iterator container::end (size_type bucketIdx)
const_local_iterator container::end (size_type bucketIdx) const
const_local_iterator container::cend (size_type bucketIdx) const
- 所有三个形式都返回一个iterator，指向编号为bucketIdx的bucket内的所有元素的终点（最末元素的下一位置）。
- 如果编号为bucketIdx的 bucket 为空，此调用相当于 container：：begin（bucketIdx） 或container：：cbegin（bucketIdx）。
- 如果bucketIdx不是区间[0，bucket_count（））内的一个有效索引，操作结果不可预测。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

## 对分配器（Allocator）的支持
所有STL容器都能够与某个分配器对象（allocator object）所定义的某种特定内存模型（memory model）搭配合作。本节描述分配器支持之各个成员。

### 基本的分配器成员（Fundamental Allocator Member）
container::allocator_type
- 分配器类型。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

allocator_type container::get_allocator () const
- 返回容器的内存模型（memory model）。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

### 带有“可选之分配器参数”的构造函数
explicit container::container (const Allocator& alloc)
- 建立一个新的空容器，使用alloc作为内存模型（memory model）。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::container (const CompFunc& cmpPred,const Allocator& alloc)
- 建立一个新的空容器，使用alloc作为内存模型，以cmpPred为排序准则。
- 排序准则必须定义出strict weak ordering（见7.7节第314页）。
- 提供者：set、multiset、map和multimap。

container::container (size_type bnum,const Hasher& hasher,const KeyEqual& eqPred,const Allocator& alloc)
- 建立一个新的空容器，带有至少bnum个bucket，以hasher为hashing函数，以eqPred为相等性准则，以alloc为内存模型。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::container (initializer-list,const Allocator& alloc)
- 建立一个新容器，以alloc为内存模型，以initializer-list的元素为初值。
- 始自C++11。
- 提供者：vector、deque、list、forward list和string。

container::container (initializer-list,const CompFunc& cmpPred、const Allocator& alloc)
- 建立一个容器，拥有排序准则cmpPred，以alloc为内存模型，以initializer-list元素为初值。
- 排序准则必须定义出strict weak ordering（见7.7节第314页）。
- 始自C++11。
- 提供者：set、multiset、map和multimap。

container::container (initializer-list,size_type bnum,const Hasher& hasher,const KeyEqual& eqPred const Allocator& alloc)
- 建立一个容器，带有至少bnum个bucket，以hasher为hashing函数，以eqPred为相等性准则，以alloc为内存模型，以initializer-list的元素为初值。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。

container::container (const container& c,const Allocator& alloc)
container::container (container&& c,const Allocator& alloc)
- 建立一个新容器，以alloc为内存模型，初始化方式为：复制/搬移（copied/moved）既有容器c的元素。
- 对c内的每个元素调用copy/move构造函数。
- 对于第二形式，调用完毕后c仍然有效，但其内容不再明确。
- 始自C++11。
- 提供者：vector、deque、list、forward list、set、multiset、map、multimap、unordered set、unordered multiset、unordered map、unordered multimap和string。

container::container (size_type num,const T& value,const Allocator& alloc)
- 建立一个容器，拥有num个元素，使用alloc作为内存模型。
- 生成的元素都是value的拷贝。
- T是容器元素的类型。注意，对于string，value以by value的形式传递。
- 提供者：vector、deque、list、forward list和string。

container::container (InputIterator beg,InputIterator end,const Allocator& alloc)
- 建立一个容器，以区间[beg，end）内的所有元素为初值，使用alloc作为内存模型。
- 此函数是个member template（见3.2节第34页）。所以只要源区间内的元素能够转换为容器的元素类型，此函数就可执行。
- 提供者：vector、deque、list、forward list和string。

container::container (InputIterator beg,InputIterator end,const CompFunc& cmpPred,const Allocator& alloc)
- 建立一个容器，拥有排序准则cmpPred，以区间[beg，end）内的所有元素为初值，以alloc为内存模型。
- 此函数是个member template（见3.2节第34页）。所以只要源区间内的元素能够转换为容器的元素类型，此函数就可执行。
- 排序准则必须定义出strict weak ordering（见7.7节第314页）。
- 提供者：set、multiset、map和multimap。

container::container (InputIterator beg,InputIterator end,size_type bnum,const Hasher& hasher,const KeyEqual& eqPred,const Allocator& alloc)
- 建立一个容器，带有至少bnum个bucket，以hasher为hashing函数，以eqPred为相等性准则，以alloc为内存模型，以区间[beg，end）内的所有元素为初值。
- 提供者：unordered set、unordered multiset、unordered map和unordered multimap。


# STL迭代器
本章详细描述iterator（迭代器），涵盖其分类、相关操作、其adapter（适配器），以及用户自定义的iterator。

## 迭代器头文件（Header Files for Iterators）
所有容器都定义有各自的iterator类型，所以当你打算使用某种容器的iterator时，不必包含什么特殊的头文件。
不过有些特别的iterator，例如reverse（反向） iterator，以及若干辅助的iterator函数，被定义于头文件＜iterator＞中。
有些实现将所有容器都包含在这个头文件中，用来定义其reverse iterator类型。然而这不具可移植性。因此，当你需要比寻常的container iterator和其类型更多东西时，你应该包含这个头文件。

## 迭代器种类（Iterator Category）
Iterator（迭代器）是一种“能够迭代某序列（sequence）内所有元素”的对象，可通过改编自寻常pointer的一致性接口来完成工作。
Iterator奉行一个纯抽象概念：任何东西，只要行为类似iteartor，就是一种iterator。
然而不同的iterator具有不同的能力（译注：指的是其行进能力）。这很重要，因为某些算法需要特殊的iterator能力。
例如sorting算法需要的iterator必须能够执行随机访问（random access），否则效能很糟。
由于这个原因，迭代器被分为不同的类型:

        ┌──────────────────────────────────────────────┐
        │  ┌──────────────┐         ┌───────────────┐  │
        │  │Input Iterator│         │Output Iterator│  │
        │  └──────────────┘         └───────────────┘  │
        │              ┌───────────────────────┐       │
        │              │Forward Iterator       │       │
        │              └───────────────────────┘       │
        │              ┌───────────────────────┐       │
        │              │Bidirectional Iterator │       │
        │              └───────────────────────┘       │
        │              ┌───────────────────────┐       │
        │              │Random-access Iterator │       │
        │              └───────────────────────┘       │
        └──────────────────────────────────────────────┘

| 迭代器种类（Category） | 能力                     | 提供者                                             |
| ---------------------- | ------------------------ | -------------------------------------------------- |
| Output 迭代器          | 向前写入                 | Ostream、inserter                                  |
| Input 迭代器           | 向前读取一次             | Istream                                            |
| Forward 迭代器         | 向前读取                 | Forward list、unordered containers                 |
| Bidirectional 迭代器   | 向前和向后读取           | List、set、multiset、map、multimap                 |
| Random-access 迭代器   | 以随机访问方式读取       | Array、vector、deque、string、C-style array        |

### Output迭代器
Output迭代器允许一步一步前行并搭配write动作。
因此你可以一个一个元素地赋值，不能使用output迭代器对同一区间迭代两次。
事实上，甚至不保证你可以将一个value赋值两次而其迭代器却不累进。
我们的目标是将一个value以下列方式写入一个“黑洞”：
```cc
while (...) {
    *pos = ...; 
    ++pos;
}
```
Operator*只有在赋值语句的左边才有效。

Output迭代器无须比较操作。
你无法检验output迭代器是否有效，或写入是否成功。
你唯一可做的就是写入、写入、再写入。
通常，一批写入动作是以一个“由额外条件定义出”的“特定output迭代器”作为结束。

Output迭代器的操作:
| 表达式     | 效果                                                 |
| ---------- | ---------------------------------------------------- |
| `*iter = val` | 将 `val` 写至迭代器所指位置                          |
| `++iter`     | 向前步进（step forward），返回新位置                 |
| `iter++`     | 向前步进（step forward），返回旧位置                 |
| `TYPE(iter)` | 复制迭代器（调用拷贝构造函数，创建迭代器的副本 ） |

通常，迭代器可用来读，也可用来写；几乎所有reading迭代器都有write的额外功能，这种情况下它们被称为mutable（可产生变化的）迭代器。

一个典型的pure output迭代器例子是：“将元素写至标准输出设备（例如屏幕或打印机）”。
如果采用两个output迭代器写至屏幕，第二个字将跟在第一个字后面，而不是覆盖（overwrite）第一个字。
另一个典型例子是inserter，那是一种用来将value插入（insert）容器内的迭代器：
如果你赋值（assign）一个value，你其实是将它插入（insert）容器。如果随后写入第二个value，并不会覆盖第一个value，而是安插进去。

### Input迭代器
Input迭代器只能一次一个以前行方向（forward）读取元素，按此顺序一个个返回元素值。

Input迭代器的各项操作:
| 表达式        | 效果                                                 |
| ------------- | ---------------------------------------------------- |
| `*iter`       | 读取实际元素                                         |
| `iter->member`| 读取实际元素的成员（如果有的话）                     |
| `++iter`      | 向前步进（返回新位置）                               |
| `iter++`      | 向前步进（返回旧位置）                               |
| `iter1 == iter2` | 判断两个迭代器是否相等                           |
| `iter1 != iter2` | 判断两个迭代器是否不等                           |
| `TYPE(iter)`  | 复制迭代器（调用 copy 构造函数，创建迭代器的副本）   |

Input迭代器只能读取元素一次。如果你复制input迭代器，并令原input迭代器和新产生的拷贝都向前读取，可能会遍历到不同的值。

所有迭代器都具备input迭代器的能力，而且往往更强。
Pure input迭代器的典型例子就是“从标准输入设备（往往是键盘）读取数据”。
同一个值不会被读取两次。一旦从input stream读入一个字（离开input缓冲区），下次读取时就会返回另一个字。

对于input迭代器，操作符==和!=只用来检查“某个迭代器是否等于一个past-the-end迭代器（此将指向最末元素之下一位置）”。
这有其必要，因为处理input迭代器的操作函数通常会有以下行为：
```cc
InputIterator pos. end;
while (pos != end) {
    ... // read-only access using pos
    ++pos;
}
```
没有任何保证说，两个迭代器如果都不是past-the-end迭代器，且指向不同位置，它们的比较结果会不相等（这个条件是和forward迭代器搭配引入的）。

也请注意，input迭代器的后置式递增操作符iter++并不一定得返回什么东西。不过通常它会返回旧位置。

你应该尽可能优先选用前置式递增操作符（++iter）而非后置式递增操作符（iter++），因为前者效能更好。
这是因为前置式递增操作符不需返回旧值，也就不必花费一个临时对象来保存旧值。因此，对于任何迭代器pos（以及任何抽象数据类型），应该优先使用
```cc
++pos; // 更快
```
而不是
```cc
pos++; // 更慢
```
这条原则对递减操作符同样适用（但请注意，input迭代器并不提供递减操作符）。

### Forward（前向）迭代器
Forward 迭代器是一种 input 迭代器且在前进读取（reading forward）时提供额外保证。

Forward迭代器的各项操作
| 表达式        | 效果                                                 |
| ------------- | ---------------------------------------------------- |
| `*iter`       | 访问实际元素                                         |
| `iter->member`| 访问实际元素的成员                                   |
| `++iter`      | 向前步进（返回新位置）                               |
| `iter++`      | 向前步进（返回旧位置）                               |
| `iter1 == iter2` | 判断两个迭代器是否相等                           |
| `iter1 != iter2` | 判断两个迭代器是否不等                           |
| `TYPE()`      | 创建迭代器（调用 default 构造函数，构造新迭代器 ）   |
| `TYPE(iter)`  | 复制迭代器（调用 copy 构造函数，拷贝已有迭代器 ）    |
| `iter1 = iter2` | 对迭代器赋值（将 `iter2` 状态赋给 `iter1` ）       |

和input迭代器不同的是，两个forward迭代器如果指向同一元素，operator==会获得true，如果两者都递增，会再次指向同一个元素。例如：
```cc
ForwardIterator pos1, pos2;

pos1 = pos2 = begin;
if (pos1 != end) {
    ++pos1;
    while (pos1 != end) {
        ...
        ++pos1;
        ++pos2;
    }
}
```
Forward迭代器由以下对象和类型提供：
- Class＜forward_list＜＞
- Unordered container.

然而标准库也允许unordered容器的实现提供bidirectional迭代器.

如果forward迭代器履行了output迭代器应有的条件，那么它就是一个mutable forward迭代器，既可用于读取，也可用于涂写。

### Bidirectional（双向）迭代器
Bidirectional迭代器在forward迭代器的基础上增加了回头迭代（iterate backward）能力。换言之，它支持递减操作符，可一步一步后退.
| 表达式 | 效果                     |
| ------ | ------------------------ |
| `--iter` | 步退（返回新位置） |
| `iter--` | 步退（返回旧位置） |

Bidirectional迭代器由以下的对象和类型提供：
- Class list<>.
- Associative（关联式）容器。

如果bidirectional迭代器履行了output迭代器应有的条件，那么它就是个mutable bidirectional迭代器，既可用于读取，也可用于涂写。

### Random-Access（随机访问）迭代器
Random-access迭代器在bidirectional迭代器的基础上增加了随机访问能力。
因此它必须提供iterator算术运算（和寻常pointer的算术运算相当）。
也就是说，它能增减某个偏移量、计算距离（difference），并运用诸如＜和＞等关系操作符（relational operator）进行比较。
下表列出了random-access迭代器的新增操作。

Random-Access迭代器的新增操作:
| 表达式       | 效果                                                         |
| ------------ | ------------------------------------------------------------ |
| `iter[n]`    | 访问索引位置为`n`的元素                                       |
| `iter+=n`    | 前进`n`个元素（如果`n`是负数，则改为回退）                   |
| `iter-=n`    | 回退`n`个元素（如果`n`是负数，则改为前进）                   |
| `iter+n`     | 返回`iter`之后的第`n`个元素                                  |
| `n+iter`     | 返回`iter`之后的第`n`个元素                                  |
| `iter-n`     | 返回`iter`之前的第`n`个元素                                  |
| `iter1-iter2` | 返回`iter1`和`iter2`之间的距离                               |
| `iter1<iter2` | 判断`iter1`是否在`iter2`之前                                 |
| `iter1>iter2` | 判断`iter1`是否在`iter2`之后                                 |
| `iter1<=iter2` | 判断`iter1`是否不在`iter2`之后                               |
| `iter1>=iter2` | 判断`iter1`是否不在`iter2`之前                               |

Random-access迭代器由以下对象和类型提供：
- 可随机访问的容器（array、vector、deque）。
- String(string、wstring).
- 寻常的C-style array（pointer）。

以下程序说明了random-access迭代器的特殊能力：
```cc
#include <vector>
#include <iostream>
using namespace std;

int main()
{
    vector<int> coll;

    // insert elements from -3 to 9
    for (int i = -3; i <= 9; ++i) {
        coll.push_back(i);
    }

    // print number of elements by processing the distance between beginning and end
    // - NOTE: uses operator - for iterators
    cout << "number/distance: " << coll.end() - coll.begin() << endl;

    // print all elements
    // - NOTE: uses operator < instead of operator !=
    vector<int>::iterator pos;
    for (pos = coll.begin(); pos < coll.end(); ++pos) {
        cout << *pos << ' ';
    }
    cout << endl;

    // print all elements
    // - NOTE: uses operator [] instead of operator *
    for (int i = 0; i < coll.size(); ++i) {
        cout << coll.begin()[i] << ' ';
    }
    cout << endl;

    // print every second element
    // - NOTE: uses operator +=
    for (pos = coll.begin(); pos < coll.end() - 1; pos += 2) {
        cout << *pos << ' ';
    }
    cout << endl;
}
```
本例对（forward） list、（unordered） set和（unordered） map无效，
因为程序中标识NOTE：的操作都只适用于random-access迭代器。特别请注意，只有在面对random-access迭代器时，你才能以operator＜作为循环结束与否的判断准则。

请注意最后一个循环内的表达式要求coll至少包含一个元素：
```cc
pos < coll.end() - 1
```
如果容器为空，coll.end()-1便会位于coll.begin()之前。
虽然如此一来上述比较动作可能仍然有效，但严格说来，将迭代器移至“起点更前面”会导致不明确行为。
同样道理，如果表达式pos+=2将迭代器移至end()之后，也会导致不明确行为。
因此，按下面方法改变上述最后那个循环，会十分危险，因为如果容器内含偶数个元素，会导致不明确行为:
```cc
for (pos = coll.begin(); pos < coll.end(); pos != 2) {
    cout << *pos;
}
```
如果random-access迭代器履行了output迭代器应有的条件，那么它就是个mutable random-access迭代器，既可用于读取，也可用于涂写。

### Vector迭代器的递增（Increment）和递减（Decrement）
迭代器的递增（累进）和递减（累退）有个奇怪的问题。一般而言你可以递增或递减临时性迭代器，但对于array、vector和string就不行（在某些编译平台上）。考虑下面的例子：
```cc
vector<int> c;
...
if (c.size() > 1) {
    sort(++c.begin(), c.end());
}
```
编译++coll.begin()可能会失败，实际情况取决于平台。但如果你换用deque取代vector，就可以通过编译。
这种奇怪问题的产生原因是，vector、array和 string 的迭代器通常被实现为寻常pointer，
而C++并不允许你修改任何基础类型（包括pointer）的临时值，但对于struct和class则允许。
因此，如果迭代器被实现为寻常pointer，则编译失败；如果被实现为 class，则编译成功。
因此，前述代码对于vector、array和string以外的容器都没问题，因为那些容器的迭代器不可能被实现为寻常pointer。
但对于vector、array和string，前述代码是否可行就取决于具体的实现了。
通常其迭代器会被实现为寻常pointer，但如果你用的是一个“安全版本”的STL，迭代器亦可能被实现为class。
为保证可移植，C++11提供了next()（见9.3.2节第443页），所以你应该这么写：
```cc
vector<int> c;
...
if (c.size() > 1) {
    sort(std::next(c.begin()), c.end());
}
```
在C++11之前，你必须使用一个辅助对象：
```cc
vector<int> c;
...
if (c.size() > 1) {
    vector<int>::iterator beg = c.begin();
    sort(++beg, c.end());
}
```
这个问题其实并不像乍听之下那么糟糕，因为编译期就会检测出错误，所以不会发生不明确行为。不过这个问题也是够隐蔽了，得花点时间才能解决。

## 迭代器相关辅助函数
C++标准库为迭代器提供了一些辅助函数：advance()、next()、prev()、distance()和iter_swap()。
前四者提供给所有迭代器一些“原本只有random access迭代器才有”的能力：前进（或后退）多个元素，及处理迭代器之间的距离。
最后一个辅助函数允许你交换两个迭代器的value。

### advance()
advance()可将迭代器的位置增加，增加幅度由实参决定，也就是说它令迭代器一次前进（或后退）多个元素：
```cc
#include <iterator>
void advance(InputIterator& pos,Dist n) 
```
- 令名称为pos的input迭代器前进（或后退）n个元素。
- 对bidirectional迭代器和random-access迭代器而言，n可为负值，表示向后退。
- Dist是个template类型。通常它必须是个整数类型，因为会调用诸如＜、++、--等操作，还要和0做比较。
- advance()并不检查迭代器是否超过序列的end()（因为迭代器通常不知道其所操作的容器，因此无从检查）。所以，调用advance()有可能导致不明确行为——因为“对序列尾端调用operator++”是一种未被定义的行为。

此函数总能根据迭代器种类（category）采用最佳方案，这归功于它使用了 iterator trait 。
对于random-access 迭代器，此函数只是简单地调用pos+=n，因此具有常量复杂度。
对于其他任何类型的迭代器，则调用++pos （或--pos，如果n为负值） n次。因此，对于其他任何类型的迭代器，本函数具有线性复杂度（linear complexity）。

如果你希望你的程序可以轻松更换容器和迭代器种类，你应该使用advance()而不是operator+=。
不过你必须意识到，这么做可能是拿效能来冒险，因为将advance()应用于“不提供random-access迭代器”的容器中，你不太容易感受效能变差
（但正是由于运行期效能不佳，random-access迭代器才会想要提供operator+=）。
另外请注意，advance()不具返回值，而operator+=会返回新位置，所以后者可作为一个更大表达式的一部分。下面是advance()的运用实例：
```cc
#include <iterator>
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

int main()
{
    list<int> coll;

    // insert elements from 1 to 9
    for (int i = 1; i <= 9; ++i) {
        coll.push_back(i);
    }

    list<int>::iterator pos = coll.begin();

    // print actual element
    cout << *pos << endl;

    // step three elements forward
    advance(pos, 3);

    // print actual element
    cout << *pos << endl;

    // step one element backward
    advance(pos, -1);

    // print actual element
    cout << *pos << endl;
}
```

使用advance()的另一个例子就是用来忽略“迭代器从input stream 中读出的某些数据”

### next()和prev()
C++11提供了两个新增的辅助函数，允许你前进/向退后移动迭代器的位置。
```cc
#include <iterator>
ForwardIterator next(ForwardIterator pos)
ForwardIterator next(ForwardIterator pos, Dist n)
```
- 导致forward迭代器pos前进1或n个位置。
- 如果处理的是bidirectional和random-access迭代器，n可为负值，导致后退（回头）移动。
- Dist是类型`std::iterator_traits<ForwardIterator>::difference_type`。
- 其内部将对一个临时对象调用advance(pos, n)。
- 注意，next()并不检查是否会跨越序列的end()。因此调用者必须自行担保其结果有效。

```cc
#include <iterator>
BidirectionalIterator prev(BidirectionalIterator pos)
BidirectionalIterator prev(BidirectionalIterator pos, Dist n)
```
- 导致bidirectional迭代器pos后退1或n个位置。
- n可为负值，导致向前移动。
- Dist是类型`std::iterator_traits<BidirectionalIterator>::difference_type`。
- 其内部将对一个临时对象调用advance（pos，-n）。
- 注意，prev()并不检查是否会跨越序列的begin()。因此调用者必须自行担保其结果有效。

举个例子，这些辅助函数允许我们走过容器，只要我们检查了下一个元素：
```cc
auto pos = c.begin();
while (pos != c.end() && next(pos) != c.end()) {
    ...
    ++pos;
}
```
这么做特别有帮助，因为 forward和bidirectional迭代器不提供operator+和-。如果没有它们，你就需要一个临时对象的协助：
```cc
auto pos = c.begin();
auto nextPos = pos;
++nextPos;
while (pos != c.end() && nextPos != c.end()) {
    ...
    ++pos;
    ++nextPos;
}
```
或者必须限制只使用random-access迭代器：
```cc
auto pos = c.begin();
while (pos != c.end() && pos + 1 != c.end()) {
    ...
    ++pos;
}
```
不要忘记确保你手上是个有效位置（在你使用它之前）。基于这个原因，我们在检查下一个位置之前先检查pos是否等于coll.end()。

next()和prev()的第二个应用是避免诸如++coll.begin()这样的表达式需要去处理容器的第二元素。
问题在于，以++coll.begin()取代std::next(coll.begin())有可能通不过编译.

next()的第三个应用是它能搭配forward_list和before_begin()

### distance()
函数distance()用来处理两个迭代器之间的距离：

```cc
#include <iterator>
Dist distance(InputIterator pos1,InputIterator pos2)
```
- 返回两个input迭代器pos1和pos2之间的距离。
- 两个迭代器必须指向同一个容器。
- 如果不是random-access迭代器，则从pos1开始前进必须能够到达pos2，亦即pos2的位置必须与pos1相同或在其后。
- 返回类型Dist是迭代器相应的difference类型：
```cc
iterator_traits<InputIterator>::difference_type
```
这个函数能够根据迭代器种类（category）采取最佳实现手法，这必须利用迭代器标志（iterator tag）才得以达成。
对于random-access迭代器，此函数仅仅是返回pos2-pos1，因此具备常量复杂度。
对于其他迭代器种类，distance()会不断递增pos1，直到抵达pos2为止，然后返回递增次数。
也就是说，对于其他迭代器种类，distance()具备线性复杂度。因此对于non-random-access迭代器而言distance()的效能并不好，应该避免使用。

```cc
#include <iterator>
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

int main()
{
    list<int> coll;

    // insert elements from -3 to 9
    for (int i = -3; i <= 9; ++i) {
        coll.push_back(i);
    }

    // search element with value 5
    list<int>::iterator pos;
    pos = find(coll.begin(), coll.end(),  // range
               5);                        // value

    if (pos != coll.end()) {
        // process and print difference from the beginning
        cout << "difference between beginning and 5: "
             << distance(coll.begin(), pos) << endl;
    } else {
        cout << "5 not found" << endl;
    }
}
```

如果你希望将来可以轻松更换容器类型和迭代器类型，你应该使用distance()而不是operator-。
不过这么一来你可能就不会意识到“将random-access迭代器更换为其他类型的迭代器，会造成效能下降”这个问题了。

处理两个non-random-access迭代器之间的距离时，必须十分小心。
第一个迭代器所指的元素绝不能在第二个迭代器所指元素之后方（更下方），否则会导致不明确的行为。
如果不知道哪个迭代器在前，你必须先算出两个迭代器分别至容器起点的距离，再根据这两个距离来判断。
不过，你一定得清楚知道迭代器所指的目标容器为何。
如果两个迭代器指向不同容器，那么任你如何挣扎，都无法摆脱“导致不明确行为”的悲惨命运。

### iter_swap()
这个简单的辅助函数用来交换两个迭代器所指的元素值。
```cc
#include <algorithm>
void iter_swap (ForwardIterator1 pos1,ForwardIterator2 pos2)
```
- 交换迭代器pos1和pos2所指的值。
- 迭代器的类型不必相同，但其所指的两个值必须可以相互赋值（assignable）。

```cc
#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;

int main()
{
    list<int> coll;

    // insert elements from 1 to 9
    for (int i = 1; i <= 9; ++i) {
        coll.push_back(i);
    }

    PRINT_ELEMENTS(coll);

    // swap first and second value
    iter_swap(coll.begin(), next(coll.begin()));

    PRINT_ELEMENTS(coll);

    // swap first and last value
    iter_swap(coll.begin(), prev(coll.end()));

    PRINT_ELEMENTS(coll);
}
```

程序输出
```bash
1 2 3 4 5 6 7 8 9
2 1 3 4 5 6 7 8 9
9 1 3 4 5 6 7 8 2
```
注意，next()和prev()始自C++11，因此若以operator++和--取而代之，有可能无法针对每一种容器都通过编译：
```cc
vector<int> c;
...
iter_swap(c.begin(), ++c.begin());  // err 不兼容
...
iter_swap(c.begin(), --c.end());  // err 不兼容
```

## 迭代器适配器（Iterator Adapter）
本节讨论C++标准库提供的迭代器适配器。此类特殊迭代器使得算法能够以反向模式（reverse mode）或安插模式（insert mode）进行工作，也可以和stream（串流）搭配工作。

### Reverse（反向）迭代器
Reverse迭代器重新定义了递增运算和递减运算，使其行为正好颠倒。
因此，如果你使用这类迭代器，算法将以反向次序处理元素。
所有标准容器都允许使用reverse迭代器来遍历元素。下面是个例子：

```cc
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

void print(int elem)
{
    cout << elem << ' ';
}

int main()
{
    // create list with elements from 1 to 9
    list<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // print all elements in normal order
    for_each(coll.begin(), coll.end(),  // range
             print);                    // operation
    cout << endl;

    // print all elements in reverse order
    for_each(coll.rbegin(), coll.rend(),  // range
             print);                      // operations
    cout << endl;
}
```
容器的成员函数rbegin()和rend()各返回一个reverse迭代器，它们就像begin()和end()的返回值一样，共同定义出一个半开区间（half-open range）。不同的是它们以相反的方向操作：
- rbegin()返回反向迭代的第一元素位置，也就是真实之最末元素的位置。
- rend()返回反向迭代的最末元素的下一位置，也就是真实之第一元素的前一个位置。

于是，上述程序输出如下：
```bash
1 2 3 4 5 6 7 8 9
9 8 7 6 5 4 3 2 1
```
自C++11 起也提供了相应的成员函数 crbegin() 和 crend()，返回只读反向（read-only reverse）迭代器。由于上述程序只是要读取元素，所以可以（也应该）这么使用它们：
```cc
for_each(c.crbegin(), c.crend(), print);
```
#### 迭代器和Reverse迭代器
你可以将正常迭代器转化成reverse迭代器。
当然，原本那个迭代器必须具有双向移动能力。
注意，转换前后的迭代器逻辑位置发生了变化。考虑以下程序：
```cc
#include <iterator>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    // create list with elements from 1 to 9
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // find position of element with value 5
    vector<int>::const_iterator pos;
    pos = find(coll.cbegin(), coll.cend(),
               5);

    // print value to which iterator pos refers
    cout << "pos:  " << *pos << endl;

    // convert iterator to reverse iterator rpos
    vector<int>::const_reverse_iterator rpos(pos);
    // print value to which reverse iterator rpos refers
    cout << "rpos: " << *rpos << endl;
}
```
程序输出如下：
```bash
pos: 5
rpos: 4
```
我们首先打印迭代器的value（也就是其所指的元素值），然后将该迭代器转化为一个reverse迭代器，再次打印其value，结果竟然变了。
这不是bug，这是特性！导致这个性质是因为区间的半开性。
为了指出容器内所有元素，我们需要采用“最末元素的下一位置”。
然而对reverse迭代器而言，这个位置位于第一元素之前。糟糕的是，这个位置可能并不存在，因为容器并不要求其第一元素之前的位置合法。
例如寻常的string和array也可被视为容器，而语言本身并不保证array不可以从地址0开始。

为此，reverse 迭代器的设计者运用了一个小技巧：他们实际倒置了“半开原则”。
Reverse迭代器所定义的区间，并不包括起点，反倒是包括了终点。然而逻辑上其行为一如往常。( [rend, rbegin)  )
这么一来reverse迭代器物理意义所指的元素位置，和逻辑意义所指的元素位置就不一致。
现在问题是，将一个迭代器转化为 reverse迭代器，过程中发生了什么？该迭代器所保持（履行）的究竟是逻辑位置（value）还是物理位置（element）？
从上面的例子可知，后者才是答案。因此，其value（也就是其所指元素值）也就移到了前一个元素身上.


Reverse（反向）迭代器的位置和其value（其所指元素值）:

              rend                                    rbegin
      value    │                                value   │
        ┌──────┤                              ┌─────────┤
        ▼      ▼                              ▼         ▼
     ┌ ─ ┐   ┌───┐     ┌───┐     ┌───┐     ┌───┐      ┌ ─ ┐
     │   │   │ 1 │     │ 2 │     │ 3 │     │ 4 │      │   │
     └ ─ ┘   └───┘     └───┘     └───┘     └───┘      └ ─ ┘
    
所以pos和rpos是指向同一个元素，但是当rpos取值时，会取前一个元素的值
```cc
vector<int>::const_reverse_iterator rpos(pos);
```

不以为然吗？好吧，它有它的优点。
如果你有个区间，由一对（而非一个）迭代器定义出来，那么变换动作就非常简单了，所有元素仍然有效。考虑下面的例子：
```cc
#include <iterator>
#include <iostream>
#include <deque>
#include <algorithm>
using namespace std;

void print(int elem)
{
    cout << elem << ' ';
}

int main()
{
    // create deque with elements from 1 to 9
    deque<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // find position of element with value 2
    deque<int>::const_iterator pos1;
    pos1 = find(coll.cbegin(), coll.cend(),  // range
                2);                          // value

    // find position of element with value 7
    deque<int>::const_iterator pos2;
    pos2 = find(coll.cbegin(), coll.cend(),  // range
                7);                          // value

    // print all elements in range [pos1, pos2)
    for_each(pos1, pos2,    // range
             print);        // operation
    cout << endl;

    // convert iterators to reverse iterators
    deque<int>::const_reverse_iterator rpos1(pos1);
    deque<int>::const_reverse_iterator rpos2(pos2);

    // print all elements in range [pos1, pos2) in reverse order
    for_each(rpos2, rpos1,  // range
             print);        // operation
    cout << endl;
}
```
迭代器pos1和pos2定义出一个半开区间，包括元素值2不包括元素值7。
当你把描述此区间的两个迭代器转化为reverse迭代器时，该区间仍然有效，可以被逆序处理。程序输出如下：
```bash
2 3 4 5 6
6 5 4 3 2
```
rbegin()其实很简单：
```cc
container::reverse_iterator(end())
```
rend()也很简单:
```cc
container::reverse_iterator(begin())
```
当然，常量迭代器const_iterator会被转化为类型const_reverse_iterator.

#### 运用base()将Reverse迭代器转回正常
你也可以将reverse迭代器转回正常迭代器。
为了这么做，reverse迭代器提供了一个base成员函数：
```cc
namespace std {
    template <typename Iterator>
    class reverse_iterator {
    public:
        Iterator base() const;
        // 其他成员和实现细节...
    };
}
```
下面是一个运用实例：
```cc
#include <iterator>
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

int main()
{
    // create list with elements from 1 to 9
    list<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // find position of element with value 5
    list<int>::const_iterator pos;
    pos = find(coll.cbegin(), coll.cend(),  // range
               5);                          // value

    // print value of the element
    cout << "pos:  " << *pos << endl;

    // convert iterator to reverse iterator
    list<int>::const_reverse_iterator rpos(pos);

    // print value of the element to which the reverse iterator refers
    cout << "rpos:  " << *rpos << endl;

    // convert reverse iterator back to normal iterator
    list<int>::const_iterator rrpos;
    rrpos = rpos.base();

    // print value of the element to which the normal iterator refers
    cout << "rrpos: " << *rrpos << endl;
}
```
程序输出如下：
```bash
pos: 5
rpos: 4
rrpos: 5
```
由此可见，通过base()进行转换：
```cc
*rpos.base()
```
就好像从寻常的迭代器转换为reverse迭代器情况一样，物理位置维持不动，变化的是逻辑位置（也就是它所指的元素）。

### Insert（安插型）迭代器
Insert迭代器，也称为inserter，用来将“赋予新值”动作转换为“安插新值”动作。
借由这种迭代器，算法将执行安插（insert）行为而非覆写（overwrite）行为。
所有insert迭代器都隶属于Output迭代器种类，所以它只提供赋值能力（assign〔assign就是overwrite，会盖掉原内容〕）。

#### Insert迭代器的功能
通常，算法会将 value 赋值给标的迭代器（desination iterator）。例如 copy() 算法:
```cc
namespace std {
    template <typename InputIterator, typename OutputIterator>
    OutputIterator copy(InputIterator from_pos,  // beginning of source
                        InputIterator from_end,   // end of source
                        OutputIterator to_pos)    // beginning of dest.
    {
        while (from_pos != from_end) {
            *to_pos = *from_pos;  // copy values
            ++from_pos;           // increment iterators
            ++to_pos;
        }
        return to_pos;
    }
}
```
循环不断执行，直到from_pos抵达终点。在循环内，来源端迭代器from_pos被赋值给标的端迭代器to_pos，然后两个迭代器都递增。

这里需要注意的是：
```cc
*to_pos = value;
```
Insert迭代器可以把上述的赋值动作转化为安插动作。
实际上其内有两个操作：首先operator*传回迭代器当前位置，然后再由operator=赋予新值。Insert迭代器通常使用下面两个实现技巧：
- 1.`Operator*`被实现为一个无作用的no-op，仅仅返回`*this`。所以对insert迭代器来说，`*pos`与pos等价。
- 2.赋值动作（assignment）被转化为安插动作（insertion）。事实上，insert迭代器会调用容器的push_back()、push_front()或insert()成员函数。

所以，对于insert 迭代器 pos，你可以写 `pos=value` 也可以写`*pos=value`，两者都可以插入新值。当然，这里谈的是insert迭代器的实现细节，从概念上讲，正确的赋值式应该是`*pos=value`。

同样道理，递增操作符也被实现为一个no-op，也是仅仅返回一个`*this`。所以，你不可以改动insert迭代器的位置。

表列出了insert迭代器的所有操作函数。

Insert迭代器允许的操作:
| 表达式   | 效果                  |
| -------- | --------------------- |
| `*iter`  | No-op（返回 `iter`）  |
| `iter = value` | 安插 `value`       |
| `++iter` | No-op（返回 `iter`）  |
| `iter++` | No-op（返回 `iter`）  |

#### Insert迭代器的种类
C++标准库提供三种insert迭代器：back inserter，front inserter和general inserter。
它们之间的区别在于安插的位置。
事实上，它们各自调用所属容器中不同的成员函数。所以insert迭代器初始化时一定要清楚指明所属的容器是哪一种。

每一种insert迭代器都可以由一个对应的便捷函数加以生成和初始化。

表列出了不同的insert迭代器及其能力。

Insert迭代器的种类:
| 名称           | Class 名称              | 其所调用的函数       | 生成函数              |
| -------------- | ----------------------- | -------------------- | --------------------- |
| Back inserter  | back_insert_iterator   | push_back(value)    | back_inserter(cont)   |
| Front inserter | front_insert_iterator  | push_front(value)   | front_inserter(cont)  |
| General inserter | insert_iterator      | insert(pos,value)   | inserter(cont,pos)    |

当然，容器本身必须支持insert迭代器所调用的函数，否则这种insert迭代器就不可用。
因此，back inserter只能用在vector、deque、list和string身上，front inserter只能用在deque和list身上。

#### Back Inserter
Back inserter，或称back insert iterator，借由成员函数push_back()将一个value附加于容器尾部。
由于push_back()只存在于vector、deque、list和string，所以C++标准库中也只有这些容器支持back inserter。

Back inserter生成时，其初始化过程必须确知其所属容器。函数back_inserter()为此提供了一条捷径。
以下例子展示了back inserter的用法：
```cc
#include <vector>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    // create back inserter for coll
    // - inconvenient way
    back_insert_iterator<vector<int>> iter(coll);

    // insert elements with the usual iterator interface
    *iter = 1;
    iter++;
    *iter = 2;
    iter++;
    *iter = 3;
    PRINT_ELEMENTS(coll);

    // create back inserter and insert elements
    // - convenient way
    back_inserter(coll) = 44;
    back_inserter(coll) = 55;
    PRINT_ELEMENTS(coll);

    // use back inserter to append all elements again
    // - reserve enough memory to avoid reallocation
    coll.reserve(2 * coll.size());
    copy(coll.begin(), coll.end(),     // source
         back_inserter(coll));         // destination
    PRINT_ELEMENTS(coll);
}
```
程序输出如下：
```bash
1 2 3
1 2 3 44 55
1 2 3 44 55 1 2 3 44 55
```
注意，一定要在调用 copy()之前确保有足够大的空间。
因为 back inserter在安插元素时，可能会造成指向该vector的其他迭代器失效。因此，如果不保留足够空间，这个算法可能会形成“源端迭代器失效”状态。

String也提供一套STL容器接口，包括push_back()。所以你也可以利用back inserter为string附加字符.

#### Front Inserter
Front inserter，或称front insert iterator，乃是借由成员函数push_front()将一个value加于容器头部。
由于push_front（）只在deque、list和forward list有所实现，所以C++标准库中也就只有这些容器支持front inserter。

Front inserter生成时，其初始化过程必须确知其所属容器。函数front_inserter()为此提供了一条捷径。以下展示了front inserter的用法：
```cc
#include <list>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;

int main()
{
    list<int> coll;

    // create front inserter for coll
    // - inconvenient way
    front_insert_iterator<list<int>> iter(coll);

    // insert elements with the usual iterator interface
    *iter = 1;
    iter++;
    *iter = 2;
    iter++;
    *iter = 3;

    PRINT_ELEMENTS(coll);

    // create front inserter and insert elements
    // - convenient way
    front_inserter(coll) = 44;
    front_inserter(coll) = 55;

    PRINT_ELEMENTS(coll);

    // use front inserter to insert all elements again
    copy(coll.begin(), coll.end(),     // source
         front_inserter(coll));        // destination

    PRINT_ELEMENTS(coll);
}
```
程序输出如下：
```bash
3 2 1
55 44 3 2 1
1 2 3 44 55 55 44 3 2 1
```
注意，安插多个元素时，front inserter以逆序方式插入，这是因为它总是将下一个元素安插于前一个元素的前面。

#### General Inserter
General inserter，或称 general insert iterator，根据两个实参完成初始化：
- 容器
- 待安插位置。
迭代器内部以“待安插位置”为实参调用成员函数insert()。便捷函数inserter()则提供了更方便的手段来产生general inserter并加以初始化。

General inserter对所有标准容器均适用（只有array和forward list除外），因为那些容器都提供有insert()成员函数。
然而对associative和unordered容器而言，安插位置只是个提示，因为在这两种容器中元素的真正位置视其value而定。

安插动作完成后，general inserter获得刚被安插的那个元素的位置。相当于调用以下语句：
```cc
pos = container.insert(pos, val);
++pos;
```
为什么要将insert()的返回值赋予pos呢？这是为了确保该迭代器的位置始终有效。
如果没有这一赋值动作，在deque、vector和string中，该general inserter本身可能会失效。
因为每一次安插动作都会（或至少可能会）使指向容器的所有迭代器失效。

下面展示general inserter的用法：
```cc
#include <set>
#include <list>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;

int main()
{
    set<int> coll;

    // create insert iterator for coll
    // - inconvenient way
    insert_iterator<set<int>> iter(coll, coll.begin());

    // insert elements with the usual iterator interface
    *iter = 1;
    iter++;
    *iter = 2;
    iter++;
    *iter = 3;

    PRINT_ELEMENTS(coll, "set:  ");

    // create inserter and insert elements
    // - convenient way
    inserter(coll, coll.end()) = 44;
    inserter(coll, coll.end()) = 55;

    PRINT_ELEMENTS(coll, "set:  ");

    // use inserter to insert all elements into a list
    list<int> coll2;
    copy(coll.begin(), coll.end(),               // source
         inserter(coll2, coll2.begin()));        // destination

    PRINT_ELEMENTS(coll2, "list: ");

    // use inserter to reinsert all elements into the list before the second element
    copy(coll.begin(), coll.end(),               // source
         inserter(coll2, ++coll2.begin()));      // destination

    PRINT_ELEMENTS(coll2, "list: ");
}
```
程序输出如下：
```bash
set: 1 2 3
set: 1 2 3 44 55
list: 1 2 3 44 55
list: 1 1 2 3 44 55 2 3 44 55
```
上述的copy()动作用来展示general inserter维护着元素次序。第二个copy()动作使用区间中的一个适当位置为实参。

#### Associative容器的订制型Inserter
如前所述，对于associative容器，general inserter的“位置实参”只不过是个提示，用来强化速度。如果使用不当反而可能导致较糟的效能。
举个例子，如果逆序安插，这个提示就可能使程序变慢，因为它使程序总是从错误的位置开始查找安插点。

### Stream（串流）迭代器
Stream迭代器是一种迭代器适配器，借由它，你可以把stream当成算法的来源端和目的端。
更明确地说，一个istream迭代器可用来从input stream读取元素，而一个ostream迭代器可以用来对output stream写入元素。

Stream迭代器的一种特殊形式，是所谓stream buffer迭代器，用来对stream buffer进行直接读取和涂写操作。

#### Ostream迭代器
Ostream迭代器可以将“被赋值”（assigned value）写入output stream。
用了它，算法就可以直接写入stream。其实现机制与insert迭代器概念一致，唯一的区别在于ostream迭代器将赋值动作转化为 output动作（通过operator<<）。
如此一来算法就可以使用寻常的迭代器接口直接对stream执行涂写动作。
表列出了ostream迭代器提供的各项操作。

ostream迭代器的各项操作:
| 表达式                             | 效果                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| `ostream_iterator<T>(ostream)`     | 为 `ostream` 建立一个 `ostream` 迭代器                       |
| `ostream_iterator<T>(ostream,delim)` | 为 `ostream` 建立一个 `ostream` 迭代器，各元素间以 `delim` 为分隔符（请注意 `delim` 的类型是 `const char*` ） |
| `*iter`                            | No-op（返回 `iter`）                                         |
| `iter = value`                     | 将 `value` 写到 `ostream`：`ostream<<value`。其后再输出一个 `delim`（分隔符；如有定义的话） |
| `++iter`                           | No-op（返回 `iter`）                                         |
| `iter++`                           | No-op（返回 `iter`）                                         |

建立ostream迭代器时，你必须提供一个output stream作为实参，迭代器会把value写至该output stream。
另一个实参可有可无，是个字符串，被用来作为各个元素值之间的分隔符。

Ostream迭代器是针对尚未确定的元素类型T而定义：
```cc
namespace std {
    template <typename T,
              typename charT = char,
              typename traits = char_traits<charT>>
    class ostream_iterator;
}
```
带默认值的第二和第三个template实参用来指明所使用的stream类型.

以下展示了ostream迭代器的用法：
```cc
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
using namespace std;

int main()
{
    // create ostream iterator for stream cout
    // - values are separated by a newline character
    ostream_iterator<int> intWriter(cout, "\n");

    // write elements with the usual iterator interface
    *intWriter = 42;
    intWriter++;
    *intWriter = 77;
    intWriter++;
    *intWriter = -5;

    // create collection with elements from 1 to 9
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    // write all elements without any delimiter
    copy(coll.cbegin(), coll.cend(),
         ostream_iterator<int>(cout));
    cout << endl;

    // write all elements with " < " as delimiter
    copy(coll.cbegin(), coll.cend(),
         ostream_iterator<int>(cout, " < "));
    cout << endl;
}
```
程序输出
```bash

42
77
-5
123456789
1 < 2 < 3 < 4 < 5 < 6 < 7 < 8 < 9 < 
```
注意，分隔符的类型是 `const char*`。如果你传一个 string 对象进去，别忘了调用c_str()成员函数以吻合正确类型。例如：
```cc
string delim;
...
ostream_iterator<int>(cout, delim.c_str());
```
### Istream迭代器
Istream迭代器是ostream迭代器的拍档，用来从input stream读取元素。
通过istream迭代器，算法可以从stream直接读取数据。
然而istream迭代器较ostream迭代器稍微复杂一些（这很正常，read本来就比write复杂一些）。

建立istream迭代器时，你必须提供一个input stream作为实参，迭代器将从其中读取数据。
然后它便经由input迭代器的寻常接口，使用operator>>读取元素。
然而，读取动作有可能失败（可能因为读到文件尾部，或读取错误），此外算法的数据来源端也需要一个“终点位置”。
为解决这些问题，你可以使用一个所谓的end-of-stream迭代器，它以istream迭代器的default构造函数生成。
只要有任何一次读取失败，所有istream迭代器都会变成end-of-stream迭代器。
所以进行一次读取后，你就应该将istream迭代器拿来和end-of-stream迭代器比较一番，看看这个迭代器是否仍然有效。

表列出了istream迭代器的所有操作。

istream迭代器的各项操作:
| 表达式                     | 效果                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `istream_iterator<T>()`    | 建立一个 end-of-stream 迭代器                                |
| `istream_iterator<T>(istream)` | 为 `istream` 建立一个迭代器（可能会立刻读取第一个值）       |
| `*iter`                    | 返回此前读取的值（如果构造函数并未立刻读取第一个值，则本式执行读取任务） |
| `iter->member`             | 返回“此前读取的元素”的成员（如果有的话）                     |
| `++iter`                   | 读取下一个值，并返回其位置                                   |
| `iter++`                   | 读取下一个值，但返回的迭代器指向前一个读取值                 |
| `iter1==iter2`             | 检查 `iter1` 和 `iter2` 是否相等                             |
| `iter1!=iter2`             | 检查 `iter1` 和 `iter2` 是否不等                             |

注意，istream 迭代器的构造函数会将 stream 打开，并往往会读取第一个值，否则一旦`operator*`在此迭代器初始化后被调用，就无法返回第一个元素了。
所以，在确实需要用到istream迭代器之前，别过早定义它。
不过某些实现版本可能会延缓第一次读取动作直到`operator*`首次被调用。

Istream迭代器是针对未定类型T而定义的：
```cc
namespace std {
    template <typename T,
              typename charT = char,
              typename traits = char_traits<charT>,
              typename Distance = ptrdiff_t>
    class istream_iterator;
}
```
拥有默认值的第二和第三template实参，用来指明stream类型。第四个template实参（也有默认值）用来指明表达“迭代器距离（difference）”的类型。

如果满足以下条件，我们便说两个istream迭代器相等：
- 两者都是end-of-stream迭代器（因而不能再进行读取），或
- 两者都可以再进行读取动作，并指向相同的stream。

以下展示istream迭代器的各项操作：
```cc
#include <iostream>
#include <iterator>
using namespace std;

int main()
{
    // create istream iterator that reads integers from cin
    istream_iterator<int> intReader(cin);

    // create end-of-stream iterator
    istream_iterator<int> intReaderEOF;

    // while able to read tokens with istream iterator
    // - write them twice
    while (intReader != intReaderEOF) {
        cout << "once:       " << *intReader << endl;
        cout << "once again: " << *intReader << endl;
        ++intReader;
    }
}
```
如果执行这个程序并给予以下输入：
```bash
1 2 3 f 4
```
程序输出
```bash
once:       1
once again: 1
once:       2
once again: 2
once:       3
once again: 3
```
如你所见，字符f的输入导致程序结束。
是的，由于格式错误，stream不再处于good状态，于是istream迭代器intReader就和end-of-stream迭代器intReaderEOF相同，使得循环条件为 false，进而结束循环。

#### Stream迭代器的另一例，使用advance()
以下例子使用了两种stream迭代器，而且用到了迭代器函数advance()：
```cc
#include <iterator>
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
    istream_iterator<string> cinPos(cin);
    ostream_iterator<string> coutPos(cout, " ");

    // while input is not at the end of the file
    // - write every third string
    while (cinPos != istream_iterator<string>()) {
        // ignore the following two strings
        advance(cinPos, 2);

        // read and write the third string
        if (cinPos != istream_iterator<string>()) {
            *coutPos++ = *cinPos++;
        }
    }
    cout << endl;
}
```
迭代器函数advance()用来帮助迭代器前进到另一位置。
当它被用来搭配istream迭代器，结果便是“跳过输入单元（input token）”。

假设你的输入如下：
```bash
No one objects if you are doing
a good programming job for
someone whom you respect.
```
则输出如下:
```bash
objects are good for you
```
千万别忘了，调用advance()之后、访问`*cinPos`之前，一定要记得检查istream迭代器是否依然有效，
如果对end-of-stream迭代器调用`operator*`，会导致不明确的行为。

### Move（搬移）迭代器
从C++11开始，提供了一个迭代器适配器（iterator adapter），用来将任何对底层元素的处理转换为一个move操作。举个例子：
```cc
list<string> l;
...
vector<string> v1(l.begin(), l.end());  // copy string into v1
vector<string> v2(make_move_iteraotr(l.begin()), 
                  make_move_iteraotr(l.begin())); // move string into v2
```
这些迭代器的应用之一是，让算法以move取代copy，将元素从一个区间放到另一个区间。
然而注意，一般而言，move()算法做同样的事情.

一般而言，只有当“算法将元素从某个来源区间迁移（transfer）至某个目标区间”，这种情况下在算法中使用move迭代器才有意义。
此外，你必须确保每个元素只被处理一次，否则，其内容将被搬移一次以上，那会导致不明确的行为。

注意，唯一保证“元素只被读取或被处理一次”的迭代器种类是input iterator。
因此，通常只有当“某算法有个来源端，其内要求 input iterator，并且有个目的端，其内使用 output iterator”，这时候使用 move 迭代器才有意义。
唯一例外是for_each()，它可处理被指明区间（passed range）内的被搬移元素（moved element），例如把它们搬移到一个新容器内。

## Iterator Trait（迭代器特性）
迭代器可以区分为不同类型（category），每个类型都代表特定的迭代器能力。
如果能根据不同的迭代器种类将操作行为重载（overload），将会很有用，甚至很必要。
通过迭代器标志（tag）和特性（trait，由`<iterator>`提供）可以实现这样的重载。

C++标准库为每个迭代器种类提供了一个迭代器标志（iterator tag），用来作为迭代器的标签（label）：
```cc
namespace std {
    struct output_iterator_tag {
    };
    struct input_iterator_tag {
    };
    struct forward_iterator_tag
        : public input_iterator_tag {
    };
    struct bidirectional_iterator_tag
        : public forward_iterator_tag {
    };
    struct random_access_iterator_tag
        : public bidirectional_iterator_tag {
    };
}
```
请注意，这里用到了继承。所以我们可以说，任何forward迭代器都是一种input迭代器。
然而请注意，forward迭代器tag只派生自input迭代器tag，和output迭代器tag无关。
事实上forward迭代器的某些特性的确不符合output迭代器的要求.

如果你撰写泛型码（generic code），可能不只对迭代器种类（category）感兴趣，可能还需要了解迭代器所指元素的类型。
C++标准库提供了一种特殊的template结构来定义所谓的迭代器特性（iterator trait），
该结构包含迭代器相关的所有信息，为“迭代器应具备的所有类型定义（包括迭代器种类、元素类型等）”提供一致的接口：
```cc
namespace std {
    template <typename T>
    struct iterator_traits {
        typedef typename T::iterator_category iterator_category;
        typedef typename T::value_type        value_type;
        typedef typename T::difference_type   difference_type;
        typedef typename T::pointer           pointer;
        typedef typename T::reference         reference;
    };
}
```
在这个template中，T表示迭代器类型。
有了它，我们就可以撰写任何“运用迭代器种类或其元素类型”的泛型码。
例如以下表达式就可以取得迭代器类型为T的元素类型（value type）：
```cc
typename std::iterator_traits<T>::value_type
```
这个trait结构有两个优点：
- 1.确保每一个迭代器都提供了所有必要的类型定义。
- 2.能够针对特定的迭代器实施特化（specialization）。

上述第二条适用于“以寻常pointer作为迭代器”时：
```cc
namespace std {
    template <typename T>
    struct iterator_traits<T*> {
        typedef T                              value_type;
        typedef ptrdiff_t                      difference_type;
        typedef random_access_iterator_tag    iterator_category;
        typedef T*                             pointer;
        typedef T&                             reference;
    };
}
```

于是，针对“指向T类型”之寻常pointer，上述特化版本告诉我们，该类型具有random-access迭代器种类。
除了上述特化版本，对`const T*`应该再准备一个相应的特化定义。

### 为迭代器编写泛型函数（Generic Function）
借由iterator trait，你可以撰写这样的泛型函数：根据迭代器而派生某种类型定义，或根据迭代器种类（category）而采用不同的实现代码。

#### 运用迭代器的value_type
某些算法内部需要一个以元素类型为类型的临时变量，这正是使用iterator trait的一个简单例子。这样的临时变量可以声明如下：
```cc
typename std::iterator_traits<T>::value_type tmp;
```
其中T是迭代器类型。

另一个例子是将元素循环往复地移动（shift cyclically）：
```cc
template <typename ForwardIterator>
void shift_left (ForwardIterator beg, ForwardIterator end)
{
    // temporary variable for first element
    typedef typename
    std::iterator_traits<ForwardIterator>::value_type value_type;

    if (beg != end) {
        // save value of first element
        value_type tmp(*beg);

        // shift following values
        ...
    }
}
```

#### 运用迭代器的iterator_category
如果希望针对不同的迭代器种类采取不同的实现方案，你需要下面两个步骤：

1.让你的template函数将迭代器种类作为附加实参，调用另一个函数。例如：
```cc
template <typename Iterator>
inline void foo(Iterator beg, Iterator end)
{
    foo (beg, end, std::iterator_traits<Iterator>::iterator_category());
}
```
2.针对不同的迭代器种类实现出上述调用的函数。注意，如果迭代器种类B为D之父类，而此处所谈函数针对B、D并无不同实现，那么只需针对B实现即可。
```cc
template <typename BiIterator>
void foo (BiIterator beg, BiIterator end, std::bidirectional_iterator_tag)
{
    ...
}

template <typename RaIterator>
void foo (RaIterator beg, RaIterator end, std::random_access_iterator_tag)
{
    ...
}
```
其中，针对random-access迭代器而写的版本可以使用随机访问操作，针对bidirec-tional迭代器而写的版本则不可以。
基于迭代器标志（tag）继承体系，你可以写出一份实现代码但适用于多个迭代器种类（category）。

#### distance()的实现
以下系根据稍早所说的两个步骤，实现出迭代器辅助函数distance()。
此函数返回两个迭代器所指元素的位置间距。
对于random-access迭代器，此函数仅仅使用operator-便可获得结果，
对于其他任何种类的迭代器，此函数必须一步一步前进至区间终点，才有能力计算出结果并返回。
```cc
// general distance()
template <typename Iterator>
typename std::iterator_traits<Iterator>::difference_type
distance(Iterator pos1, Iterator pos2)
{
    return distance(pos1, pos2,
                    std::iterator_traits<Iterator>
                        ::iterator_category());
}

// distance() for random-access iterators
template <typename RaIterator>
typename std::iterator_traits<RaIterator>::difference_type
distance(RaIterator pos1, RaIterator pos2,
         std::random_access_iterator_tag)
{
    return pos2 - pos1;
}

// distance() for input, forward, and bidirectional iterators
template <typename InIterator>
typename std::iterator_traits<InIterator>::difference_type
distance(InIterator pos1, InIterator pos2,
         std::input_iterator_tag)
{
    typename std::iterator_traits<InIterator>::difference_type d;
    for (d = 0; pos1 != pos2; ++pos1, ++d) {
        ;
    }
    return d;
}
```

返回类型必须是迭代器的距离类型（difference type）。
请注意第二版本使用input迭代器，所以该版本对forward迭代器、bidirectional迭代器都有效，因为这两种迭代器的标志（tag）是从input_iterator_tag派生出来的。

## 用户自定义（User-Defined）迭代器
让我们自己写个迭代器。如前所述，你必须让iterator trait能够处理这样的迭代器。两种办法可行：
- 1.提供必要的五种类型定义，就像iterator_traits结构所描述.
- 2.为 iterator_traits结构提供一个（偏）特化版本。

关于第一种方法，C++标准库提供了一个特殊的基类（base class） iterator<>，专门用来进行这一定义，你只需这样指定类型：
```cc
class MyIterator 
  : public std::iterator<std::bidirectional_iterator_tag, type, std::ptrdiff_t, type *, type &>{
    ...
};
```
第一个template参数用来定义迭代器种类，
第二个参数用来定义元素类型，
第三参数用来定义difference（距离）类型，
第四个参数用来定义pointer类型，
第五个参数用来定义reference类型。
末尾的三个参数有默认值ptrdiff_t、type*和type&，所以通常这样写就够了：
```cc
class MyIterator 
  : public std::iterator<std::bidirectional_iterator_tag, type>{
    ...
};
```
以下实例说明如何编写自定义迭代器。
这是一个associative和unordered容器的insert迭代器。它和C++标准库的insert迭代器不同，它不需要指明“安插位置”。
```cc
#include <iterator>

// class template for insert iterator for associative and unordered containers
template <typename Container>
class asso_insert_iterator
    : public std::iterator<std::output_iterator_tag,
                           typename Container::value_type> {
protected:
    Container& container;  // container in which elements are inserted

public:
    // constructor
    explicit asso_insert_iterator(Container& c) : container(c) {}

    // assignment operator
    // - inserts a value into the container
    asso_insert_iterator<Container>& operator=(const typename Container::value_type& value) {
        container.insert(value);
        return *this;
    }

    // dereferencing is a no-op that returns the iterator itself
    asso_insert_iterator<Container>& operator*() {
        return *this;
    }

    // increment operation is a no-op that returns the iterator itself
    asso_insert_iterator<Container>& operator++() {
        return *this;
    }
    asso_insert_iterator<Container>& operator++(int) {
        return *this;
    }
};

// convenience function to create the inserter
template <typename Container>
inline asso_insert_iterator<Container> asso_inserter(Container& c) {
    return asso_insert_iterator<Container>(c);
}
```
其中的 class asso_insert_iterator 派生自 class iterator。
传给 iterator 的第一个实参output_iterator_tag指定了迭代器种类。
第二实参是此迭代器所指的元素值类型，此处设为容器的value_type；由于output迭代器只能用于写入某东西，因而此类型并非必需，因此你可以传入void。
然而像本例这样指明为value type，将可适用于任何迭代器种类。

诞生之时，这一迭代器将容器存储于其成员container中。
所有被赋予（assigned）的值都借由insert()被安插到容器内。`Operators*`和`operater++`只返回迭代器自身，无任何实际动作，但这么虚晃一招使得迭代器得以维护其控制权。
如果下面这样的迭代器一般性接口被使用了：
```cc
*pos = value;
```
`*pos`会返回`*this`，新值被赋予其中。至于赋值动作（operator=）则被转化为对容器成员函数insert(value)的调用。

这一insert迭代器完成后，我们还可以提供一个asso_inserter函数，用来简化迭代器的创建和初始化。
以下程序便是使用这样一个inserter对一个unordered set安插若干元素：
```cc
#include <iostream>
#include <unordered_set>
#include <vector>
#include <algorithm>
#include "print.hpp"
#include "assoiter.hpp"

int main()
{
    std::unordered_set<int> coll;

    // create inserter for coll
    // - inconvenient way
    asso_insert_iterator<decltype(coll)> iter(coll);

    // insert elements with the usual iterator interface
    *iter = 1;
    iter++;
    *iter = 2;
    iter++;
    *iter = 3;

    PRINT_ELEMENTS(coll);

    // create inserter for coll and insert elements
    // - convenient way
    asso_inserter(coll) = 44;
    asso_inserter(coll) = 55;

    PRINT_ELEMENTS(coll);

    // use inserter with an algorithm
    std::vector<int> vals = { 33, 67, -4, 13, 5, 2 };
    std::copy(vals.begin(), vals.end(),     // source
              asso_inserter(coll));         // destination

    PRINT_ELEMENTS(coll);
}
```

# STL函数对象及Lambda
本章详细介绍如何传递特定机能给算法和成员函数。我们用的是所谓function object（函数对象），或简称functors（仿函数）。
本章涵盖STL预定义的所有function object、function adapter（函数适配器）和binder（绑定器），以及机能合成（functional composition）概念，并提供笔者自己写的一些function object实例。
本章也详细表现lambda的应用。

## Function Object（函数对象）的概念
所谓function object（或者说functor），是一个定义了operator()的对象。
```cc
FunctionObjectType fo;
...
fo(...);
```
中表达式 fo() 系调用function object fo 的operator ()，而非调用函数 fo()。
你可以将function object视为一般函数，只不过用的是一种更复杂的撰写手段，并非将所有语句放在函数体中：
```cc
void fo() {
    statements
}
```
而是在function object class的operator ()内撰写代码：
```cc
class FunctionObjectType {
    public:
    void operator() {
        statements
    }
};
```
这种定义形式更为复杂，却有三大优点：
- 1.Function object比一般函数更灵巧（smarter），因为它可以拥有状态（state）。事实上，对于相同的function object class你可以拥有两个状态不同的实例（instance）。寻常的函数无法做到这一点。
- 2.每个function object都有其类型。因此你可以将function object的类型当作template参数传递，从而指定某种行为。还有一个好处：容器类型也会因为 function object的不同而不同。
- 3.执行速度上，function object通常比function pointer更快。

### 以Function Object为排序准则（Sorting Criterion）
程序员经常需要将某些class object 以排序（sorted）状态置入容器（例如一个 Person 集合）。
然而，或许因为不想，或许因为不能，你无法使用一般的operator＜对这些对象排序，你必须以某种特别规则（通常基于某些成员函数）来排序。
此时function object可以派上用场，试看下例：
```cc
#include <iostream>
#include <string>
#include <set>
#include <algorithm>
using namespace std;

class Person {
public:
    string firstname() const;
    string lastname() const;
    ...
};

// class for function predicate
// - operator () returns whether a person is less than another person
class PersonSortCriterion {
public:
    bool operator() (const Person& p1, const Person& p2) const {
        // a person is less than another person
        // - if the last name is less
        // - if the last name is equal and the first name is less
        return p1.lastname() < p2.lastname() ||
               (p1.lastname() == p2.lastname() &&
                p1.firstname() < p2.firstname());
    }
};

int main()
{
    // create a set with special sorting criterion
    set<Person, PersonSortCriterion> coll;
    ...

    // do something with the elements
    for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
        ...
    }
    ...
}
```
这里的set coll 使用特殊排序准则 PersonSortCriterion，而它正是一个function object class。
PersonSortCriterion这么定义operator ()：先比较两人的姓，如果相等再比较其名。
coll构造函数会自动产生class PersonSortCriterion的一个实例（instance），所有元素都将以此为排序准则进行排序。

注意，排序准则PersonSortCriterion是个class，所以你可以把它当作set的template实参。
如果以寻常函数担任排序准则，就无法做到这一点.

“以上述类型作为排序准则”的所有set，都拥有属于自己的独一无二的类型。
你无法将这个set拿来和“拥有不同排序准则”的其他set合并或赋值。
虽然你无论做什么都无法回避set的自动排序特性，但你可以设计出“表现不同的排序准则却有着相同类型”的function object.

### Function Object拥有内部状态（Internal State）
下面展示function object如何能够“行为像个函数同时又拥有多个状态”：
```cc
#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;

class IntSequence {
private:
    int value;
public:
    IntSequence(int initialValue)  // constructor
        : value(initialValue) {
    }

    int operator()() {             // 'function call'
        return ++value;
    }
};

int main()
{
    list<int> coll;

    // insert values from 1 to 9
    generate_n(back_inserter(coll),  // start
               9,                    // number of elements
               IntSequence(1));      // generates values, starting with 1

    PRINT_ELEMENTS(coll);

    // replace second to last element but one with values starting at 42
    generate(next(coll.begin()),     // start
             prev(coll.end()),       // end
             IntSequence(42));       // generates values, starting with 42

    PRINT_ELEMENTS(coll);
}
```
本例以function object IntSequence生成一个整数序列。每当其operator ()被调用，就返回一个整数值（返回之前会先累加1）。至于初值，可通过构造函数的实参加以指定。

本例有两个这样的function object，分别被generate()和generate_n()算法使用。这两个算法的作用是产生数值并写入容器：
```cc
generate_n(back_inserter(coll), 9 IntSequence(1));
```
其中表达式
```cc
IntSequence(1)
```
便是以1为初值产生这么一个function object。
generate_n（）算法前后共9次运用它写入元素值，而它也实实在在地产生了数值2～10。同样道理，以下表达式：
```cc
IntSequence(42)
```
会产出以42为初值的function object。generate()算法运用这些值改写了“自第二个开始，至倒数第二个”元素。程序输出如下：
```bash
2 3 4 5 6 7 8 9 10
2 43 44 45 46 47 48 49 10
```
只要改变operator ()，就可以轻松产出更复杂的序列。

默认情况下function object是passed by value，不是passed by reference，因此算法并不会改变function object的状态。例如以下产生的两个function object都从1开始：
```cc
IntSequence seq(1);
generate_n(back_inserter(coll), 9, seq);
generate_n(back_inserter(coll), 9, seq);
```
将函数对象以by value（而非by reference）传递的好处是，你可以传递常量表达式或暂态表达式。如果不这么设计，你就不可能传递IntSequence(1).

至于缺点就是，你无法改变function object的状态。
算法当然可以改变function object的状态，但你无法取得并处理其最终状态，因为算法所改变的只是function object的拷贝（副本）而已。
然而有时候我们的确需要其最终状态，问题在于如何从一个算法中获得运算后的“结果”。

有三个办法可以从“运用了function object”的算法中获取“结果”或“反馈”：
- 1.在外部持有状态，并让function object指向它。
- 2.以by reference方式传递function object。
- 3.利用for_each()算法的返回值。

最后一种做法将于下一小节讨论。

为了以by reference方式传递function object，你需要在调用算法时明白标示 function object是个reference类型。
例如：
```cc
// fo/sequence2.cpp
#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>
#include "print.hpp"
using namespace std;

class IntSequence {
private:
    int value;

public:
    // constructor
    IntSequence(int initialValue)
        : value(initialValue) {
    }

    // 'function call'
    int operator()() {
        return ++value;
    }
};

int main()
{
    list<int> coll;
    IntSequence seq(1);    // integral sequence starting with 1

    // insert values from 1 to 4
    // - pass function object by reference
    // - so that it will continue with 5
    generate_n<back_insert_iterator<list<int>>,
               int, IntSequence&>(back_inserter(coll),  // start
                                  4,                    // number of elements
                                  seq);                 // generates values

    PRINT_ELEMENTS(coll);

    // insert values from 42 to 45
    generate_n(back_inserter(coll),  // start
               4,                    // number of elements
               IntSequence(42));     // generates values

    PRINT_ELEMENTS(coll);

    // continue with first sequence
    // - pass function object by value
    // - so that it will continue with 5 again
    generate_n(back_inserter(coll),  // start
               4,                    // number of elements
               seq);                 // generates values

    PRINT_ELEMENTS(coll);

    // continue with first sequence again
    generate_n(back_inserter(coll),  // start
               4,                    // number of elements
               seq);                 // generates values

    PRINT_ELEMENTS(coll);
}
```
程序输出如下
```bash
2 3 4 5
2 3 4 5 43 44 45 46
2 3 4 5 43 44 45 46 6 7 8 9
2 3 4 5 43 44 45 46 6 7 8 9 6 7 8 9
```
第一次调用generate_n()时function object seq是以by reference方式传递。是的，只需将template实参明白标示，就可以达到这个效果：
```cc
generate_n<back_insert_iterator<list<int>>, int, IntSequence &>(back_inserter(coll), 4, seq);
```
调用之后，seq内部值被改变了。第三次调用generate_n()时再度使用seq，这次产生的序列会接续第一次调用所产生的序列。然而这个调用系以by value方式来传递seq：
```cc
generate_n(back_inserter(coll), 4, seq);
```
所以这次调用并不会改变seq的状态。因此最后一次调用generate_n()时序列又从5开始。

### for_each（）的返回值
如果你使用的算法是 for_each()，那就不必特别费神以 by reference 方式传递 function object来获得其最终状态。
for_each()有一个独门绝技，其他算法概莫有之，就是可以传回其function object。
于是你可以通过for_each()的返回值来获取function object的状态。

下面是一个使用for_each()返回值的极佳例子，用来处理一个序列的平均值：
```cc
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// function object to process the mean value
class MeanValue {
private:
    long num;  // number of elements
    long sum;  // sum of all element values
public:
    // constructor
    MeanValue() : num(0), sum(0) {
    }

    // "function call"
    // - process one more element of the sequence
    void operator()(int elem) {
        ++num;        // increment count
        sum += elem;  // add value
    }

    // return mean value
    double value() {
        return static_cast<double>(sum) / static_cast<double>(num);
    }
};

int main()
{
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8 };
    // process and print mean value
    MeanValue mv = for_each(coll.begin(), coll.end(),  // range
                            MeanValue());               // operation

    cout << "mean value: " << mv.value() << endl;
}
```
其中的表达式
```cc
MeanValue()
```
会产生一个function object用来记录元素数量，并计算元素总和。
将此function object传给for_each()，后者便针对容器coll内的每一个元素调用function object：
```cc
    MeanValue mv = for_each(coll.begin(), coll.end(),  // range
                            MeanValue());               // operation
```
返回的function object被赋值给mv，此后你可以调用mv.value（）查询其状态。程序输出如下：
```bash
mean value: 4.5
```
你甚至可以将MeanValue改得更聪明些，为它定义一个类型转换函数operator double()。然后就可以直接使用“for_each()处理过的平均值”了。

Lambda提供一个更方便指定此种行为的做法。
然而这并不意味着lambda总是好过function object。
当我们需要类型的时候，function object还是比较方便，例如当我们需要为associative或unordered容器声明一个hash函数或一个排序准则或相等准则。
Function object通常是全局性的（globally），这一事实有利于我们把它放入头文件或程序库，而lambda则是方便局部性地（locally）指明行为。

### Predicate（判断式） vs.Function Object（函数对象）
所谓 predicate （判断式），就是返回 Boolean 值（意指任何可转为 bool 的值）的函数或function object。
对STL而言并非所有返回Boolean值的函数都是合法的predicate。这可能会导致出人意料的行为。试看下例：
```cc
#include <iostream>
#include <list>
#include <algorithm>
#include "print.hpp"
using namespace std;

class Nth {  // function object that returns true for the nth call
private:
    int nth;    // call for which to return true
    int count;  // call counter
public:
    Nth(int n) : nth(n), count(0) {
    }
    bool operator()(int) {
        return ++count == nth;
    }
};

int main()
{
    list<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    PRINT_ELEMENTS(coll, "coll:       ");

    // remove third element
    list<int>::iterator pos;
    pos = remove_if(coll.begin(), coll.end(),  // range
                    Nth(3));                   // remove criterion
    coll.erase(pos, coll.end());

    PRINT_ELEMENTS(coll, "3rd removed: ");
}
```
这个程序定义了一个function object Nth，当它第n次被调用时会返回 true。
然而如果你把它传给remove_if()——此算法会把每一个“令单参数判断式（unary predicate）结果为true”的元素移除，得到的结果会让你大吃一惊：
```bash
coll: 1 2 3 4 5 6 7 8 9 10
3rd removed: 1 2 4 5 7 8 9 10
```
两个（而非一个）元素——也就是第3和第6个元素——被移除了！为什么这样？
因为该算法的常见做法会在其内部保留predicate的一份拷贝（副本）：
```cc
template <typename ForwIter, typename Predicate>
ForwIter std::remove_if(ForwIter beg, ForwIter end,
                        Predicate op)
{
    beg = find_if(beg, end, op);
    if (beg == end) {
        return beg;
    } else {
        ForwIter next = beg;
        return remove_copy_if(++next, end, beg, op);
    }
}
```
这个算法使用find_if()查找应被移除的第一个元素。
然而，接下来它使用传入的predicate op的拷贝去处理剩余元素，这时原始状态下的Nth再次被使用，因而会移除剩余元素中的第3个元素，也就是整体的第6个元素。

这种行为不能说是一种错误，因为 C++standard并未明定predicate是否可被算法复制一份拷贝。
因此，为了获得C++标准库的保证行为，你传递的function object其行为“不应该因被复制次数或被调用次数而异”。
也就是说，如果你以两个相同的实参调用同一个unary predicate，该式应该总是返回相同结果。

换句话说，predicate不应该因为被调用而改变自身状态；predicate的拷贝应该和其正本有着相同状态。
要达到这一点，你一定得保证不能因为函数调用而改变predicate的状态，你应当将operator ()声明为const成员函数。

其实我们完全可以避免这种尴尬结果，让算法和Nth这样的function object一起正常运作，而且效率不打折扣。
你可以这么实现 remove_if()，直接以其 find_if()的内容替换其调用：
```cc
template <typename ForwIter, typename Predicate>
ForwIter std::remove_if(ForwIter beg, ForwIter end,
                        Predicate op)
{
    while (beg != end && !op(*beg)) {
        ++beg;
    }
    if (beg == end) {
        return beg;
    } else {
        ForwIter next = beg;
        return remove_copy_if(++next, end, beg, op);
    }
}
```
像上面这样改变remove_if()的实现代码，或是向标准库实现小组提交一份更改申请，也许是个好主意。
就我所知，目前的STL实现中只有remove_if()算法有此问题。如果你换用remove_copy_if()，一切正常。（
是否“C++标准库应该保证绝不出现本例所呈现的情况”，目前仍在讨论之中，未有结论。）然而如果考量可移植性，你永远不该依赖任何实现细节，
你应该总是将predicate的operator ()声明为const成员函数。

注意，如果采用lambda，你可以让function object的每一个拷贝共享状态，这个问题就不会发生。

## 预定义的Function Object和Binder
C++标准库提供了许多预定义的function object和binder，后者允许你合成更多精巧的function object。
我们称之为机能合成（functional composition）的能力，其所要求的基础function object和adapter都在本节呈现。
欲使用它们，你必须首先包含头文件`<functional>`

### 预定义的Function Object
表列出了所有预定义的function object，其中bit_and、bit_or及bit_xor始自C++11。

预先定义好的Function Object:
| 表达式                   | 效果                  |
| ------------------------ | --------------------- |
| `negate<type>()`         | `- param`             |
| `plus<type>()`           | `param1 + param2`     |
| `minus<type>()`          | `param1 - param2`     |
| `multiplies<type>()`     | `param1 * param2`     |
| `divides<type>()`        | `param1 / param2`     |
| `modulus<type>()`        | `param1 % param2`     |
| `equal_to<type>()`       | `param1 == param2`    |
| `not_equal_to<type>()`   | `param1 != param2`    |
| `less<type>()`           | `param1 < param2`     |
| `greater<type>()`        | `param1 > param2`     |
| `less_equal<type>()`     | `param1 <= param2`    |
| `greater_equal<type>()`  | `param1 >= param2`    |
| `logical_not<type>()`    | `! param`             |
| `logical_and<type>()`    | `param1 && param2`    |
| `logical_or<type>()`     | `param1 || param2`    |
| `bit_and<type>()`        | `param1 & param2`     |
| `bit_or<type>()`         | `param1 | param2`     |
| `bit_xor<type>()`        | `param1 ^ param2`     |

对对象排序或比较（用于排序函数和associative容器）时，默认以less<>为比较准则，因此默认的排序操作总是产生升序（也就是element < nextElement）。
Unordered容器的默认相等性准则是equal_to<>。

为了对“国际化字符串”（internationalized string）进行比较，C++标准库提供能力，允许你使用locale对象作为 function object，使它们能被当作一个string排序准则.

### Function Adapter和Binder
所谓function adapter （函数适配器，函数改造器），是指能够将不同的function object （或是和某值或某寻常函数）结合起来的东西，它自身也是个function object。

预定义的Function Adapter:
| 表达式          | 效果说明                                                 |
| --------------- | -------------------------------------------------------- |
| `bind(op,args...)` | 将 `args` 绑定给 `op` ，用于调整可调用对象的参数绑定   |
| `mem_fn(op)`       | 把 `op` 当作对象（或指向对象的指针 ）的成员函数进行调用 |
| `not1(op)`         | 单参反相（一元否定 ）：`!op(param)`                     |
| `not2(op)`         | 双参反相（二元否定 ）：`!op(param1,param2)`             |

最重要的adapter就是bind()。它允许你：
- 在既有的或预定义的function object之外另配接及合成（adapt and compose）新的function object。
- 调用全局函数（global function）。
- 针对object、pointer to object和smart pointer to object调用成员函数。

#### bind() Adapter
一般而言 bind() 用来将参数绑定于可调用对象。
因此，如果一个函数、成员函数、函数对象或lambda需要若干参数，你可以将参数绑定为“明白指出的”或“被传入的”实参。
欲明白指出实参，你只需写出其名称，欲使用被传入的实参，则可利用预定义占位符_1、_2、...，它们被定义于命名空间std::placeholders内。

Binder的一个典型应用是，当使用“C++标准库提供之预定义function object”时具体指定参数。例如：
```cc
#include <functional>
#include <iostream>

int main()
{
    auto plus10 = std::bind(std::plus<int>(),
                            std::placeholders::_1,
                            10);
    std::cout << "+10:    " << plus10(7) << std::endl;

    auto plus10times2 = std::bind(std::multiplies<int>(),
                                  std::bind(std::plus<int>(),
                                            std::placeholders::_1,
                                            10),
                                  2);
    std::cout << "+10 *2: " << plus10times2(7) << std::endl;

    auto pow3 = std::bind(std::multiplies<int>(),
                          std::bind(std::multiplies<int>(),
                                    std::placeholders::_1,
                                    std::placeholders::_1),
                          std::placeholders::_1);
    std::cout << "x*x*x:  " << pow3(7) << std::endl;

    auto inversDivide = std::bind(std::divides<double>(),
                                  std::placeholders::_2,
                                  std::placeholders::_1);
    std::cout << "invdiv: " << inversDivide(49, 7) << std::endl;
}
```
这里出现四个不同的binder，分别定义出不同的function object。例如plus10定义为：
```cc
std::bind(std::plus<int>(), std::placeholders::_1, 10);
```

它所表现的function object内部调用plus<>（也就是operator+），以占位符（placeholder）_1作为第一参数/操作数，以10作为第二参数/操作数。
占位符_1表示实际传入此表达式之第一实参。
于是，对于传给此表达式之任何实参，这个function object会产出“实参+10”的结果值。

也可以直接调用binder而不必先为它建立一个对应的function object。例如：
```cc
cout << bind(plus<int>(), _1, 10)(32);
```
这会输出42。如果你把binder或function object传给算法，后者会把它作用于所操作的每一个元素身上。例如：
```cc
transform(coll.begin(), coll.end(), bind(plus<int>(), _1, 10));
```
以此方式你可以定义一个binder表现排序准则。例如“找出第一个大于42的元素”，你可以将“被传入之实参”绑定为greater<>的第一实参，42为第二实参：
```cc
auto pos = find_if(coll.begin(), coll.end(), bind(greater<int>(), _1, 42));
```
注意，你永远必须指明预定义之function object所使用的实参类型。如果这个类型没有能够被正确匹配，编译器会对它实施强制类型转换，若不成功将导致编译错误。

本例的其他语句示范如何嵌套合成更复杂的function object。例如下列表达式定义了一个function object，把10加在被传入的实参身上，再将结果乘以2（以下省略命名空间）：
```cc
bind(multiplies<int>(), bind(plus<int>(), _1, 10), 2); // (param1 + 10) * 2
```
如你所预期，表达式的核定（evaluated）次序是由内而外。
同样道理，我们可以制造一个值的三次方：组合两个multiplies<>对象并绑定被传入的实参（使用占位符）。
```cc
bind(multiplies<int>(), bind(multiplies<int>(), _1, _1), _1); // (param1 * param1) * param1
```
最后一个表达式所定义的function object将除法的实参互换。它拿第二实参去除以第一实参：
```cc
bind(divides<int>(), _2, _1); // param2 / param1
```

#### 调用全局函数
下面的例子示范了bind()如何被用来调用全局函数:
```cc
#include <iostream>
#include <algorithm>
#include <functional>
#include <locale>
#include <string>
using namespace std;
using namespace std::placeholders;

char myToupper(char c)
{
    std::locale loc;
    return std::use_facet<std::ctype<char>>(loc).toupper(c);
}

int main()
{
    string s("Internationalization");
    string sub("Nation");

    // search substring case insensitive
    string::iterator pos;
    pos = search(s.begin(), s.end(),            // string to search in
                 sub.begin(), sub.end(),        // substring to search
                 bind(equal_to<char>(),         // compar. criterion
                      bind(myToupper, _1),
                      bind(myToupper, _2)));

    if (pos != s.end()) {
        cout << "\"" << sub << "\" is part of \"" << s << "\""
             << endl;
    }
}
```
这里我们使用search()算法检验sub是否为s的一个子字符串，大小写不计。有了以下：
```cc
                 bind(equal_to<char>(),   
                      bind(myToupper, _1),
                      bind(myToupper, _2))
```
便是建立一个function object并相当于调用：
```cc
myToupper(param1) == myToupper(param2)
```
其中 myToupper() 是我们自己写的一个便捷函数，用来将string 内的字符转为大写.

请注意，bind()内部会复制被传入的实参。
若要改变这种行为，让function object使用一个reference指向被传入之实参，可利用ref()或cref()。例如：
```cc
void inc(int &i)
{
    ++i;
}

int i = 10;
bind(incr, i)();      // 增加i的拷贝
bind(incr, ref(i))(); // 增加i
```

#### 调用成员函数
以下程序示范bind()如何被用来调用成员函数:
```cc
#include <functional>
#include <algorithm>
#include <vector>
#include <iostream>
#include <string>
using namespace std;
using namespace std::placeholders;

class Person {
private:
    string name;
public:
    Person(const string& n) : name(n) {
    }
    void print() const {
        cout << name << endl;
    }
    void print2(const string& prefix) const {
        cout << prefix << name << endl;
    }
    // 原代码的...表示可能有其他成员，提取时保留示意
    ...
};

int main()
{
    vector<Person> coll
        = { Person("Tick"), Person("Trick"), Person("Track") };

    // call member function print() for each person
    for_each(coll.begin(), coll.end(),
             bind(&Person::print, _1));
    cout << endl;

    // call member function print2() with additional argument for each person
    for_each(coll.begin(), coll.end(),
             bind(&Person::print2, _1, "Person: "));
    cout << endl;

    // call print2() for temporary Person
    bind(&Person::print2, _1, "This is: ")(Person("nico"));
}
```
其中的
```cc
bind(&Person::print, _1)
```
定义一个function object，其内针对传入的Person调用param1.print()。
也就是说，由于第一实参是个成员函数，下一个实参将定义“用以调用成员函数”的对象。
其他任何实参都会被传递给该成员函数。这意味着：
```cc
bind(&Person::print2, _1, "Person: ")
```
定义出一个function object，其内针对传入的Person调用`param1.print2("Person: ")`。

在这儿，传入的对象是coll的成员（元素）。原则上你可以直接传递对象，例如：
```cc
Person n("nico");
bind(&Person::print2, _1, "This is: ")(n);
```
这会导致调用`n.print2（＂This is：＂）`。
本程序输出如下：
```bash
Tick
Trick
Track

Person: Tick
Person: Trick
Person: Track

This is: nico
```
注意，你也可以传递pointer to object甚至smart pointer给bind()：
```cc
std::vector<Person*> cp;
//...
std::for_each(cp.begin(), cp.end(),
              std::bind(&Person::print,
                        std::placeholders::_1));

std::vector<std::shared_ptr<Person>> sp;
//...
std::for_each(sp.begin(), sp.end(),
              std::bind(&Person::print,
                        std::placeholders::_1));
```
注意，你也可以调用“具改动能力的成员函数”（modifying member function）：
```cc
class Person {
public:
    //...
    void setName(const std::string& n) {
        name = n;
    }
private:
    std::string name;
};

std::vector<Person> coll;
//...
std::for_each(coll.begin(), coll.end(),
              std::bind(&Person::setName,
                        std::placeholders::_1,
                        "Paul"));
```
调用virtual成员函数也没问题。如果base class的某个成员函数被绑定，而调用它的是个derived class对象，正确的derived class virtual函数会被调用。

#### mem_fn() Adapter

对于成员函数，你也可以改用 mem_fn() adapter，那就不再需要以占位符表示调用者（对象）：
```cc
for_each(c.begin(), c.end(), std::mem_fn(&Person::print));
```
若有额外实参被传给成员函数，mem_fn()就拿其中第一实参作为调用者（对象），其他实参当作成员函数的实参：
```cc
mem_fn(&Person::print)(n);  // 调用n.print
mem_fn(&Person::print2)(n, "Person: "); // 调用n.print2("Person: ")
```
然而，如果要为function object绑定额外实参，还是必须使用bind()：
```cc
for_each(c.begin(), c.end(), bind(mem_fn(&Person::print2, std::placeholders::_1, "Person: ")));
```
#### 绑定至数据成员（Data Member）
你也可以绑定至数据成员。考虑以下例子（命名空间在此省略不写）：
```cc
map<string, int> coll;
...
// plus<int>(_1, )
int sum = accumulate(coll.begin(), coll.end(), 0, bind(plus<int>(), _1, bind(&map<string, int>::value_type::second, _2)));
```
这里调用 accumulate()，它使用一个binary predicate对所有元素求和。
然而由于我们的容器是个map，其元素是key/value pair，为了得到对元素的value的访问权，必须这么做：
```cc
	//    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
	//        _BinaryOperation __binary_op)
	//    {
	//      // concept requirements
	//      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
	//      __glibcxx_requires_valid_range(__first, __last);
	//
	//      for (; __first != __last; ++__first)
	// __init = __binary_op(_GLIBCXX_MOVE_IF_20(__init), *__first);
	//      return __init;
	//    }
    //    从accumulate可知 __binary_op的第一个实参为 __init, 第二个实参为 *iterator
    //
    //    对plus<int>(int a, int b) 函数进行封装
    //    第一个参数不需要修改，第二个参数将 *iterator 改成 取 对象的某个成员，这里是 map的second
    //       bind(plus<int>(), 
                // std::placeholders::_1,  
                // bind(&map<string, int>::value_type::second, std::placeholders::_2)));

    int sum = accumulate(coll.begin(), coll.end(),  // 遍历范围
            0,  // 累加初始值
            // binary_op
            bind(plus<int>(), 
                std::placeholders::_1,  // init_val
                bind(&map<string, int>::value_type::second, std::placeholders::_2)));


```
把“每次调用这个predicate所传入的第二实参”绑定为元素的数据成员second。

更简单的例子
```cc
    struct Point { int x, y; };

    // 正确：获取成员指针
    // &class::mem 表示成员指针，是语法规定
    auto getX = bind(&Point::x, std::placeholders::_1);

    // 错误：缺少 &，无法编译
    // auto getX = bind(Point::x, std::placeholders::_1);

    Point p{10, 20};
    Point *pp = &p;
    // 对bind传递obj或pobj都可以
    cout << getX(p) << endl;  // 输出 10
    cout << getX(pp) << endl;  // 输出 10
```

#### Adapter not1（）和not2（）
Adapter not1() 和 not2() 几乎可被视为过时。它们的唯一用途是令预定义的 function object的意义相反，例如：
```cc
sort(c.begin(), c.end(), std::not2(std::less<int>()));
```
这看起来比下面简便多了：
```cc
sort(c.begin(), c.end(), bind(std::logical_not<bool>(), std::bind(std::less<int>(), _1, _2)));
```
然而真实世界中并没有not1()和not2()真正可发挥的剧本，因为你可以轻松选用另一个预定义的function object：
```cc
sort(c.begin(), c.end(), std::greater_equal<int>());
```
更重要的是，请注意，not2()搭配less<>其实是错误的。
你或许想的是改变排序准则，从升序改为降序，但＜的反相是＞=，不是＞。
事实上，greater_equal<>甚至会导致不明确行为，因为 sort()要求一个strict weak ordering，＜满足条件，＞=则不然，因为它违反“必须是反对称的”条件。
因此，你要不就传递：
```cc
greater<int>()
```
要不就交换实参次序，这么传递：
```cc
bind(less<int>(), _2, _1)
```
### 以Function Adapter搭配用户自定义的Function Object
你也可以把binder用在你自定义的function object身上。
以下展示了一份function object的完整定义，它把第二实参当作第一实参的幂：
```cc
#include <cmath>

template <typename T1, typename T2>
struct fopow {
    T1 operater() (T1 base, T2 exp) const {
        return std::pow(base, exp);
    }
};
```
注意，第一实参和返回值拥有相同的类型T1，指数则可以拥有不同的类型T2。

下列程序展示了如何使用用户自定义的function object fopow<>()。更明确地说，它使用fopow<>()搭配bind() function adapter：
```cc
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>
#include "fopow.hpp"
using namespace std;
using namespace std::placeholders;

int main()
{
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    // print 3 raised to the power of all elements
    transform (coll.begin(), coll.end(),                   // source
               ostream_iterator<float>(cout," "),         // destination
               bind(fopow<float,int>(),3,_1));            // operation
    cout << endl;

    // print all elements raised to the power of 3
    transform (coll.begin(), coll.end(),                   // source
               ostream_iterator<float>(cout," "),         // destination
               bind(fopow<float,int>(),_1,3));            // operation
    cout << endl;
}
```
程序输出如下：
```bash
3 9 27 81 243 729 2187 6561 19683
1 8 27 64 125 216 343 512 729
```
注意，fopow<>()只对float和int有意义。
如果你以int作为其base（底数）和exponent （指数）类型，其实就是调用pow()并给予两个类型为int的实参，但这样不具可移植性，
因为根据C++standard的说法，pow()有许多重载版本，接受一个以上（但非全部）基础类型：
```cc
transform(coll.begin(), coll.end(), ostream_iterator<int>(cout, " "), bind1st(fopow<int, int>(), 3)); // err 二义性
```
### 过时的（Deprecated） Function Adapter
表列出了C++11之前C++标准库所提供的预定义function adapter class，如今它们都已过时。
只因唯恐你遭遇这些过时的东西，所以这里列出一些精简的例子，示范如何使用它们。

过时的若干预定义Function Adapter:
| 表达式       | 效果说明                          |
| ------------ | --------------------------------- |
| bind1st(op,arg) | 调用 op(arg,param)               |
| bind2nd(op,arg) | 调用 op(param,arg)               |
| ptr_fun(op)     | 调用 *op(param) 或 *op(param1,param2) |
| mem_fun(op)     | 调用 op()，视之为一个 pointer to object 的成员函数 |
| mem_fun_ref(op) | 调用 op()，视之为一个 object 的成员函数 |
| not1(op)        | 单参反相（unary negation）：!op(param) |
| not2(op)        | 双参反相（binary negation）：!op(param1,param2) |

注意，这些adapter都需要使用定义于function object中的若干类型。
为了定义那些类型，C++标准库为function adapter 提供了特殊的base class：std::unary_function<> 和std::binary_function<>。这些class如今也都过时了。

bind1st()和bind2nd()的用法很像bind()，但它们有固定的参数绑定位置。举个例子：
```cc
find_if(c.begin(), c.end(), bind2nd(greater<int>(), 42));
```
然而bind1st()和bind2nd()不能被用来将binder合成为 binder，也不能直接传入寻常函数。

not1() 和 not2() “几乎过时”，因为它们的唯一用途就是和其他过时的 function adapter合作。举个例子：
```cc
find_if(c.begin(), c.end(), not1(bind2nd(modulus<int>(), 2)));
```
以上找出第一个int偶数的位置（偶数就是%2结果为0，not1()则是把结果反相为true）。这比使用新式binder（如下）看起来方便些：
```cc
find_if(c.begin(), c.end(), bind(logical_not<bool>(), bind(modulus<int>(), _1, 2)));
```
真正的大改善则是使用lambda：
```cc
find_if(c.begin(), c.end(), 
    [](int elem) {
        return elem % 2 == 0;
    });
```
ptr_fun()用来调用寻常函数。假设你有一个全局函数，它为每一个参数进行某种检验：
```cc
bool check(int elem);
```
你可以调用下面的语句找出第一个不通过检验的元素：
```cc
find_if(c.begin(), c.end(), not1(ptr_fun(check)));
```
当你有一个全局函数，带两个参数，并且（举例）打算将它当作单参（unary）函数使用，这时ptr_fun（）的第二形式可以派上用场：
```cc
find_if(c.begin(), c.end(), bind2nd(ptr_fun(std::strcmp), ""));
```
在这里，strcmp() C函数被用来比较每个元素是否等于empty C-string。如果两个string吻合，strcmp()就返回0，相当于false。因此，调用find_if()会返回第一个非空字符串的元素位置。

mem_fun()和 mem_fun_ref()被用来定义“其内调用成员函数”的function object。例如：
```cc
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

class Person {
public:
    void print() const {
        // 这里简单输出示例内容，可根据实际需求修改
        cout << "Person print" << endl;
    }
    ...
};

int main() {
    const vector<Person> coll = {Person(), Person(), Person()};
    // call member function print() for each person
    for_each(coll.begin(), coll.end(),
             mem_fun_ref(&Person::print));
    return 0;
}
```
注意，被mem_fun_ref()和mem_fun()调用的成员函数，以及被当作实参传给bind1st()或bind2nd()的成员函数，必须是const成员函数。

## 运用Lambda
lambda的引入始自C++11。这带来一种很具威力又十分便利的方法，允许我们提供局部机能（local functionality），特别是用来具体指明算法和成员函数的细节。
虽然lambda是一种语言特性，但它们的运用对C++标准库是如此重要，因此我要在这里好好谈谈它们。

lambda为 C++带来十分重要而深具意义的改善（当我们使用STL时）。
因为如今你有了一个直观、易读的方式，可将独特的行为传递给算法和容器的成员函数。
如果你需要将特定行为传给算法，只要在需要的地方像指明函数那样把它写出来即可。

示范lambda用法的最佳方式就是给出实例，尤其当我们拿它和“未使用lambda”的情况比较。
下面数个小节中我给出了数个例子，呼应先前使用其他function object和adapter如bind()。

### Lambda vs.Binder
当我们改用lambda，相应代码看起来如下：
```cc
#include <iostream>
using namespace std;

int main()
{
    auto plus10 = [] (int i) {
        return i + 10;
    };
    cout << "+10:   " << plus10(7) << endl;

    auto plus10times2 = [] (int i) {
        return (i + 10) * 2;
    };
    cout << "+10 *2: " << plus10times2(7) << endl;

    auto pow3 = [] (int i) {
        return i * i * i;
    };
    cout << "x*x*x:  " << pow3(7) << endl;

    auto inversDivide = [] (double d1, double d2) {
        return d2 / d1;
    };
    cout << "invdiv: " << inversDivide(49, 7) << endl;

    return 0;
}
```
拿下面这个function object声明式来比较：使用binder制造出“加10而后乘以2”。
```cc
auto plus10times2 = bind(std::multiset<int>(), bind(std::plus<int>(), std::placeholder::_1, 10), 2);
```
以lambda定义相同的机能，如下：
```cc
auto plus10times2 = [] (int i) {
                        return (i + 10) * 2;
                    };
```
### Lambda vs.带有状态的（Stateful） Function Object
让我们以 lambda 替换定制的 function object。
```cc
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8 };

    // process and print mean value
    long sum = 0;
    for_each (coll.begin(), coll.end(),  // range
              [&sum] (int elem) {
                  sum += elem;
              });
    double mv = static_cast<double>(sum) / static_cast<double>(coll.size());
    cout << "mean value: " << mv << endl;
}
```
这里，不再需要针对将被传入的function object定义一个class，只要传入你所需要的机能就是了。
然而计算所得的状态（state）被置于lambda之外的变量sum，所以你最终必须使用sum来计算中值（mean value）。

在function object中，状态（sum）将被彻底封装，我们可以提供额外的成员函数来处理状态，例如以sum为基础计算中值。
```cc
MeanValue mv = for_each(coll.begin(), coll.end(), MeanValue());
cout << mv.value() << endl;
```
所以，从调用端的视角观之，你可以把“用户自定义的function object”视为比“这里所展示的lambda版本”更紧凑更不易造成错误。

处理状态（state）时，如果使用mutable就该特别小心。
其对应的lambda版本严格讲应该以by value方式传递内部计数器（用来表现状态）。
之所以by value是因为这个计数器在此次算法调用之外是不需要的。
写上mutable你便可以对该状态提供write访问权，且适用于对它的所有函数调用：

```cc
#include <iostream>
#include <list>
#include <algorithm>
#include "print.hpp"
using namespace std;

int main()
{
    list<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    PRINT_ELEMENTS(coll,"coll:         ");

    // remove third element
    list<int>::iterator pos;
    int count=0;    // call counter
    pos = remove_if(coll.begin(),coll.end(),  // range
                    [count] () mutable {      // remove criterion，原代码(int)多余，修正
                        return ++count == 3;
                    });
    coll.erase(pos,coll.end());

    PRINT_ELEMENTS(coll,"3rd removed: ");
    return 0;
}
```
你可能会陷入同一个问题，第三和第六元素都被移除了，导致以下输出：
```bash
coll: 1 2 3 4 5 6 7 8 9 10
3rd removed: 1 2 4 5 7 8 9 10
```
之所以如此，因为lambda对象被remove_if()算法在执行过程中复制了一份，于是存在两个lambda对象都移除第三元素，导致重复的行为。

如果你以by reference方式传递实参，又未使用 mutable，那么行为一如预期，因为remove_if()内部所用的两个lambda对象共享同一状态。因此，对于下面的动作：
```cc
int count = 0;
pos = remove_if(coll.begin(), coll.end(), 
                [&count] (int) {
                    return ++count == 3;
                });
```
输出将是
```bash
coll: 1 2 3 4 5 6 7 8 9 10
3rd removed: 1 2 4 5 6 7 8 9 10
```
### Lambda调用全局函数和成员函数
当然，任何lambda都可以调用其他函数
```cc
#include <iostream>
#include <algorithm>
#include <locale>
#include <string>
using namespace std;

char myToupper(char c)
{
    std::locale loc;
    return std::use_facet<std::ctype<char>>(loc).toupper(c);
}

int main()
{
    string s("Internationalization");
    string sub("Nation");

    // search substring case insensitive
    string::iterator pos;
    pos = search(s.begin(), s.end(),       // string to search in
                 sub.begin(), sub.end(),   // substring to search
                 [](char c1, char c2) {    // compar criterion
                     return myToupper(c1) == myToupper(c2);
                 });

    if (pos != s.end()) {
        cout << "\"" << sub << "\" is part of \"" << s << "\""
             << endl;
    }

    return 0;
}
```
当然，你可以用相同方式调用成员函数:
```cc
#include <functional>
#include <algorithm>
#include <vector>
#include <iostream>
#include <string>
using namespace std;
using namespace std::placeholders;

class Person {
private:
    string name;
public:
    Person(const string& n) : name(n) {
    }
    void print() const {
        cout << name << endl;
    }
    void print2(const string& prefix) const {
        cout << prefix << name << endl;
    }
    // 原代码中...表示可能有其他成员，这里可根据实际补充，示例中无特殊其他成员则可保留空
};

int main()
{
    vector<Person> coll
        = { Person("Tick"), Person("Trick"), Person("Track") };

    // call member function print() for each person
    for_each(coll.begin(), coll.end(),
             [](const Person& p) {
                 p.print();
             });
    cout << endl;

    // call member function print2() with additional argument for each person
    for_each(coll.begin(), coll.end(),
             [](const Person& p) {
                 p.print2("Person: ");
             });

    return 0;
}
```

### Lambda作为Hash函数、排序准则或相等准则
一如先前所言，你也可以使用lambda作为hash函数、排序准则或相等准则。例如：
```cc
class Person {
    ...
};
auto hash = [] (const Person &p) {
    ...
};
auto eq = [] (const Person &p1, Person &p2) {
    ...
};
...
unordered_set<Person, decltype<hash>, decltype<eq>> pset(10, hash, eq);
```
注意，你必须使用decltype将lambda的类型传给unordered_set，因为后者会建立属于它自己的一份实例。
此外你也必须传递一个hash函数和相等准则给构造函数，否则构造函数会调用hash函数和相等准则的default构造函数，而那对lambda而言是未定义的。

基于这些不方便性，在这里，针对function object给出一个class，也许可读性较高，甚至较便捷。所以当涉及状态（state）时，lambda并非总是较好的选择。

# STL算法
本章描述C++标准库提供的所有算法。首先对所有算法及其主要特征进行概述，然后展示每一个算法的确切形式，并运用一个或多个例子说明其用法。

## 算法概观
本节概述C++标准库提供的所有算法。你可以从中体会它们的能力，进而在遇到某些问题时选择最适用的算法。

### 扼要介绍
算法的角色和使用上的一些重要限制。
所有STL算法都被设计用来处理一个或多个iterator区间。
第一个区间通常以起点和终点表示，其他区间则多数情况下只需提供起点便足矣，其终点可自动以第一区间的元素数量推导出来。
调用者必须确保这些区间的有效性，也就是说起点和终点必须指向同一容器，且起点位置必须指向一个（与终点相较）较早出现或相同的元素；其他区间必须有足够空间。

STL算法采用覆盖（overwrite）模式而非安插（insert）模式。所以调用者必须保证标的区间拥有足够空间。
当然，你也可以运用特殊的insert iterator将覆盖模式改变为安插模式。

为了提高灵活度和功效，某些STL算法允许使用者传递自定义操作，由STL算法调用之。
这些操作既可以是寻常函数，也可以是function object；如果其返回值是个Boolean，它们便被称为predicate（判断式）。
你可以运用predicate完成以下工作：
- 对于查找（search）算法，你可以传递一个函数或function object或lambda，表现出一个unary predicate作为查找准则。这个unary predicate用来判断某元素是否符合条件。例如你可以查找第一个“小于50”的元素。
- 对于排序（sorting）算法，你可以传递一个函数或function object或lambda，表现出一个binary predicate作为排序准则。这个binary predicate用来比较两元素。例如你可以传递一个准则让Person对象按姓氏排序。
- 你可以传递一个unary predicate作为准则，判断是否应该对某元素施以某项操作。例如你可以令奇数值元素被移除。
- 你可以为某个数值算法指定一个数值运算。例如你可以让通常用来求和（sum）的accumulate()算法改为求积（product）。

注意，predicate不应该在被调用的过程中改变自身状态。

关于可被当作算法参数的寻常函数、function object和lambda.

### 算法分门别类
不同的算法满足不同的需求。所以，我们可以根据它们的主要目的加以分类。
例如某些算法的操作是只读的（read only），某些算法会改动元素自身，某些则改动元素顺序。
本节简单介绍每个算法的功能，并指出相似算法之间的区别。

为了顾名思义，STL设计者为算法命名时，引入了两个特殊后缀：

1. 后缀_if如果某算法有两个形式，参数个数相同，但第一形式要求传入一个值，第二形式要求传入一个函数或function object，那么后缀_if就派上用场。
无后缀的那个要求数值，有后缀的那个要求函数或function object。
例如find()用来查找具有某值的元素，而find_if（）接受一个被当作查找准则的函数或function object，查找第一个满足该准则的元素。

并非所有“要求传递函数或function object”的算法都有后缀_if。
如果算法以额外参数接受这样的函数或 function object，那么这样的算法就不易名。
例如当你调用min_element()并传入两个实参，该算法以operator<为比较准则，返回区间中的最小元素，但如果你传入第三实参，这个实参会被当作比较准则。

2. 后缀_copy这个后缀用来表示在此算法中元素不只被操作，还会被复制到标的区间。
例如reverse()将区间中的元素颠倒次序，而reverse_copy（）则是逆序将元素复制到另一区间。

接下来数节将按照以下分类方式描述各STL算法：
- 非更易型算法（nonmodifying algorithm）
- 更易型算法（modifying algorithm）
- 移除型算法（removing algorithm）
- 变序型算法（mutating algorithm）
- 排序算法（sorting algorithm）
- 已排序区间算法（sorted-range algorithm）
- 数值算法（numeric algorithm）

如果某个算法同时隶属多个分类，我会把它放在我认为最贴切的分类中讲述。

#### 非更易型算法（Nonmodifying Algorithm）
非更易型算法既不改动元素次序，也不改动元素值。
它们通过input迭代器和forward迭代器完成工作，因此可作用于所有标准容器身上。
表展示了C++标准库囊括的所有非更易型算法。
还有一些非更易型算法专门用来操作已排序（sorted）输入区间.

最重要的算法之一便是 for_each()，它将调用者提供的操作作用于每一个元素身上，该操作通常被用来处理区间内的每个单独元素。
例如你可以利用for_each()打印区间内每个元素，或对每个元素调用某个更易型操作。
然而请注意，自C++11起，range-based for循环已经更方便也更自然地提供了这种行为，因此for_each()恐怕将日渐失去其重要性。

有若干个非更易型算法执行查找动作。不幸的是查找算法的命名方式一团乱。
此外，查找算法的命名方式又和string查找函数的命名大相径庭。
为什么会这样？还不是老掉牙的“历史因素”。首先，STL class和string class乃是各自独立设计的。
其次，find_end(),find_first_of() 和 search_n() 算法并不囊括于早期 STL。
所以最后选择的名称是find_end() 而不是 search_end()，这完全不是刻意的（说实话，一旦你钻入细节，就很容易忽略“一致性”这种大局观问题）。
同样是偶发事件，search_n()的某一形式竟然违背了原始STL的一般性概念。

非更易型算法:
| 名称                  | 效果                                                                                                     | 
| --------------------- | -------------------------------------------------------------------------------------------------------- | 
| for_each()            | 对每个元素执行某操作                                                                                     | 
| count()               | 返回元素个数                                                                                             | 
| count_if()            | 返回满足某一准则（条件）的元素个数                                                                       | 
| min_element()         | 返回最小值元素                                                                                           | 
| max_element()         | 返回最大值元素                                                                                           | 
| minmax_element()      | 返回最小值和最大值元素（始自C++11）                                                                      | 
| find()                | 查找“与被传入值相等”的第一个元素                                                                         | 
| find_if()             | 查找“满足某个准则”的第一个元素                                                                           | 
| find_if_not()         | 查找“不满足某个准则”的第一个元素（始自C++11）                                                            | 
| search_n()            | 查找“具备某特性”之前n个连续元素                                                                          | 
| search()              | 查找某个子区间的第一次出现位置                                                                           | 
| find_end()            | 查找某个子区间的最后一次出现位置                                                                         | 
| find_first_of()       | 查找“数个可能元素中的第一个出现者”                                                                       | 
| adjacent_find()       | 查找连续两个相等（或者说符合特定准则）的元素                                                             | 
| equal()               | 判断两区间是否相等                                                                                       | 
| is_permutation()      | 两个不定序区间（unordered range）是否内含相等元素（始自C++11）                                           | 
| mismatch()            | 返回两序列的各组对应元素中的第一对不相等元素                                                             | 
| lexicographical_compare() | 判断在“字典顺序”（lexicographically）下某序列是否小于另一序列                                          | 
| is_sorted()           | 返回“是否区间内的元素已排序”（始自C++11）                                                               | 
| is_sorted_until()     | 返回“区间内第一个未遵循排序准则的元素”（始自C++11）                                                     | 
| is_partitioned()      | 返回“区间内的元素是否基于某准则被分割为两组”（始自C++11）                                               | 
| partition_point()     | 返回区间内的一个分割元素（partitioning element），它把元素切割为两组，其中一组满足某个 predicate，另一组则不然（始自C++11） | 
| is_heap()             | 返回“是否区间内的元素形成一个 heap”（始自C++11）                                                        | 
| is_heap_until()       | 返回“区间内第一个未遵循 heap 排序准则的元素”（始自C++11）                                              | 
| all_of()              | 返回“是否所有元素都吻合某准则”（始自C++11）                                                             | 
| any_of()              | 返回“是否至少一个元素吻合某准则”（始自C++11）                                                           | 
| none_of()             | 返回“是否无任何元素吻合某准则”（始自C++11）                                                             | 

String查找函数和STL查找算法的比较:
| 查找需求                           | String 函数          | STL 算法                              |
| ---------------------------------- | -------------------- | ------------------------------------- |
| 某元素第一次出现位置               | find()               | find()                                |
| 某元素最后一次出现位置             | rfind()              | find()，搭配 reverse_iterator         |
| 某子区间第一次出现位置             | find()               | search()                              |
| 某子区间最后一次出现位置           | rfind()              | find_end()                            |
| 某数个元素第一次出现位置           | find_first_of()      | find_first_of()                       |
| 某数个元素最后一次出现位置         | find_last_of()       | find_first_of()，搭配 reverse_iterator |
| n 个连续元素第一次出现位置         | -                    | search_n()                            |

#### 更易型算法（Modifying Algorithm）
非更易型算法:
| 名称               | 效果                                                         | 
| ------------------ | ------------------------------------------------------------ | 
| for_each()         | 针对每个元素执行某项操作                                     | 
| copy()             | 从第一个元素开始，复制某个区间                               | 
| copy_if()          | 复制那些“符合某个给定准则”的元素（始自C++11）                | 
| copy_n()           | 复制n个元素（始自C++11）                                     | 
| copy_backward()    | 从最后一个元素开始，复制某个区间                             | 
| move()             | 从第一个元素开始，搬移某个区间（始自C++11）                  | 
| move_backward()    | 从最后一个元素开始，搬移某个区间（始自C++11）                | 
| transform()        | 改动（并复制）元素，将两个区间的元素合并                     | 
| merge()            | 合并两个区间                                                 | 
| swap_ranges()      | 交换两区间的元素                                             | 
| fill()             | 以给定值替换每一个元素                                       | 
| fill_n()           | 以给定值替换n个元素                                          | 
| generate()         | 以某项操作的结果替换每一个元素                               | 
| generate_n()       | 以某项操作的结果替换n个元素                                  | 
| iota()             | 将所有元素以一系列的递增值取代（始自C++11）                  | 
| replace()          | 将具有某特定值的元素替换为另一个值                           | 
| replace_if()       | 将符合某准则的元素替换为另一个值                             | 
| replace_copy()     | 复制整个区间，并将具有某特定值的元素替换为另一个值           | 
| replace_copy_if()  | 复制整个区间，并将符合某准则的元素替换为另一个值             | 

更易型算法，要不是直接改变元素值，就是在复制元素到另一区间的过程中改变元素值。
如果是第二种情况，原区间不会发生变化。表列出了C++标准库囊括的更易型算法。

最基本的更易型算法是 for_each()（又是它！）和 transform()。两者都可以变动序列中的所有元素值。它们的行为有以下不同：
- for_each() 接受一个操作，该操作可改动其所接受的实参。因此该实参必须以 by reference方式传递。例如：
```cc
void square(int &elem) {
    elem = elem * elem;
}
...
for_each(c.begin(), c.end(), square);
```
- transform()运用某个操作，该操作返回被改动后的实参。此间奥妙在于它可以被用来将结果赋值给原元素。例如：
```cc
int square(int elem) {
    return elem * elem;
}
...
transform(c.begin(), c.end(),  // src
            c.begin(),         // dest
            square);           // op
```

transform()的速度稍稍慢些，因为它是将操作的返回值赋予元素，而不是直接改动元素。
不过其灵活性较高，因为它可以把某个序列复制到标的序列中，同时改动元素内容。
transform()的第二形式可以将两个源区间的元素的组合结果放到标的区间。

严格地说，merge()不算是更易型算法的当然一员，因为它要求输入区间必须已排序（sorted），所以应该归为“作用于已排序区间之算法”。
然而现实中merge()也可用来合并无序区间——当然其结果也是无序的。
不过，基于安全考量，你最好只对已排序区间调用merge()。

注意，associative和unordered容器的元素被视为常量，唯其如此，你才不会在改动元素的时候有任何可能违反整个容器的排序准则。
因此，你不可使用这些容器当作更易型算法的目标区。

除了这些更易型算法，C++标准库还提供了不少专门处理已排序（sorted）区间的算法.

#### 移除型算法（Removing Algorithm）

 移除型算法（Removing Algorithm）:
| 名称              | 效果                                   |
| ----------------- | -------------------------------------- |
| remove()          | 将“等于某特定值”的元素全部移除         |
| remove_if()       | 将“满足某准则”的元素全部移除           |
| remove_copy()     | 将“不等于某特定值”的元素全部复制到他处 |
| remove_copy_if()  | 将“不满足某准则”的元素全部复制到他处   |
| unique()          | 移除毗邻的重复元素（元素值相等者）     |
| unique_copy()     | 移除毗邻的重复元素，并复制到他处       |

移除型算法是一种特殊的更易型算法。
它们可以移除区间内的元素，也可以在复制过程中执行移除动作。
和更易型算法类似，你也不可以使用associative和unordered容器作为目标区间，因为那些容器的元素都被视为常量。
表列出了C++标准库囊括的所有移除型算法。

注意，移除型算法只是“逻辑上”移除元素，其手段是：将不应移除的元素往前覆盖（overwrite）应被移除的元素。
因此它并不改变操作区间内的元素个数，而是返回逻辑上的新终点位置。
至于是否使用这个位置进行诸如“真实移除”之类的操作，那是调用者的事情。

#### 变序型算法（Mutating Algorithm）
| 名称                 | 效果                                                         |
| -------------------- | ------------------------------------------------------------ |
| reverse()            | 将元素的次序逆转                                             |
| reverse_copy()       | 复制的同时，逆转元素顺序                                     |
| rotate()             | 旋转元素次序                                                 |
| rotate_copy()        | 复制的同时，旋转元素次序                                     |
| next_permutation()   | 得到元素的下一个排列次序                                     |
| prev_permutation()   | 得到元素的上一个排列次序                                     |
| shuffle()            | 将元素的次序随机打乱（始自 C++11）                           |
| random_shuffle()     | 将元素的次序随机打乱                                         |
| partition()          | 改变元素次序，使“符合某准则”者移到前面                       |
| stable_partition()   | 和 partition() 类似，但保持“与准则相符”和“与准则不符”之各个元素之间的相对位置 elements |
| partition_copy()     | 改变元素次序，使“符合某准则”者移到前面，过程中会复制元素     |

所谓变序型算法是，通过元素值的赋值和互换（assigning and swapping），改变元素顺序，但不改变元素值。
表列出了C++标准库囊括的所有变序型算法。
和更易型算法（modifying algorithm）一样，变序型算法也不能以associative和unordered容器作为目标区，因为那些容器的元素都被视为常量。

#### 排序算法（Sorting Algorithm）
| 名称                  | 效果                                                         |
| --------------------- | ------------------------------------------------------------ |
| sort()                | 对所有元素排序                                               |
| stable_sort()         | 对所有元素排序，并保持相等元素之间的相对次序                 |
| partial_sort()        | 排序，直到前 n 个元素就位                                     |
| partial_sort_copy()   | 排序，直到前 n 个元素就位；将结果复制于他处                   |
| nth_element()         | 根据第 n 个位置进行排序                                       |
| partition()           | 改变元素次序，使“符合某准则”的元素放在前面                   |
| stable_partition()    | 和 partition() 类似，但保持“与准则相符”和“与准则不符”之各个元素之间的相对位置 |
| partition_copy()      | 改变元素次序，使“符合某准则”者移到前面，过程中会复制元素     |
| make_heap()           | 将某个区间转换成一个 heap                                      |
| push_heap()           | 将元素加入一个 heap                                            |
| pop_heap()            | 从 heap 移除一个元素                                           |
| sort_heap()           | 对 heap 进行排序（完成后就不再是个 heap 了）                    |

排序算法是一种特殊的变序型（mutating）算法，因为它们也改变元素的顺序。但它们更复杂些，因此也花费更多时间。

事实上它们的复杂度通常比线性还差一些，而且必须用到random-access iterator。

表列出的算法允许你检验某个区间是否（局部）已排序。
| 名称                | 效果                                                         |
| ------------------- | ------------------------------------------------------------ |
| is_sorted()         | 检验区间内的元素是否都已排序（始自 C++11）                   |
| is_sorted_until()   | 返回区间内第一个 “破坏排序状态” 的元素（始自 C++11）         |
| is_partitioned()    | 检验区间内的元素是否根据某个准则被分为两组（始自 C++11）     |
| partition_point()   | 返回区间内的分割点 (partitioning element)，它把区间分割为 “满足” 和 “不满足” 某 predicate 的两组（始自 C++11） |
| is_heap()           | 检验区间内的元素是否都排序成为一个 heap（始自 C++11）          |
| is_heap_until()     | 返回区间内第一个 “破坏 heap 排序状态” 的元素（始自 C++11）     |

对排序算法而言，时间经常是关键。
所以C++标准库提供了多个排序算法，它们使用不同的排序手法。
有些算法并非对所有元素排序，例如nth_element()在第n个元素就位后即停止排序，对其他元素它只保证凡小于“已就位之第n个元素”的所有元素都排在前面，大的元素则排在n位置之后。
如果要对所有元素排序，可考虑以下算法：
- sort()传统上采用quicksort算法。因此保证了很好的平均效能，复杂度为n× log（n），
  - 但最差情况下也可能效能很差（n x n)

如果“避免最差情况”对你是一件重要的事，你应该采用其他算法，例如接下来要讨论的partial_sort（）或stable_sort（）。
- partial_sort() 传统上采用 heapsort 算法。因此它在任何情况下保证 n× log（n）复杂度。
  - 然而很多实际情况中heapsort比quicksort慢2～5倍.
  - 虽然partial_sort()拥有较好复杂度，但sort()在多数情况下却拥有较好的运行期效能。
  - partial_sort()的优点是它在任何时候都保证n× log（n）复杂度，绝不会变成二次复杂度。
  - partial_sort()还有一种特殊能力：如果你只需前n个元素排序，它可在完成任务后立刻停止。
    - 所以如果想对所有元素排序，你可将序列终点作为第二实参和最后一个实参传进去：
```cc
partial_sort(c.begin(), c.end(), c.end());
```

- stable_sort()传统上采用mergesort。它对所有元素进行排序：
  - 只有在内存充足的前提下它才有n× log（n）复杂度，否则其复杂度为n× log（n）× log（n）。
  - stable_sort()的优点是会保持相等元素之间的相对次序。

还有更多算法可以对元素排序。
例如heap算法中有个函数，可直接为你实现出一个heap, 所谓heap，可视为一个“以序列集合实现出来的二叉树”。Heap算法是priority queue 的实现基础。你可以像下面这样将集合内的所有元素排序：
```cc
make_heap(c.begin(), c.end());
sort_heap(c.begin(), c.end());
```
如果你只需要前n个排序元素，或只需要令最先或最后的n个元素（未排序）就位，可以使用nth_element()。
你可以利用nth_element()将元素依照某排序准则分割成两个子集，也以利用partition()或stable_partition()达到相同效果。三者区别如下：

- 对于nth_element()，在第一子集中指出元素个数（当然也就确定了第二子集的元素个数）。例如：
```cc
// 将最小的四个元素排在最前面
nth_element(c.begin(),      // 区间起始
            c.begin() + 3,  // 两个子集之间的位置
            c.end());       // 区间结束
```
然而调用之后你并不精确知道第一子集和第二子集之间有什么不同。
两部分都可能包含“与第n个元素相等”的元素。

- 对于partition()，你必须传入“将第一子集和第二子集区别开”的精确排序准则：
```cc
vector<int>::iterator pos;
pos = partition(c.begin(), c.end(), 
                [](int elem) {
                    return elem < 7;
                });
```
调用之后，你并不知道第一和第二子集内各有多少元素。
返回的pos用来指出第二子集起点。第二子集的所有元素都不满足上述（被指出的）准则。

- stable_partition()的行为类似partition()，不过更具额外能力，保证两子集内的元素的相对次序维持不变。

你永远可以把排序准则当作选择性实参，传给所有排序算法。
默认的排序准则是function object less<>，造成元素升序排列。
注意，排序准则必须定义出一个关于元素值的strict weak ordering，像operator<=这样（判断等于或小于）的准则并不适用.

和更易型算法的情况一样，associative和unordered容器不可作为排序算法的目标区，因为那些容器的元素被视为常量。

List和forward list并不提供random-access iterator，所以你不可以对它们使用排序算法。
然而它们都提供一个成员函数sort()，可用来对其元素排序。

#### 已排序区间算法（Sorted-Range Algorithm）
|名称|效果|
| ---- | ---- |
|binary_search()|判断某区间内是否包含某个元素|
|includes()|判断某区间内的每一个元素是否都涵盖于另一区间中|
|lower_bound()|查找第一个 “大于等于某给定值” 的元素|
|upper_bound()|查找第一个 “大于某给定值” 的元素|
|equal_range()|返回 “等于某给定值” 的所有元素构成的区间|
|merge()|将两个区间的元素合并|
|set_union()|求两个区间的并集|
|set_intersection()|求两个区间的交集|
|set_difference()|求 “位于第一区间” 但 “不位于第二区间” 的所有元素，形成一个已排序（sorted）区间|
|set_symmetric_difference()|找出 “只出现于两区间之一” 的所有元素，形成一个已排序（sorted）区间|
|inplace_merge()|将两个连贯的已排序（sorted）区间合并|
|partition_point()|用一个判断式分割区间，返回分割元素（始自 C++11）|

所谓已排序区间算法，意指其所作用的区间在某种排序准则下已排序（sorted）。
表列出了C++标准库中囊括的所有已排序区间算法。
与associative容器相比，这些算法的优势是具有较好复杂度。

表中的前5个算法属于非更易型算法，它们只是依使命查找元素。
其他算法用来将两个已排序（sorted）区间组合，然后把结果写到目标区。
一般而言，这些算法的结果仍然是已排序的（sorted）。

#### 数值算法（Numeric Algorithm）

|名称|效果|
| ---- | ---- |
|accumulate()|结合所有元素（求总和、求乘积……）|
|inner_product()|结合两区间内的所有元素|
|adjacent_difference()|将每个元素和其前一元素结合|
|partial_sum()|将每个元素和其之前的所有元素结合|

数值算法以各种不同的方式结合数值元素。
表列出了C++标准库囊括的所有数值算法。
它们很容易顾名思义，而实际上它们比给你的第一印象更灵活更强劲。
例如在默认状态下，accumulate()求取所有元素的总和，
而如果你把它作用在 string 身上，就可以产生字符串连接功效；
而当你不采用 operator+却改用operator*，得到的将是所有元素的乘积。
另一个例子是，adjacent_difference() 和partial_sum()可将某区间在相对值和绝对值之间互相转换。

accumulate()和inner_product()都返回一个值，不改动区间。
其他算法会把结果写到目标区内，目标区间与源区间的元素个数相同。

## 辅助函数
本章剩余部分将对所有STL算法逐一详细讨论。
每个算法至少配备一个运用实例。
为了简化这些例子，使你集中精力于真正重要的问题上，我用了一些辅助函数：
```cc
#ifndef ALGOSTUFF_HPP
#define ALGOSTUFF_HPP

#include <array>
#include <vector>
#include <deque>
#include <list>
#include <forward_list>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <algorithm>
#include <iterator>
#include <functional>
#include <numeric>
#include <iostream>
#include <string>

// INSERT_ELEMENTS (collection, first, last)
// - fill values from first to last into the collection
// - NOTE: NO half-open range
template <typename T>
inline void INSERT_ELEMENTS(T& coll, int first, int last) {
    for (int i = first; i <= last; ++i) {
        coll.insert(coll.end(), i);
    }
}

// PRINT_ELEMENTS()
// - prints optional string optcstr followed by 
// - all elements of the collection coll
// - separated by spaces
template <typename T>
inline void PRINT_ELEMENTS(const T& coll, const std::string& optcstr = "") {
    std::cout << optcstr;
    for (auto elem : coll) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

// PRINT_MAPPED_ELEMENTS()
// - prints optional string optcstr followed by 
// - all elements of the key/value collection coll
// - separated by spaces
template <typename T>
inline void PRINT_MAPPED_ELEMENTS(const T& coll, const std::string& optcstr = "") {
    std::cout << optcstr;
    for (auto elem : coll) {
        std::cout << '[' << elem.first 
                  << ',' << elem.second << "] ";
    }
    std::cout << std::endl;
}

#endif /*ALGOSTUFF_HPP*/
```
首先，algostuff.hpp包含了本章程序例子可能用到的所有头文件，这样程序本身就不必多劳了。然后，它定义了三个辅助函数：
- 1.INSERT_ELEMENTS()将元素安插于第一实参所引入的容器内。元素值来自第二实参和第三实参——其间的所有元素值都将供安插之用。请注意这并不是一个半开区间（half-open range）。
- 2.PRINT_ELEMENTS()将第一实参所引入的容器内的所有元素打列出来，其间以空格区分。第二实参可有可无，若指定将会成为前缀打印于元素值之前（参见6.6节第216页）。
- 3.PRINT_MAPPED_ELEMENTS()和上述函数的功能相同，只不过它适用于带有key/value pair元素的容器：map、multimap、unordered map和unordered multimap。

## for_each()算法
for_each()算法非常灵活，它允许你以不同的方式访问、处理、修改每一个元素。
然而请注意，自C++11起，range-based for循环提供了更方便更自然的行为。
因此，for_each()恐将日渐丧失其重要性。

### UnaryProc
```cc
for_each (InputIterator beg,InputIterator end,UnaryProc op)
```
- 对区间[beg，end）中的每一个元素调用：
```cc
op(elem)
```
- 返回op（它已在算法内部被改动过）的一个拷贝（副本）。Since C++11，the returned opis moved.
- op可以改动元素。然而，与transform（）之间的比较，后者具有相同能力，但行事稍有不同。
- op的任何返回值都会被忽略。
- 复杂度：线性。调用op()共numElems次。

下面的例子把每一个元素传给一个lambda，后者将它所获得的元素打印出来。因此，这个调用会打印所有元素：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);

    // call print() for each element
    for_each(coll.cbegin(), coll.cend(),  // range
             [](int elem) {               // operation
                 cout << elem << ' ';
             });
    cout << endl;
}
```
你也可以传入一个寻常函数print()取代lambda，该函数会因每一个元素而被调用：
```cc
void print(int elem)
{
    cout << elem << " ";
}
for_each(c.cbegin(), c.cend(), print);
```
但是，再次提醒你，自C++11开始，使用range-based for循环往往更方便：
```cc
for (auto elem : coll) {
    cout << elem << " ";
}
```
下面的例子示范如何改变每一个元素：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);

    // add 10 to each element
    for_each(coll.begin(), coll.end(),  // range
             [](int& elem) {            // operation
                 elem += 10;
             });
    PRINT_ELEMENTS(coll);

    // add value of first element to each element
    for_each(coll.begin(), coll.end(),  // range
             [=](int& elem) {           // operation
                 elem += *coll.begin();
             });
    PRINT_ELEMENTS(coll);
}
```
如你所见，你必须声明elem的类型为reference，为的是改动元素值。你也必须定义lambda的capture像这样[=]，为的是加“第一元素的拷贝”：
```cc
    for_each(coll.begin(), coll.end(),  // range
             [=](int& elem) {           // operation
                 elem += *coll.begin();
             });
```
如果你在上述程序第二次调用for_each()时传入一个reference指向第一元素：
```cc
    for_each(coll.begin(), coll.end(),  // range
             [&](int& elem) {           // operation
                 elem += *coll.begin();
             });
```
也可以定义一个寻常的function object取而代之：
```cc
// function object that adds the value with which it is initialized
template <typename T>
class AddValue {
private:
    T theValue;  // value to add
public:
    // constructor initializes the value to add
    AddValue(const T& v) : theValue(v) {
    }

    // the function call for the element adds the value
    void operator()(T& elem) const {
        elem += theValue;
    }
};
```
将它传给for_each()：
```cc
for_each(c.begin(), c.end(), AddValue<int>(10));
...
for_each(c.begin(), c.end(), AddValue<int>(*c.begin()));
```
Class AddValue<>定义了一个function object，把构造函数所获得的值加到每一个元素身上。

注意，你也可以如下这般运用transform()算法，完成相同任务：
```cc
transform(c.cbegin(), c.cend(), c.begin(), 
        [](int elem){
            return elem + 10;
        });
...
transform(c.cbegin(), c.cend(), c.begin(),
        [=](int elem){
            return elem + *c.begin();
        });
```
第三个例子展示如何利用for_each()的返回值。
for_each()有一个特殊性质就是它能返回其操作，我们可利用这一特性，处理和返回“置于该操作中的结果”：
```cc
#include "algostuff.hpp"
using namespace std;

// function object to process the mean value
class MeanValue {
private:
    long num;  // number of elements
    long sum;  // sum of all element values
public:
    // constructor
    MeanValue() : num(0), sum(0) {
    }

    // function call
    // - process one more element of the sequence
    void operator()(int elem) {
        num++;        // increment count
        sum += elem;  // add value
    }

    // return mean value (implicit type conversion)
    operator double() {
        return static_cast<double>(sum) / static_cast<double>(num);
    }
};

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 8);

    // process and print mean value
    double mv = for_each(coll.begin(), coll.end(),  // range
                         MeanValue());               // operation
    cout << "mean value: " << mv << endl;
}
```
你也可以使用lambda 完成任务，并以by reference 方式传递返回值。
然而在这种情形下lambda不见得较好，因为function object不但封装sum作为其内部状态，也封装了“sum除以元素个数”这一最终除法。

## 非更易型算法（Nonmodifying Algorithm）
本节讲述的算法不会改动元素值，也不会改变元素次序。

### 元素计数
```cc
difference_type
count (InputIterator beg,InputIterator end,const T&value)

difference_type
count_if (InputIterator beg,InputIterator end,UnaryPredicate op)
```
- 第一形式计算区间[beg，end）中“元素值等于value”的元素个数。
- 第二形式计算区间[beg，end）中“令unary predicate
```cc
op(elem)
```
结果为true”的元素个数。

- 返回类型difference_type，是用以表现iterator间距的类型：
```cc
typename iterator_traits<InputIterator>::difference_type
```
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- Associative和unordered容器提供了一个类似的成员函数count()，用来计算“以某给定值为key”的元素个数.
- 复杂度：线性。执行比较动作（或调用op()）共numElems次。

以下范例根据不同的准则对元素进行计数：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;
    int num;
    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll: ");

    // count elements with value 4
    num = count(coll.cbegin(), coll.cend(), 4);  // range、value
    cout << "number of elements equal to 4: " << num << endl;

    // count elements with even value
    num = count_if(coll.cbegin(), coll.cend(),  // range
                   [](int elem) {               // criterion
                       return elem % 2 == 0;
                   });
    cout << "number of elements with even value: " << num << endl;

    // count elements that are greater than value 4
    num = count_if(coll.cbegin(), coll.cend(),  // range
                   [](int elem) {               // criterion
                       return elem > 4;
                   });
    cout << "number of elements greater than 4: " << num << endl;
}
```
也可以不使用上述的lambda（检查元素是否为偶数），改用binder如下：
```cc
bind(logical_not<bool>(), bind(modulus<int>(), _1, 2));
```
甚至使用过时的表达式：
```cc
not1(bind2nd(modulus<int>(), 2))
```
#### 最小值和最大值
```cc
ForwardIterator
min_element (ForwardIterator beg,ForwardIterator end)

ForwardIterator
min_element (ForwardIterator beg,ForwardIterator end,CompFunc op)

ForwardIterator
max_element (ForwardIterator beg,ForwardIterator end)

ForwardIterator
max_element (ForwardIterator beg,ForwardIterator end,CompFunc op)

pair<ForwardIterator,ForwardIterator>
minmax_element (ForwardIterator beg,ForwardIterator end)

pair<ForwardIterator,ForwardIterator>
minmax_element (ForwardIterator beg,ForwardIterator end,CompFunc op)
```
- 所有这些算法分别返回[beg，end）区间中的最小元素位置、最大元素位置，或“最小和最大元素的位置所组成的pair”。
- 上述无op实参的各个版本，将以operator＜进行元素比较。
- op用来比较两个元素：
```cc
op(elem1, elem2)
```
如果第一元素小于第二元素，应当返回true。

- 如果存在多个最小值或最大值，
  - min_element()和 max_element()返回其所找到的第一个目标元素。
  - minmax_element()返回第一个最小元素和最后一个最大元素。
  - 所以，max_element()和minmax_element()返回的最大元素不是同一个。
- op不应改动传入的实参。

下列程序打印coll中的最小元素和最大元素，分别运用min_element()和max_element()，以及minmax_element()。并借由absLess()打印最小元素和最大元素的绝对值：
```cc
#include <cstdlib>
#include "algostuff.hpp"
using namespace std;

bool absLess(int elem1, int elem2) {
    return abs(elem1) < abs(elem2);
}

int main() {
    deque<int> coll;

    INSERT_ELEMENTS(coll, 2, 6);
    INSERT_ELEMENTS(coll, -3, 6);

    PRINT_ELEMENTS(coll);

    // process and print minimum and maximum
    cout << "minimum: "
         << *min_element(coll.cbegin(), coll.cend())
         << endl;
    cout << "maximum: "
         << *max_element(coll.cbegin(), coll.cend())
         << endl;

    // print min and max and their distance using minmax_element()
    auto mm = minmax_element(coll.cbegin(), coll.cend());
    cout << "min: " << *(mm.first) << endl;      // print minimum
    cout << "max: " << *(mm.second) << endl;     // print maximum
    cout << "distance: " << distance(mm.first, mm.second) << endl;

    // process and print minimum and maximum of absolute values
    cout << "minimum of absolute values: "
         << *min_element(coll.cbegin(), coll.cend(),
                         absLess)
         << endl;
    cout << "maximum of absolute values: "
         << *max_element(coll.cbegin(), coll.cend(),
                         absLess)
         << endl;
}
```
程序输出
```bash
2 3 4 5 6 -3 -2 -1 0 1 2 3 4 5 6
minimum: -3
maximum: 6
min: -3
max: 6
distance: 9
minimum of absolute values: 0
maximum of absolute values: 6
```
注意，这些算法返回的是最大元素和最小元素的位置，你必须使用unary operator*才能取其值来打印：
```cc
    auto mm = minmax_element(coll.cbegin(), coll.cend());
    cout << "min: " << *(mm.first) << endl;      // print minimum
    cout << "max: " << *(mm.second) << endl;     // print maximum
```
#### 查找元素（Searching Element）
查找第一个匹配元素（Search First Matching Element）
```cc
InputIterator
find (InputIterator beg,InputIterator end,const T&value)

InputIterator
find_if (InputIterator beg,InputIterator end,UnaryPredicate op)

InputIterator
find_if_not (InputIterator beg,InputIterator end,UnaryPredicate op)
```
- 第一形式返回[beg，end）区间中第一个“元素值等于value”的元素位置。
- 第二形式返回[beg，end）区间中第一个“造成以下unary predicate结果为true”的元素：
```cc
op(elem)
```

- 第三形式（始自C++11）返回[beg，end）区间中第一个“造成以下unary predicate结果为false”的元素：
```cc
op(elem)
```

- 如果没有找到匹配元素，它们都返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 如果是已排序区间（sorted range），应使用lower_bound()、upper_bound()、equal_range()或binary_search()算法以获得更高效能.
- Associative和unordered容器提供一个等效的成员函数 find()，拥有较好复杂度（对associative容器而言是对数，对unordered容器而言甚至是常量）。
- 复杂度：线性。至多比较（或调用op()） numElems次。

下面这个例子展示了如何运用find()查找某个子区间：以“元素值为 4”的第一个元素开始，以“元素值为 4”的第二个元素结束：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    INSERT_ELEMENTS(coll, 1, 9);

    PRINT_ELEMENTS(coll, "coll: ");

    // find first element with value 4
    list<int>::iterator pos1;
    pos1 = find(coll.begin(), coll.end(), 4);  // range、value

    // find second element with value 4
    // - note: continue the search behind the first 4 (if any)
    list<int>::iterator pos2;
    if (pos1 != coll.end()) {
        pos2 = find(++pos1, coll.end(), 4);  // range、value
    }

    // print all elements from first to second 4 (both included)
    // - note: now we need the position of the first 4 again (if any)
    if (pos1 != coll.end() && pos2 != coll.end()) {
        copy(--pos1, ++pos2,
             ostream_iterator<int>(cout, " "));
        cout << endl;
    }
}
```
为了查找第二个4，你必须从第一个4的位置前进。
然而如果在集合的end()位置上再前进，会导致不确定行为。
如果没有十足把握，最好在行进之前先检查find()的返回值。

你可以在同一区间中以不同的值先后两次调用find()。
然而当你使用该查找结果作为子区间的起点和终点时，务必十分小心，因为该子区间可能形成一个无效区间。

以下程序展示了find_if()和find_if_not()的用法，使用差别极大的查找准则来查找某个元素：
```cc
#include "algostuff.hpp"
using namespace std;
using namespace std::placeholders;

int main()
{
    vector<int> coll;
    vector<int>::iterator pos;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll: ");

    // find first element greater than 3
    pos = find_if(coll.begin(), coll.end(),        // range
                  bind(greater<int>(), _1, 3));    // criterion
    // print its position
    cout << "the "
         << distance(coll.begin(), pos) + 1
         << ". element is the first greater than 3" << endl;

    // find first element divisible by 3
    pos = find_if(coll.begin(), coll.end(),        // range
                  [](int elem) {                   // criterion
                      return elem % 3 == 0;
                  });
    // print its position
    cout << "the "
         << distance(coll.begin(), pos) + 1
         << ". element is the first divisible by 3" << endl;

    // find first element not <5
    pos = find_if_not(coll.begin(), coll.end(),    // range
                      bind(less<int>(), _1, 5));    // criterion
    cout << "first value >=5: " << *pos << endl;
}
```
第一次调用 find_if()时，搭配一个以 bind adapter组合而成的function object，查找第一个大于3的元素。
第二次调用搭配的是lambda，查找第一个可被3整除的元素。

#### 查找前n个连续匹配值（Search First n Matching Consecutive Elements）
```cc
ForwardIterator
search_n (ForwardIterator beg,ForwardIterator end,Size count,const T&value)

ForwardIterator
search_n (ForwardIterator beg,ForwardIterator end,Size count,const T&value,BinaryPredicate op)
```
- 第一形式返回[beg，end）区间内“连续count个元素值都等于value”中的第一元素位置。
- 第二形式返回[beg，end）区间内“连续count个元素造成以下unary predicate结果为true”中的第一元素位置：
```cc
op(elem, value) // value通过第四个参数传入
```

- 如果没有找到匹配元素，两种形式都返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 这两个算法不在早期的STL规范中，也没有获得谨慎的对待，因此第二形式使用了一个binary predicate而非unary predicate，这破坏了STL的一致性。
- 复杂度：线性。至多比较（或调用op()） numElems×count次。

下面这个例子查找连续的“数值等于7或为奇数”的元素：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;

    coll = {1, 2, 7, 7, 6, 3, 9, 5, 7, 7, 7, 3, 6};
    PRINT_ELEMENTS(coll);

    // find three consecutive elements with value 7
    deque<int>::iterator pos;
    pos = search_n(coll.begin(), coll.end(),  // range
                   3,                          // count
                   7);                         // value

    // print result
    if (pos != coll.end()) {
        cout << "three consecutive elements with value 7 "
             << "start with " << distance(coll.begin(), pos) + 1
             << ". element" << endl;
    } else {
        cout << "no four consecutive elements with value 7 found"
             << endl;
    }

    // find four consecutive odd elements
    pos = search_n(coll.begin(), coll.end(),  // range
                   4,                          // count
                   0,                          // value
                   [](int elem, int value) {  // criterion
                       return elem % 2 == 1;
                   });

    // print result
    if (pos != coll.end()) {
        cout << "first four consecutive odd elements are: ";
        for (int i = 0; i < 4; ++i, ++pos) {
            cout << *pos << ' ';
        }
        cout << endl;
    } else {
        cout << "no four consecutive elements with value > 3 found";
    }
    cout << endl;
}
```
关于search_n()的第二形式，有个令人讨厌的问题。请看以下调用动作：
```cc
pos = search_n(coll.begin(), coll.end(), 
                4,  // count
                0,  // value
                [](int elem, int value) {
                    return elem%2 == 1;
                });
```
以这种方式来查找“符合某给定准则”的元素，手法和STL其他组件大相径庭。按照STL的惯常概念，应该写成这样：
```cc
pos = search_n_if(coll.begin(), coll.end(), 
                4,  // count
                [](int elem) {
                    return elem%2 == 1;
                });
```
以上要求一个unary predicate用以获得传入值，而这个角色在 search_n()中却成了一个binary predicate且其第二参数未被用到。

不幸的是，当这些新算法被引入C++98标准时（它们不属于早期STL），没人注意到这个不一致性。
也许一开始你会觉得四个实参的形式更加便捷，因为你可以这么使用它：
```cc
pos = search_n(coll.begin(), coll.end(), 
                4,  // count
                3,  // value
                greater<int>());
```

不过，正如我们的例子所展示的，它要求一个binary predicate，即便实际上只需要unary predicate。

因此，如果你有一个寻常的unary predicate像这样：
```cc
bool is_prime(int elem);
```
那么你要么必须改变其签名式（signature），要么必须为它写出一个简单的包裹器（wrapper）：
```cc
bool binaryIsPrime(int elem1, int) {
    return is_prime(elem1);
}
...
pos = search_n(coll.begin(), coll.end(), 4, 0, binaryIsPrime);
```
#### 查找第一个子区间（Search First Subrange）

```cc
ForwardIterator1
search (ForwardIterator1 beg,ForwardIterator1 end,ForwardIterator2 searchBeg,ForwardIterator2 searchEnd)

ForwardIterator1
search (ForwardIterator1 beg,ForwardIterator1 end,ForwardIterator2 searchBeg,ForwardIterator2 searchEnd,BinaryPredicate op)
```
- 两个形式都返回[beg，end）区间内“与[searchBeg，searchEnd）区间完全吻合”的第一个子区间内的第一元素位置。
- 第一形式中，子区间内的元素必须完全等于[searchBeg，searchEnd）的元素。
- 第二形式中，子区间内的元素和[searchBeg，searchEnd）的对应元素必须造成以下binary predicate的结果为true：
```cc
op(elem, searchElem)
```

- 如果没有找到匹配元素，两种形式都返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 如果你想查找一个子区间但是“只知其第一元素和最末元素”.
- 复杂度：线性。至多比较（或调用op（））共numElems×numSearchElems次。

下面展示如何在某个序列中查找其子序列。请将这个例子和第537页的find_end()例子进行比较。
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;
    list<int> subcoll;

    INSERT_ELEMENTS(coll, 1, 7);
    INSERT_ELEMENTS(coll, 1, 7);
    INSERT_ELEMENTS(subcoll, 3, 6);

    PRINT_ELEMENTS(coll, "coll:     ");
    PRINT_ELEMENTS(subcoll, "subcoll: ");

    // search first occurrence of subcoll in coll
    deque<int>::iterator pos;
    pos = search(coll.begin(), coll.end(),        // range
                 subcoll.begin(), subcoll.end()); // subrange

    // loop while subcoll found as subrange of coll
    while (pos != coll.end()) {
        // print position of first element
        cout << "subcoll found starting with element "
             << distance(coll.begin(), pos) + 1
             << endl;

        // search next occurrence of subcoll
        ++pos;
        pos = search(pos, coll.end(),              // range
                     subcoll.begin(), subcoll.end()); // subrange
    }
}
```
程序输出如下：
```bash
coll:     1 2 3 4 5 6 7 1 2 3 4 5 6 7
subcoll: 3 4 5 6
subcoll found starting with element 3
subcoll found starting with element 10
```
下面这个例子展示如何运用search()算法的第二形式，以更复杂的准则查找某个子序列。本例将要查找偶数、奇数、偶数排列而成的子序列：
```cc
#include "algostuff.hpp"
using namespace std;

// checks whether an element is even or odd
bool checkEven(int elem, bool even)
{
    if (even) {
        return elem % 2 == 0;
    } else {
        return elem % 2 == 1;
    }
}

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll: ");

    // arguments for checkEven()
    // - check for: "even odd even"
    bool checkEvenArgs[3] = {true, false, true};

    // search first subrange in coll
    vector<int>::iterator pos;
    pos = search(coll.begin(), coll.end(),        // range
                 checkEvenArgs, checkEvenArgs+3,  // subrange values
                 checkEven);                       // subrange criterion

    // loop while subrange found
    while (pos != coll.end()) {
        // print position of first element
        cout << "subrange found starting with element "
             << distance(coll.begin(), pos) + 1
             << endl;

        // search next subrange in coll
        pos = search(++pos, coll.end(),            // range
                     checkEvenArgs, checkEvenArgs+3,  // subr. values
                     checkEven);                       // subr. criterion
    }
}
```
程序输出如下：
```bash
coll: 1 2 3 4 5 6 7 8 9
subrange found starting with element 2
subrange found starting with element 4
subrange found starting with element 6
```

#### 查找最后一个子区间（Search Last Subrange）
```cc
ForwardIterator1
find_end (ForwardIterator1 beg,ForwardIterator1 end,ForwardIterator2 searchBeg,ForwardIterator2 searchEnd)

ForwardIterator1
find_end (ForwardIterator1 beg,ForwardIterator1 end,ForwardIterator2 searchBeg,ForwardIterator2 searchEnd,BinaryPredicate op)
```
- 两种形式都返回[beg，end）区间之中“和区间[searchBeg，searchEnd）完全吻合”的最后一个子区间内的第一元素位置。
- 第一形式中，子区间的元素必须完全等于[searchBeg，searchEnd）的元素。
- 第二形式中，子区间的元素和 [searchBeg，searchEnd） 的对应元素必须造成以下 binary predicate的结果为true：
```cc
op(elem)
```

- 如果没有找到匹配元素，两种形式都返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 如果你想查找某个子区间但是“只知道其第一元素和最末元素”.
- 这些算法并不是早期STL的一部分。很不幸它们被命名为find_end()而不是search_end()，后者较具一致性，因为用来查找第一个子区间的算法名为 search()。
- 复杂度：线性。至多比较（或调用op()）共numElems×numSearchElems次。

下面的例子展示了如何在一个序列中查找最后一个“与某序列相等”的子序列（请和search()例子进行比较）：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;
    list<int> subcoll;

    INSERT_ELEMENTS(coll, 1, 7);
    INSERT_ELEMENTS(coll, 1, 7);
    INSERT_ELEMENTS(subcoll, 3, 6);

    PRINT_ELEMENTS(coll, "coll:     ");
    PRINT_ELEMENTS(subcoll, "subcoll: ");

    // search last occurrence of subcoll in coll
    deque<int>::iterator pos;
    pos = find_end(coll.begin(), coll.end(),        // range
                   subcoll.begin(), subcoll.end()); // subrange

    // loop while subcoll found as subrange of coll
    deque<int>::iterator end(coll.end());
    while (pos != end) {
        // print position of first element
        cout << "subcoll found starting with element "
             << distance(coll.begin(), pos) + 1
             << endl;

        // search next occurrence of subcoll
        end = pos;
        pos = find_end(coll.begin(), end,            // range
                       subcoll.begin(), subcoll.end()); // subrange
    }
}
```
程序输出如下：
```bash
coll:     1 2 3 4 5 6 7 1 2 3 4 5 6 7
subcoll: 3 4 5 6
subcoll found starting with element 10
subcoll found starting with element 3
```
这个算法的第二形式，可参考search()第二例子。你可以采用类似手法来使用find_end()。

#### 查找某些元素的第一次出现地点（Search First of Several Possible Elements）
```cc
InputIterator
find_first_of (InputIterator beg,InputIterator end,ForwardIterator searchBeg,ForwardIterator searchEnd)

InputIterator
find_first_of (InputIterator beg,InputIterator end,ForwardIterator searchBeg,ForwardIterator searchEnd,BinaryPredicate op)
```
- 第一形式返回第一个“既出现于[beg，end）区间也出现于[searchBeg，searchEnd）区间”的元素的位置。
- 第二形式返回[beg，end）区间内第一个满足以下条件的元素：它和区间[searchBeg，searchEnd）内每一个元素进行以下动作的结果都是true。
```cc
op(elem)
```

- 如果没有找到匹配元素，两种形式都返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 你可以使用reverse iterator查找最后一个符合条件的元素。
- 这几个算法并不在早期STL规范中。
- 在C++11 之前，这些算法面对 [beg，end） 区间所需要的是forward iterator 而不是input iterator。
- 复杂度：线性。至多比较（或调用op()）共numElems×numSearchElems次。

下面的例子展示了find_first_of()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;
    list<int> searchcoll;

    INSERT_ELEMENTS(coll, 1, 11);
    INSERT_ELEMENTS(searchcoll, 3, 5);

    PRINT_ELEMENTS(coll, "coll:        ");
    PRINT_ELEMENTS(searchcoll, "searchcoll: ");

    // search first occurrence of an element of searchcoll in coll
    vector<int>::iterator pos;
    pos = find_first_of(coll.begin(), coll.end(),    // range
                        searchcoll.begin(),           // beginning of search set
                        searchcoll.end());            // end of search set
    cout << "first element of searchcoll in coll is element "
         << distance(coll.begin(), pos) + 1
         << endl;

    // search last occurrence of an element of searchcoll in coll
    vector<int>::reverse_iterator rpos;
    rpos = find_first_of(coll.rbegin(), coll.rend(),  // range
                         searchcoll.begin(),           // beginning of search set
                         searchcoll.end());            // end of search set
    cout << "last element of searchcoll in coll is element "
         << distance(coll.begin(), rpos.base())
         << endl;
}
```
第二次调用采用了 reverse iterator，查找最后一个“与 searchcoll 内某一元素相等”的元素。
为了打印这个元素的位置，此处调用 base()将reverse iterator转化成一般（正向） iterator，这样你就可以得到从起点算起的距离。
通常你应该将distance()的结果加1，因为第一元素的距离是0。然而因为 base()私自移动了iterator所指元素的位置，所以你得到相同的效果。

程序输出如下：
```bash
coll:        1 2 3 4 5 6 7 8 9 10 11
searchcoll: 3 4 5
first element of searchcoll in coll is element 3
last element of searchcoll in coll is element 5
```
#### 查找两个连续且相等的元素
```cc
ForwardIterator
adjacent_find (ForwardIterator beg,ForwardIterator end)

ForwardIterator
adjacent_find (ForwardIterator beg,ForwardIterator end,BinaryPredicate op)
```
- 第一形式返回[beg，end）区间内第一对“连续两个相等元素”中的第一元素位置。
- 第二形式返回[beg，end）区间内第一对“连续两个元素均造成以下binary predicate结果为true”的其中第一元素位置：
```cc
op(elem)
```

- 如果没有找到匹配元素，两种形式都返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 复杂度：线性。至多比较（或调用op()）共numElems次。

下面的程序展示了adjacent_find()两种形式的用法：
```cc
#include "algostuff.hpp"
using namespace std;

// return whether the second object has double the value of the first
bool doubled(int elem1, int elem2)
{
    return elem1 * 2 == elem2;
}

int main()
{
    vector<int> coll;

    coll.push_back(1);
    coll.push_back(3);
    coll.push_back(2);
    coll.push_back(4);
    coll.push_back(5);
    coll.push_back(5);
    coll.push_back(0);

    PRINT_ELEMENTS(coll, "coll: ");

    // search first two elements with equal value
    vector<int>::iterator pos;
    pos = adjacent_find(coll.begin(), coll.end());

    if (pos != coll.end()) {
        cout << "first two elements with equal value have position "
             << distance(coll.begin(), pos) + 1
             << endl;
    }

    // search first two elements for which the second has double the value of the first
    pos = adjacent_find(coll.begin(), coll.end(),  // range
                        doubled);                   // criterion

    if (pos != coll.end()) {
        cout << "first two elements with second value twice the "
             << "first have pos. "
             << distance(coll.begin(), pos) + 1
             << endl;
    }
}
```
第一次调用adjacent_find()是为了查找相等值。第二次调用则是以doubled()查找“连续两元素，后一元素是前一元素的两倍”，找到后返回其中第一元素的位置。程序输出如下：
```bash
coll: 1 3 2 4 5 5 0
first two elements with equal value have position 5
first two elements with second value twice the first have pos. 3
```
#### 区间的比较
检验相等性（Equality）
```cc
bool
equal (InputIterator1 beg,InputIterator1 end,InputIterator2 cmpBeg)

bool
equal (InputIterator1 beg,InputIterator1 end,InputIterator2 cmpBeg,BinaryPredicate op)
```
- 第一形式判断 [beg，end）区间内的元素是否都和“以cmpBeg开头的区间”内的元素相等。
- 第二形式判断[beg，end）区间内的元素和“以cmpBeg开头的区间”内的对应元素是否都能够造成以下binary predicate产出true：
```cc
op(elem)
```

- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 调用者必须确保“以cmpBeg开头”的区间内含足够元素。
- 当序列不相等时，如果想要了解其间的不同，应使用mismatch()算法.
- 自C++11起提供了is_permutation()算法，用来判断是否两个序列内含的元素数值相同但次序不同。
- 复杂度：线性。至多比较（或调用op()）共numElems次。

下面的例子展示了equal()两种形式的用法。第一次调用检查元素是否相等。第二次调用使用一个辅助式predicate，检查两集合内的元素是否具备一一对应的奇偶关系：
```cc
#include "algostuff.hpp"
using namespace std;

bool bothEvenOrOdd(int elem1, int elem2)
{
    return elem1 % 2 == elem2 % 2;
}

int main()
{
    vector<int> coll1;
    list<int> coll2;

    INSERT_ELEMENTS(coll1, 1, 7);
    INSERT_ELEMENTS(coll2, 3, 9);

    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");

    // check whether both collections are equal
    if (equal(coll1.begin(), coll1.end(),  // first range
              coll2.begin())) {             // second range
        cout << "coll1 == coll2" << endl;
    }
    else {
        cout << "coll1 != coll2" << endl;
    }

    // check for corresponding even and odd elements
    if (equal(coll1.begin(), coll1.end(),  // first range
              coll2.begin(),                // second range
              bothEvenOrOdd)) {             // comparison criterion
        cout << "even and odd elements correspond" << endl;
    }
    else {
        cout << "even and odd elements do not correspond" << endl;
    }
}
```
程序输出如下：
```bash
coll1: 1 2 3 4 5 6 7
coll2: 3 4 5 6 7 8 9
coll1 != coll2
even and odd elements correspond
```
#### 测试不定序之相等性（Testing for Unordered Equality）
```cc
bool
is_permutation (ForwardIterator1 beg1,ForwardIterator1 end1,ForwardIterator2 beg2)

bool
is_permutation (ForwardIterator1 beg1,ForwardIterator1 end1,ForwardIterator2 beg2,CompFunc op)
```
- 两个形式都检测[beg1，end1）区间内的元素是否为 beg2起始之区间元素的一个排列组合（a permutation）；也就是说，“顺序无所谓”的情况下两区间的元素是否相等。
- 第一形式以operator==比较元素。
- 第二形式使用binary predicate op(elem1，elem2)比较元素，它应该在“elem1等于elem2”时返回true。
- 注意，op不应在函数调用过程中改变状态（state）
- op不应改动传入的实参。
- 所有iterator必须有相同的value type（即所指向的元素的类型）。
- 这些算法都始自C++11。
- 复杂度：最糟情况下是二次（quadratic；共numElems1次比较或调用op()，前提是所有对应元素相等且有相同次序）。

以下示范不定序比较（unordered comparison）的用法：
```cc
#include "algostuff.hpp"
using namespace std;

bool bothEvenOrOdd(int elem1, int elem2)
{
    return elem1 % 2 == elem2 % 2;
}

int main()
{
    vector<int> coll1;
    list<int> coll2;
    deque<int> coll3;

    coll1 = {1, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    coll2 = {1, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    coll3 = {11, 12, 13, 19, 18, 17, 16, 15, 14, 11};

    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");
    PRINT_ELEMENTS(coll3, "coll3: ");

    // check whether both collections have equal elements in any order
    if (is_permutation(coll1.cbegin(), coll1.cend(),  // first range
                       coll2.cbegin())) {              // second range
        cout << "coll1 and coll2 have equal elements" << endl;
    }
    else {
        cout << "coll1 and coll2 don't have equal elements" << endl;
    }

    // check for corresponding number of even and odd elements
    if (is_permutation(coll1.cbegin(), coll1.cend(),  // first range
                       coll3.cbegin(),                 // second range
                       bothEvenOrOdd)) {               // comparison criterion
        cout << "numbers of even and odd elements match" << endl;
    }
    else {
        cout << "numbers of even and odd elements don't match" << endl;
    }
}
```
程序输出如下：
```bash
coll1: 1 1 2 3 4 5 6 7 8 9
coll2: 1 9 8 7 6 5 4 3 2 1
coll3: 11 12 13 19 18 17 16 15 14 11
coll1 and coll2 have equal elements
numbers of even and odd elements match
```
#### 查找第一处不同（Search the First Difference）
```cc
pair＜InputIterator1,InputIterator2＞
mismatch (InputIterator1 beg,InputIterator1 end,InputIterator2 cmpBeg)

pair＜InputIterator1,InputIterator2＞
mismatch (InputIterator1 beg,InputIterator1 end,InputIterator2 cmpBeg,BinaryPredicate op)
```
- 第一形式返回 [beg，end）区间和“以cmpBeg起始的区间”内第一组两两相异的对应元素。
- 第二形式返回 [beg，end） 区间和“以cmpBeg 起始的区间”内第一组“造成以下binary predicate结果为false”的对应元素：
```cc
op(elem)
```
- 如果没有找到相异点，就返回“以end和第二序列的对应元素组成”的pair<>。这并不意味着两序列相等，因为第二序列有可能内含较多元素。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 调用者必须确保“以cmpBeg开头”的区间内含足够元素。
- 如果想知道两个序列是否相等，应当使用equal()算法.
- 复杂度：线性。至多比较（或调用op()）共numElems次。

下面的例子展示了mismatch()两种形式的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll1 = {1, 2, 3, 4, 5, 6};
    list<int> coll2 = {1, 2, 4, 8, 16, 3};

    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");

    // find first mismatch
    auto values = mismatch(coll1.cbegin(), coll1.cend(),  // first range
                           coll2.cbegin());                // second range

    if (values.first == coll1.cend()) {
        cout << "no mismatch" << endl;
    } else {
        cout << "first mismatch: "
             << *values.first << " and "
             << *values.second << endl;
    }

    // find first position where the element of coll1 is not
    // less than the corresponding element of coll2
    values = mismatch(coll1.cbegin(), coll1.cend(),  // first range
                      coll2.cbegin(),                // second range
                      less_equal<int>());            // criterion

    if (values.first == coll1.cend()) {
        cout << "always less-or-equal" << endl;
    } else {
        cout << "not less-or-equal: "
             << *values.first << " and "
             << *values.second << endl;
    }
}
```
第一次调用mismatch()为的是查找第一对互异的对应元素。其返回类型是：
```cc
pair<vector<int>::const_iterator, list<int>::const_iterator>
```
只要检查返回的pair的第一元素是否等于被传入的区间的终点，就知道异点（mismatch）是否存在。如果找到了就把它们的值写到标准输出设备。

第二次调用是为了查找符合“第一序列的元素比第二序列的对应元素大”条件下的第一对元素，找到后就返回它们。程序输出如下：
```bash
coll1: 1 2 3 4 5 6
coll2: 1 2 4 8 16 3
first mismatch: 3 and 4
not less-or-equal: 6 and 3
```
#### 检验“小于”（Testing for“Less Than”）
```cc
bool
lexicographical_compare (InputIterator1 beg1,InputIterator1 end1,InputIterator2 beg2,InputIterator2 end2)

bool
lexicographical_compare (InputIterator1 beg1,InputIterator1 end1,InputIterator2 beg2,InputIterator2 end2,CompFunc op)
```
- 两个形式都用来判断[beg1，end1）区间内的元素是否小于[beg2，end2）的元素。所谓“小于”是指就“字典（lexicographical）次序”意义而言。
- 第一形式以operator＜比较元素。
- 第二形式以binary predicate
```cc
op(elem)
```
比较元素。如果elem1小于elem2，应当返回true。

- 所谓字典次序的排序意味着两序列中的元素一一比较，直到以下情况发生：
  - 如果两元素不相等，则这两个元素的比较结果就是整个两序列的比较结果。
  - 如果两序列的元素数量不同，则元素较少的序列小于另一序列。所以如果第一序列的元素数量较少，比较结果是true。
  - 如果两序列都没有更多的元素可进行比较，则这两个序列相等，整个比较结果是false。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 复杂度：线性。至多比较（或调用op()） min（numElems1，numElems2）次。

下面的例子展示了如何利用这个算法对集合完成“字典次序”的排序：
```cc
#include "algostuff.hpp"
using namespace std;

void printCollection(const list<int>& l)
{
    PRINT_ELEMENTS(l);
}

bool lessForCollection(const list<int>& l1, const list<int>& l2)
{
    return lexicographical_compare(l1.cbegin(), l1.cend(),  // first range
                                   l2.cbegin(), l2.cend());  // second range
}

int main()
{
    list<int> c1, c2, c3, c4;

    // fill all collections with the same starting values
    INSERT_ELEMENTS(c1, 1, 5);
    c4 = c3 = c2 = c1;

    // and now some differences
    c1.push_back(7);
    c3.push_back(2);
    c3.push_back(0);
    c4.push_back(2);

    // create collection of collections
    vector<list<int>> cc;
    cc.insert(cc.begin(), {c1, c2, c3, c4, c3, c1, c4, c2});

    // print all collections
    for_each(cc.cbegin(), cc.cend(),
             printCollection);
    cout << endl;

    // sort collection lexicographically
    sort(cc.begin(), cc.end(),      // range
         lessForCollection);        // sorting criterion

    // print all collections again
    for_each(cc.cbegin(), cc.cend(),
             printCollection);
}
```
其中vector cc由若干集合（都是list）组成。调用sort()时使用binary predicate lessForCollection()比较两集合，其中又借由lexicographical_compare()算法对集合进行字典序比较。

程序输出如下：
```bash
1 2 3 4 5 7
1 2 3 4 5
1 2 3 4 5 2 0
1 2 3 4 5 2
1 2 3 4 5 2 0
1 2 3 4 5 7
1 2 3 4 5 2
1 2 3 4 5

1 2 3 4 5
1 2 3 4 5
1 2 3 4 5 2
1 2 3 4 5 2
1 2 3 4 5 2 0
1 2 3 4 5 2 0
1 2 3 4 5 7
1 2 3 4 5 7
```

#### Predicate用以检验区间
下面各算法都始自C++11，用来检验某个给定区间是否符合某条件。

检验是否排序（或局部排序）
```cc
bool
is_sorted (ForwardIterator beg,ForwardIterator end)

bool
is_sorted (ForwardIterator beg,ForwardIterator end,BinaryPredicate op)

ForwardIterator
is_sorted_until (ForwardIterator beg,ForwardIterator end)

ForwardIterator
is_sorted_until (ForwardIterator beg,ForwardIterator end,BinaryPredicate op)
```
- is_sorted() 检验[beg，end）区间内的元素是否已经排序。
- is_sorted() _until返回[beg，end）区间内第一个破坏排序的元素。如果没有这样的元素，返回end。
- 第一和第三形式使用operator＜比较元素。第二和第四形式使用binary predicate

比较元素——如果elem1“小于”elem2它就该返回true。

- 如果区间为空，这些算法返回true，如果只有一个元素则返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 这些算法全部始自C++11。
- 复杂度：线性。至多调用＜或op()共numElems-1次。

以下程序示范了如何使用这些算法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll1 = {1, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    PRINT_ELEMENTS(coll1, "coll1: ");

    // check whether coll1 is sorted
    if (is_sorted(coll1.begin(), coll1.end())) {
        cout << "coll1 is sorted" << endl;
    } else {
        cout << "coll1 is not sorted" << endl;
    }

    map<int, string> coll2;
    coll2 = {{1, "Bill"}, {2, "Jim"}, {3, "Nico"}, {4, "Liu"}, {5, "Ai"}};
    PRINT_MAPPED_ELEMENTS(coll2, "coll2: ");

    // define predicate to compare names
    auto compareName = [](const pair<int, string>& e1,
                          const pair<int, string>& e2) {
        return e1.second < e2.second;
    };

    // check whether the names in coll2 are sorted
    if (is_sorted(coll2.cbegin(), coll2.cend(),
                  compareName)) {
        cout << "names in coll2 are sorted" << endl;
    } else {
        cout << "names in coll2 are not sorted" << endl;
    }

    // print first unsorted name
    auto pos = is_sorted_until(coll2.cbegin(), coll2.cend(),
                               compareName);
    if (pos != coll2.cend()) {
        cout << "first unsorted name: " << pos->second << endl;
    }
}
```
程序输出如下：
```bash
coll1: 1 1 2 3 4 5 6 7 8 9
coll1 is sorted
coll2: [1,Bill] [2,Jim] [3,Nico] [4,Liu] [5,Ai]
names in coll2 are not sorted
first unsorted name: Liu
```
注意，is_sorted_until()返回的是第一个“破坏排序规则”的元素位置（以iterator表示），所以我们必须调用pos->second才能取出name（那是key/value pair中的value）。

#### 检验是否被分割（Check for Being Partitioned）
```cc
bool
is_partitioned (InputIterator beg,InputIterator end,UnaryPredicate op)

ForwardIterator
partition_point (ForwardIterator beg,ForwardIterator end,BinaryPredicate op)
```
- is_partitioned()判断[beg，end）区间内的元素是否被分割（are partitions），也就是所有符合predicate op()的元素都被置于所有不符合的元素之前（较早出现）。
- partition_point()返回[beg，end）区间中的第一个元素的位置。因此，对于[beg，end），is_partitioned()必定产出true on entry。
- 这些算法使用binary predicate
```cc
op(elem1, elem2)
```

它应该在elem1“小于”elem2时返回true。
- 如果区间为空，partition_point()返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 这些算法都始自C++11。
- 复杂度：
  - is_partitioned()：线性（至多numElems次调用op()）。
  - partition_point()：如果收到的是 random-access iterator 则为对数（logarithmic），否则是线性（无论如何至多log（numElems）次调用op()）。

以下程序示范了如何使用这些算法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll = {5, 3, 9, 1, 3, 4, 8, 2, 6};
    PRINT_ELEMENTS(coll, "coll: ");

    // define predicate: check whether element is odd:
    auto isOdd = [](int elem) {
        return elem % 2 == 1;
    };

    // check whether coll is partitioned in odd and even elements
    if (is_partitioned(coll.cbegin(), coll.cend(),  // range
                        isOdd)) {                     // predicate
        cout << "coll is partitioned" << endl;

        // find first even element:
        auto pos = partition_point(coll.cbegin(), coll.cend(),
                                   isOdd);
        cout << "first even element: " << *pos << endl;
    } else {
        cout << "coll is not partitioned" << endl;
    }
}
```
程序输出如下：
```bash
coll: 5 3 9 1 3 4 8 2 6
coll is partitioned
first even element: 4
```
#### 检验是否形成Heap（最大值元素在第一位）
```cc
bool
is_heap (RandomAccessIterator beg,RandomAccessIterator end)

bool
is_heap (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)

RandomAccessIterator
is_heap_until (RandomAccessIterator beg,RandomAccessIterator end)

RandomAccessIterator
is_heap_until (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)
```
- is_heap()判断[beg，end）区间内的元素是否形成一个heap，那意味着beg是最大值元素（之一）。
- is_heap() _until返回[beg，end）区间内第一个“破坏排序使无法成为 heap”的元素位置（该元素将会比第一元素更大）。如果没有这样的元素就返回end。
- 第一和第三形式使用operator＜比较元素，第二和第四形式使用binary predicateop(elem1，elem2) 完成比较，后者应该在elem1“小于”elem2的情况下返回true。
- 如果区间为空，这些算法返回true，如果只有一个元素则返回end。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 这些算法都始自C++11。
- 复杂度：线性。至多调用＜或op()共numElems-1次。

以下程序示范了如何使用这些算法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll1 = {9, 8, 7, 7, 7, 5, 4, 2, 1};
    vector<int> coll2 = {5, 3, 2, 1, 4, 7, 9, 8, 6};

    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");

    // check whether the collections are heaps
    cout << boolalpha << "coll1 is heap: "
         << is_heap(coll1.cbegin(), coll1.cend()) << endl;
    cout << "coll2 is heap: "
         << is_heap(coll2.cbegin(), coll2.cend()) << endl;

    // print the first element that is not a heap in coll2
    auto pos = is_heap_until(coll2.cbegin(), coll2.cend());
    if (pos != coll2.cend()) {
        cout << "first non-heap element: " << *pos << endl;
    }
}
```
程序输出如下：
```bash
coll1: 9 8 7 7 7 5 4 2 1
coll2: 5 3 2 1 4 7 9 8 6
coll1 is heap: true
coll2 is heap: false
first non-heap element: 4
```
#### 检验All、Any或None
```cc
bool
all_of (InputIterator beg,InputIterator end,UnaryPredicate op)

bool
any_of (InputIterator beg,InputIterator end,UnaryPredicate op)

bool
none_of (InputIterator beg,InputIterator end,UnaryPredicate op)
```
- 这些算法将判断，[beg，end）区间内是否全部，或至少一个，或没有任何元素造成unary predicate
```cc
op(elem)
```
产出true。
- 如果区间为空，all_of()和none_of()返回true，而any_of()返回false。
- 注意，op不应在函数调用过程中改变状态（state）.
- op不应改动传入的实参。
- 这些算法都始自C++11。
- 复杂度：线性。至多调用op() numElems次。

以下程序示范了如何使用这些算法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;
    vector<int>::iterator pos;

    INSERT_ELEMENTS(coll,1,9);
    PRINT_ELEMENTS(coll,"coll: ");

    // define an object for the predicate (using a lambda)
    auto isEven = [](int elem) {
        return elem%2==0;
    };

    // print whether all, any, or none of the elements are/is even
    cout << boolalpha << "all even?: "
         << all_of(coll.cbegin(),coll.cend(), isEven) << endl;
    cout << "any even?: "
         << any_of(coll.cbegin(),coll.cend(), isEven) << endl;
    cout << "none even?: "
         << none_of(coll.cbegin(),coll.cend(), isEven) << endl;
}
```
程序输出如下：
```bash
coll: 1 2 3 4 5 6 7 8 9
all even?: false
any even?: true
none even?: false
```
## 更易型算法（Modifying Algorithm）
本节描述的算法会更易（变动，改动）区间内的元素内容。
两种方法可以更易元素：
- 1.“运用iterator遍历序列”的过程中直接改动。
- 2.“将元素从源区间复制到目标区间”的过程中加以变动。

有些更易型算法同时提供上述两种方法，此时使用第二种方法的版本会有后缀_copy。

注意，目标区间不可以是个associative或unordered容器，因为它们的元素被视为常量。
如果没有这个限制，其自动排序性质就无法获得保证（因为允许任意改动的话会破坏排序）。

所有“具单一目标区间”的算法，都返回区间内“最后一个被复制元素”的下一位置。

### 复制元素（Copying Element）
```cc
OutputIterator
copy (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg)

OutputIterator
copy_if (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,UnaryPredicate op)

OutputIterator
copy_n (InputIterator sourceBeg,Size num,OutputIterator destBeg)

BidirectionalIterator2
copy_backward (BidirectionalIterator1 sourceBeg,BidirectionalIterator1 sourceEnd,BidirectionalIterator2 destEnd)
```
- 上述四个算法都将源区间[sourceBeg，sourceEnd）中的所有元素复制到以destBeg为起点或以destEnd为终点的目标区间。
- 它们都返回目标区间内最后一个被复制元素的下一位置，也就是第一个未被覆盖（overwritten）的元素的位置。
- 关于copy()， destBeg不可处于`[sourceBeg，sourceEnd）区间内。关于copy_if()，源区间和目标区间不可重叠。关于copy_backward()， destEnd不可处于（sourceBeg，sourceEnd]`区间内。
- copy()正向遍历（forward），而 copy_backward()反向遍历（backward）。只有当源区间和目标区间重叠时，这个不同点才会导致一些问题：
  - 若要把一个子区间复制到前端，应使用copy()。因此对copy()而言， destBeg的位置应该在sourceBeg之前。
  - 若要把一个子区间复制到后端，应使用copy_backward()。因此对copy_backward()而言， destEnd的位置应该在sourceEnd之后。

所以，只要第三实参位于“前两个实参所指出的源区间”中，你就应该使用另一算法。
注意，如果转而使用另一形式，意味着原本应传入目标区间的起点，现在要改而传入终点了。

- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 自C++11起，如果源端元素不再被使用，你应该以move()取代copy()，以move_backward()取代copy_backward()
- C++11 之前并未提供 copy_if() 和 copy_n() 算法，因此若要复制“符合某给定准则”之元素，必须选择remove_copy_if()并搭配一个negated predicate。
- 如果希望在复制过程中反转元素次序，应使用reverse_copy()。该算法比起“copy()算法搭配reverse iterator”略快些。
- 如果想把容器内的所有元素赋值（assign）给另一个容器，应当使用assignment操作符（当两个容器的类型相同时才能这么做）或使用容器的assign()成员函数（当两个容器的类型不同时就采用此法）。
- 如果希望在复制的同时移除元素，应使用算法 remove_copy() 和 remove_copy_if().
- 如果希望在复制过程中改动元素，请使用 transform() 或replace_copy().
- 可使用partition_copy()将元素复制到两个目标区间：其中一组满足predicate而另一组不满足。
- 复杂度：线性，执行numElems次赋值。

下面的例子展示了copy()的若干简单用法。
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<string> coll1 = { "Hello", "this", "is", "an", "example" };
    list<string> coll2;

    // copy elements of coll1 into coll2
    // - use back inserter to insert instead of overwrite
    copy (coll1.cbegin(), coll1.cend(),           // source range
          back_inserter(coll2));                  // destination range

    // print elements of coll2
    // - copy elements to cout using an ostream iterator
    copy (coll2.cbegin(), coll2.cend(),           // source range
          ostream_iterator<string>(cout," "));    // destination range
    cout << endl;

    // copy elements of coll1 into coll2 in reverse order
    // - now overwriting
    copy (coll1.crbegin(), coll1.crend(),         // source range
          coll2.begin());                         // destination range

    // print elements of coll2 again
    copy (coll2.cbegin(), coll2.cend(),           // source range
          ostream_iterator<string>(cout," "));    // destination range
    cout << endl;
}
```
在这个例子里，back inserter被用来在目标区内安插元素。
如果不使用inserter，copy()算法就会在空的coll2容器上实施覆盖（overwrite），导致不确定的行为。
同样道理，我们可使用ostream iterator把标准输出设备当成目标区。程序输出如下：
```bash
Hello this is an example
example an is this Hello
```
下面的例子展示了copy()和copy_backward()之间的区别：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    // initialize source collection with "..........abcdef.........."
    vector<char> source(10, '.');
    for (int c = 'a'; c <= 'f'; c++) {
        source.push_back(c);
    }
    source.insert(source.end(), 10, '.');
    PRINT_ELEMENTS(source, "source: ");

    // copy all letters three elements in front of the 'a'
    vector<char> c1(source.cbegin(), source.cend());
    copy(c1.cbegin() + 10, c1.cbegin() + 16,  // source range
         c1.begin() + 7);                     // destination range
    PRINT_ELEMENTS(c1, "c1:        ");

    // copy all letters three elements behind the 'f'
    vector<char> c2(source.cbegin(), source.cend());
    copy_backward(c2.cbegin() + 10, c2.cbegin() + 16,  // source range
                  c2.begin() + 19);                    // destination range
    PRINT_ELEMENTS(c2, "c2:        ");
}
```
注意，无论是调用copy()或是copy_backward()，第三实参都不处于源区间中。程序输出如下：
```bash
source: ..........abcdef..........
c1:     .......abcdefdef..........
c2:     ..........abcabcdef.......
```
第三个例子示范如何使用copy()作为标准输入设备和标准输出设备之间的数据筛检程序。程序读取string，并以一行一个的方式打印它们：
```cc
#include <iostream>
#include <algorithm>
#include <iterator>
#include <string>
using namespace std;

int main()
{
    copy (istream_iterator<string>(cin),       // beginning of source
          istream_iterator<string>(),          // end of source
          ostream_iterator<string>(cout,"\n"));// destination
}
```
### 搬移元素（Moving Element）
```cc
OutputIterator
move (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg)

BidirectionalIterator2
move_backward (BidirectionalIterator1 sourceBeg,BidirectionalIterator1 sourceEnd,BidirectionalIterator2 destEnd)
```
- 上述两个算法将源区间[sourceBeg，sourceEnd）中的所有元素搬移至以destBeg为起点或以destEnd为终点的目标区间。
- 它们会针对每一个元素调用

因此，如果元素类型提供有move语义，源端元素从此不再明确，它们也就不该再被使用，除非重新初始化或被赋予新值。
如果元素类型未提供move语义，元素会被copy，就像copy()或copy_backward()的行为一样.

- 它们会返回目标区间内最后一个被复制元素的下一位置，也就是第一个未被覆盖（overwritten）的元素的位置。
- move()的destBeg不可处于`[sourceBeg，sourceEnd）区间内。move_backward()的destEnd不可处于（sourceBeg，sourceEnd]`区间内。
- move()正向遍历（forward），而 move_backward()反向遍历（backward）。只有当源区间和目标区间重叠时，这个不同点才会导致一些问题：
  - 若要把一个子区间搬移到前端，应使用 move()。因此对 move()而言，destBeg的位置应该在sourceBeg之前。
  - 若要把一个子区间复制到后端，应使用move_backward()。因此对move_backward()而言，destEnd的位置应该在sourceEnd之后。

所以，只要第三实参位于“前两个实参所指出的源区间”中，你就应该使用另一算法。
注意，如果转而使用另一形式，意味着原本应传入目标区间的起点，现在要改而传入终点了。

- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 这些算法都始自C++11。
- 复杂度：线性，执行numElems次“搬移赋值”（move assignment）。

下面的例子展示了对 move()的一些简单调用。
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<string> coll1 = { "Hello", "this", "is", "an", "example" };
    list<string> coll2;

    // copy elements of coll1 into coll2
    // - use back inserter to insert instead of overwrite
    // - use copy() because the elements in coll1 are used again
    copy (coll1.cbegin(), coll1.cend(),           // source range
          back_inserter(coll2));                  // destination range

    // print elements of coll2
    // - copy elements to cout using an ostream iterator
    // - use move() because the elements in coll2 are not used again
    move (coll2.cbegin(), coll2.cend(),           // source range
          ostream_iterator<string>(cout," "));    // destination range
    cout << endl;

    // copy elements of coll1 into coll2 in reverse order
    // - now overwriting (coll2.size() still fits)
    // - use move() because the elements in coll1 are not used again
    move (coll1.crbegin(), coll1.crend(),         // source range
          coll2.begin());                         // destination range

    // print elements of coll2 again
    // - use move() because the elements in coll2 are not used again
    move (coll2.cbegin(), coll2.cend(),           // source range
          ostream_iterator<string>(cout," "));    // destination range
    cout << endl;
}
```
注意，coll2的元素在它们初次被输出后，状态就变得不确定，因为这里用的是move()。
然而coll2的大小仍然是5，所以我们可以再次调用move()覆盖（overwrite）这些元素。程序输出如下：
```bash
Hello this is an example
example an is this Hello
```
### 转换和结合元素（Transforming and Combining Ele-ment）
算法transform()提供以下两个能力：
- 1.第一形式有4个实参。把来源区的元素转换到目标区。也就是说元素的复制和修改一气呵成。
- 2.第二形式有5个实参，将两个源序列中的元素合并，将结果写入目标区。

#### 转换元素（Transforming Element）
```cc
OutputIterator
transform (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,UnaryFunc op)
```
- 针对源区间[sourceBeg，sourceEnd）中的每一个元素调用：op(elem)并将结果写到以destBeg起始的目标区间内。
- 返回目标区间内“最后一个被转换元素”的下一位置，也就是第一个未被覆盖（overwritten）的元素的位置。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- sourceBeg与destBeg可以完全相同，所以，和for_each()算法一样，你可以使用这个算法来改动“序列内”的元素。
- 如果想以某值替换掉“符合给定准则”的元素，应使用replace().
- 复杂度：线性，对op()执行numElems次调用。

下面的例子展示了以上所说的transform()用法：
```cc
#include "algostuff.hpp"
using namespace std;
using namespace std::placeholders;

int main()
{
    vector<int> coll1;
    list<int> coll2;

    INSERT_ELEMENTS(coll1, 1, 9);

    PRINT_ELEMENTS(coll1, "coll1:  ");

    // negate all elements in coll1
    transform(coll1.cbegin(), coll1.cend(),  // source range
              coll1.begin(),                 // destination range
              negate<int>());                // operation
    PRINT_ELEMENTS(coll1, "negated: ");

    // transform elements of coll1 into coll2 with ten times their value
    transform(coll1.cbegin(), coll1.cend(),  // source range
              back_inserter(coll2),          // destination range
              bind(multiplies<int>(), _1, 10));  // operation
    PRINT_ELEMENTS(coll2, "coll2:  ");

    // print coll2 negatively and in reverse order
    transform(coll2.crbegin(), coll2.crend(),  // source range
              ostream_iterator<int>(cout, " "),  // destination range
              [](int elem) {                     // operation
                  return -elem;
              });
    cout << endl;
}
```
程序输出如下：
```bash
coll1:  1 2 3 4 5 6 7 8 9
negated: -1 -2 -3 -4 -5 -6 -7 -8 -9
coll2:  -10 -20 -30 -40 -50 -60 -70 -80 -90
90 80 70 60 50 40 30 20 10
```
#### 将两序列的元素结合（Combining Elements of Two Sequences）
```cc
OutputIterator
transform (InputIterator1 source1Beg,InputIterator1 source1End,InputIterator2 source2Beg,OutputIterator destBeg,BinaryFunc op)
```
- 针对第一源区间[source1Beg，source1End）以及“从source2Beg开始的第二源区间”的对应元素，调用
```cc
op(source1Elem, source2Elem)
```
并将结果写入以destBeg起始的目标区内。

            ┌─────┐
            │     ├────┐
            └─────┘    │   ┌──────────┐
                       ├──►│          │
            ┌─────┐    │   └──────────┘
            │     ├────┘
            └─────┘

- 返回目标区间内“最后一个被转换元素”的下一位置，就是第一个未被覆盖（overwritten）的元素的位置。
- 调用者必须保证第二源区间有足够空间（至少拥有和第一源区间相同的大小）。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- source1Beg、source2Beg和destBeg可相同。因此，你可以让元素自己和自己结合，然后将结果覆盖（overwrite）自己。
- 复杂度：线性，对op()执行numElems次调用。

下面的例子展示了上述transform()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll1;
    list<int> coll2;

    INSERT_ELEMENTS(coll1, 1, 9);
    PRINT_ELEMENTS(coll1, "coll1:  ");

    // square each element
    transform(coll1.cbegin(), coll1.cend(),  // first source range
              coll1.cbegin(),                // second source range
              coll1.begin(),                 // destination range
              multiplies<int>());            // operation
    PRINT_ELEMENTS(coll1, "squared: ");

    // add each element traversed forward with each element traversed backward
    // and insert result into coll2
    transform(coll1.cbegin(), coll1.cend(),  // first source range
              coll1.crbegin(),               // second source range
              back_inserter(coll2),          // destination range
              plus<int>());                  // operation
    PRINT_ELEMENTS(coll2, "coll2:  ");

    // print differences of two corresponding elements
    cout << "diff: ";
    transform(coll1.cbegin(), coll1.cend(),  // first source range
              coll2.cbegin(),                // second source range
              ostream_iterator<int>(cout, " "),  // destination range
              minus<int>());                  // operation
    cout << endl;
}
```
程序输出如下：
```bash
coll1:  1 2 3 4 5 6 7 8 9
squared: 1 4 9 16 25 36 49 64 81
coll2:  82 68 58 52 50 52 58 68 82
diff:  -81 -64 -49 -36 -25 -16 -9 -4 -1
```
### 互换元素（Swapping Elements）
```cc
ForwardIterator2
swap_ranges (ForwardIterator1 beg1,ForwardIterator1 end1,ForwardIterator2 beg2)
```
- 将区间[beg1，end1）内的元素和“从beg2开始的区间”内的对应元素互换。
- 返回第二区间中“最后一个被交换元素”的下一位置。
- 调用者必须确保目标区间有足够空间。
- 两区间不得重叠。
- 如果要将相同类型的两个容器内的所有元素都互换，应使用swap()成员函数，因为该成员函数通常具备常量复杂度.
- 复杂度：线性，执行numElems次交换动作。

下面的例子展示了swap_ranges()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll1;
    deque<int> coll2;

    INSERT_ELEMENTS(coll1, 1, 9);
    INSERT_ELEMENTS(coll2, 11, 23);
    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");

    // swap elements of coll1 with corresponding elements of coll2
    deque<int>::iterator pos;
    pos = swap_ranges(coll1.begin(), coll1.end(),  // first range
                      coll2.begin());               // second range

    PRINT_ELEMENTS(coll1, "\ncoll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");
    if (pos != coll2.end()) {
        cout << "first element not modified: "
             << *pos << endl;
    }

    // mirror first three with last three elements in coll2
    swap_ranges(coll2.begin(), coll2.begin() + 3,  // first range
                coll2.rbegin());                    // second range

    PRINT_ELEMENTS(coll2, "\ncoll2: ");
}
```
第一次调用 swap_ranges()是为了将 coll1的元素和 coll2的对应元素交换。
coll2之内的其余元素不变动。swap_ranges() 算法返回第一个未被改动的元素。第二次调用swap_ranges() 是为了将 coll2 内的前 3 个元素和后 3 个元素交换。
由于运用了一个reverse iterator，所以元素以镜像方式交换（从外向内交换）。程序输出如下：
```bash
coll1: 1 2 3 4 5 6 7 8 9
coll2: 11 12 13 14 15 16 17 18 19 20 21 22 23

coll1: 11 12 13 14 15 16 17 18 19
coll2: 1 2 3 4 5 6 7 8 9 20 21 22 23
first element not modified: 20

coll2: 23 22 21 4 5 6 7 8 9 20 3 2 1
```
### 赋值（Assigning New Value）
#### 赋予相同数值（Assigning the Same Value）
```cc
void
fill (ForwardIterator beg,ForwardIterator end,const T&newValue)

void
fill_n (OutputIterator beg,Size num,const T&newValue)
```
- fill()将区间[beg，end）内的每一个元素都赋予新值newValue。
- fill_n()将“从beg开始的前num个元素”赋予新值newValue。如果num为负值则不做任何事（始自C++11）。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 自C++11起，fill_n()返回最后被改动的元素的下一位置（beg+num），如果num是负值则返回beg（在C++11之前，fill_n()的返回类型是void）。
- 复杂度：线性（执行numElems次或num次或0次赋值）。

以下程序展示了fill()和fill_n()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    // print ten times 7.7
    fill_n(ostream_iterator<float>(cout, " "),  // beginning of destination
           10,                                  // count
           7.7);                                // new value
    cout << endl;

    list<string> coll;

    // insert "hello" nine times
    fill_n(back_inserter(coll),  // beginning of destination
           9,                    // count
           "hello");             // new value
    PRINT_ELEMENTS(coll, "coll: ");

    // overwrite all elements with "again"
    fill(coll.begin(), coll.end(),  // destination
         "again");                  // new value
    PRINT_ELEMENTS(coll, "coll: ");

    // replace all but two elements with "hi"
    fill_n(coll.begin(),          // beginning of destination
           coll.size() - 2,       // count
           "hi");                 // new value
    PRINT_ELEMENTS(coll, "coll: ");

    // replace the second and up to the last element but one with "hmmm"
    list<string>::iterator pos1, pos2;
    pos1 = coll.begin();
    pos2 = coll.end();
    fill(++pos1, --pos2,  // destination
         "hmmm");         // new value
    PRINT_ELEMENTS(coll, "coll: ");
}
```
第一次调用示范了如何使用 fill_n()打印特定数量的值。
其他针对 fill()和 fill_n()的调用示范了如何在一个string list中安插和替换元素。程序输出如下：
```bash
7.7 7.7 7.7 7.7 7.7 7.7 7.7 7.7 7.7 7.7
coll: hello hello hello hello hello hello hello hello hello
coll: again again again again again again again again again again again
coll: hi hi hi hi hi hi hi again again
coll: hi hmmm hmmm hmmm hmmm hmmm hmmm hmmm again
```
#### 赋予新生值（Assigning Generated Value）
```cc
void
generate (ForwardIterator beg,ForwardIterator end,Func op)

void
generate_n (OutputIterator beg,Size num,Func op)
```
- generate()会调用`op()`产生新值，并将它赋值给区间[beg，end）内的每个元素。
- generate_n()会调用`op()`产生新值，并将它赋值给“以beg起始的区间”内的前num个元素。如果num为负值则不做任何事（始自C++11）。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 自C++11起，generate_n()返回最后被改动的元素的下一位置（beg+num），如果num是负值则返回beg（在C++11之前，generate_n（）的返回类型是void）。
- 复杂度：线性（op()动作和赋值，执行numElems次或num次或0次）。

以下展示了如何利用generate()和generate_n()安插和赋值若干随机数：
```cc
#include <cstdlib>
#include <algostuff.hpp>
using namespace std;

int main()
{
    list<int> coll;

    // insert five random numbers
    generate_n(back_inserter(coll),  // beginning of destination range
               5,                    // count
               rand);                // new value generator
    PRINT_ELEMENTS(coll);

    // overwrite with five new random numbers
    generate(coll.begin(), coll.end(),  // destination range
             rand);                     // new value generator
    PRINT_ELEMENTS(coll);
}
```
程序可能输出如下：
```bash
1481765933 1085377743 1270216262 1191391529 812669700
553475508 445349752 1344887256 730417256 1812158119
```
实际输出结果取决于平台——因为 rand()产生的随机数序列并无一定标准。

#### 赋予一系列递增值（Assigning Sequence of Increments Values）
```cc
void
iota (ForwardIterator beg,ForwardIterator end,T startValue)
```
- 依序赋值startValue、startValue+1、startValue+2……
- 始自C++11。
- 复杂度：线性（执行numElems次赋值和累加）。

下面的例子示范了如何使用iota()：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    array<int,10> coll;

    iota (coll.begin(), coll.end(),  // destination range
          42);                       // start value

    PRINT_ELEMENTS(coll,"coll: ");
}
```
输出
```bash
coll: 42 43 44 5 46 47 48 49 50 51
```
### 替换元素（Replacing Element）
#### 替换序列内的元素（Replacing Values Inside a Sequence）
```cc
void
replace (ForwardIterator beg,ForwardIterator end,const T&oldValue,const T&newValue)

void
replace_if (ForwardIterator beg,ForwardIterator end,UnaryPredicate op,const T&newValue)
```
- replace()将[beg，end）区间内每一个“与oldValue相等”的元素替换为newValue。
- replace_if()将[beg，end）区间内每一个令以下unary predicate：`op(elem)` 产生true的元素替换为newValue。
- 注意，op不应在函数调用过程中改变状态（state）.
- 复杂度：线性（执行比较动作或调用op()，numElems次）。

以下程序示范了replace()和replace_if()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll,2,7);
    INSERT_ELEMENTS(coll,4,9);
    PRINT_ELEMENTS(coll,"coll: ");

    // replace all elements with value 6 with 42
    replace (coll.begin(), coll.end(),  // range
             6,                         // old value
             42);                       // new value
    PRINT_ELEMENTS(coll,"coll: ");

    // replace all elements with value less than 5 with 0
    replace_if (coll.begin(), coll.end(),  // range
                [](int elem){              // criterion for replacement
                    return elem<5;
                },
                0);                        // new value
    PRINT_ELEMENTS(coll,"coll: ");
}
```
输出
```bash
coll: 2 3 4 5 6 7 4 5 6 7 8 9
coll: 2 3 4 5 42 7 4 5 42 7 8 9
coll: 0 0 0 5 42 7 0 5 42 7 8 9
```
#### 复制并替换元素（Copying and Replacing Element）
```cc
OutputIterator
replace_copy (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,const T&oldValue,const T&newValue)

OutputIterator
replace_copy_if (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,UnaryPredicate op,const T&newValue)
```
- replace_copy()是copy()和replace()的组合。它将源区间[sourceBeg，sourceEnd）中的元素复制到“以destBeg为起点”的目标区，同时将其中“与oldValue相等”的所有元素替换为newValue。
- replace_copy_if()是copy()和replace_if()的组合。[sourceBeg，sourceEnd）中的元素被复制到“以destBeg为起点”的目标区，同时将其中“令unary predicate `op(elem)` 结果为true”的所有元素替换为newValue。
- 两个算法都返回目标区间中“最后一个被复制元素”的下一位置，也就是第一个未被覆盖（overwritten）的元素的位置。
- 注意，op不应在函数调用过程中改变状态（state）.
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 复杂度：线性，执行比较动作（或调用op()）numElems次。

以下程序示范了如何使用replace_copy()和replace_copy_if()：
```cc
#include "algostuff.hpp"
using namespace std;
using namespace std::placeholders;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll, 2, 6);
    INSERT_ELEMENTS(coll, 4, 9);
    PRINT_ELEMENTS(coll);

    // print all elements with value 5 replaced with 55
    replace_copy(coll.cbegin(), coll.cend(),  // source
                 ostream_iterator<int>(cout, " "),  // destination
                 5,                            // old value
                 55);                          // new value
    cout << endl;

    // print all elements with a value less than 5 replaced with 42
    replace_copy_if(coll.cbegin(), coll.cend(),  // source
                    ostream_iterator<int>(cout, " "),  // destination
                    bind(less<int>(), _1, 5),    // replacement criterion
                    42);                         // new value
    cout << endl;

    // print each element while each odd element is replaced with 0
    replace_copy_if(coll.cbegin(), coll.cend(),  // source
                    ostream_iterator<int>(cout, " "),  // destination
                    [](int elem) {               // replacement criterion
                        return elem % 2 == 1;
                    },
                    0);                          // new value
    cout << endl;
}
```
输出
```bash
2 3 4 5 6 4 5 6 7 8 9
2 3 4 55 6 4 55 6 7 8 9
42 42 42 5 6 42 5 6 7 8 9
2 0 4 0 6 4 0 6 0 8 0
```

## 移除型算法（Removing Algorithm）
本节所列算法系根据元素值或根据某一准则，在一个区间内移除某些元素。
这些算法并不会改变元素的数量，它们只是以逻辑上的思考，将原本置于后面的“不移除元素”向前移动，覆盖那些应被移除的元素而已。
它们都返回新区间的逻辑终点（也就是最后一个“不移除元素”的下一位置）.

### 移除某些元素
移除序列内的元素（Removing Elements in a Sequence）
```cc
ForwardIterator
remove (ForwardIterator beg,ForwardIterator end,const T&value)

ForwardIterator
remove_if (ForwardIterator beg,ForwardIterator end,UnaryPredicate op)
```
- remove()会移除[beg，end）区间中每一个“与value相等”的元素。
- remove_if()会移除[beg，end）区间中每一个“令unary predicate `op(elem)` 结果为true”的元素。
- 两个算法都返回被改动的序列的新逻辑终点（也就是最后一个未被移除元素的下一位置）。
- 这些算法会把原本置于后面的未移除元素向前移动，覆盖被移除元素。
- 未被移除的元素在相对次序上保持不变。
- 调用者在调用此算法之后，应保证从此采用其所返回的新逻辑终点，不再使用原始终点end.
- 注意，op不应在函数调用过程中改变状态（state）.
- 注意，remove_if()通常会在内部复制它所获得的那个unary predicate，然后两次运用它。如果该unary predicate在函数调用过程中改变状态，就可能导致问题。
- 由于元素会被改动，所以这些算法不可用于associative或unordered容器。然而这些容器提供了功能类似的成员函数erase().
- List提供了一个效果相同的成员函数remove()，效能较高，原因是它不重新赋值，而是重新链接pointer.
- 复杂度：线性，执行比较动作（或调用op()）numElems次。

以下程序示范了remove()和remove_if()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 2, 6);
    INSERT_ELEMENTS(coll, 4, 9);
    INSERT_ELEMENTS(coll, 1, 7);
    PRINT_ELEMENTS(coll, "coll:                         ");

    // remove all elements with value 5
    vector<int>::iterator pos;
    pos = remove(coll.begin(), coll.end(),  // range
                 5);                         // value to remove

    PRINT_ELEMENTS(coll, "size not changed:             ");

    // erase the "removed" elements in the container
    coll.erase(pos, coll.end());
    PRINT_ELEMENTS(coll, "size changed:                 ");

    // remove all elements less than 4
    coll.erase(remove_if(coll.begin(), coll.end(),  // range
                         [](int elem) {             // remove criterion
                             return elem < 4;
                         }),
               coll.end());
    PRINT_ELEMENTS(coll, "<4 removed:                   ");
}
```
输出
```bash
coll:                         2 3 4 5 6 4 5 6 7 8 9 1 2 3 4 5 6 7
size not changed:             2 3 4 6 4 6 7 8 9 1 2 3 4 6 7 5 6 7
size changed:                 2 3 4 6 4 6 7 8 9 1 2 3 4 6 7
<4 removed:                   4 6 4 6 7 8 9 4 6 7
```

#### 复制时一并移除元素（Removing Elements While Copying）
```cc
OutputIterator
remove_copy (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,const T&value)

OutputIterator
remove_copy_if (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,UnaryPredicate op)
```
- remove_copy()是copy()和remove()的组合。它将源区间[sourceBeg，sourceEnd）内的所有元素复制到“以destBeg为起点”的目标区间去，并在复制过程中移除“与value相等”的所有元素。
- remove_copy_if()是copy()和remove_if()的组合。它将源区间[sourceBeg，sourceEnd）内的元素复制到“以destBeg为起点”的目标区间去，并在复制过程中移除“造成unary predicate `op(elem)`结果为true”的所有元素。
- 两个算法都返回目标区间中最后一个被复制元素的下一位置（也就是第一个未被覆盖的元素）。
- 注意，op不应在函数调用过程中改变状态（state）.
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- partition_copy()会把元素复制到两个目标区间：其中一个满足某个predicate而另一个不满足（始自C++11）。
- 复杂度：线性，执行比较动作（或调用op()）以及赋值numElems次。

以下程序示范了remove_copy()和remove_copy_if()的用法：
```cc
#include "algostuff.hpp"
using namespace std;
using namespace std::placeholders;

int main()
{
    list<int> coll1;

    INSERT_ELEMENTS(coll1, 1, 6);
    INSERT_ELEMENTS(coll1, 1, 9);
    PRINT_ELEMENTS(coll1);

    // print elements without those having the value 3
    remove_copy(coll1.cbegin(), coll1.cend(),  // source
                ostream_iterator<int>(cout, " "),  // destination
                3);  // removed value
    cout << endl;

    // print elements without those having a value greater than 4
    remove_copy_if(coll1.cbegin(), coll1.cend(),  // source
                   ostream_iterator<int>(cout, " "),  // destination
                   [](int elem) {  // criterion for elements NOT copied
                       return elem > 4;
                   });
    cout << endl;

    // copy all elements not less than 4 into a multiset
    multiset<int> coll2;
    remove_copy_if(coll1.cbegin(), coll1.cend(),  // source
                   inserter(coll2, coll2.end()),  // destination
                   bind(less<int>(), _1, 4));  // elements NOT copied
    PRINT_ELEMENTS(coll2);
}
```
输出
```bash
程序输出如下:
1 2 3 4 5 6 1 2 3 4 5 6 7 8 9
1 2 4 5 6 1 2 4 5 6 7 8 9
1 2 3 4 1 2 3 4
4 4 5 5 6 6 7 8 9
```
### 移除重复元素
#### 移除连续重复元素（Removing Consecutive Duplicates）
```cc
ForwardIterator
unique (ForwardIterator beg,ForwardIterator end)

ForwardIterator
unique (ForwardIterator beg,ForwardIterator end,BinaryPredicate op)
```
- 以上两种形式都会移除连续重复元素中的多余元素。
- 第一形式将[beg，end）区间内所有“与前一元素相等”的元素移除。因此源序列必须先经过排序，才能使用这个算法移除所有重复元素。
- 第二形式将每一个“位于元素e之后并造成binary predicate `op(elem)` 结果为true”的所有elem元素移除。
  - 换言之，上述predicate并非拿元素和其原本的前一元素比较，而是拿它和“经过处理后仍健在”的前一元素比较，
  - 如果序列A，B，C，D，E，A不符合移除条件，B符合，轮到C时，C将被拿来和A比较，而不是和原本的前一元素（但已被移除的）B比较。
- 两个形式都返回被改动的序列的新逻辑终点（也就是最后一个未被移除元素的下一位置）。
- 这两个算法将“原本位置在后”的未移除元素向前移动，覆盖掉（overwrite）被移除元素。
- 未被移除的元素在相对次序上保持不变。
- 调用者在调用这些算法之后，应保证从此使用返回的新逻辑终点，不再使用原始终点end.
- 注意，op不应在函数调用过程中改变状态（state）.
- 由于会造成元素被改动，所以这些算法不可用于associative或unordered容器.
- List提供了一个效果相同的成员函数 unique()，原因是它不重新赋值，而是重新链接pointer.
- 复杂度：线性，执行比较动作（或调用op()）numElems次。

以下程序示范了unique()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    // source data
    int source[] = { 1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4 };
    list<int> coll;

    // initialize coll with elements from source
    copy(begin(source), end(source),     // source
         back_inserter(coll));           // destination
    PRINT_ELEMENTS(coll);

    // remove consecutive duplicates
    auto pos = unique(coll.begin(), coll.end());
    // print elements not removed
    // - use new logical end
    copy(coll.begin(), pos,                  // source
         ostream_iterator<int>(cout, " "));  // destination
    cout << "\n\n";

    // reinitialize coll with elements from source
    copy(begin(source), end(source),  // source
         coll.begin());               // destination
    PRINT_ELEMENTS(coll);

    // remove elements if there was a previous greater element
    coll.erase(unique(coll.begin(), coll.end(),
                      greater<int>()),
               coll.end());
    PRINT_ELEMENTS(coll);
}
```
程序输出
```bash
1 4 4 6 1 2 2 3 1 6 6 6 5 7 5 4 4 
1 4 6 1 2 3 1 6 5 7 5 4 

1 4 4 6 1 2 2 3 1 6 6 6 5 7 5 4 4 
1 4 4 6 6 6 6 7 
```
第一次调用unique()是为了移除连续重复元素。
第二次调用则示范了unique()第二形式的行为：将“greater结果为true”的所有元素移除。
举个例子，第一个6大于其后的1，2，2，3，1，所以后面这些元素都被移除。
换言之，该predicate不是拿元素和其原本的前一元素比较，而是拿它和“经过处理后仍然健在”的前一元素比较（稍后的unique_copy()另有一个类似例子）。


#### 复制过程中移除重复元素（Removing Duplicates While Copying）
```cc
OutputIterator
unique_copy (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg)

OutputIterator
unique_copy (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,BinaryPredicate op)
```
- 两种形式都是copy()和unique()的组合。
- 两者都将源区间[sourceBeg，sourceEnd）内的元素复制到“以destBeg起始的目标区间”，并移除重复元素。
- 两个算法都返回目标区间内“最后一个被复制元素”的下一位置（也就是第一个未被覆盖的元素）。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 复杂度：线性，执行比较动作（或调用op()）numElems次。

以下程序示范了unique_copy()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

bool differenceOne(int elem1, int elem2)
{
    return elem1 + 1 == elem2 || elem1 - 1 == elem2;
}

int main()
{
    // source data
    int source[] = { 1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4 };

    // initialize coll with elements from source
    list<int> coll;
    copy(begin(source), end(source),     // source
         back_inserter(coll));           // destination
    PRINT_ELEMENTS(coll);

    // print elements with consecutive duplicates removed
    unique_copy(coll.cbegin(), coll.cend(),           // source
                ostream_iterator<int>(cout, " "));    // destination
    cout << endl;

    // print elements without consecutive entries that differ by one
    unique_copy(coll.cbegin(), coll.cend(),           // source
                ostream_iterator<int>(cout, " "),     // destination
                differenceOne);                        // duplicates criterion
    cout << endl;
}
```
输出
```bash
1 4 4 6 1 2 2 3 1 6 6 6 5 7 5 4 4 
1 4 6 1 2 3 1 6 5 7 5 4 
1 4 4 6 1 3 1 6 6 6 4 4 
```
注意，第二次调用 unique_copy()并非移除“与其原本之前置元素相差 1”的所有元素，而是移除与其“经过处理后仍存在之前置元素”相差1的所有元素。
例如，三个6之后紧跟着的元素是5，7，5，都与6相差1，所以都被移除。然而更后面的两个4并非和6相差1，所以被保留下来。

另一个例子用来压缩空白序列：
```cc
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;

bool bothSpaces(char elem1, char elem2)
{
    return elem1 == ' ' && elem2 == ' ';
}

int main()
{
    // don't skip leading whitespaces by default
    cin.unsetf(ios::skipws);

    // copy standard input to standard output
    // - while compressing spaces
    unique_copy(istream_iterator<char>(cin),  // beginning of source: cin
                istream_iterator<char>(),     // end of source: end-of-file
                ostream_iterator<char>(cout), // destination: cout
                bothSpaces);                  // duplicate criterion
}
```
输出
```cc
输入
Hello, here are  sometimes more  and sometimes fewer    spaces.
输出
Hello, here are sometimes more and sometimes fewer spaces.
```
## 变序型算法（Mutating Algorithm）
变序型算法会改变元素的次序，但不改变元素值。
这些算法不能用于 associative 和unordered容器，因为那些容器内的元素有一定次序，不能随意变动之。

### 反转元素次序（Reversing the Order of Elements）
```cc
void
reverse (BidirectionalIterator beg,BidirectionalIterator end)

OutputIterator
reverse_copy (BidirectionalIterator sourceBeg,BidirectionalIterator sourceEnd,OutputIterator destBeg)
```
- reverse()会将[beg，end）区间内的元素全部反转次序。
- reverse_copy()会将源区间[sourceBeg，sourceEnd）内的元素复制到“以destBeg起始的目标区间”，并在复制过程中颠倒次序。
- reverse_copy()返回目标区间内“最后一个被复制元素”的下一位置，也就是第一个未被覆盖（overwritten）的元素。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- List 提供了一个效果相同的成员函数 reverse()，但它并非重新赋值，而是重新链接pointer，因此具有更佳效能.
- 复杂度：线性，分别进行numElems/2次交换，或numElems次赋值。

下面程序展示了reverse()和reverse_copy()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll: ");

    // reverse order of elements
    reverse(coll.begin(), coll.end());
    PRINT_ELEMENTS(coll, "coll: ");

    // reverse order from second to last element but one
    reverse(coll.begin() + 1, coll.end() - 1);
    PRINT_ELEMENTS(coll, "coll: ");

    // print all of them in reverse order
    reverse_copy(coll.cbegin(), coll.cend(),            // source
                 ostream_iterator<int>(cout, " "));     // destination
    cout << endl;
}
```
程序输出如下:
```bash
coll: 1 2 3 4 5 6 7 8 9
coll: 9 8 7 6 5 4 3 2 1
coll: 9 2 3 4 5 6 7 8 1
1 8 7 6 5 4 3 2 9
```
### 旋转元素（Rotating Elements）
#### 旋转序列内的元素
```cc
ForwardIterator
rotate (ForwardIterator beg,ForwardIterator newBeg,ForwardIterator end)
```
- 将[beg，end）区间内的元素旋转，执行后，*newBeg成为新的第一元素。
- 自 C++11 起，它返回 beg+（end-newbeg），那是原本的第一元素经旋转后的新位置。C++11之前的返回类型是void。
- 调用者必须确保newBeg是 [beg，end）区间内的一个有效位置，否则会引发不确定的行为。
- 复杂度：线性，最多进行numElems次交换。

以下程序示范了如何使用rotate()：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll:          ");

    // rotate one element to the left
    rotate(coll.begin(),        // beginning of range
           coll.begin() + 1,    // new first element
           coll.end());         // end of range
    PRINT_ELEMENTS(coll, "one left:      ");

    // rotate two elements to the right
    rotate(coll.begin(),        // beginning of range
           coll.end() - 2,      // new first element
           coll.end());         // end of range
    PRINT_ELEMENTS(coll, "two right:     ");

    // rotate so that element with value 4 is the beginning
    rotate(coll.begin(),                            // beginning of range
           find(coll.begin(), coll.end(), 4),       // new first element
           coll.end());                             // end of range
    PRINT_ELEMENTS(coll, "4 first:       ");
}
```
正如上例所示，你可以使用起点的正偏移量（positive offset）将元素旋转，也可以使用终点的负偏移量（negative offset）将元素旋转。
不过请注意，只有对random-access iterator才能为它加上偏移量。如果不是这一类iterator，你就得使用 advance().

程序输出如下:
```bash
coll:          1 2 3 4 5 6 7 8 9
one left:      2 3 4 5 6 7 8 9 1
two right:     9 1 2 3 4 5 6 7 8
4 first:       4 5 6 7 8 9 1 2 3
```

#### 复制并同时旋转元素（Rotating Elements While Copying）
```cc
OutputIterator
rotate_copy (ForwardIterator sourceBeg,ForwardIterator newBeg,ForwardIterator sourceEnd,OutputIterator destBeg)
```
- 它是copy()和rotate()的组合。
- 将源区间[sourceBeg，sourceEnd）内的元素复制到“以destBeg起始”之目标区间内，同时旋转元素，使*newBeg成为新的第一元素。
- 返回目标区间内“最后一个被复制元素”的下一位置destBeg+（sourceEnd-sourceBeg）。
- 调用者必须确保newBeg是[beg，end）区间内的一个有效位置，否则会引发不确定行为。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 源区间和目标区间两者不可重叠。
- 复杂度：线性，执行numElems次赋值。

以下程序示范了rotate_copy()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    set<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll);

    // print elements rotated one element to the left
    set<int>::const_iterator pos = next(coll.cbegin());
    rotate_copy(coll.cbegin(),       // beginning of source
                pos,                 // new first element
                coll.cend(),         // end of source
                ostream_iterator<int>(cout, " ")); // destination
    cout << endl;

    // print elements rotated two elements to the right
    pos = coll.cend();
    advance(pos, -2);
    rotate_copy(coll.cbegin(),       // beginning of source
                pos,                 // new first element
                coll.cend(),         // end of source
                ostream_iterator<int>(cout, " ")); // destination
    cout << endl;

    // print elements rotated so that element with value 4 is the beginning
    rotate_copy(coll.cbegin(),       // beginning of source
                coll.find(4),        // new first element
                coll.cend(),         // end of source
                ostream_iterator<int>(cout, " ")); // destination
    cout << endl;
}
```
与先前的rotate()的实例不同，这里用了一个set而不是一个vector。这导致两个后果：
- 1.你必须使用advance()或next()来改变iterator本身的值，因为bidirectional iterator不支持operator+。
- 2.你应当使用find()成员函数，而非find()算法，因为前者有更好的效能。

程序输出
```bash
1 2 3 4 5 6 7 8 9
2 3 4 5 6 7 8 9 1
8 9 1 2 3 4 5 6 7
4 5 6 7 8 9 1 2 3
```

### 排列元素（Permuting Elements）
```cc
bool
next_permutation (BidirectionalIterator beg,BidirectionalIterator end)

bool
next_permutation (BidirectionalIterator beg,BidirectionalIterator end,BinaryPredicate op)

bool
prev_permutation (BidirectionalIterator beg,BidirectionalIterator end)

bool
prev_permutation (BidirectionalIterator beg,BidirectionalIterator end,BinaryPredicate op)
```
- next_permutation() 会改变 [beg，end） 区间内的元素次序，使它们符合“下一排列次序”。
- prev_permutation() 会改变 [beg，end） 区间内的元素次序，使它们符合“上一排列次序”。
- 第一形式使用operator＜比较元素。
- 第二形式使用binary predicate

比较元素，如果“elem1小于elem2”它应该返回true。
- 如果元素得以排列成正规次序（normal order，意指字典顺序），则两个算法都返回false。
  - 所谓正规次序，对next_permutation()而言是升序，对prev_permutation()而言是降序。
  - 因此，如果要遍历所有排列，你必须首先将所有元素（按升序或降序）排序，然后逐次调用next_permutation()或prev_permutation()，直到算法返回true。
- 复杂度：线性，最多执行numElems/2次交换。

下面的例子展示了利用next_permutation()和prev_permutation()获得所有元素的所有可能的排列组合：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 3);
    PRINT_ELEMENTS(coll, "on entry:  ");

    // permute elements until they are sorted
    // - runs through all permutations because the elements are sorted now
    while (next_permutation(coll.begin(), coll.end())) {
        PRINT_ELEMENTS(coll, " ");
    }
    PRINT_ELEMENTS(coll, "afterward: ");

    // permute until descending sorted
    // - this is the next permutation after ascending sorting
    // - so the loop ends immediately
    while (prev_permutation(coll.begin(), coll.end())) {
        PRINT_ELEMENTS(coll, " ");
    }
    PRINT_ELEMENTS(coll, "now:       ");

    // permute elements until they are sorted in descending order
    // - runs through all permutations because the elements are sorted in descending order now
    while (prev_permutation(coll.begin(), coll.end())) {
        PRINT_ELEMENTS(coll, " ");
    }
    PRINT_ELEMENTS(coll, "afterward: ");
}
```
程序输出
```bash
on entry:  1 2 3
 1 3 2
 2 1 3
 2 3 1
 3 1 2
 3 2 1
afterward: 1 2 3
now:       3 2 1
 3 1 2
 2 3 1
 2 1 3
 1 3 2
 1 2 3
afterward: 3 2 1
```
### 对元素重新洗牌（Shuffling Elements）
#### 以随机数重新洗牌（Shuffling Using the Random-Number Library）
```cc
void
shuffle (RandomAccessIterator beg,RandomAccessIterator end,UniformRandomNumberGenerator&&eng)

void
random_shuffle (RandomAccessIterator beg,RandomAccessIterator end)

void
random_shuffle (RandomAccessIterator beg,RandomAccessIterator end,RandomFunc&&op)
```
- 第一形式始自C++11，将[beg，end）区间内的元素打乱次序重新洗牌，使用你所给定的随机数引擎eng。
- 第二形式使用一个均匀分布随机数产生器（uniform distribution random number generator）打乱[beg，end）区间内的元素次序。
- 第三形式使用op打乱[beg，end）区间内的元素次序。算法内部使用一个整数值（其类型为“迭代器所提供之difference_type”）来调用op： `op(elem)` 这个操作应该返回一个“大于0，小于max”的随机数，不包括max自身。
- 对于shuffle()，你不该传入一个只是临时创建出来的引擎。
- 在C++11之前， op被声明为 RandomFunc&，所以你不能够对此传入一个临时对象或一个寻常函数。
- 复杂度：线性，执行numElems-1次交换。

注意，旧式的C全局函数，例如rand()，将其局部状态（local state）存储于static变量中。
但这有些缺点，例如这样的随机数产生器本质上就属于线程不安全（thread unsafe），而且你也不能够拥有两个各自独立的随机数串流（stream of random numbers）。
如果使用function object，把局部状态封装为一或多个成员变量，则是较好的解决方案。这么一来，算法就可以改变被传入的产生器的状态——当后者产生一个新的随机数时。

以下例子示范了如何打乱元素次序。我将调用random_shuffle()但不指定随机数产生器，另一做法是使用shuffle()：
```cc
#include <cstdlib>
#include <algostuff.hpp>
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll:    ");

    // shuffle all elements randomly
    random_shuffle(coll.begin(), coll.end());

    PRINT_ELEMENTS(coll, "shuffled: ");

    // sort them again
    sort(coll.begin(), coll.end());
    PRINT_ELEMENTS(coll, "sorted:   ");

    // shuffle elements with default engine
    default_random_engine dre;
    shuffle(coll.begin(), coll.end(),  // range
            dre);                      // random-number generator

    PRINT_ELEMENTS(coll, "shuffled: ");
}
```
一个可能的（但非必然的）输出如下:
```bash
coll:    1 2 3 4 5 6 7 8 9
shuffled: 8 2 4 9 5 7 3 6 1
sorted:   1 2 3 4 5 6 7 8 9
shuffled: 8 7 5 6 2 4 9 3 1
```

下面的例子示范了如何将自定义的随机数生成器传给 random_shuffle()以对元素重新洗牌：
```cc
#include <cstdlib>
#include <algostuff.hpp>
using namespace std;

class MyRandom {
public:
    ptrdiff_t operator()(ptrdiff_t max) {
        double tmp;
        tmp = static_cast<double>(rand()) 
              / static_cast<double>(RAND_MAX);
        return static_cast<ptrdiff_t>(tmp * max);
    }
};

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll:    ");

    // shuffle elements with self-written random-number generator
    MyRandom rd;
    random_shuffle(coll.begin(), coll.end(),  // range
                   rd);                        // random-number generator

    PRINT_ELEMENTS(coll, "shuffled: ");
}
```
调用random()时用上了一个自定义的随机数产生器rd()，这是根据辅助的function object class MyRandom产生的一个对象，采用的随机数算法通常比直接调用rand()的效能好些。
注意，在C++11之前，你不可以像本例这样传递一个临时对象作为随机数产生器。
```cc
random_shuffle (coll.begin(), coll.end(),
                MyRandom());            // ERROR before C++11
```
一个可能（但非必然）的输出如下:
```bash
coll:    1 2 3 4 5 6 7 8 9
shuffled: 1 8 6 2 4 9 3 7 5
```
### 将元素向前搬（Moving Elements to the Front）
```cc
ForwardIterator
partition (ForwardIterator beg,ForwardIterator end,UnaryPredicate op)

BidirectionalIterator
stable_partition (BidirectionalIterator beg,BidirectionalIterator end,UnaryPredicate op)
```
- 这两个算法将[beg，end）区间内造成以下unary predicate `op(elem)` 结果为true的元素向前端移动（to the front）。
- 这两个算法都返回“令op()结果为false”的第一个元素位置。
- 两者的差别是，无论元素是否满足给定准则，stable_partition()会保持它们之间的相对次序。
- 你可以运用此算法，根据排序准则，将所有元素分割为两部分。nth_element()具有类似能力。至于这些算法和nth_element()之间的区别.
- 注意，op不应在函数调用过程中改变状态（state）.
- 在C++11之前，partition()要求的是bidirectional iterator而不是forward iterator，并保证至多执行numElems/2次交换。
- 可使用partition_copy()将满足某个predicate的元素复制到一个目标区间内，将不满足的元素复制到另一个目标区间（始自C++11）。
- 复杂度：
  - 对于 partition()：线性，共执行op() numElems 次，以及最多numElems/2 次交换。
  - 对于 stable_partition()：如果系统拥有足够内存，那么就是线性复杂度，执行op()及交换共numElems次；如果没有足够内存，则是n-log-n复杂度，执行op()动作numElems×log（numElems）次。

以下程序示范了partition()和stable_partition()的用法以及两者的区别：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll1;
    vector<int> coll2;

    INSERT_ELEMENTS(coll1, 1, 9);
    INSERT_ELEMENTS(coll2, 1, 9);
    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");
    cout << endl;

    // move all even elements to the front
    vector<int>::iterator pos1, pos2;
    pos1 = partition(coll1.begin(), coll1.end(),  // range
                     [](int elem) {                // criterion
                         return elem % 2 == 0;
                     });
    pos2 = stable_partition(coll2.begin(), coll2.end(),  // range
                            [](int elem) {                // criterion
                                return elem % 2 == 0;
                            });

    // print collections and first odd element
    PRINT_ELEMENTS(coll1, "coll1: ");
    cout << "first odd element: " << *pos1 << endl;
    PRINT_ELEMENTS(coll2, "coll2: ");
    cout << "first odd element: " << *pos2 << endl;
}
```
程序输出如下:
```bash
coll1: 1 2 3 4 5 6 7 8 9
coll2: 1 2 3 4 5 6 7 8 9

coll1: 8 2 6 4 5 3 7 1 9
first odd element: 5
coll2: 2 4 6 8 1 3 5 7 9
first odd element: 1
```
正如此例所示，stable_partition()保持了奇数元素和偶数元素的相对次序，这一点和partition()不同。

### 划分为两个子区间（Partition into Two Subranges）
```cc
pair＜OutputIterator1,OutputIterator2＞
partition_copy (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator1 destTrueBeg,OutputIterator2 destFalseBeg,UnaryPredicate op)
```
- 以predicate op()为依据，拆分[beg，end）区间内的所有元素成为两个子区间。
- 所有“造成unary predicate `op(elem)` 产生true”的元素都被复制到始于destTrueBeg的区间内。所有“造成该predicate产生false”的元素都被复制到始于destFalseBeg的区间内。
- 返回一个pair，其内是两个iterator，分别指向destTrueBeg区间和destFalseBeg区间内之最末元素的下一位置。
- 注意，op不应在函数调用过程中改变状态（state）.
- 始自C++11。
- 如果你只是需要“满足（或不满足）predicate”的元素，可使用copy_if()或remove_copy_if().
- 复杂度：线性（至多numElems次调用op()）。

以下程序示范了如何使用partition_copy()：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll = { 1, 6, 33, 7, 22, 4, 11, 33, 2, 7, 0, 42, 5 };
    PRINT_ELEMENTS(coll, "coll: ");

    // destination collections:
    vector<int> evenColl;
    vector<int> oddColl;

    // copy all elements partitioned accordingly into even and odd elements
    partition_copy(coll.cbegin(), coll.cend(),  // source range
                   back_inserter(evenColl),     // destination for even elements
                   back_inserter(oddColl),      // destination for odd elements
                   [](int elem) {               // predicate: check for even elements
                       return elem % 2 == 0;
                   });

    PRINT_ELEMENTS(evenColl, "evenColl: ");
    PRINT_ELEMENTS(oddColl, "oddColl: ");
}
```
程序输出如下:
```bash
coll: 1 6 33 7 22 4 11 33 2 7 0 42 5
evenColl: 6 22 4 2 0 42
oddColl: 1 33 7 11 33 7 5
```

## 排序算法（Sorting Algorithm）
STL提供了好几种算法用来对区间内的元素排序。
除了完全排序（full sorting），还支持数个变体用于局部排序（partial sorting）。
如果后者的功能对你已经足够，应该优先使用它们，因为通常它们的效能更佳。

由于（forward） list和associative及unordered容器不提供random-access iterator，所以你不能使用这些容器作为排序算法的目标区。
但你可以使用associative容器，让元素自动排序。
然而请注意，对全体元素进行一次性排序，通常比“始终维护它们保持排序状态”来得高效一些.

### 对所有元素排序
```cc
void
sort (RandomAccessIterator beg,RandomAccessIterator end)

void
sort (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)

void
stable_sort (RandomAccessIterator beg,RandomAccessIterator end)

void
stable_sort (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)
```
- sort()和 stable_sort()的第一形式使用operator ＜对区间[beg，end）内的所有元素排序。
- sort()和stable_sort()的第二形式使用binary predicate `op(elem)` 作为排序准则，对区间[beg，end）内的所有元素排序。
- 注意，op必须针对元素值定义出strict weak ordering（详见7.7节第314页）。
- 注意，op不应在函数调用过程中改变状态（state）.
- sort()和stable_sort()的区别是，后者保证相等之各元素的相对次序在排序后保持不变。
- 不可以对list或forward list调用这些算法，因为两者都不提供random-access iterator。不过它们提供了成员函数sort()可用来对其自身元素排序.
- sort()保证了很不错的平均效能n-log-n。然而如果你需要极力避免可能出现的最差状况，就该使用partial_sort()或stable_sort()。
- 复杂度：
  - sort()：平均n-log-n（平均大约执行numElems×log（numElems）次比较）。
  - stable_sort()：如果系统拥有足够内存，那么就是n-log-n，也就是执行numElems×log（numElems）次比较；如果没有足够内存，则复杂度是n-log-n×log-n，亦即执行numElems×log（numElems）2次比较。

下面的例子示范了sort()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    INSERT_ELEMENTS(coll, 1, 9);

    PRINT_ELEMENTS(coll, "on entry: ");

    // sort elements
    sort(coll.begin(), coll.end());

    PRINT_ELEMENTS(coll, "sorted:   ");

    // sorted reverse
    sort(coll.begin(), coll.end(),  // range
         greater<int>());           // sorting criterion

    PRINT_ELEMENTS(coll, "sorted >: ");
}
```
程序输出如下:
```bash
on entry: 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9
sorted:   1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
sorted >: 9 9 8 8 7 7 6 6 5 5 4 4 3 3 2 2 1 1
```

以下程序示范了 sort() 和 stable_sort() 两者间的区别。该程序通过排序准则lessLength()将字符串按照字符个数排序：
```cc
#include "algostuff.hpp"
using namespace std;

bool lessLength(const string& s1, const string& s2)
{
    return s1.length() < s2.length();
}

int main()
{
    // fill two collections with the same elements
    vector<string> coll1 = { "1xxx", "2x", "3x", "4x", "5xx", "6xxxx",
                             "7xx", "8xxx", "9xx", "10xxx", "11", "12",
                             "13", "14xx", "15", "16", "17" };
    vector<string> coll2(coll1);

    PRINT_ELEMENTS(coll1, "on entry:\n ");

    // sort (according to the length of the strings)
    sort(coll1.begin(), coll1.end(),      // range
         lessLength);                     // criterion
    stable_sort(coll2.begin(), coll2.end(),  // range
                lessLength);                // criterion

    PRINT_ELEMENTS(coll1, "\nwith sort():\n ");
    PRINT_ELEMENTS(coll2, "\nwith stable_sort():\n ");
}
```
程序输出如下:
```bash
on entry:
 1xxx 2x 3x 4x 5xx 6xxxx 7xx 8xxx 9xx 10xxx 11 12 13 14xx 15 16 17

with sort():
 2x 3x 4x 17 16 15 13 12 11 9xx 7xx 5xx 1xxx 8xxx 14xx 10xxx 6xxxx

with stable_sort():
 2x 3x 4x 11 12 13 15 16 17 5xx 7xx 9xx 1xxx 8xxx 14xx 6xxxx 10xxx
```

只有stable_sort()保持了元素的相对位置（每个字符串前头的阿拉伯数字标识出了原本的元素顺序）。

### 局部排序（Partial Sorting）
```cc
void
partial_sort (RandomAccessIterator beg,RandomAccessIterator sortEnd,RandomAccessIterator end)

void
partial_sort (RandomAccessIterator beg,RandomAccessIterator sortEnd,RandomAccessIterator end,BinaryPredicate op)
```
- 第一形式以operator＜对[beg，end）区间内的元素排序，使[beg，sortEnd）区间内的元素处于已序状态（sorted order）。
- 第二形式使用binary predicate `op(elem)` 作为排序准则，使[beg，sortEnd）区间内的元素处于已序状态（sorted order）。
- 注意，op必须针对元素值定义出strict weak ordering.
- 注意，op不应在函数调用过程中改变状态（state）.
- 和sort()不同的是，partial_sort()并不对全部元素排序：一旦第一个元素至sortEnd之间的所有元素都排妥次序，就立刻停止。
  - 所以，如果你只需要前3个排好序的元素，可使用partial_sort()来节省时间，它不会对剩余的元素进行非必要的排序。
- 如果sortEnd等于end，那么partial_sort()会对整个序列排序。平均而言其效能不及sort()，不过以最差情况而论则优于sort()。
- 复杂度：在线性和n-log-n之间，大约执行numElems×log（numSortedElems）次比较。

以下程序示范了partial_sort()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;

    INSERT_ELEMENTS(coll, 3, 7);
    INSERT_ELEMENTS(coll, 2, 6);
    INSERT_ELEMENTS(coll, 1, 5);
    PRINT_ELEMENTS(coll);

    // sort until the first five elements are sorted
    partial_sort(coll.begin(),       // beginning of the range
                 coll.begin() + 5,   // end of sorted range
                 coll.end());        // end of full range
    PRINT_ELEMENTS(coll);

    // sort inversely until the first five elements are sorted
    partial_sort(coll.begin(),       // beginning of the range
                 coll.begin() + 5,   // end of sorted range
                 coll.end(),         // end of full range
                 greater<int>());    // sorting criterion
    PRINT_ELEMENTS(coll);

    // sort all elements
    partial_sort(coll.begin(),       // beginning of the range
                 coll.end(),         // end of sorted range
                 coll.end());        // end of full range
    PRINT_ELEMENTS(coll);
}
```
程序输出如下:
```bash
3 4 5 6 7 2 3 4 5 6 1 2 3 4 5
1 2 2 3 3 7 6 5 5 6 4 4 3 4 5
7 6 6 5 5 1 2 2 3 3 3 4 4 3 4 5
1 2 2 3 3 3 4 4 4 5 5 5 6 6 7
```

```cc
RandomAccessIterator
partial_sort_copy (InputIterator sourceBeg,InputIterator sourceEnd,RandomAccessIterator destBeg,RandomAccessIterator destEnd)

RandomAccessIterator
partial_sort_copy (InputIterator sourceBeg,InputIterator sourceEnd,RandomAccessIterator destBeg,RandomAccessIterator destEnd,BinaryPredicate op)
```
- 两者都是copy()和partial_sort()的组合。
- 它们将元素从源区间[sourceBeg，sourceEnd）复制到目标区间[destBeg，destEnd）并且进行排序。
- “被排序（被复制）的元素量”是源区间和目标区间两者所含元素量的较小值。
- 两者都返回目标区间内“最后一个被复制元素”的下一位置（也就是第一个未被覆盖的元素）。
- 如果源区间[sourceBeg，sourceEnd）内的元素量小于目标区间[destBeg，destEnd）内的元素量，所有元素都会被排序并复制，整个行为相当于copy()和sort()的组合。
- 注意，op必须针对元素值定义出strict weak ordering.
- 复杂度：在线性和n-log-n之间，大约执行numElems×log（numSortedElems）次比较。

以下程序示范了partial_sort_copy()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll1;
    vector<int> coll6(6);     // initialize with 6 elements
    vector<int> coll30(30);   // initialize with 30 elements

    INSERT_ELEMENTS(coll1, 3, 7);
    INSERT_ELEMENTS(coll1, 2, 6);
    INSERT_ELEMENTS(coll1, 2, 6);
    INSERT_ELEMENTS(coll1, 1, 5);
    PRINT_ELEMENTS(coll1);

    // copy elements of coll1 sorted into coll6
    vector<int>::const_iterator pos6;
    pos6 = partial_sort_copy(coll1.cbegin(), coll1.cend(),
                             coll6.begin(), coll6.end());

    // print all copied elements
    copy(coll6.cbegin(), pos6,
         ostream_iterator<int>(cout, " "));
    cout << endl;

    // copy elements of coll1 sorted into coll30
    vector<int>::const_iterator pos30;
    pos30 = partial_sort_copy(coll1.cbegin(), coll1.cend(),
                              coll30.begin(), coll30.end(),
                              greater<int>());

    // print all copied elements
    copy(coll30.cbegin(), pos30,
         ostream_iterator<int>(cout, " "));
    cout << endl;
}
```
程序输出如下:
```bash
3 4 5 6 7 2 3 4 5 6 1 2 3 4 5
1 2 2 3 3 3 
7 6 6 5 5 5 4 4 4 3 3 3 2 2 1 
```

第一次调用 partial_sort_copy() 时，目标区间内只有 6 个元素，所以该算法只复制了6个元素，返回coll6的终点。
第二次调用partial_sort_copy()时，由于coll30有充足的空间，所以coll1的所有元素都被复制并排序。

### 根据第n个元素排序
```cc
void
nth_element (RandomAccessIterator beg,RandomAccessIterator nth,RandomAccessIterator end)

void
nth_element (RandomAccessIterator beg,RandomAccessIterator nth,RandomAccessIterator end,BinaryPredicate op)
```
- 两种形式都对[beg，end）区间内的元素排序，使第n个位置上的元素就位，也就是说所有在位置n之前的元素都小于等于它，所有在位置n之后的元素都大于等于它。
  - 这样，你就得到了“根据n位置上的元素”分割开来的两个子序列，第一子序列的元素统统小于第二子序列的元素。
  - 如果你只需要n个最大或最小元素，但不要求它们必须处于排序状态（sorted），这个算法就很有用。
- 第一形式使用operator＜作为排序准则。
- 第二形式使用binary predicate `op(elem)` 作为排序准则。
- 注意，op必须针对元素值定义出strict weak ordering.
- 注意，op不应在函数调用过程中改变状态（state）.
- partition（）算法也可以根据某个排序准则将序列中的元素分割成两部分。
- 复杂度：平均为线性。

以下程序示范了nth_element()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;

    INSERT_ELEMENTS(coll, 3, 7);
    INSERT_ELEMENTS(coll, 2, 6);
    INSERT_ELEMENTS(coll, 1, 5);
    PRINT_ELEMENTS(coll);

    // extract the four lowest elements
    nth_element(coll.begin(),      // beginning of range
                coll.begin() + 3,  // element that should be sorted correctly
                coll.end());       // end of range

    // print them
    cout << "the four lowest elements are: ";
    copy(coll.cbegin(), coll.cbegin() + 4,
         ostream_iterator<int>(cout, " "));
    cout << endl;

    // extract the four highest elements
    nth_element(coll.begin(),      // beginning of range
                coll.end() - 4,    // element that should be sorted correctly
                coll.end());       // end of range

    // print them
    cout << "the four highest elements are: ";
    copy(coll.cend() - 4, coll.cend(),
         ostream_iterator<int>(cout, " "));
    cout << endl;

    // extract the four highest elements (second version)
    nth_element(coll.begin(),      // beginning of range
                coll.begin() + 3,  // element that should be sorted correctly
                coll.end(),        // end of range
                greater<int>());   // sorting criterion

    // print them
    cout << "the four highest elements are: ";
    copy(coll.cbegin(), coll.cbegin() + 4,
         ostream_iterator<int>(cout, " "));
    cout << endl;
}
```
程序输出如下:
```bash
3 4 5 6 7 2 3 4 5 6 1 2 3 4 5
the four lowest elements are: 2 1 2 3 
the four highest elements are: 5 6 7 6 
the four highest elements are: 6 7 6 5
```
### Heap算法
就排序而言，heap是一种特别的元素组织方式，应用于heap排序法（heapsort）。
Heap可被视为一个以序列式集合（sequential collection）实现而成的二叉树，具有两大性质：
- 1.第一个元素总是最大。
- 2.总是能够在对数时间（logarithmic time）内增加或移除一个元素。

Heap是实现priority queue（其内元素会自动排序）的一个理想结构，因此heap算法也被priority_queue容器使用。
为了处理heap，STL提供了4个算法：
- 1.make_heap()将某区间内的元素转化为heap。
- 2.push_heap()对heap增加一个元素。
- 3.pop_heap()对heap取出下一元素。
- 4.sort_heap()将heap转化为一个已排序群集（此后它就不再是heap了）。

和以往常见情况一样，你可以传入一个binary predicate作为排序准则。默认的排序准则是operator＜。

#### Heap算法细节
```cc
void
make_heap (RandomAccessIterator beg,RandomAccessIterator end)

void
make_heap (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)
```
- 两种形式都将[beg，end）区间内的元素转化为heap。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem)`
- 只有在多于一个元素的情况下，才有必要使用这些函数处理heap，如果只有单一元素，那么它自动形成一个heap。
- 复杂度：线性，至多执行3× numElems次比较。

```cc
void
push_heap (RandomAccessIterator beg,RandomAccessIterator end)

void
push_heap (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)
```
- 两种形式都将end之前的最后一个元素加入原本就是heap的[beg，end-1）区间内，使整个[beg，end）区间成为一个heap。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem)`
- 调用者必须保证，进入函数时，[beg，end-1）区间内的元素原本便已形成一个heap（在相同的排序准则下），而新元素紧跟其后。
- 复杂度：对数，至多执行log（numElems）次比较。

```cc
void
pop_heap (RandomAccessIterator beg,RandomAccessIterator end)

void
pop_heap (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)
```
- 以上两种形式都将heap [beg，end）内的最高元素（也就是第一个元素）移到最后位置，并将剩余区间[beg，end-1）内的元素组织起来，成为一个新的heap。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem)`
- 调用者必须保证，进入函数时，[beg，end）区间内的元素原本便已形成一个heap（在相同的排序准则下）。
- 复杂度：对数，至多执行2×log（numElems）次比较。

```cc
void
sort_heap (RandomAccessIterator beg,RandomAccessIterator end)

void
sort_heap (RandomAccessIterator beg,RandomAccessIterator end,BinaryPredicate op)
```
- 以上两种形式都可以将heap [beg，end）转换为一个已排序（sorted）序列。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem)`
- 注意，此算法一旦结束，该区间就不再是个heap了。
- 调用者必须保证，进入函数时，区间[beg，end）内的元素原本便已形成一个heap（在相同的排序准则下）。
- 复杂度：n-log-n，最多执行numElems×log（numElems）次比较动作。

#### Heap算法使用实例

以下程序示范了如何使用各种heap算法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 3, 7);
    INSERT_ELEMENTS(coll, 5, 9);
    INSERT_ELEMENTS(coll, 1, 4);

    PRINT_ELEMENTS(coll, "on entry:              ");

    // convert collection into a heap
    make_heap(coll.begin(), coll.end());

    PRINT_ELEMENTS(coll, "after make_heap():     ");

    // pop next element out of the heap
    pop_heap(coll.begin(), coll.end());
    coll.pop_back();

    PRINT_ELEMENTS(coll, "after pop_heap():      ");

    // push new element into the heap
    coll.push_back(17);
    push_heap(coll.begin(), coll.end());

    PRINT_ELEMENTS(coll, "after push_heap():     ");

    // convert heap into a sorted collection
    // - NOTE: after the call it is no longer a heap
    sort_heap(coll.begin(), coll.end());

    PRINT_ELEMENTS(coll, "after sort_heap():     ");
}
```
程序输出如下:
```bash
on entry:              3 4 5 6 7 5 6 7 8 9 1 2 3 4 
after make_heap():     9 8 6 7 7 5 5 3 6 4 1 2 3 4 
after pop_heap():      8 7 6 7 4 5 5 3 6 4 1 2 3 
after push_heap():     17 7 8 7 4 5 5 6 3 6 4 1 2 3 5 
after sort_heap():     1 2 3 3 4 4 5 5 6 6 7 7 8 17
```

调用make_heap()之后，元素被排序为heap：
```bash
9 8 6 7 7 5 5 3 6 4 1 2 3 4 
```
如果把这些元素转换为二叉树（binary tree）结构，你会发现每个节点的值都小于或等于其父节点值。
push_heap()和 pop_heap()虽然会替换元素，但二叉树结构的恒常性质（亦即每个节点不大于其父节点）不变。

                                            9
                                            │
                           ┌────────────────┴───────────────┐
                           ▼                                ▼
                           8                                6
                           │                                │
                 ┌─────────┴────────┐             ┌─────────┴──────────┐
                 ▼                  ▼             ▼                    ▼
                 7                  7             5                    5
                 │                  │             │                    │
           ┌─────┴───┐        ┌─────┴───┐     ┌───┴──┐             ┌───┘
           ▼         ▼        ▼         ▼     ▼      ▼             ▼
           3         6        4         1     2      3             4


## 已排序区间算法（Sorted-Range Algorithm）
“针对已排序区间（sorted-range）执行”的算法，其适用前提是源区间必须在某个排序准则的作用下已排好序。
较之其对应兄弟（适用于未排序区间〔unsorted range〕），它们有明显的效能优势（通常是对数复杂度，而不再是线性复杂度）。
即使你所拥有的并非random-access iterator，也可以使用这些算法——不过这么一来这些算法的复杂度会降为线性，因为你的iterator只能一步一步移动。但其“比较次数”的复杂度仍是对数型。

根据C++standard所言，对“未排序区间”调用这些算法会导致不确定的行为。
然而在大部分实现中，这些算法对于“未排序区间”仍能运转（work），只不过如果你倚仗这个事实，你的程序将不具移植性。

关于此处所给的算法，associative和unordered容器提供了对应的成员函数。如果要查找某个特定的key或value，你应该使用那些成员函数。

### 查找元素（Searching Element）
下列算法在已排序（sorted）区间中查找某个元素。

检查某个元素是否存在
```cc
bool
binary_search (ForwardIterator beg,ForwardIterator end,const T&value)

bool
binary_search (ForwardIterator beg,ForwardIterator end,const T&value,BinaryPredicate op)
```
- 两种形式都用来判断已排序区间[beg，end）中是否包含“和value等值”的元素。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem)`
- 如果想要获得你所查找的元素的位置，应该使用 lower_bound()、upper_bound() 或equal_range()
- 调用者必须确保，进入算法之际，工作区间已排序（在指定的排序准则下）。
- 复杂度：如果搭配random-access iterator将是对数复杂度，否则为线性复杂度（这些算法至多执行log（numElems）+2次比较，但若搭配的不是random-access iterator，遍历元素的操作复杂度是线性，于是整体复杂度就是线性了）。

以下程序示范了binary_search()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll);

    // check existence of element with value 5
    if (binary_search(coll.cbegin(), coll.cend(), 5)) {
        cout << "5 is present" << endl;
    }
    else {
        cout << "5 is not present" << endl;
    }

    // check existence of element with value 42
    if (binary_search(coll.cbegin(), coll.cend(), 42)) {
        cout << "42 is present" << endl;
    }
    else {
        cout << "42 is not present" << endl;
    }
}
```
程序输出如下:
```bash
1 2 3 4 5 6 7 8 9
5 is present
42 is not present
```
#### 检查数个元素是否存在
```cc
bool
includes (InputIterator1 beg,InputIterator1 end,InputIterator2 searchBeg,InputIterator2 searchEnd)

bool 
includes (InputIterator1 beg,InputIterator1 end,InputIterator2 searchBeg,InputIterator2 searchEnd,BinaryPredicate op)
```
- 两种形式都用来判断已排序区间[beg，end）是否包含另一个已排序区间[searchBeg，searchEnd）的全部元素。
  - 也就是说，对于[searchBeg，searchEnd）中的每一个元素，如果[beg，end）必有一个对应的相等元素，那么[searchBeg，searchEnd）肯定是[beg，end）的子集。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem1, elem2)`
- 调用者必须确保在进入算法之际，两区间都已根据同一个排序准则排好序了。
- 复杂度：线性，至多执行2×（numElems+numSearchElems）-1次比较动作。

以下程序示范了includes()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;
    vector<int> search;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll, "coll:    ");

    search.push_back(3);
    search.push_back(4);
    search.push_back(7);
    PRINT_ELEMENTS(search, "search: ");

    // check whether all elements in search are also in coll
    if (includes(coll.cbegin(), coll.cend(),
                 search.cbegin(), search.cend())) {
        cout << "all elements of search are also in coll"
             << endl;
    }
    else {
        cout << "not all elements of search are also in coll"
             << endl;
    }
}
```
程序输出如下:
```bash
coll:    1 2 3 4 5 6 7 8 9 
search: 3 4 7 
all elements of search are also in coll
```

#### 查找第一个或最后一个可能位置
```cc
ForwardIterator
lower_bound (ForwardIterator beg,ForwardIterator end,const T&value)

ForwardIterator
lower_bound (ForwardIterator beg,ForwardIterator end,const T&value,BinaryPredicate op)

ForwardIterator
upper_bound (ForwardIterator beg,ForwardIterator end,const T&value)

ForwardIterator
upper_bound (ForwardIterator beg,ForwardIterator end,const T&value,BinaryPredicate op)
```
- lower_bound() 返回第一个“大于等于 value”的元素位置。这是可插入“元素值为value”且“不破坏区间[beg，end）之已排序性”的第一个位置。
- upper_bound() 返回第一个“大于value”的元素位置。这是可插入“元素值为 value”且“不破坏区间[beg，end）已排序性”的最后一个位置。
- 如果不存在“其值为value”的元素，上述所有算法都返回end。
- op是个可有可无的（可选的）binary predicate，被视为排序准则: `op(elem1, elem2)`
- 调用者必须确保进入算法之际，所有区间都已根据排序准则排好序了。
- 若要同时获得 lower_bound()和 upper_bound()的结果，请使用 equal_range()（稍后介绍）。
- Associative容器提供等效的成员函数，且效能更佳.
- 复杂度：如果搭配random-access iterator将是对数复杂度，否则为线性复杂度（这些算法至多执行log（numElems）+1次比较，但若搭配的不是random-access iterator，遍历元素的操作复杂度是线性，于是整体复杂度就是线性了）。

以下程序示范了lower_bound()和upper_bound()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    INSERT_ELEMENTS(coll, 1, 9);
    coll.sort();
    PRINT_ELEMENTS(coll);

    // print first and last position 5 could get inserted
    auto pos1 = lower_bound(coll.cbegin(), coll.cend(), 5);
    auto pos2 = upper_bound(coll.cbegin(), coll.cend(), 5);

    cout << "5 could get position "
         << distance(coll.cbegin(), pos1) + 1
         << " up to "
         << distance(coll.cbegin(), pos2) + 1
         << " without breaking the sorting" << endl;

    // insert 3 at the first possible position without breaking the sorting
    coll.insert(lower_bound(coll.begin(), coll.end(), 3),
                3);

    // insert 7 at the last possible position without breaking the sorting
    coll.insert(upper_bound(coll.begin(), coll.end(), 7),
                7);

    PRINT_ELEMENTS(coll);
}
```
程序输出如下:
```bash
1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 
5 could get position 9 up to 11 without breaking the sorting
1 1 2 2 3 3 3 4 4 5 5 6 6 7 7 7 8 8 9 9
```
其中的pos1和pos2有着以下类型：
```cc
list<int>::const_iterator
```

#### 查找第一个和最后一个可能位置
```cc
pair＜ForwardIterator,ForwardIterator＞
equal_range (ForwardIterator beg,ForwardIterator end,const T&value)

pair＜ForwardIterator,ForwardIterator＞
equal_range (ForwardIterator beg,ForwardIterator end,const T&value,BinaryPredicate op)
```
- 两种形式都返回“与value相等”的元素所形成的区间。在此区间内插入“其值为value”的元素，并不会破坏[beg，end）区间的已排序性。
- 和下式等效：
```cc
make_pair(lower_bound(...), upper_bound(...))
```
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem1, elem2)`
- 调用者必须确保在进入算法之际，区间已按照排序准则排好序了。
- Associative和unordered容器都提供有等效的成员函数，且效能更佳
- 复杂度：如果搭配random-access iterator将是对数复杂度，否则为线性复杂度（这些算法至多执行2×log（numElems）+1次比较，但若搭配的不是random-access iterator，遍历元素的操作复杂度是线性，于是整体复杂度就是线性了）。

以下程序展示了equal_range()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    INSERT_ELEMENTS(coll, 1, 9);
    coll.sort();
    PRINT_ELEMENTS(coll);

    // print first and last position 5 could get inserted
    pair<list<int>::const_iterator, list<int>::const_iterator> range;
    range = equal_range(coll.cbegin(), coll.cend(), 5);

    cout << "5 could get position "
         << distance(coll.cbegin(), range.first) + 1
         << " up to "
         << distance(coll.cbegin(), range.second) + 1
         << " without breaking the sorting" << endl;
}
```
程序输出如下:
```bash
1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 
5 could get position 9 up to 11 without breaking the sorting
```

### 合并元素（Merging Elements）
本节出现的算法用来将两个区间的元素合并，包括汇总（sum）、并集（union）、交集（intersection）等处理。

两个已排序集合的总和（Sum of Two Sorted Sets）
```cc
OutputIterator
merge (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg)

OutputIterator
merge (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg,BinaryPredicate op)
```
- 两者都是将源区间[source1Beg，source1End）和[source2Beg，source2End）内的元素合并，使得“以destBeg起始之目标区间”内含两个源区间的所有元素。假设你对下面两个序列调用merge()：
```bash
1 2 2 4 6 7 7 9
```
和
```bash
2 2 2 3 6 6 8 9
```
结果将会是：
```bash
1 2 2 2 2 2 3 4 6 6 6 7 7 8 9 9
```
- 目标区间内的所有元素都将处于排序状态下。
- 两者都返回目标区间内“最后一个被复制元素”的下一位置（也就是第一个未被覆盖的元素位置）。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem1, elem2)`
- 源区间不会有任何变化。
- 根据C++standard的说法，调用者应当确保两个源区间一开始都已排序。然而在大部分实现中，上述算法可以将两个未排序的源区间内的元素合并到一个未排序的目标区间中。不过，如果考量移植性，这种情况下你应该改而调用copy（）两次，而不是使用merge（）。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 源区间和目标区间两者不可重叠。
- List和forward list都提供一个特殊成员函数merge()，用来合并两个list
- 如果你要确保“两个源区间中都出现的元素”在目标区间中只出现一次，请使用set_union()
- 如果你只想获得“同时存在于两个源区间内”的元素，请使用set_intersection()
- 复杂度：线性，至多执行numElems1+numElems2-1次比较。

下面的例子展示了merge()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll1;
    set<int> coll2;

    // fill both collections with some sorted elements
    INSERT_ELEMENTS(coll1, 1, 6);
    INSERT_ELEMENTS(coll2, 3, 8);

    PRINT_ELEMENTS(coll1, "coll1: ");
    PRINT_ELEMENTS(coll2, "coll2: ");

    // print merged sequence
    cout << "merged: ";
    merge(coll1.cbegin(), coll1.cend(),
          coll2.cbegin(), coll2.cend(),
          ostream_iterator<int>(cout, " "));
    cout << endl;
}
```
程序输出如下:
```bash
coll1: 1 2 3 4 5 6 
coll2: 3 4 5 6 7 8 
merged: 1 2 3 3 4 4 5 5 6 6 7 8
```

#### 两个已排序集合的并集（Union of Two Sorted Sets）
```cc
outputiterator
set_union (inputiterator source1beg,inputiterator source1end,inputiterator source2beg,inputiterator source2end,outputiterator destbeg)

outputiterator
set_union (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg,BinaryPredicate op)
```
- 两者都是将已排序的源区间[source1Beg，source1End）和[source2Beg，source2End）内的元素合并，得到“以 destBeg 起始”之目标区间，
后者内含的元素要么来自第一源区间，要么来自第二源区间，抑或同时来自两者。
例如，对下面两个已排序数列调用set_union()：
```bash
1 2 2 4 6 7 7 9
```
和
```bash
2 2 2 3 6 6 8 9
```
结果是：
```cc
1 2 2 2 3 4 6 6 7 7 8 9
```
- 目标区间内的所有元素都处于排序状态。
- 同时出现于两个源区间内的元素，在并集区间（union range）中将只出现一次。不过如果原来的某个源区间内原本就存在重复元素，则目标区间内也会有重复元素——重复的次数是两个源区间内的重复次数的较大值。
- 两者都返回目标区间内“最后一个被复制元素”的下一位置（也就是第一个未被覆盖的元素的位置）。
- op是个可有可无的（可选的）binary predicate，被视为排序准则：`op(elem1, elem2)`
- 源区间不会有任何变化。
- 调用者应当确保两个源区间一开始都已根据排序准则排好序。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 源区间和目标区间两者不可重叠。
- 如果你想得到两个源区间内的全部元素，请用merge()
- 复杂度：线性，至多执行2×（numElems1+numElems2）-1次比较。

#### 两个已排序集合的交集（Intersection of Two Sorted Sets）
```cc
OutputIterator
set_intersection (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg)

OutputIterator
set_intersection (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg,BinaryPredicate op)
```
- 两者都是将已排序之源区间[source1Beg，source1End）和[source2Beg，source2End）的元素合并，得到“以destBeg起始”之目标区间，后者内含的元素不但存在于第一源区间，也存在于第二源区间。
例如，对下面两个已排序数列调用set_intersection()：
```bash
1 2 2 4 6 7 7 9
```
和
```bash
2 2 2 3 6 6 8 9
```
结果是：
```bash
2 2 6 9
```
- 目标区间内的所有元素都处于排序状态。
- 如果某个源区间内原就存在有重复元素，则目标区间内也会有重复元素——重复的次数是两个源区间内的重复次数的较小值。
- 两者都返回目标区间内“最后一个被合并元素”的下一位置。
- op是个可有可无的（可选的）binary predicate，被视为排序准则：`op(elem1, elem2)`
- 源区间不会有任何变化。
- 调用者应当确保两个源区间一开始都已根据排序准则排好序。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 源区间和目标区间两者不可重叠。
- 复杂度：线性，至多执行2×（numElems1+numElems2）-1次比较。

#### 两个已排序集合的差集（Difference of Two Sorted Sets）
```cc
OutputIterator
set_difference (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg)

OutputIterator
set_difference (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg,BinaryPredicate op)
```
- 两者都是将已排序之源区间[source1Beg，source1End）和[source2Beg，source2End）的元素合并，得到“以destBeg起始”之目标区间，后者内含的元素只存在于第一源区间，不存在于第二源区间。
例如，对下面两个已排序数列调用set_difference()：
```bash
1 2 2 4 6 7 7 9
```
和
```bash
2 2 2 3 6 6 8 9
```
结果是：
```bash
1 4 7 7
```
- 目标区间内的所有元素都处于排序状态。
- 如果某个源区间内原就存在有重复元素，则目标区间内也会有重复元素——重复的次数是第一源区间内的重复次数减去第二源区间内的相应重复次数，
  - 如果第二源区间内的重复次数大于第一源区间内的相应重复次数，目标区间内的对应重复次数将会是0。
- 两者都返回目标区间内“最后一个被合并元素”的下一位置。
- op是个可有可无的（可选的）binary predicate，被视为排序准则：`op(elem1, elem2)`
- 源区间不会有任何变化。
- 调用者应当确保两个源区间一开始都已根据排序准则排好序。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。· 源区间和目标区间两者不可重叠。
- 复杂度：线性，至多执行2×（numElems1+numElems2）-1次比较。

```cc
OutputIterator
set_symmetric_difference (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg)

OutputIterator
set_symmetric_difference (InputIterator source1Beg,InputIterator source1End,InputIterator source2Beg,InputIterator source2End,OutputIterator destBeg,BinaryPredicate op)
```
- 两者都是将已排序之源区间[source1Beg，source1End）和[source2Beg，source2End）的元素合并，得到“以destBeg起始”之目标区间，
  - 后者内含的元素或存在于第一源区间，或存在于第二源区间，但不同时存在于两个源区间内。
  - 例如，对下面两个已排序数列调用set_symmetric_difference()：
```bash
1 2 2 4 6 7 7 9
```
和
```bash
2 2 2 3 6 6 8 9
```
结果是：
```bash
1 2 3 4 6 7 7 8
```
- 目标区间内的所有元素都处于排序状态。
- 如果某个源区间内原就存在有重复元素，则目标区间内也会有重复元素——重复的次数是两个源区间内的对应重复元素的个数差值。
- 两者都返回目标区间内“最后一个被合并元素”的下一位置。
- op是个可有可无的（可选的）binary predicate，被视为排序准则： `op(elem1, elem2)`
- 源区间不会有任何变化。
- 调用者应当确保两个源区间一开始都已根据排序准则排好序。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- 源区间和目标区间两者不可重叠。
- 复杂度：线性，至多执行2×（numElems1+numElems2）-1次比较。

#### “合并算法”的综合范例

下面这个例子对“应用于已排序数列”之各个合并算法做了比较，展示其用法和区别：
```cc
// algo/sorted1.cpp
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> c1 = { 1, 2, 2, 4, 6, 7, 7, 9 };
    deque<int> c2 = { 2, 2, 2, 3, 6, 6, 8, 9 };

    // print source ranges
    cout << "c1:                         ";
    copy(c1.cbegin(), c1.cend(),
         ostream_iterator<int>(cout, " "));
    cout << endl;
    cout << "c2:                         ";
    copy(c2.cbegin(), c2.cend(),
         ostream_iterator<int>(cout, " "));
    cout << '\n' << endl;

    // sum the ranges by using merge()
    cout << "merge():                    ";
    merge(c1.cbegin(), c1.cend(),
          c2.cbegin(), c2.cend(),
          ostream_iterator<int>(cout, " "));
    cout << endl;

    // unite the ranges by using set_union()
    cout << "set_union():                ";
    set_union(c1.cbegin(), c1.cend(),
              c2.cbegin(), c2.cend(),
              ostream_iterator<int>(cout, " "));
    cout << endl;

    // intersect the ranges by using set_intersection()
    cout << "set_intersection():         ";
    set_intersection(c1.cbegin(), c1.cend(),
                     c2.cbegin(), c2.cend(),
                     ostream_iterator<int>(cout, " "));
    cout << endl;

    // determine elements of first range without elements of second range
    // by using set_difference()
    cout << "set_difference():           ";
    set_difference(c1.cbegin(), c1.cend(),
                   c2.cbegin(), c2.cend(),
                   ostream_iterator<int>(cout, " "));
    cout << endl;

    // determine difference the ranges with set_symmetric_difference()
    cout << "set_symmetric_difference(): ";
    set_symmetric_difference(c1.cbegin(), c1.cend(),
                             c2.cbegin(), c2.cend(),
                             ostream_iterator<int>(cout, " "));
    cout << endl;
}
```
程序输出如下:
```bash
c1:                         1 2 2 4 6 7 7 9 
c2:                         2 2 2 3 6 6 8 9 

merge():                    1 2 2 2 2 2 3 4 6 6 6 7 7 8 9 9 
set_union():                1 2 2 2 3 4 6 6 7 7 8 9 
set_intersection():         2 2 6 9 
set_difference():           1 4 7 7 
set_symmetric_difference(): 1 3 4 6 7 7 8 
```
#### 合并连贯之已排序区间（Merging Consecutive Sorted Ranges）
```cc
void
inplace_merge (BidirectionalIterator beg1,BidirectionalIterator end1beg2,BidirectionalIterator end2)

void
inplace_merge (BidirectionalIterator beg1,BidirectionalIterator end1beg2,BidirectionalIterator end2,BinaryPredicate op)
```
- 两者都是将已排序源区间[beg1，end1beg2）和[end1beg2，end2）的元素合并，使区间[beg1，end2）成为两者之总和（且形成已排序状态）。
- 复杂度：若有足够内存则为线性，执行 numElems-1 次比较，否则为 n-log-n，执行numElems×log（numElems）次比较。

以下程序示范了inplace_merge()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    // insert two sorted sequences
    INSERT_ELEMENTS(coll, 1, 7);
    INSERT_ELEMENTS(coll, 1, 8);
    PRINT_ELEMENTS(coll);

    // find beginning of second part (element after 7)
    list<int>::iterator pos;
    pos = find(coll.begin(), coll.end(),  // range
               7);                        // value
    ++pos;

    // merge into one sorted range
    inplace_merge(coll.begin(), pos, coll.end());

    PRINT_ELEMENTS(coll);
}
```
程序输出如下:
```bash
1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 
1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 
```

## 数值算法（Numeric Algorithm）
本节描述用于数值处理的STL算法。当然你也可以用它们来处理非数值元素。
例如你可以用accumulate()求数个字符串的总和。运用数值算法之前，必须先包含头文件＜numeric＞：

### 运算后产生结果
对数列进行某种运算
```cc
T accumulate (InputIterator beg,InputIterator end,T initValue)
T accumulate (InputIterator beg,InputIterator end,T initValue,BinaryFunc op)
```
- 第一形式计算initValue和区间[beg，end）内每个元素的总和，更具体地说，它针对每一个元素调用以下运算：`initValue = initValue + elem`
- 第二形式计算initValue和区间[beg，end）内每一个元素进行op运算的结果，更具体地说，它针对每一个元素调用以下表达式： `initValue = op(initValue, elem)`
- 因此，对于以下数列：`a1 a2 a3 a4 ...`上述两个算法分别计算`initValue = a1 + a2 + a3 + a4 ...`和`initValue op a1 op a2 op a3 op a4 ...`
- 如果数列为空（beg==end），两者都返回initValue。
- op不可以改动其所接获的实参。
- 复杂度：线性，上述两式分别调用operator+或op()各numElems次。

下面的例子展示了如何使用accumulate()得到区间内所有元素的总和，以及乘积：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 9);
    PRINT_ELEMENTS(coll);

    // process sum of elements
    cout << "sum: "
         << accumulate(coll.cbegin(), coll.cend(),  // range
                       0)                            // initial value
         << endl;

    // process sum of elements less 100
    cout << "sum: "
         << accumulate(coll.cbegin(), coll.cend(),  // range
                       -100)                         // initial value
         << endl;

    // process product of elements
    cout << "product: "
         << accumulate(coll.cbegin(), coll.cend(),  // range
                       1,                            // initial value
                       multiplies<int>())            // operation
         << endl;

    // process product of elements (use 0 as initial value)
    cout << "product: "
         << accumulate(coll.cbegin(), coll.cend(),  // range
                       0,                            // initial value
                       multiplies<int>())            // operation
         << endl;
}
```
程序输出
```bash
1 2 3 4 5 6 7 8 9 
sum: 45 
sum: -55 
product: 362880 
product: 0 
```
最后一项输出是0，因为任何数乘以0都得0。

### 计算两数列的内积（Inner Product）
```cc
T
inner_product (InputIterator1 beg1,InputIterator1 end1,InputIterator2 beg2,T initValue)

T
inner_product (InputIterator1 beg1,InputIterator1 end1,InputIterator2 beg2,T initValue,BinaryFunc op1,BinaryFunc op2)
```
- 第一形式计算并返回[beg，end）区间和“以beg2为起始的区间”的对应元素组的内积，并为每次的内积值加上initValue。具体地说，也就是针对“两区间内的每一组对应元素”调用以下表达式：
`initValue = initValue + elem1 * elem2`
- 第二形式将[beg，end）区间和“以beg2为起始的区间”内的对应元素组进行op2运算，然后再和initValue进行op1运算，并将结果返回。具体地说，也就是针对“两区间内的每一组对应元素”调用以下表达式：
`initValue = op1(initValue, op2(elem1, elem2))`
- 所以，对于数列：
`a1 a2 a3 ..`
`b1 b2 b3 ..`
上述算法分别计算并返回：
`initValue + (a1 * b1) + (a2 * b2) + (a3 * b3) + ..`
和
`initValue op1 (a1 op2 b1) op1 (a2 op2 b2) op1 (a3 op2 b3) ..`
- 如果第一区间为空（beg1==end1），则两者都返回initValue。
- 调用者必须确保“以beg2为起始的区间”内含足够的元素空间。
- op1和op2都不可以改动其所接获的实参。
- 复杂度：线性，调用operators+和operators*各numElems次，或是调用op1()和op2()各numElems次。

以下程序示范了inner_product()的用法。它计算两个数列的“对应元素组的乘积”总和（sum of product）以及“对应元素组的和”的乘积（product of sum）：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    list<int> coll;

    INSERT_ELEMENTS(coll, 1, 6);
    PRINT_ELEMENTS(coll);

    // process sum of all products
    // (0 + 1*1 + 2*2 + 3*3 + 4*4 + 5*5 + 6*6)
    cout << "inner product: "
         << inner_product(coll.cbegin(), coll.cend(),  // first range
                           coll.cbegin(),               // second range
                           0)                           // initial value
         << endl;

    // process sum of 1*6 ... 6*1
    // (0 + 1*6 + 2*5 + 3*4 + 4*3 + 5*2 + 6*1)
    cout << "inner reverse product: "
         << inner_product(coll.cbegin(), coll.cend(),  // first range
                           coll.crbegin(),              // second range
                           0)                           // initial value
         << endl;

    // process product of all sums
    // (1 * 1+1 * 2+2 * 3+3 * 4+4 * 5+5 * 6+6)
    cout << "product of sums: "
         << inner_product(coll.cbegin(), coll.cend(),  // first range
                           coll.cbegin(),               // second range
                           1,                           // initial value
                           multiplies<int>(),           // outer operation
                           plus<int>())                 // inner operation
         << endl;
}
```
程序输出如下:
```bash
1 2 3 4 5 6 
inner product: 91 
inner reverse product: 56 
product of sums: 46080
```

### 相对数列和绝对数列之间的转换
下面两个算法可以在相对数列（a sequence of relative values）和绝对数列（a sequence of absolute values）之间相互转换。

#### 将相对值转换成绝对值（Converting Relative Values into Absolute Values）
```cc
OutputIterator
partial_sum (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg)

OutputIterator
partial_sum (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,BinaryFunc op)
```
- 第一形式计算源区间[sourceBeg，sourceEnd）中每个元素的部分和（partial sum），然后将结果写入以destBeg为起点的目标区间。
- 第二形式将源区间[sourceBeg，sourceEnd）中的每个元素和其先前所有元素进行op运算，并将结果写入以destBeg为起点的目标区间。
- 因此，对于以下数列：
`a1 a2 a3 ..`
它们分别计算：
`a1, a1 + a2, a1 + a2 + a3, ..`
和
`a1, a1 op a2, a1 op a2 op a3, ..`
- 两种形式都返回目标区间内“最后一个被写入的值”的下一位置（也就是第一个未被覆盖的元素的位置）。
- 第一形式相当于把一个相对数列转换为一个绝对数列。就此而言，partial_sum()正好和adjacent_difference()互补。
- 源区间和目标区间可以完全相同。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- op不应改动传入的实参。
- 复杂度：线性，分别调用operator+或op() numElems次。

以下程序示范了partial_sum()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll;

    INSERT_ELEMENTS(coll, 1, 6);
    PRINT_ELEMENTS(coll);

    // print all partial sums
    partial_sum(coll.cbegin(), coll.cend(),  // source range
                ostream_iterator<int>(cout, " "));  // destination
    cout << endl;

    // print all partial products
    partial_sum(coll.cbegin(), coll.cend(),  // source range
                ostream_iterator<int>(cout, " "),  // destination
                multiplies<int>());  // operation
    cout << endl;
}
```
程序输出如下:
```bash
1 2 3 4 5 6 
1 3 6 10 15 21 
1 2 6 24 120 720
```

#### 将绝对值转换成相对值（Converting Absolute Values into Relative Values）
```cc
OutputIterator
adjacent_difference (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg)

OutputIterator
adjacent_difference (InputIterator sourceBeg,InputIterator sourceEnd,OutputIterator destBeg,BinaryFunc op)
```
- 第一形式计算[sourceBeg，sourceEnd）区间内每个元素和其紧临的前一元素的差额，并将结果写入以destBeg为起点的目标区间。
- 第二形式针对[sourceBeg，sourceEnd）区间内的每个元素和其紧临的前一元素调用op操作，并将结果写入以destBeg为起点的目标区间。
- 第一个元素只是被很单纯地复制。
- 因此，对于以下数列：
`a1 a2 a3 ..`
它们分别计算：
`a1, a2 - a1, a3 - a2, a4 - a3, ..`
和
`a1, a2 op a1, a3 op a2, a4 op a3, ..`
- 两个形式都返回目标区间内“最后一个被写入值”的下一位置（也就是第一个未被覆盖的元素的位置）。
- 第一形式相当于把一个绝对数列转换为一个相对数列。就此而言，adjacent_difference ()正好与partial_sum()互补。
- 源区间和目标区间可以完全相同。
- 调用者必须确保目标区间有足够空间，要不就得使用insert iterator。
- op不应改动传入的实参。
- 复杂度：线性，分别调用operator-或op()共numElems-1次。

以下程序示范了adjacent_difference()的用法：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    deque<int> coll;

    INSERT_ELEMENTS(coll, 1, 6);
    PRINT_ELEMENTS(coll);

    // print all differences between elements
    adjacent_difference(coll.cbegin(), coll.cend(),  // source
                        ostream_iterator<int>(cout, " "));  // destination
    cout << endl;

    // print all sums with the predecessors
    adjacent_difference(coll.cbegin(), coll.cend(),  // source
                        ostream_iterator<int>(cout, " "),  // destination
                        plus<int>());  // operation
    cout << endl;

    // print all products between elements
    adjacent_difference(coll.cbegin(), coll.cend(),  // source
                        ostream_iterator<int>(cout, " "),  // destination
                        multiplies<int>());  // operation
    cout << endl;
}
```
程序输出如下:
```bash
1 2 3 4 5 6 
1 1 1 1 1 1 
1 3 5 7 9 11 
1 2 6 12 20 30 
```
#### 相对值（Relative Value）转为绝对值（Absolute Value），实例解说
下面的例子展示了如何运用partial_sum()和adjacent_difference()将一个相对数列转化为一个绝对数列，以及如何反向转化：
```cc
#include "algostuff.hpp"
using namespace std;

int main()
{
    vector<int> coll = { 17, -3, 22, 13, 13, -9 };
    PRINT_ELEMENTS(coll, "coll:    ");

    // convert into relative values
    adjacent_difference(coll.cbegin(), coll.cend(),  // source
                        coll.begin());               // destination
    PRINT_ELEMENTS(coll, "relative: ");

    // convert into absolute values
    partial_sum(coll.cbegin(), coll.cend(),  // source
                coll.begin());               // destination
    PRINT_ELEMENTS(coll, "absolute: ");
}
```
程序输出如下:
```bash
coll:    17 -3 22 13 13 -9 
relative: 17 -20 25 -9 0 -22 
absolute: 17 -3 22 13 13 -9
```

# 特殊容器
C++标准库不只是包含了STL framework 所提供的容器，还包含一些为满足特殊需求而设计的容器，它们提供简单而清晰（几乎足以自我说明）的接口。
这些容器可被归类为container adapter（容器适配器），它们配接（改造）标准STL容器，使之满足特殊需求。
另外还有所谓的bitset，用来包含bit或Boolean值。

有三种标准的container adapter：stacks、queues和priority queues。
Priority queue就是“根据排序准则，自动将元素排序”的queue，其所谓“下一个”元素总是拥有最大值（最高优先级）。

所谓bitset是一个位域（bitfield），其内可含任意数量的bit，但一旦确定大小就固定不再变动。
你可以想象它是一个bit容器或Boolean容器。
注意，C++标准库同时也为Boolean值提供了一个长度可变的特殊容器：`vector<bool>`.

## C++11带来的变化
C++98几乎已经确立所有container adapter性质。下面是C++11加入的若干最重要性质：
- Container adapter如今提供了 reference和 const_reference两个类型定义.
- Container adapter如今支持move语义和rvalue reference：
  - push（）如今提供了move语义.
  - 作为初始值的那个容器，其元素可被搬移过来.
- Container adapter提供emplace（）能力，其内部会创建一个“以其所获得的实参为初值”的新元素.
- Container adapter如今提供了swap（）.
- Constructor adapter如今允许你传递一个allocator给其构造函数.

## Stack（堆栈）
Class stack<>实现出一个stack（也称为LIFO，后进先出）。
你可以使用push()将任意数量的元素放入stack，也可以使用pop()将元素依其插入的相反次序从容器中移除（此即所谓“后进先出〔LIFO〕”）。
在头文件＜stack＞中，class stack定义如下：
```cc
namespace std {
    template <typename T,
              typename Container = deque<T>>
              class stack;
}
```
第一个template参数代表元素类型。带有默认值的第二个template参数用来定义stack内部存放元素的实际容器，默认为 deque。
之所以选择deque而非vector，是因为 deque移除元素时会释放内存，并且不必在重分配（reallocation）时复制全部元素.

例如，以下定义了一个元素类型为整数的stack
```cc
stack<int> st;
```
Stack的实现中只是很单纯地把各项操作转化为内部容器的对应调用。
你可以使用任何sequence容器支持stack，只要它们提供以下成员函数：back()、push_back()和pop_back()。
例如你可以使用vector或list来容纳元素：
```cc
stack<int, vector<int>> st;
```
### 核心接口
Stack的核心接口由三个成员函数提供：push()、top()和pop()。
- push()将一个元素放入stack内。
- top()返回stack内的“下一个”元素。
- pop()从stack中移除元素。

pop()移除下一个元素，但是并不返回它；
top()返回下一个元素，但是并不移除它。
所以，如果你想移除stack的下一个元素同时返回它，那么这两个函数都得调用。
这样的接口可能有点麻烦，但如果你只是想移除下一个元素而并不想处理它，这样的安排就比较好。

注意，如果stack内没有元素，调用top()和pop()会导致不明确的行为。
你可以采用成员函数size()和empty()来检验容器是否为空。

如果你不喜欢 stack<> 的标准接口，轻易便可写出若干更方便的接口。

### Stack运用实例
下面的程序展示了stack<>的用法：
```cc
#include <iostream>
#include <stack>
using namespace std;

int main()
{
    stack<int> st;

    // push three elements into the stack
    st.push(1);
    st.push(2);
    st.push(3);

    // pop and print two elements from the stack
    cout << st.top() << ' ';
    st.pop();
    cout << st.top() << ' ';
    st.pop();

    // modify top element
    st.top() = 77;

    // push two new elements
    st.push(4);
    st.push(5);

    // pop one element without processing it
    st.pop();

    // pop and print remaining elements
    while (!st.empty()) {
        cout << st.top() << ' ';
        st.pop();
    }
    cout << endl;
}
```
程序输出如下:
```bash
3 2 4 77
```
注意，当使用nontrivial（译注：意指不凡的、复杂的）元素类型时，你可以考虑在安插“不再被使用的元素”时采用std::move()，或是采用emplace()，由stack内部创建元素（二者都始自C++11）：
```cc
stack<pair<string, string>> st;
auto p = make_pair("hello", "world");
st.push(move(p));
st.emplace("nico", "jaa");
```

### 一个用户自定义的Stack Class
标准的stack<> class将运作速度置于方便性和安全性之上。但我通常并不很重视这些，所以我自己写了一个stack class，拥有以下优势：
- 1.pop()会返回下一元素。
- 2.如果stack为空，pop()和top()会抛出异常（throw exception）。

此外，我把一般人不常使用的成员函数如比较动作（comparison）略去。我的stack class定义如下：
```cc
/********************************************************************
 * Stack.hpp
 * - safer and more convenient stack class
 ********************************************************************/
#ifndef STACK_HPP
#define STACK_HPP

#include <deque>
#include <exception>

template <typename T>
class Stack {
protected:
    std::deque<T> c;  // container for the elements

public:
    // exception class for pop() and top() with empty stack
    class ReadEmptyStack : public std::exception {
    public:
        virtual const char* what() const throw() {
            return "read empty stack";
        }
    };

    // number of elements
    typename std::deque<T>::size_type size() const {
        return c.size();
    }

    // is stack empty?
    bool empty() const {
        return c.empty();
    }

    // push element into the stack
    void push(const T& elem) {
        c.push_back(elem);
    }

    // pop element out of the stack and return its value
    T pop() {
        if (c.empty()) {
            throw ReadEmptyStack();
        }
        T elem(c.back());
        c.pop_back();
        return elem;
    }

    // return value of next element
    T& top() {
        if (c.empty()) {
            throw ReadEmptyStack();
        }
        return c.back();
    }
};

#endif /* STACK_HPP */
```
测试代码
```cc
// contadapt/stack2.cpp
#include <iostream>
#include <exception>
#include "Stack.hpp"  // use special stack class
using namespace std;

int main()
{
    try {
        Stack<int> st;

        // push three elements into the stack
        st.push(1);
        st.push(2);
        st.push(3);

        // pop and print two elements from the stack
        cout << st.pop() << ' ';
        cout << st.pop() << ' ';

        // modify top element
        st.top() = 77;

        // push two new elements
        st.push(4);
        st.push(5);

        // pop one element without processing it
        st.pop();

        // pop and print three elements
        // - ERROR: one element too many
        cout << st.pop() << ' ';
        cout << st.pop() << endl;
        cout << st.pop() << endl;
    }
    catch (const exception& e) {
        cerr << "EXCEPTION: " << e.what() << endl;
    }
}
```
最后一个（多出来的） pop () 调用是为了刻意引发错误。和标准stack class不同的是，我这个版本会抛出异常，而不是引发不明确行为。程序输出如下:
```bash
3 2 4 77
EXCEPTION: read empty stack
```

### 细究Class stack<>
Class stack<>的接口或多或少直接映射了容器内部所用的相应成员。例如：
```cc
namespace std {
    template <typename T, typename Container = deque<T>>
    class stack {
    public:
        typedef typename Container::value_type      value_type;
        typedef typename Container::reference       reference;
        typedef typename Container::const_reference const_reference;
        typedef typename Container::size_type       size_type;
        typedef Container                           container_type;

    protected:
        Container c;  // container

    public:
        bool empty() const { 
            return c.empty(); 
        }

        size_type size() const { 
            return c.size(); 
        }

        void push(const value_type& x) { 
            c.push_back(x); 
        }

        void push(value_type&& x) { 
            c.push_back(move(x)); 
        }

        void pop() { 
            c.pop_back(); 
        }

        value_type& top() { 
            return c.back(); 
        }

        const value_type& top() const { 
            return c.back(); 
        }

        template <typename... Args>
        void emplace(Args&&... args) { 
            c.emplace_back(forward<Args>(args)...); 
        }

        void swap(stack& s) { 
            swap(c, s.c); 
        }
    };
}
```

## Queue（队列）
Class queue<>实现出一个queue（也称为FIFO〔先进先出〕）。
你可以使用push()将任意数量的元素放入queue中，也可以使用pop()将元素依其插入次序从容器中移除（此即所谓“先进先出〔FIFO〕”）。
换句话说，queue是一个典型的数据缓冲构造。

在头文件＜queue＞中，class queue定义如下：
```cc
namespace {
    template <typename T,
            typename Container = deque<T>>
            class queue;
}
```
第一个template参数代表元素类型。带有默认值的第二个template参数定义queue内部用来存放元素的实际容器，默认采用deque。
例如下面的例子定义出了一个内含string的queue：
```cc
queue<string> q;
```
实际上queue只是很单纯地把各项操作转化为内部容器的对应调用。
你可以使用任何sequence容器支持queue，只要它们支持front()、back()、push_back()和pop_front()等操作。
例如你可以使用list来容纳元素：
```cc
queue<string, list<string>> q;
```
### 核心接口
Queue的核心接口主要由成员函数push()、front()、back()和pop()构成：
- push()将一个元素放入queue内。
- front()返回queue内的下一个元素（也就是第一个被放入的元素）。
- back()返回queue内的最后一个元素（也就是第一个被插入的元素）。
- pop()从queue中移除一个元素。

注意，pop()虽然移除下一个元素，但是并不返回它，
front()和 back()返回下一个元素，但并不移除它。
所以，如果你想移除queue的下一个元素，又想处理它，那就得同时调用front()和pop()。
这样的接口可能有点麻烦，但如果你只是想移除下一个元素而并不想处理它，这样的安排就比较好。

注意，如果queue内没有元素，则front()、back()和pop()的执行会导致不确定的行为。
你可以采用成员函数size()和empty()来检验容器是否为空。

如果你不喜欢queue<.的标准接口，轻易便可写出更方便的接口。

### Queue运用实例
下面的程序展示了queue<>的用法：
```cc
#include <iostream>
#include <queue>
#include <string>
using namespace std;

int main()
{
    queue<string> q;

    // insert three elements into the queue
    q.push("These ");
    q.push("are ");
    q.push("more than ");

    // read and print two elements from the queue
    cout << q.front();
    q.pop();
    cout << q.front();
    q.pop();

    // insert two new elements
    q.push("four ");
    q.push("words!");

    // skip one element
    q.pop();

    // read and print two elements
    cout << q.front();
    q.pop();
    cout << q.front() << endl;
    q.pop();

    // print number of elements in the queue
    cout << "number of elements in the queue: " << q.size()
         << endl;
}
```
程序输出如下:
```bash
These are four words!
number of elements in the queue: 0
```

### 一个用户自定义的Queue Class
标准的queue<> class将运作速度置于方便性和安全性之上。
但不是所有程序员都喜欢这样。你可以轻松提供你自己完成的一个queue class，就像先前自己完成一个stack class一样.

### 细究Class queue＜＞
queue<>的接口或多或少直接映射了容器内部所用的相应成员

## Priority Queue（带优先级的队列）
Class priority_queue<> 实现出一个 queue，其中的元素依优先级被读取。
它的接口和queue非常相近，亦即 push()将会放入一个元素，top()/pop()将会访问/移除下一元素。
然而这里所谓“下一元素”并非第一个放入的元素，而是“优先级最高”的元素。
换句话说，priority queue内的元素已经根据其值进行了排序。
和往常一样，你可以通过template参数指定一个排序准则。
默认的排序准则是以operator＜形成降序排列，那么所谓“下一元素”就是“数值最大的元素”。
如果同时存在若干个数值最大的元素，我们无法确知究竟哪一个会入选。

                                          ▲
                                          │ top()
                  ┌───────────────────────┴┐
        push() ──►│                        │──► pop()
                  └────────────────────────┘

在头文件＜queue＞中，class priority_queue定义如下：
```cc
namespace {
    template <typename T,
            typename Container = vector<T>,
            typename Compare = less<typename Container::value_type>>
            class priority_queue;
}
```
第一个template参数是元素类型，带有默认值的第二个template参数定义了priority queue内部用来存放元素的容器。默认容器是vector。
带有默认值的第三个template参数定义出“用以查找下一个最高优先级元素”的排序准则，默认以operator＜作为比较标准。
例如，以下定义了一个元素类型为int的priority queue：
```cc
priority_queue<int> p;
```
实际上priority queue只是很单纯地把各项操作转化为内部容器的对应调用。
你可以使用任何sequence 容器支持priority queue，只要它们支持random-access iterator 和 front()、push_back()、pop_back()等操作就行。
由于priority queue需要用到STL heap算法，所以其内部容器必须支持random access。
例如你可以使用deque来容纳元素：
```cc
priority_queue<int, deque<int>> p;
```
如果要定义自己的排序准则，就必须传递一个函数（或function object）作为 binary pre-dicate，用以比较两个元素并以此作为排序准则。
例如，以下式子定义了一个反向排序（降序）的priority queue：
```cc
priority_queue<int, vector<int>, greater<int>> p;
```
在此priority queue中，“下一个元素”始终是元素值最小者。

12.3.1 核心接口
Priority queue的核心接口主要由成员函数push()、top()和pop()组成：
- push()将一个元素放入priority queue中。
- top()返回priority queue内的“下一个元素”。
- pop()从priority queue内移除一个元素。

和其他container adapter一样，pop()会移除下一元素，但是不返回它；
top()会返回下一元素，但并不移除它。
所以，如果你想移除priority queue内的下一元素，又想处理它，就得同时调用上述两个函数。

注意，如果priority queue内没有元素，执行top()和pop()会导致不确定的行为。
你可以调用成员函数size()和empty()检验容器是否为空。

### Priority Queue运用实例
以下程序示范了class priority_queue<>的用法：
```cc
#include <iostream>
#include <queue>
using namespace std;

int main()
{
    priority_queue<float> q;

    // insert three elements into the priority queue
    q.push(66.6);
    q.push(22.2);
    q.push(44.4);

    // read and print two elements
    cout << q.top() << ' ';
    q.pop();
    cout << q.top() << endl;
    q.pop();

    // insert three more elements
    q.push(11.1);
    q.push(55.5);
    q.push(33.3);

    // skip one element
    q.pop();

    // pop and print remaining elements
    while (!q.empty()) {
        cout << q.top() << ' ';
        q.pop();
    }
    cout << endl;
}
```
程序输出如下:
```bash
66.6 44.4 
33.3 22.2 11.1
```
由上可见，元素 66.6、22.2、44.4 被放入后，程序打印出优先级最高的元素 66.6 和44.4。
另三个元素被放入后，priority queue内含 22.2、11.1、55.5、33.3 （按插入次序）。
下一个元素被pop()忽略掉了，所以最后一个循环依次打印33.3、22.2和11.1。

### 细究Class priority_queue<>
```cc
namespace std {
    template <typename T, 
              typename Container = vector<T>, 
              typename Compare = less<typename Container::value_type>>
    class priority_queue {
    protected:
        Compare comp;  // sorting criterion
        Container c;   // container

    public:
        // constructors
        explicit priority_queue(const Compare& cmp = Compare(),
                                const Container& cont = Container())
            : comp(cmp), c(cont) {
            make_heap(c.begin(), c.end(), comp);
        }

        void push(const value_type& x) {
            c.push_back(x);
            push_heap(c.begin(), c.end(), comp);
        }

        void pop() {
            pop_heap(c.begin(), c.end(), comp);
            c.pop_back();
        }

        bool empty() const { 
            return c.empty(); 
        }

        size_type size() const { 
            return c.size(); 
        }

        const value_type& top() const { 
            return c.front(); 
        }
    };
}
```

注意，和前述两个container adapter不同的是，这里没有比较（comparison）操作符。

## 细究Container Adapter
以下各小节详细描述container adapter stack<>、queue<>和priority_queue<>的成员和操作。

### 类型定义
contadapt::value_type
- 元素的类型。
- 和container::value_type相当。

contadapt::reference
- “用以指向元素”之reference的类型。
- 和container::reference相当。
- 始自C++11。

contadapt::const_reference
- “用以指向只读元素（read-only element）”之reference的类型。
- 和container::const_reference相当。
- 始自C++11。

contadapt::size_type
- 不带正负号的整数类型，用来表现大小。
- 和container::size_type相当。

contadapt::container_type
- 内部容器的类型。

### 构造函数（Constructor）
contadapt::contadapt() 
- Default构造函数。
- 创建一个空的stack或（priority） queue。

explicit contadapt::contadapt (const Container& cont)
explicit contadapt::contadapt (Container&& cont)
- 创建一个stack 或queue，以容器cont 的元素为初值，后者必须是container adapter 的container_type之下的一个对象。
- 第一形式中，cont内的所有元素均被复制。
- 第二形式中，cont内的所有元素均被搬移（moved）——前提是被传入之容器提供有move语义，否则元素仍然是被复制。
- 两种形式都不存在于priority_queue＜＞中。

自C++11开始，所有构造函数都允许你传入一个allocator作为新增实参，用来初始化内部容器的allocator。

#### Priority Queue额外提供的构造函数
explicit priority_queue::priority_queue (const CompFunc& op)
- 创建一个空的priority queue，以op为排序准则。
- 如何将排序准则当作实参传入.

priority_queue::priority_queue (const CompFunc& op const Container& cont)
- 创建一个priority queue，以op为排序准则，以容器cont内的元素为初值。
- cont的所有元素都被复制过来。

priority_queue::priority_queue (InputIterator beg,InputIterator end)
- 创建一个priority queue，以[beg，end）区间内的元素为初值。
- 这是一个template member，所以只要源区间内的元素类型可以转化为本容器内的元素类型，此构造函数即可运作。

priority_queue::priority_queue (InputIterator beg,InputIterator end,const CompFunc& op)
- 创建一个priority queue，以op为排序准则，并以[beg，end）区间内的元素为初值。
- 这是一个template member，所以只要源区间内的元素类型可以转化为本容器内的元素类型，此构造函数即可运作。
- 如何将排序准则当作实参传入.

priority_queue::priority_queue (InputIterator beg,InputIterator end,const CompFunc& op,const Container& cont)
- 创建一个priority queue，以op为排序准则，以[beg，end）区间内的元素加上cont容器内的元素为初值。
- 这是一个template member，所以只要源区间内的元素类型可以转化为本容器内的元素类型，此构造函数即可运作。

自C++11开始，所有构造函数都允许你传入一个allocator作为新增实参，用来初始化内部容器的allocator。

### 各项操作（Operation）
bool contadapt::empty () const
- 判断container adpater是否为空（不含任何元素）。
- 与contadapt::size（）==0等效，但速度可能更快。

size_type contadapt::size () const
- 返回当前的元素个数。
- 若要检验容器是否为空（不含任何元素），应使用empty（），因为后者有可能更快。

void contadapt::push (const value_type& elem)
void contadapt::push (value_type&& elem)
- 第一形式安插elem的一份拷贝（副本）。
- 第二形式始自C++11，elem将被搬移（如果元素类型提供move语义的话），否则elem将被复制。

void contadapt::emplace (args)
- 安插一个新元素，它将被args初始化。
- 始自C++11。

reference contadapt::top ()
const_reference contadapt::top () const
reference contadapt::front ()
const_reference contadapt::front () const
- 上述任何形式，只要container adapter提供了它们，都会返回下一元素。
  - Stack提供两个形式的top（），返回最后一个安插元素。
  - Queue提供两个形式的front（），返回第一个安插元素。
  - Priority queue只提供第二形式的 top（），获得的是带有最大值的元素。如果候选多于1，究竟返回哪个元素并不明确。
- 调用者必须确保container adapter不为空（size（）＞0），否则可能导致不明确的行为。
- 上述形式中“返回non-const reference”者允许你改动下一元素（当它还在stack/queue内）。这样做合宜与否，由你自己决定。
- 在C++11之前，返回类型是const value_type&，通常那是相同的。

void contadapt::pop ()
- 移除container adapter内的下一个元素。
  - 对stack而言，所谓“下一元素”是指“最后一个被安插元素”。
  - 对queue而言，所谓“下一元素”是指“第一个被安插元素”。
  - 对priority queue而言，所谓“下一元素”是指“带有最大值的元素”。如果候选多于1，究竟移除哪个元素并不明确。
- 此函数无返回值。如果想处理被移除的那个元素，你必须先调用top（）才能取得它。
- 调用者必须确保stack不为空（size（）＞0），否则可能导致不明确的行为。

reference queue::back ()
const_reference queue::back () const
- 两种形式都返回queue的最终元素。所谓“最终元素”是指最后一个被插入的元素。
- 调用者必须确保queue不为空（size（）＞0），否则可能导致不明确的行为。
- 第一形式是针对non-const queue而设计，返回一个reference。所以你可以改动最终元素（当它还在queue内）。
- 第一形式是针对non-const queue而设计，返回一个reference。所以你可以改动最终元素（当它还在queue内）。这样做合宜与否，由你自己决定。
- 在C++11之前，返回类型是（const） value_type&，通常那是相同的。
- 只有queue＜＞提供。

bool comparison (const contadapt& stack1,const contadapt& stack2)
- 返回两个相同类型的stack或queue的比较结果。
- comparison可以是下面任何运算：
`operater== !=  < > <= >=`
- 如果两个stack（或两个queue）的元素个数相等，且相同次序上的元素值也相等（也就是所有对应元素之间的比较都得到true），则这两个容器相等。
- Stack或queue之间的大小比较是以“字典顺序”来决定.
- priority_queue＜＞不提供这个操作。

void contadapt::swap (contadapt& c)
void swap (contadapt& c1, contadapt& c2)
- 交换*this和c的内容，或交换c1和c2的内容。对于priority queue，还交换排序准则。
- 调用相应容器之swap（）.
- 始于C++11。

## Bitset
Bitset造出了一个内含bit或Boolean值且大小固定的array。
当你需要管理各式flag，并以flag的任意组合来表现变量时，就可运用bitset。
C程序和传统C++程序通常使用类型long来作为bit array，再借由&、|、～等位操作符（bit operator）操作各个bit。
Class bitset的优点在于可容纳任意个数（译注：但不能动态改变个数）之bit，并提供各项操作。
例如你可以对某个特定位置赋予一个bit，也可以将bitset作为由0和1组成的数列，进行读/写。

注意，不可以改变bitset的bit个数。这个数量的具体值是由template实参决定的。
如果你需要一个可变长度的bit容器，可考虑使用`vector<bool>`.

其中的class bitset是个template class，有一个template参数，用来指定可容纳的bit数量：
```cc
namespace std {
    template <size_t Bits>
    class bitset;
}
```
在这里，template 参数并不是一个类型，而是一个不带正负号的整数.

注意，如果template实参不同，实例化所得的template类型就不同。
换句话说，你只能针对bit个数相同的bitset进行比较和组合。

## C++11带来的改变
C++98已经指出几乎所有的bitset特性。下面是C++11添加的一些最重要的特性：
- Bitset如今可被string字面常量初始化。
- “转换至”和“转换自”数值如今支持unsigned long long类型。为了这一支持于是引入了to_ullong().
- “转换至”和“转换自” string如今允许你指定某字符代表set bit而某字符代表unset bit。
- 如今提供了成员all()，用以检验是否所有bit都被设立。
- 为了能够被运用在unordered容器内，bitset提供了一个默认的hash函数.

## Bitset运用实例
### 将Bitset当作一组标志

第一个例子展示了如何运用bitset来管理一组flag。
每个flag都有一个由枚举类型（enum）定义出来的值。
该枚举值就表示bit在bitset中的位置。
举个例子，用这些bit代表颜色，于是每个枚举值都代表一个颜色。
借由运用bitset，你可以管理一个变量，其中包含颜色的任意组合：
```cc
#include <bitset>
#include <iostream>
using namespace std;

int main()
{
    // enumeration type for the bits
    // - each bit represents a color
    enum Color { red, yellow, green, blue, white, black, ...,
                 numColors };

    // create bitset for all bits/colors
    bitset<numColors> usedColors;

    // set bits for two colors
    usedColors.set(red);
    usedColors.set(blue);

    // print some bitset data
    cout << "bitfield of used colors:   " << usedColors << endl;
    cout << "number  of used colors:   " << usedColors.count() << endl;
    cout << "bitfield of unused colors: " << ~usedColors << endl;

    // if any color is used
    if (usedColors.any()) {
        // loop over all colors
        for (int c = 0; c < numColors; ++c) {
            // if the actual color is used
            if (usedColors[(Color)c]) {
                ...
            }
        }
    }
}
```
### 以Bitset表述二进制
Bitset的一个强有力的特色就是可以在整数值和bit序列之间相互转化，只需创建一个临时的bitset就可以办到：
```cc
#include <bitset>
#include <iostream>
#include <string>
#include <limits>
using namespace std;

int main()
{
    // print some numbers in binary representation
    cout << "267 as binary short:    "
         << bitset<numeric_limits<unsigned short>::digits>(267)
         << endl;

    cout << "267 as binary long:     "
         << bitset<numeric_limits<unsigned long>::digits>(267)
         << endl;

    cout << "10,000,000 with 24 bits: "
         << bitset<24>(1e7) << endl;

    // write binary representation into string
    string s = bitset<42>(12345678).to_string();
    cout << "12,345,678 with 42 bits: " << s << endl;

    // transform binary representation into integral number
    cout << "\"1000101011\" as number:  "
         << bitset<100>("1000101011").to_ullong() << endl;
}
```

本例中，以下表达式将数值267转换为一个bitset，且其bit个数符合类型unsigned short :
```cc
bitset<numeric_limits<unsigned short>::digits>(267)
```
特别为 bitset而设计的output操作符（operator<<）能够将bit打印成一系列的0和1字符。
你可以直接输出bitset，也可以把它们的值转为一个string：
```cc
    string s = bitset<42>(12345678).to_string();
```
类似情况，以下式子将一系列二进制字符（a sequence of binary characters）转为一个bitset，而后调用其成员函数to_ullong()转化为一个整数值：
```cc
         bitset<100>("1000101011")
```
注意，bitset 内的bit 个数应小于 sizeof（unsigned long long）。万一你的bitset 无法以unsigned long long表现，会抛出异常。

# 字符串
本章讲述C++标准库中的string（字符串）类型，描述的是基础的template class basic_string<>及其标准特化版string、wstring、u16string和u32string。

本章之中我对术语string的定义是：根据C++标准库中“某个string类型（string、wstring、u16string或u32string）”创建出来的object。
至于寻常由char*或const char*类型所构成的string，我采用的术语是C-string。

## C++11带来的最新改变
C++98已经规范出string class的几乎所有特性。下面是C++11增补的几个最重要的特性：
- String如今提供了 front()和 back()，用来访问第一元素和最末元素，还提供shrink_to_fit()用来缩小容量.
- String如今提供了方便的函数用来将string转换为数值，以及反向转换.
- data() 和 c_str() 不会再造成“指向 string”的 reference、iterator 和 pointer 无效.
- String如今支持move语义以及初值列（initializer list）。
- 除了 string和 wstring之外，basic_string<>的特化版本 u16string和 u32string如今也预定义好了.
- String如今可以间接要求提供一个end-of-string字符（对string而言是'\0'），因为对于一个string s，`s[s.length（）]`应该总是合法且s.data（）返回的字符包含一个末尾的end-of-string字符.
- 不再提供string class的reference-counted实现版本.

## String Class的目的
C++标准库中的string class使你得以将string当作一般类型而不会令用户感觉任何问题。
你可以像对待基础类型那样针对string复制、赋值和比较，再也不必担心内存是否足够、占用的内存实际长度等问题，只需运用操作符，例如以=进行赋值，以==进行比较，以+进行串连。
简而言之，C++标准库对string的设计思维就是，让它的行为尽可能像基础类型，不至于在操作上引起什么麻烦（至少原则如此）。
现今世界的数据处理大部分就是string的处理，所以对于从C、Fortran或类似语言一路走来的程序员而言，这是非常重要的进步，因为string在那些语言中往往是烦恼之源。

### 例一：提炼临时文件名
第一个例子通过命令行（command line）实参产生一个临时文件名。如果你如下启动这个程序：
```bash
string1 prog.dat mydir hello. oops.tmp end.dat
```

输出如下：
```bash
prog.dat => prog.tmp
mydir => mydir.tmp
hello. => hello.tmp
oops.tmp => oops.xxx
end.dat => end.tmp
```
通常产生的扩展名是.tmp，但如果原本的扩展名就是.tmp，则换成.xxx。
```cc
#include <iostream>
#include <string>
using namespace std;
int main (int argc, char* argv[])
{
    string filename, basename, extname, tmpname;
    const string suffix("tmp");

    // for each command-line argument (which is an ordinary C-string)
    for (int i=1; i<argc; ++i) {
        // process argument as filename
        filename = argv[i];

        // search period in filename
        string::size_type idx = filename.find('.');
        if (idx == string::npos) {
            // filename does not contain any period
            tmpname = filename + '.' + suffix;
        }
        else {
            // split filename into base name and extension
            // - base name contains all characters before the period
            // - extension contains all characters after the period
            basename = filename.substr(0, idx);
            extname = filename.substr(idx+1);
            if (extname.empty()) {
                // contains period but no extension: append tmp
                tmpname = filename;
                tmpname += suffix;
            }
            else if (extname == suffix) {
                // replace extension tmp with xxx
                tmpname = filename;
                tmpname.replace (idx+1, extname.size(), "xxx");
            }
            else {
                // replace any extension with tmp
                tmpname = filename;
                tmpname.replace (idx+1, string::npos, suffix);
            }
        }

        // print filename and temporary name
        cout << filename << " => " << tmpname << endl;
    }
}
```

### 例二：提炼单词并反向打印
第二个例子从标准输入设备取得一个个英文单词，然后将其内各个字符逆序打印。单词和单词之间以一般空白字符（换行符newline、空格字符space或制表符tab）或逗号、句号、分号分隔开来。
```cc
#include <iostream>
#include <string>
using namespace std;

int main (int argc, char** argv)
{
    const string delims(" \t.,;");
    string line;

    // for every line read successfully
    while (getline(cin, line)) {
        string::size_type begIdx, endIdx;

        // search beginning of the first word
        begIdx = line.find_first_not_of(delims);

        // while beginning of a word found
        while (begIdx != string::npos) {
            // search end of the actual word
            endIdx = line.find_first_of(delims, begIdx);
            if (endIdx == string::npos) {
                // end of word is end of line
                endIdx = line.length();
            }

            // print characters in reverse order
            for (int i = endIdx - 1; i >= static_cast<int>(begIdx); --i) {
                cout << line[i];
            }
            cout << ' ';

            // search beginning of the next word
            begIdx = line.find_first_not_of(delims, endIdx);
        }
        cout << endl;
    }
}
```
## String Class细节描述
在 ＜string＞之中，class basic_string<>被定义为所有string类型的基础模板类（basic template class）
```cc
namespace std {
    template <typename charT,
    typename trait = char_traits<charT>,
    typename Allocator = allocator<charT>>
    class basic_string;
}
```
这个class将字符类型、字符类型的trait、内存模型（memory model）都参数化了：
- 第一参数是单个字符所属类型（也许是ASCII字符或Unicode字符）。
- 带默认值的第二参数是个trait class，提供string class 的所有“字符内核操作”。这个trait class规定如何复制字符或比较字符，
  - 如果你没有指明它，string就会根据现有之字符类型采用默认的trait class。用户可以自定义的trait class，让字符串以“不分大小写”方式进行各种操作。
- 带默认值的第三参数定义了 string class 所采取的内存模型，一如寻常，默认使用allocator.

### 具体的String类型

C++标准库提供了若干basic_string<>特化版本：

- string是针对char而预定义的特化版本：
```cc
namespace std {
    typedef basic_string<char> string;
}
```
- 对于使用宽字符（例如Unicode或某些亚洲字符集）的string，存在三个预定义的特化版本（其中u16string和u32string始自C++11）：
```cc
namespace std {
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
```
以下几节的讨论适合于上述所有string class。
由于所有string class采用相同接口，所以用法和问题都一样。
我将以string代表任何string type，包括string、wstring、u16string和u32string。
由于一般软件开发大多顺应欧美环境，所以本书的例子大多采用string类型。

String的各项操作:
以下是提取并转换为 Markdown 格式的表格：

| 操作（Operation）              | 效果（Effect）                                                                 |
| ----------------------------- | ----------------------------------------------------------------------------- |
| 构造函数（constructor）         | 创建或复制一个 string                                                          |
| 析构函数（destructor）          | 销毁一个 string                                                                |
| =, assign()                    | 赋予新值（assign a new value）                                                  |
| swap()                         | 交换两个 string 的内容                                                         |
| +=, append(), push_back()      | 添加字符                                                                       |
| insert()                       | 插入字符                                                                       |
| erase(), pop_back()            | 删除字符。pop_back() 始自 C++11                                                 |
| clear()                        | 移除全部字符（使之为空）                                                         |
| resize()                       | 改变字符数量（在尾端删除或添加字符）                                             |
| replace()                      | 替换字符                                                                       |
| +                             | 串接 string                                                                    |
| ==, !=, <, <=, >, >=, compare()| 比较 string                                                                    |
| empty()                        | 判断字符串是否为空                                                              |
| size(), length()               | 返回字符数量                                                                   |
| max_size()                     | 返回字符的最大可能个数                                                          |
| capacity()                     | 返回重分配前的字符容量                                                          |
| reserve()                      | 保留一定量内存以容纳一定数量的字符                                               |
| shrink_to_fit()                | 缩减内存存储符合当前的字符量（始自 C++11）                                       |
| [], at()                       | 访问某个单一字符                                                               |
| front(), back()                | 访问第一或最末字符（始自 C++11）                                                |
| >>, getline()                  | 从一个 stream 读取某值                                                         |
| <<                            | 将某值写入 stream                                                              |
| stoi(), stol(), stoll()        | 将 string 转为带正负号的整数（始自 C++11）                                       |
| stoul(), stoull()              | 将 string 转为不带正负号的整数（始自 C++11）                                     |
| stof(), stod(), stold()        | 将 string 转为浮点数（始自 C++11）                                              |
| to_string(), to_wstring()      | 将整数/浮点数转为 string（始自 C++11）                                          |
| copy()                         | 将 string 复制为一个字符 array——亦即 C-string                                   |
| data(), c_str()                | 将 string 内容以 C-string 形式返回                                              |
| substr()                       | 返回某个子字符串（substring）                                                   |
| find functions                 | 查找某个子字符串（substring）或字符                                             |
| begin(), end()                 | 提供正常的（normal）iterator 支持                                              |
| cbegin(), cend()               | 提供 const iterator 支持（始自 C++11）                                          |
| rbegin(), rend()               | 提供 reverse iterator 支持                                                     |
| crbegin(), crend()             | 提供 const reverse iterator 支持（始自 C++11）                                  |
| get_allocator()                | 返回分配器（allocator）                                                        |

### 操作函数概览
#### String操作的实参
STL提供了很多字符串操作函数，其中许多往往具有数个重载版本，分别以一、二或三个实参来指定新值。

表13.2 String操作的实参体制
| 实参（Argument）                             | 含义                                                                 |
| ------------------------------------------- | ------------------------------------------------------------------ |
| `const string& str`                         | 整个 `string str`                                                   |
| `const string& str, size_type idx, size_type num` | 通常是指 `string str` 中从 `idx` 开始的 `num` 个字符                       |
| `const char* cstr`                          | 整个 C-string `cstr`                                                |
| `const char* chars, size_type len`          | 字符数组 `chars` 中的 `len` 个字符                                      |
| `char c`                                    | 字符 `c`                                                            |
| `size_type num, char c`                     | `num` 个字符 `c`                                                    |
| `const_iterator beg, const_iterator end`    | 区间 `[beg,end)` 内的所有字符                                          |
| `initlist`                                  | `initlist` 内的所有字符（始自 C++11）                                   |

注意，只有单实参的const char*版本才将字符'\0'视为string的结尾特殊符号，其他所有情况下'\0'都不被视为特殊字符：
```cc
// initializes s1 with: 'n' 'i' 'c' 'o'
std::string s1("nico");
// initializes s2 with: 'n' 'i' 'c' 'o' '\0' 
std::string s2("nico", 5);
// initializes s3 with: '\0' '\0' '\0' '\0' '\0' 
std::string s3(5, '\0');

// yields 4
s1.length();
// yields 5
s2.length();
// yields 5
s3.length();
```
因此，一般而言，string可以内含任何字符，甚至可以包含二进制文件（binary file）的内容。

把一个null pointer传入作为cstr，会导致不明确的行为。

哪一个操作函数使用哪一种实参，所有操作符都只能把对象当作单一值来处理，
因此，如果要赋值、比较或附加“string（或C-string）的一部分”，就必须采用相应的函数。

拥有String参数之各项操作:
| 操作                             | Full String | Part of String | C-string (char*) | char Array | Single char | num chars | Iterator Range | Init list |
| -------------------------------- | ----------- | -------------- | ---------------- | ---------- | ----------- | --------- | -------------- | --------- |
| 构造函数                         | Yes         | Yes            | Yes              | Yes        | —           | Yes       | Yes            | Yes       |
| `=`                              | Yes         | —              | Yes              | —          | Yes         | —         | —              | Yes       |
| `assign()`                       | Yes         | Yes            | Yes              | Yes        | —           | Yes       | Yes            | Yes       |
| `+=`                             | Yes         | —              | Yes              | —          | Yes         | —         | —              | Yes       |
| `append()`                       | Yes         | Yes            | Yes              | Yes        | —           | Yes       | Yes            | Yes       |
| `push_back()`                    | —           | —              | —                | —          | Yes         | —         | —              | —         |
| `insert()` for idx               | Yes         | Yes            | Yes              | Yes        | —           | Yes       | —              | —         |
| `insert()` for iter.             | —           | —              | —                | —          | Yes         | Yes       | Yes            | Yes       |
| `replace()` for idx              | Yes         | Yes            | Yes              | Yes        | Yes         | Yes       | —              | —         |
| `replace()` for iter.            | Yes         | —              | Yes              | Yes        | —           | Yes       | Yes            | Yes       |
| `find`（查找）函数               | Yes         | —              | Yes              | Yes        | Yes         | —         | —              | —         |
| `+`                              | Yes         | —              | Yes              | —          | Yes         | —         | —              | —         |
| `==, !=, <, <=, >, >=`           | Yes         | —              | Yes              | —          | —           | —         | —              | —         |
| `compare()`                      | Yes         | Yes            | Yes              | Yes        | —           | —         | —              | —         | 

#### 未提供的操作函数
C++标准库的string class并未解决所有可能遇到的string问题。
事实上它并没有提供下列问题的直接解决方案：正则表达式（regular expression）和文本处理（text processing）。

### 构造函数和析构函数（Constructor and Destructor）
表列出了string的所有构造函数和析构函数。
| 表达式                            | 效果                                                                 |
| ------------------------------- | ------------------------------------------------------------------ |
| `string s`                      | 生成一个空的 `string s`                                                |
| `string s(str)`                 | Copy 构造函数，创建一个 `string str` 的拷贝                                 |
| `string s(ruStr)`               | Move 构造函数，创建一个 `string` 并将 `ruStr` 的内容搬移过去给它（此后 `ruStr` 将处于有效状态但其值不确定） |
| `string s(str,stridx)`          | 将 `string str` 内“始于位置 `stridx`”的部分当作字符串 `s` 的初值                     |
| `string s(str,stridx,strlen)`   | 将 `string str` 内“始于位置 `stridx` 且长度顶多 `strlen`”的部分当作字符串 `s` 的初值       |
| `string s(cstr)`                | 以 C-string `cstr` 作为字符串 `s` 的初值                                   |
| `string s(chars,charslen)`      | 以字符数组（character array）`chars` 的前 `charslen` 个字符作为字符串 `s` 的初值          |
| `string s(num,c)`               | 生成一个字符串，包含 `num` 个 `c` 字符                                       |
| `string s(beg,end)`             | 以 `[beg,end)` 区间内的字符作为字符串 `s` 的初值                              |
| `string s(initlist)`            | 以 `initlist` 内的字符作为字符串 `s` 的初值（始自 C++11）                       |
| `s.~string()`                   | 销毁所有字符，释放内存                                                      |

注意，你不能以单一字符初始化某字符串，但是可以这么做：
```cc
string s('x'); // err
string s(1, 'x'); // err
string s({'x'}); // ok
```
这表示存在一个从 const char*到 string 的自动类型转换，但不存在一个从 char 到string的自动类型转换。

### String和C-String
C++standard将string literal（字符串字面常量）的类型由char*改为 const char*。
为了提供向后兼容性，C++standard规定了一个颇有争议的隐式转换，可从const char*隐式转为char*。
由于string literal的类型并非string，因此在新的string object和传统的C-string之间必须存在一个强关系：
在“string与string-like object”的共通操作中（例如比较、附加、插入等动作）都应该可以使用C-string。
或者具体地说，存在一个从 const char*到string的隐式类型转换。
然而现实却不存在一个从string object到C-string的自动类型转换，这是出于安全考虑，防止意外类型转换导致奇异行为（char*经常有奇异行为）和模棱两可
（例如在一个结合了string和C-string的表达式中，如果既可把string转化为 char*也可反其道而行，就会导致模棱两可，也就是所谓歧义）。
有好几种办法可以创建或涂写/复制C-string。
更具体地说，c_str（）可以得到“string对应的C-string”，所得结果和“以'\0'为结尾”的字符数组一样。
运用copy（），你也可以将string内容复制或写入既有的C-string或字符数组内。

请注意，'\0'在string之中并不具有特殊意义，但在一般C-string中却用来标识结束。
在string中，字符'\0'和其他字符的地位完全相同。

还要注意，千万不要以旧式的null pointer（NULL）取代nullptr或取代char*参数，这会导致奇异的行为，
因为 NULL具有整数类型，如果某个操作被重载（overloaded），接受“单一整数类型”，那么 NULL会被解释为数字 0或“其值为 0”的字符。

有三个函数可以将string内容转换为字符数组或C-String：
- 1. data()和c_str()以字符数组的形式返回string内容。该数组在位置`[size()]`上有一个end-of-string字符，所以其结果是一个内含'\0'字符的有效C-string。
- 2. copy()将string内容复制到“调用者提供的字符数组”中，其末尾不添加'\0'字符。注意，data()和c_str()返回的字符数组由该string拥有。也就是说，调用者绝不可以改动它或释放其内存。例如：
```cc
string s("1111");  // 
atoi(s.c_str());   // 将string转换为int
f(s.data(), s.length()); // 调用函数，参数1为 char[] , 参数2为数组长度

char buff[100];    
s.copy(buff, 100);    // 最多拷贝100字符到buff
s.copy(buff, 100, 2); //  
```
一般而言，整个程序中你应该坚持使用string，直到你必须将其内容转化为 char*时才把它们转换为C-string。
注意c_str()和data()的返回值的有效期限在下次调用non-const成员函数时即告终止。
```cc
string s;
...
foo(s.c_str()); // ok
p = s.c_str();
foo(p);  // ok: p有效
s += "ext";
foo(p);  // err: p无效
```
### 大小和容量（Size and Capacity）
为了高效无误地运用string，你应该理解string的大小和容量之间的关系。
一个string存在三种“大小”：
- 1. size()和length()返回string的现有字符数。两个函数等效。
  - 成员函数empty()用来检验字符数是否为0，亦即字符串是否为空。你应该优先使用该函数，因为它比length()或size()更快。
- 2. max_size()返回“string最多能够包含的字符数”。String通常包含“单独一个内存区块内的所有字符”，所以可能与PC本身的限制有关系。
  - 返回值一般而言是索引类型之最大值减1。之所以“减1”有两个原因：
    - （a）最大值本身是npos；
    - （b）具体实现中可因此轻易在内部缓冲区之末尾添加一个'\0'，以便将这个string当作C-string使用（例如通过c_str（））。
  - 一旦某个操作函数使用一个长度大于max_size()的string，length_error异常就会被抛出。
- 3. capacity()重新分配内存之前，string所能包含的最大字符数。

让string拥有足够的容量是很重要的，原因有二：
- 1.重新分配会造成所有指向string的reference、pointer和iterator失效。
- 2.重新分配（reallocation）很耗时间。

因此，如果程序要用到指向string（或其内部字符）的reference、pointer和iterator，抑或需要很快的执行速度，就必须考虑容量（capacity）问题。

成员函数reserve()就用来避免重分配行为，它使你得以预留一定容量，并确保该容量用尽之前reference一直保持有效：
```cc
string s;
s.reserve(80);
```
容量概念应用于string和应用于vector是相同的；
但有一个显著差异：
对string你可以调用reserve()缩减实际容量，而vector的reserve()却没有这项功能。
拿一个“小于现有容量”的实参来调用reserve()，实际上就是一种非强制性缩减请求，如果实参“小于现有字符数”，则被视为“非强制性合身缩减”的请求。
也就是说，你可能想要缩减容量至某个目标，但不保证可以如愿。
String reserve()的实参默认值为 0，所以调用reserve()且不给实参就是一种“非强制性合身缩减”：
```cc
s.reserve(); // 会考虑缩减容量到合适大小
```
自C++11起提供了shrink_to_fit()，实现了相同效果：
```cc
s.shrink_to_fit(); // 会考虑缩减容量到合适大小
```
为什么缩减动作是非强制性的呢？
因为“如何获得最佳效能”由实现决定。具体实现string时，不同的实现对于速度和内存耗用量之间的取舍可能有不同的思路。

因此，任何实现都可以拿出较大的魄力增加容量，并且永不缩减。

C++standard规定，唯有在回应reserve()或shrink_to_fit()调用时，容量才有可能缩减。
因此，即使发生“字符被删除或被改变”的事情，任何其他字符只要位于“被操作字符”之前，那些“指向它们自身”的reference、pointer和iterator就仍然有效。

### 元素访问（Element Access）
String允许我们对其所包含的字符进行读/写。
有两种方法可以访问单一字符：subscript（下标）操作符[]和成员函数at()。
自C++11开始，front()和back()也被提供，分别用来访问第一字符和最末字符。

所有这些函数都返回某指定索引之对应位置上的字符。
一如以往，第一个字符的索引为 0，最末字符的索引为 length()-1。但是请注意以下区别：
- Operator []并不检查索引是否有效，at()则会检查。如果调用 at()时指定的索引无效，系统会抛出out_of_range异常。
  - 如果调用operator []时指定的索引无效，其行为不明确——可能访问非法内存，因而引起某些讨厌的边缘效应甚至崩溃（崩溃还算运气好，因为你好歹知道出错了）。
- 一般而言，最末字符的更后面位置也是有效的。
  - 因此，“当前实际字符数”可被当成一个有效的索引。此情况下operator []返回的是“由字符类型之default构造函数所产生”的字符，就类型为string的对象来说返回值是char'\0'。
- front()相当于。这意味着对于空string，获得的是end-of-string（对string而言是'\0'）。
- 对于at()，“当前字符个数”不是个有效索引。
- 对一个空string调用back()，会导致不明确的行为。
举个例子：
```cc
// cs contains: 'n' 'i' 'c' 'o'
const std::string cs("nico");
// s contains: 'a' 'b' 'c' 'd' 'e'
std::string s("abcde");
// t contains no character (is empty)
std::string t;

// yields 'c' as char&
s[2];
// yields 'c' as char&
s.at(2);
// yields 'a' as char&
s.front();
// yields 'i' as const char&
cs[2];
// yields 'o' as const char&
cs.back();
// ERROR: undefined behavior
s[100];
// throws out_of_range
s.at(100);
// yields '\0'
t.front();
// ERROR: undefined behavior
t.back();

// yields '\0' (undefined behavior before C++11)
s[s.length()];
// yields '\0'
cs[cs.length()];
// throws out_of_range
s.at(s.length());
// throws out_of_range
cs.at(cs.length());
```
为了允许改动string内容，operator []的non-const版本以及at()、front()和back()都返回字符的reference。一旦发生重分配行为，那些reference立即失效：
```cc
// s contains: 'a' 'b' 'c' 'd' 'e'
std::string s("abcde");
// reference to third character
char& r = s[2];
// pointer to fourth character
char* p = &s[3];

// OK, s contains: 'a' 'b' 'X' 'd' 'e'
r = 'X';
// OK, s contains: 'a' 'b' 'X' 'Y' 'e'
*p = 'Y';

// reallocation invalidates r and p
s = "new long value";

// ERROR: undefined behavior
r = 'X';
// ERROR: undefined behavior
*p = 'Y';
```
这里，为了避免运行时期出错，我们应该在r和p被初始化之前，先运用reserve()保留足够的容量。

以下操作可能导致“指向字符”的reference和pointer失效：
- 以swap()交换两值。
- 以operator>>()或getline()读入新值。
- 调用operator []、at()、begin()、end()、rbegin()和rend()之外的任何non-const成员函数。

### 比较（Comparison）
String支持常见的比较（comparison）操作符，操作数可以是string或C-string：
```cc
string s1, s2;
...
s1 == s2;
s1 < "hello"
```
如果以＜、＜=、＞或＞=比较string，将会是根据“当前之char trait”将字符依字典顺序逐一比较。例如以下所有比较结果均为true：
```cc
string("aaaa") < string("bbbb");
string("aaaa") < string("abab");
string("aaaa") < string("aaaaaa");
```
也可以使用成员函数compare()比较子字符串，此函数针对一个string可接受多个实参进行处理，如此一来就可以采用索引和长度，双管齐下定位出子字符串。
请注意compare()返回的是整数值而非Boolean值，意义如下：0表示相等，小于0表示小于，大于0表示大于。例如：
```cc
std::string s("abcd");

// returns 0
s.compare("abcd");
// returns a value <0 (s is less)
s.compare("dcba");
// returns a value >0 (s is greater)
s.compare("ab");

// returns 0 (s is equal to s)
s.compare(s);
// returns a value <0 ("ab" is less than "cd")
s.compare(0, 2, s, 2, 2);
// returns 0 ("bc" is equal to "bc")
s.compare(1, 2, "bcx", 2);
```
如果想采用不同的比较准则，你可以自行定义一个比较准则并采用STL的比较算法，或使用特殊的char trait完成“不计大小写”的比较动作。
不过由于“拥有特殊trait class”的string是另一个不同的数据类型，所以不能将这种string object拿来和string object结合或处理.

针对国际市场而开发的程序，可能需要按特殊的当地（locale）规则来比较字符串。
为简化这个问题，locale class提供了小（圆）括号操作符，采用string collation facet，根据当地惯例来比较字符串，从而进行排序。

### 更改内容（Modifier）
你可以运用不同的成员函数或操作符更改string内容。

#### 赋值（Assignment）
使用operator=可对string赋予新值。新值可以是string、C-string或单一字符。如果需要多个实参来描述新值，可改用成员函数assign()。举个例子：
```cc
const std::string aString("othello");
std::string s;

// assign "othello"
s = aString;
// assign a C-string
s = "two\nlines";
// assign a single character
s = ' ';

// assign "othello" (equivalent to operator =)
s.assign(aString);
// assign "the"
s.assign(aString, 1, 3);
// assign "hello"
s.assign(aString, 2, std::string::npos);

// assign a C-string (equivalent to operator =)
s.assign("two\nlines");
// assign the character array: 'n' 'i' 'c' 'o' '\0'
s.assign("nico", 5);
// assign five characters: 'x' 'x' 'x' 'x' 'x'
s.assign(5, 'x');
```
也可以对“两个iterator定义出来的字符区间”进行赋值.

#### 交换（Swapping Values）
和许多“不平淡的”（nontrivial）类型一样，string类型提供了一个特殊的 swap()函数用来交换两个string内容。
这个特殊化的swap()保证常量复杂度，所以如果赋值后不再需要旧值，你应该利用这个函数进行交换，从而达成赋予新值的目的。

#### 令String成空
许多动作都可以令string成空，例如：
```cc
string s;
s = "";
s.clear();
s.erase();
```
#### 安插和移除（Inserting and Removing）字符
String 提供了许多成员函数用于安插（insert）、移除（remove）、替换（replace）、抹除（erase）字符。
另有operator+=、append（）和push_back（）可附加字符。
实例如下：
```cc
// append "othello" (equivalent to operator +=)
s.append(aString);
// append "the"
s.append(aString, 1, 3);
// append "hello"
s.append(aString, 2, std::string::npos);

// append C-string (equivalent to operator +=)
s.append("two\nlines");
// append character array: 'n' 'i' 'c' 'o' '\0'
s.append("nico", 5);
// append five characters: 'x' 'x' 'x' 'x' 'x'
s.append(5, 'x');

// append single character (equivalent to operator +=)
s.push_back('\n');
```
Operator+=将单一实参附加于string末尾，append()可接受多个实参指明附加值。
另有一个append()版本可将两个iterator所指出的字符区间附加于string末尾。
push_back()是为支持back inserter而设，STL算法可借此向string末尾添加字符.

和append()类似，成员函数insert()也允许你安插字符。使用insert()时需要知道安插位置的索引，新字符将被安插于此位置之后。
```cc
const string aString("age");
string s("p");

s.insert(1, aString); // page
s.insert(1, "ersifl"); // persiflage
```
注意，成员函数insert()不接受“索引+单字符”的实参组合，你必须传入一个string或加上一个额外数字：
```cc
s.insert(0, ' '); // err
s.insert(0, " "); // ok
```
你也可以尝试这样：
```cc
s.insert(0, 1, ' '); // err
```
然而由于insert()具有以下重载形式，上一行会导致令人厌烦的歧义（模棱两可）现象：
```cc
insert(size_type idx, size_type num, charT c); // position is idx
insert(iterator idx, size_type num, charT c);  // position is iterator
```
string的size_type通常被定义为unsigned，string的iterator通常被定义为char*。
于是第一实参0有两种转换可能，不分优劣（这就是歧义）。为获得正确操作，必须如下：
```cc
s.insert((string::size_type)0, 1, ' '); // ok
```
刚才提到的歧义第二形式，恰恰给出了“运用iterator安插字符”的例子。
如果你想运用iteartor指出安插位置，有三种情况：安插单一字符、安插多个相同字符、安插“两iterator所指区间”内的字符.

与 append()和 insert()类似，移除字符用的 erase()函数也有好几个（自C++11起，还可以用pop_back()），替换字符用的replace()函数也有好几个。例如：
```cc

std::string s = "i18n";  // s: i18n
s.replace(1, 2, "nternationalizatio"); // s: internationalization
s.erase(13); // s: international
s.erase(7, 5); // s: internal
s.pop_back(); // s: interna (since C++11)
s.replace(0, 2, "ex"); // s: externa
```
你可以使用resize()改变string的字符数量。
如果实参指出的大小比现有字符数少，末尾字符会被移除。
如果实参指出的大小比现有字符数多，则以某个字符填充尾部。
你可以传入一个字符实参作为填充字符，否则就以字符类型之default构造函数建立填充字符（对于类型char，该填充字符为'\0'）。

### 子字符串（Substring）及字符串接合（String Concate-nation）
你可以使用成员函数substr()从string身上萃取出substring。例如：
```cc
std::string s("interchangeability");
s.substr(); // returns a copy of s
s.substr(11); // returns string("ability")
s.substr(5,6); // returns string("change")
s.substr(s.find('c')); // returns string("changeability")
```
你可以使用成员函数 substr() 从 string 身上萃取出 substring。例如：
```cc
std::string s1("enter");
std::string s2("nation");
std::string i18n;

i18n = 'i' + s1.substr(1) + s2 + "aliz" + s2.substr(1);
std::cout << "i18n means: " + i18n << std::endl;
```
输出如下:
```bash
i18n means: internationalization
```
自 C++11 开始，operator+ 也被重载以应付 “身为 rvalue reference” 的 string，用以支持 move 语义。
因此，如果一个 string 实参被传给 operator+ 且以后不再被使用，你就应对该 string 使用 move() 将它搬移给操作符。例如:
```cc
string foo()
{
    std::string s1("international");
    std::string s2("ization");
    std::string s = std::move(s1) + std::move(s2);  // OK
    // s1 and s2 have valid state with unspecified value
    return s;
}
```

### I/O操作符
String定义了常用的I/O操作符：
- Operator>>从input stream读取一个string。
- Operator<<把一个string写到output stream中。

这些操作符的用法和面对一般C-string时相同。更明确地说，operator>>的执行方式如下：
- 1.如果设立了skipws flag，则跳过开头空格。
- 2.持续读取所有字符，直到发生以下情形之一：
  - 下个字符为空白字符（whitespace）。
  - Stream不再处于good状态（例如遇到end-of-file）。
  - Stream的width()结果大于0，而目前已读出width()个字符。
  - 已读取max_size()个字符。
- 3.Stream width()被设为 0。

一般而言，input操作符读入下一个字时，会跳过前导的空白字符。所谓空白字符是指任何令`isspace(c，strm.getloc())`结果值为 true的字符.

Output操作符通常也会考虑stream width()。如果width()大于0，则operator<<至少要写入width()个字符。

注意，自C++11开始，`operator<<`和`>>`被声明为可处理rvalue reference to stream，这（例如）允许你使用“临时（temporary）string stream”.

#### getline()
String class还提供一种用于逐行读取的特殊函数：`std::getline()`。
该函数读取所有字符，包括开头的空白字符，直到遭遇分行符或end-of-file。分行符会被读取出来但是不会被附加到结果上。
默认情况下分行符是newline字符，但你也可以把自己喜欢的分行符作为实参传给getline()，这样就可以指定任意符号作为分界读取一个个的语汇单元（token）了：
```cc
string s;
while (getline(cin, s)) {

}
while (getline(cin, s, ';')) { // 分行符为 ;

}
```
注意，如果你是逐一读取语汇单元（token），那么newline字符不被视为特殊字符。因此语汇单元也可能包含newline字符。

还要注意，自C++11开始，getline()被重载为两个版本，分别针对lvalue和rvalue stream reference，因此允许你使用临时（temporary）string stream：
```cc
void process(const string &filecontent) {
    string firstLine;
    // 处理filecontent的第一行
    getline(stringstream(filecontent), firstLine);
    ...
}
```
### 搜索和查找（Searching and Finding）
C++标准库的string提供了许多用于搜索和查找字符及子字符串的函数：
- 使用成员函数，你可以：
  - 查找单一字符、字符序列（substring）或某个字符组（set of characters）。
  - 前向（forward）查找和回头（backward）查找。
  - 从string的起点或内部任何位置开始查找。
- 使用regex程序库，你可以查找更复杂的字符序列样式（pattern of character sequence）。
- 使用STL算法，你也可以搜索单一字符，或指定之字符序列。注意，这些算法允许你使用你自己提供的比较准则.

#### “搜索和查找”成员函数
所有查找函数的名字中都有find这个字眼，它们试图找到“与传入之实参值相等”的字符的位置。实际查找方式则取决于究竟哪一个find函数。表列出了string提供的所有查找函数。

String的查找函数:
| String 函数          | 效果                                                 |
| -------------------- | ---------------------------------------------------- |
| `find()`             | 查找第一个与 `value` 相等的字符                       |
| `rfind()`            | 查找最后一个与 `value` 相等的字符（反向查找）         |
| `find_first_of()`    | 查找第一个“与 `value` 中的某值相等”的字符             |
| `find_last_of()`     | 查找最后一个“与 `value` 中的某值相等”的字符           |
| `find_first_not_of()`| 查找第一个“与 `value` 中任何值都不相等”的字符         |
| `find_last_not_of()` | 查找最后一个“与 `value` 中任何值都不相等”的字符       |

所有查找函数都返回字符序列中“符合查找条件”的第一个字符的索引。如果查找不成功（没找到目标）则返回npos。这些查找函数都采用下面的实参体系：
- 第一实参永远是被查找的对象。
- 第二实参（可有可无）指出string内的查找起点（索引）。
- 第三实参（可有可无）指出欲查找的字符个数（也就是查找范围，或说查找长度）。

不幸的是上面这个实参体系与其他string函数不同。
其他string函数的第一个实参是起点的索引值，随后是数值和长度。
某种程度上说，每个查找函数都以下面的“实参集”实现真实意义上的重载（overloaded with the following set of arguments）：
- const string& value
  - 查找value（一个string）。

- const string& value, size_type idx
  - 从*this的idx索引位置开始，查找value（一个string）。

- const char＊ value
  - 查找value（一个C-string）。

- const char＊ value, size_type idx
  - 从*this的idx索引位置开始，查找value（一个C-string）。

- const char＊ value, size_type idx, size_type value_len
  - 从*this的idx索引位置开始，搜索value（一个C-string）内的前value_len个字符所组成的字符序列。value内的null字符（'\0'）无特殊意义。

- const char value
  - 查找value（一个字符）。

- const char value, size_type idx
  - 从*this的idx索引位置开始，查找value（一个字符）。

例如：
```cc
std::string s("Hi Bill, I'm ill, so please pay the bill");

s.find("il"); // returns 4 (first substring "il")
s.find("il", 10); // returns 13 (first substring "il" starting from s[10])
s.rfind("il"); // returns 37 (last substring "il")
s.find_first_of("il"); // returns 1 (first char 'i' or 'l')
s.find_last_of("il"); // returns 39 (last char 'i' or 'l')
s.find_first_not_of("il"); // returns 0 (first char neither 'i' nor 'l')
s.find_last_not_of("il"); // returns 36 (last char neither 'i' nor 'l')
s.find("hi"); // returns npos
```

注意，STL查找算法的命名方式不同于string查找函数的命名方式.

### npos的意义
如果查找函数失败，会返回string：：npos。试看下面的例子：
```cc
string s;
string::size_type idx;
...
idx = s.find("substring");
if (idx == std::string::npos) {
    ...
}
```
只有当＂substring＂不是string s的子字符串时，上面的if语句才会得到true值。

使用 string 的 npos 值及其类型时要格外小心：
若要检查函数返回值，一定要使用类型 string::size_type，不能以 int 或 unsigned 作为返回值类型；
否则返回值与string::npos之间的比较可能无法正确执行。这是因为 npos被设计为-1：
```cc
namespace std {
    template <typename charT,
              typename traits = char_traits<charT>,
              typename Allocator = allocator<charT> >
    class basic_string {
    public:
        typedef typename Allocator::size_type size_type;
        ...
        static const size_type npos = -1;
        ...
    };
}
```
不幸的是size_type（由string的分配器定义出）必须是个无正负号整数类型，因为default分配器乃是以类型 size_t作为 size_type）。
于是-1被转换为无正负号整数类型，npos也就成了该类型的最大无正负号值。
然而实际值取决于类型size_type的真实定义。不幸的是这些最大值都不相同。
事实上（unsigned long）-1和（unsigned short）-1不同（如果两个类型的大小不同）。
因此，对于以下表达式：
```cc
idx == std::string::npos;
```
如果 idx 的值为-1，由于 idx 和字符串 string::npos 类型不同，比较结果可能会是false：
```cc
string s;
int idx;
...
idx = s.find("substring"); // 假设返回npos
if (idx == std::string::npos) { // err
    ...
}
```
避免这种错误的办法之一就是直接检验查找是否失败：
```cc
if (s.find("hi") == std::string::npos) {
    ...
}
```
但由于我们常常需要用到匹配的（查找到的）字符的位置索引，所以另一个简单的解决方法是自行定义对应于npos的带正负号数值：
```cc
const int NPOS=1;
```
前述的比较式必须略加修改，但方便多了：
```cc
if (idx == NPOS) {
    ...
}
```
遗憾的是如果idx的类型为unsigned short，抑或索引大于int最大值，上述比较式就会失败，所以这种解决方法并不完善（也因此，C++standard并没有按这种方式定义）。
但是这两种情况很少发生，所以此解决方法在大多数情况下都有效。
如果你希望你的代码有高度移植性，你应该对string的任何索引都采用string::size_type。
若要获得完善解决方法，更需要某些重载函数用来对付确切类型string::size_type。

### 数值转换（Numeric Conversion）
自C++11开始，C++标准库提供了一些便捷函数，用来将string转换为数值（numeric value）或是反向转换。
然而请注意，这些转换只可用于类型string和wstring，不适用于u16string和u32string。

String的数值转换:
| String 函数                          | 效果                              |
| ----------------------------------- | --------------------------------- |
| `stoi(str, idxRet=nullptr, base=10)`   | 转换 `str` 成为一个 `int`           |
| `stol(str, idxRet=nullptr, base=10)`   | 转换 `str` 成为一个 `long`          |
| `stoul(str, idxRet=nullptr, base=10)`  | 转换 `str` 成为一个 `unsigned long` |
| `stoll(str, idxRet=nullptr, base=10)`  | 转换 `str` 成为一个 `long long`     |
| `stoull(str, idxRet=nullptr, base=10)` | 转换 `str` 成为一个 `unsigned long long` |
| `stof(str, idxRet=nullptr)`            | 转换 `str` 成为一个 `float`         |
| `stod(str, idxRet=nullptr)`            | 转换 `str` 成为一个 `double`        |
| `stold(str, idxRet=nullptr)`           | 转换 `str` 成为一个 `long double`   |
| `to_string(val)`                       | 转换 `val` 成为一个 `string`        |
| `to_wstring(val)`                      | 转换 `val` 成为一个 `wstring`       |

对于所有“将string转换为数值”的函数，以下都适用：
- 它们会跳过前导的任何空白字符（whitespace）。
- 它们允许返回“被处理之最末字符”后的第一个字符的索引。
- 如果转换无法发生，它们会抛出std::invalid_argument，如果被转换值超出返回类型的可表达范围，它们会抛出std::out_of_range。
- 对于整数，你可以（也可以不）传递基数（base）。

对于所有将数值转换为 string 或 wstring 的函数， val 可以是以下任何类型：int、unsigned int、long、unsigned long、long long、unsigned long long、float、double或long double。

举个例子，考虑以下程序：
```cc
#include <string>
#include <iostream>
#include <limits>
#include <exception>

int main()
{
    try {
        // convert to numeric type  // 转换为数值类型
        std::cout << std::stoi(" 77") << std::endl;
        std::cout << std::stod(" 77.7") << std::endl;
        std::cout << std::stoi("-0x77") << std::endl;

        // use index of characters not processed  // 使用未处理字符的索引
        std::size_t idx;
        std::cout << std::stoi(" 42 is the truth", &idx) << std::endl;
        std::cout << "idx of first unprocessed char: " << idx << std::endl;

        // use bases 16 and 8  // 使用 16 进制和 8 进制
        std::cout << std::stoi(" 42", nullptr, 16) << std::endl;
        std::cout << std::stol("789", &idx, 8) << std::endl;
        std::cout << "idx of first unprocessed char: " << idx << std::endl;

        // convert numeric value to string  // 数值转换为字符串
        long long ll = std::numeric_limits<long long>::max();
        std::string s = std::to_string(ll);  // converts maximum long long to string  // 转换最大 long long 到字符串
        std::cout << s << std::endl;

        // try to convert back  // 尝试转换回来
        std::cout << std::stoi(s) << std::endl;  // throws out_of_range  // 抛出 out_of_range
    }
    catch (const std::exception& e) {
        std::cout << e.what() << std::endl;
    }
}
```
程序输出
```bash
77
77.7
0
42
idx of first unprocessed char: 4
66
7
idx of first unprocessed char: 1
9223372036854775807
stoi argument out of range
```
注意std::stoi("-0x77")会导致0，因为它只解析-0，然后就把x解释为它所找到的数值终点；
std::stol("789", &idx, 8)只解析string中的第一个字符，因为8在八进制（octal）中不是个有效字符。

### String对迭代器的支持
String是字符的有序集合（ordered collection）。所以C++标准库为string提供了相应接口让你把string当作STL容器使用。

更具体地说，你可以调用惯用的那些成员函数，取得“能够遍历string内所有字符”的iterator。
如果对iterator不熟悉，可以把它们看作是指向string内部单个字符的东西，就像寻常的pointer之于C-string。
有了iterator你便可以调用C++标准库（或用户自定义的）算法遍历string内的所有字符。
是的，你于是可以对string内的字符排序、反向重排、找出最大字符等。

String拥有的是random-access iterator。也就是说，它支持随机访问，所以可被任何一个STL算法接受。
一如往常，string的iterator type（iterator、const_iterator等）由string class自己定义。
虽然确切类型由实现定义，但往往被简单定义为寻常的pointer。“以pointer实现”和“以class实现”的iterator之间有着难对付的差别.

对 iterator 而言，如果发生重分配（reallocation），或其所指向的值发生某种变化，iterator会失效.

#### String的Iterator相关函数

| 表达式 | 效果 |
| --- | --- |
| `s.begin()`, `s.cbegin()` | 返回一个 random-access iterator 指向第一字符 |
| `s.end()`, `s.cend()` | 返回一个 random-access iterator 指向最终字符的下一位置 |
| `s.rbegin()`, `s.crbegin()` | 返回一个 reverse iterator 指向倒数第一个字符（亦即最终字符） |
| `s.rend()`, `crend()` | 返回一个 reverse iterator 指向倒数最终字符的下一位置（亦即第一字符的前一位置） |
| `string s(beg,end)` | 以 `[beg,end)` 区间内的所有字符作为 string `s` 的初值 |
| `s.append(beg,end)` | 将 `[beg,end)` 区间内的所有字符附加于 `s` 末尾 |
| `s.assign(beg,end)` | 将 `[beg,end)` 区间内的所有字符赋值给 `s` |
| `s.insert(pos,c)` | 在 iterator `pos` 所指处安插字符 `c`，并返回新字符的 iterator 位置 |
| `s.insert(pos,num,c)` | 在 iterator `pos` 所指处安插 `num` 个字符 `c`，并返回第一个新字符的 iterator 位置 |
| `s.insert(pos,beg,end)` | 在 iterator `pos` 所指处安插 `[beg,end)` 区间内的所有字符 |
| `s.insert(pos,initlist)` | 在 iterator `pos` 所指处安插初值列 `initlist` 的所有字符（始自 C++11） |
| `s.erase(pos)` | 删除 iterator `pos` 所指字符，返回下一字符位置 |
| `s.erase(beg,end)` | 删除 `[beg,end)` 区间内的所有字符，返回下一字符的下一位置 |
| `s.replace(beg,end,str)` | 以 string `str` 内的字符替代 `[beg,end)` 区间内的所有字符 |
| `s.replace(beg,end,cstr)` | 以 C-string `cstr` 内的字符替代 `[beg,end)` 区间内的所有字符 |
| `s.replace(beg,end,cstr,len)` | 以字符数组（char array）`cstr` 的前 `len` 个字符替代 `[beg,end)` 区间内的所有字符 |
| `s.replace(beg,end,num,c)` | 以 `num` 个字符 `c` 替代 `[beg,end)` 区间内的所有字符 |
| `s.replace(beg,end, newBeg,newEnd)` | 以 `[newBeg,newEnd)` 区间内的所有字符替代 `[beg,end)` 区间内的所有字符 |
| `s.replace(beg,end, initlist)` | 以初值列 `initlist` 内的所有字符替代 `[beg,end)` 区间内的所有字符（始自 C++11） |

表列出了string提供的所有iterator相关函数。通常beg和end规范的区间包含beg但不包含end，是个半开区间，常写作[beg，end）.

为了支持back inserter，string定义了push_back()。

#### String Iterator的使用实例
String iterator可以做一件非常有用的事情：通过一个简单的语句把string内的所有字符都转为大写或小写。例如：
```cc
#include <string>
#include <iostream>
#include <algorithm>
#include <cctype>
#include <regex>
using namespace std;

int main()
{
    // create a string
    string s("The zip code of Braunschweig in Germany is 38100");
    cout << "original: " << s << endl;

    // lowercase all characters
    transform(s.cbegin(), s.cend(),  // source
              s.begin(),             // destination
              [](char c) {           // operation
                  return tolower(c);
              });
    cout << "lowered:  " << s << endl;

    // uppercase all characters
    transform(s.cbegin(), s.cend(),  // source
              s.begin(),             // destination
              [](char c) {           // operation
                  return toupper(c);
              });
    cout << "uppered:  " << s << endl;

    // search case-insensitive for Germany
    string g("Germany");
    string::const_iterator pos;
    pos = search(s.cbegin(), s.cend(),  // source string in which to search
                 g.cbegin(), g.cend(),  // substring to search
                 [](char c1, char c2) { // comparison criterion
                     return toupper(c1) == toupper(c2);
                 });
    if (pos != s.cend()) {
        cout << "substring \"" << g << "\" found at index "
             << pos - s.cbegin() << endl;
    }
}
```
在这里，我们两次把cbegin()、cend()和begin()返回的iterator传给算法transform()，后者将输入区间内的所有元素“变换”至某个给定的目标区间，“变换准则”乃是作为第四实参传入.

本例的“变换准则”被设定为一个lambda，用来把string的元素（也就是字符）转换为小写或大写。注意，tolower()和toupper()都是旧式C函数，使用全局性locale。
如果你的程序拥有不同的locale或一个以上的locale，你应该使用新式的tolower()和toupper().

最后，我们使用查找算法，以我们自己给定的“查找准则”寻找一个substring。这个查找准则又是一个lambda，以不分大小写的方式比较字符。

另外，也可以选择使用regex程序库:
```cc
// search case-insensitive for Germany
std::regex pat("Germany",
               regex_constants::icase);  // search case-insensitive
smatch m;
if (regex_search(s, m, pat)) {           // search regex pattern in s
    cout << "substring \"Germany\" found at index "
         << m.position() << endl;
}
```
程序输出
```bash
original: The zip code of Braunschweig in Germany is 38100
lowered:  the zip code of braunschweig in germany is 38100
uppered:  THE ZIP CODE OF BRAUNSCHWEIG IN GERMANY IS 38100
substring "Germany" found at index 32
```
最后一条语句以这种方式处理两个string iterator之间的距离，用以获得字符位置的索引：
```cc
pos - s.cbegin()
```
之所以能够这么使用operator-，是因为string iterator是一种random-access iterator。将索引转换为iterator位置也是一样：只要把索引值加到iterator身上即可。

如果在set或map中使用string，也许你会想要一个特别的排序准则，让这些容器以“大小写无关”的方式对string排序。

以下程序示范了string iterator的另一种运用：
```cc
#include <string>
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    // create constant string  // 创建常量字符串
    const string hello("Hello, how are you?");

    // initialize string s with all characters of string hello  // 用 hello 的所有字符初始化字符串 s
    string s(hello.cbegin(), hello.cend());

    // ranged-based for loop that iterates through all the characters  // 基于范围的 for 循环遍历所有字符
    for (char c : s) {
        cout << c;
    }
    cout << endl;

    // reverse the order of all characters inside the string  // 反转字符串内所有字符的顺序
    reverse(s.begin(), s.end());
    cout << "reverse:       " << s << endl;

    // sort all characters inside the string  // 对字符串内所有字符排序
    sort(s.begin(), s.end());
    cout << "ordered:       " << s << endl;

    // remove adjacent duplicates  // 移除相邻重复项
    // - unique() reorders and returns new end  // - unique() 重新排序并返回新的末尾
    // - erase() shrinks accordingly  // - erase() 相应地收缩
    s.erase(unique(s.begin(),
                   s.end()),
            s.end());
    cout << "no duplicates: " << s << endl;
}
```
程序输出
```bash
Hello, how are you?
reverse:       ?uoy era woh ,olleH
ordered:       ,?Haaehlloooruwuy
no duplicates: ,?Haehloruwuy
```
以下例子采用back inserter，从标准输入设备读取数据放进一个string：
```cc
#include <string>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <locale>
using namespace std;

int main()
{
    string input;

    // don't skip leading whitespaces  // 不跳过前导空白字符
    cin.unsetf(ios::skipws);

    // read all characters while compressing whitespaces  // 读取所有字符并压缩空白字符
    const locale& loc(cin.getloc());  // locale  // 区域设置
    unique_copy(istream_iterator<char>(cin),  // beginning of source  // 源起始位置
                istream_iterator<char>(),     // end of source      // 源结束位置
                back_inserter(input),         // destination        // 目标位置
                [&] (char c1, char c2) {      // criterion for adj. duplicates  // 相邻重复的判断准则
                    return isspace(c1, loc) && isspace(c2, loc);
                });

    // process input  // 处理输入
    // - here: write it to the standard output  // - 此处：写入标准输出
    cout << input;
}
```
通过unique_copy()算法，来自input stream cin的所有字符都被安插到string input中。

传进去的lambda用来检验给定的两个字符是否为whitespace。它让unique_copy()得以检测出相邻重复性，进而得以移除重复。
于是，从输入设备读数据时，这个算法就会压缩多重的（也是多余的）whitespace.

这个准则自身考虑的是当前的（current）locale。为了这么做，loc必须以cin的locale为初值，并以by value方式交给lambda.

### 国际化（Internationalization）
正如先前介绍string class时所说，template string class basic_string<>乃是以下列三项为模板参数：字符类型、字符类型的trait、内存模型。它针对char特化为string，针对wchar_t特化为 wstring。

注意，自C++11开始，你可以指明string literal （字符串字面常量）所使用的字符集（char set）.

为了应付那些“答案取决于字符类型”的技术问题，string使用所谓的character trait提供相关细节。
我们需要一个新的class，因为我们无法改变内建类型（例如char和wchar_t）的接口。

下面展示了一个为string打造的trait class，允许以“大小写无关”的方式操作字符：
```cc
#ifndef ICSTRING_HPP
#define ICSTRING_HPP

#include <string>
#include <iostream>
#include <cctype>  // 译注: for toupper()

// replace functions of the standard char_traits<char>
// so that strings behave in a case-insensitive way
struct ignorecase_traits : public std::char_traits<char> {
    // return whether c1 and c2 are equal
    static bool eq(const char& c1, const char& c2) {
        return std::toupper(c1) == std::toupper(c2);
    }

    // return whether c1 is less than c2
    static bool lt(const char& c1, const char& c2) {
        return std::toupper(c1) < std::toupper(c2);
    }

    // compare up to n characters of s1 and s2
    static int compare(const char* s1, const char* s2, std::size_t n) {
        for (std::size_t i = 0; i < n; ++i) {
            if (!eq(s1[i], s2[i])) {
                return lt(s1[i], s2[i]) ? -1 : 1;
            }
        }
        return 0;
    }

    // search c in s
    static const char* find(const char* s, std::size_t n, const char& c) {
        for (std::size_t i = 0; i < n; ++i) {
            if (eq(s[i], c)) {
                return &(s[i]);
            }
        }
        return 0;
    }
};

// define a special type for such strings
typedef std::basic_string<char, ignorecase_traits> icstring;

// define an output operator
// because the traits type is different from that for std::ostream
inline std::ostream& operator << (std::ostream& strm, const icstring& s) {
    // simply convert the icstring into a normal string
    return strm << std::string(s.data(), s.length());
}

#endif  // ICSTRING_HPP
```
由于C++standard只为“采用相同character类型和trait类型”的stream定义I/O操作，而此处的trait类型并不相同，所以我们不得不定义自己的output操作符。同样情况也发生于input操作符。

以下程序说明了如何使用这些特殊种类的string：
```cc
#include "icstring.hpp"

int main()
{
    using std::cout;
    using std::endl;

    icstring s1("hallo");
    icstring s2("otto");
    icstring s3("hALlo");

    cout << std::boolalpha;
    cout << s1 << " == " << s2 << ": " << (s1 == s2) << endl;
    cout << s1 << " == " << s3 << ": " << (s1 == s3) << endl;

    icstring::size_type idx = s1.find("All");
    if (idx != icstring::npos) {
        cout << "index of \"All\" in \"" << s1 << "\": "
             << idx << endl;
    } else {
        cout << "\"All\" not found in \"" << s1 << endl;
    }
}
```
程序输出
```bash
hallo == otto : false
hallo == hALlo : true
index of "All" in "hallo": 1
```

### 效率（Performance）
C++standard并未规定如何实现string class，只是定义了其接口。由于理念和侧重点各有不同，不同的实现可能在速度和内存耗用方面存在显著的差异。

注意，自C++11开始，不再允许使用reference counted实现手法，原因是“让string的内部缓冲区被共享”在多线程环境（multithreaded context）中是行不通的。

### String和Vector
String和vector很相似，这不奇怪，因为它们都是容器，而且都被典型地实现为 dynamic array（动态数组）。
因此，你可以把string视为一种“以字符为元素”的特定vector。事实上你可以把string当作STL容器使用。
但由于string和vector之间还是有许多本质上的不同，把string当作一种特殊的vector还是存在一定危险。最重要的差异在于两者的主要目标：
- 1.Vector的首要目标是处理和操作容器内的元素，而非容器整体。因此实现时通常会考虑“容器元素的操作行为”的最优化。
- 2.String主要是把整个容器视为整体来处理和操作，因此实现时通常会考虑“整个容器的赋值和传递”的最优化。

不同的目标往往导致完全不同的实现手法。例如string常会采用reference counting（引用计数）手法，vector则绝不会如此。然而你也可以把vector当作寻常的C-string使用.

## 细究String Class
本节中显示的string字样，指的是真实的相应的string class，可以是string、wstring或basic_string<>之任何一种特化形式；
char则是指相应之字符类型，亦即string所使用的char，wstring所使用的wchar_t，或是u16string所使用的char16_t，u32string所使用的char32_t。
其他以斜体字标出的类型和值的定义都取决于char type或trait class的个别定义。

### 类型定义和静态值
string::traits_type
- Character trait的类型。
- basic_string的第二个template参数。
- 对类型string而言，这等价于char_traits＜char＞。

string::value_type
- 字符类型。
- 等价于traits_type：：char_type。
- 对类型string而言，这等价于char。

string::size_type
- 未带正负号的整数类型，用来指定大小值和索引。
- 等价于allocator_type：：size_type。
- 对类型string而言，这等价于size_t。

string::difference_type
- 带正负号的整数类型，用来指定差值（距离）。
- 等价于allocator_type：：difference_type。
- 对类型string而言，这等价于ptrdiff_t。

string::reference
- 字符的reference类型。
- 等价于allocator_type：：reference。
- 对类型string而言，这等价于char&。

string::const_reference
- 常量型的字符的reference类型。
- 等价于allocator_type：：const_reference。
- 对类型string而言，这等价于const char&。

string::pointer
- 字符的pointer类型。
- 等价于allocator_type：：pointer。
- 对类型string而言，这等价于char*。

string::const_pointer
- 常量型的字符pointer类型。
- 等价于allocator_type：：const_pointer。
- 对类型string而言，这等价于const char*。

string::iterator
- Iterator（迭代器）类型。
- 确切类型由实现定义。
- 对类型string而言通常是char*。

string::const_iterator
- 常量型iterator（迭代器）类型。
- 确切类型由实现定义。
- 对类型string而言通常是const char*。

string::reverse_iterator
- Reverse iterator（反向迭代器）类型。
- 等价于reverse_iterator＜iterator＞。

string::const_reverse_iterator
- Constant reverse iterator（常量型反向迭代器）类型。
- 等价于reverse_iterator＜const_iterator＞。

static const size_type string::npos
- 这是一个特殊值，表示未找到或所有剩余字符。
- 它是个无正负号整数，初值为-1。
- 使用npos时要十分小心，详见13.2.12节第680页。

### 创建、复制、销毁（Create，Copy，and Destroy）
string::string ()
- Default构造函数。
- 建立一个空的string。

string::string (const string& str)
- Copy （拷贝）构造函数。
- 建立一个新的string，是str的拷贝（副本）。

string::string (string&& str)
- Move （搬移）构造函数。
- 建立一个新的string，以既有的string str的元素为初值。
- 执行之后，str的内容不明确。
- 始自C++11。

string::string (const string& str,size_type str_idx)
string::string (const string& str,size_type str_idx,size_type str_num)
- 建立一个新string，其初值为“str之内从索引str_idx开始的最多str_num个字符”。
- 如果没有指定str_num，则取“从str_idx开始到str末尾”的所有字符。
- 如果str_idx＞str.size（），抛出out_of_range异常。

string::string (const char* cstr)
- 建立一个string，以C-string cstr为初值。
- 初值为cstr内“以'\0'为结束符（但不包括'\0'）”的所有字符。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。
- 如果所得结果超出最大字符数，抛出length_error异常。

string::string (const char* chars,size_type chars_len)
- 建立一个string，以字符数组chars内的chars_len个字符为初值。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。
- 如果chars_len等于string：：npos，抛出length_error异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string::string (size_type num, char c)
- 建立一个string，初值为num个字符c。
- 如果num等于string：：npos，抛出length_error异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string::string (InputIterator beg,InputIterator end)
- 建立一个字符串，以[beg，end）区间内的字符为初值。
- 如果所得结果超出最大字符数，抛出length_error异常。

string::string (initializer-list)
- 建立一个新的string，以initializer-list的字符为初值。
- 始自C++11。
- 如果所得结果超出最大字符数，抛出length_error异常。

string::~string ()
- 析构函数。
- 销毁所有字符并释放内存。

大多数构造函数都接受一个allocator（分配器）作为附加实参.

### 大小和容量（Size and Capacity）
大小相关操作

bool string::empty () const
- 判断string是否为空（不含任何字符）。
- 等价于string：：size（）==0，但有可能更快。

size_type string::size () const
size_type string::length () const
- 两个函数都返回现有的字符数。
- 两者等价（equivalent）。
- 如果想检查string是否为空，应采用速度更快的empty（）。

size_type string::max_size () const
- 返回“字符串可含之最多字符数”。
- 任何操作一旦生成的string长度大于max_size（），就会抛出length_error异常。

### 容量相关操作

size_type string::capacity () const
- 返回重分配之前string所能包含的最多字符数。

void string::reserve ()
void string::reserve (size_type num)
- 第一形式是个“非强制性合身缩减”请求（nonbinding shrink-to-fit request）。
- 第二形式保留“至少能容纳num个字符”的内存。
- 如果num小于当前容量，这一调用相当于一个“非强制性缩减容量”请求（nonbinding request to shrink the capacity）。
- 如果num小于当前字符数，这一调用相当于一个“非强制性缩减容量”请求，希望能够令容量吻合当前字符数。
- 容量永远不能小于实际字符数。
- 这个操作有可能造成“指向string所含字符”之reference、pointer和iterator失效。然而可以保证的是，在调用 reserve（）之后的安插过程中不会发生重分配，直到某次安插造成大小超过num。因此，我们可事先调用reserve（）来加快速度并保持reference、pointer和iterator的有效性（详见13.2.5节第670页）。

void string::shrink_to_fit ()
- 降低内部内存，以符合当前字符数。
- 其效果相当于reserve（0）。
- 这一调用被视为一个非强制性请求（nonbinding request），允许实现方有优化余地。
- 这个操作有可能造成“指向string所含字符”的reference、pointer和iterator失效。
- 始自C++11。

### 比较（Comparison）
bool comparison (const string& str1,const string& str2)
bool comparison (const string& str,const char* cstr)
bool comparison (const char* cstr,const string& str)
- 第一形式返回两个string的比较结果。
- 第二和第三形式返回string和C-string的比较结果。
- comparison可以是以下任何一种动作： == != < > >= <=
- 按字典次序（lexicographically）进行比较

int string::compare (const string& str) const
- 把string*this拿来和string str比较。
- 返回值：
  - 0，表示两端strings相等。
  - ＜ 0，表示`*this`小于str（按字典次序）。
  - ＞ 0，表示`*this`大于str（按字典次序）。
- 以traits::compare（）为比较准则（参见16.1.4节第854页）。

int string::compare (size_type idx,size_type len,const string& str) const
- 将string*this之内“从idx开始的最多len个字符”拿来和str比较。
- 如果idx＞size（），抛出out_of_range异常。
- 比较动作和前述的compare（str）相同。

int string::compare (size_type idx,size_type len,const string& str,size_type str_idx,size_type str_len) const
- 将string*this内“从idx开始的最多len个字符”拿来和str之内“从str_idx开始的最多str_len个字符”相较。
- 如果idx＞size（），抛出out_of_range异常。
- 如果str_idx＞str.size（），抛出out_of_range异常。
- 比较动作和前述的compare（str）相同。

int string::compare (const char* cstr) const
- 将string*this的字符和C-string cstr的字符进行比较。
- 比较动作和前述的compare（str）相同。

int string::compare (size_type idx,size_type len,const char* cstr) const
- 将string*this内“从idx开始最多len个字符”和C-string cstr的所有字符比较。
- 比较动作和前述的compare（str）相同。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。

int string::compare (size_type idx,size_type len,const char* chars,size_type chars_len) const
- 将string*this内“从idx开始最多len个字符”拿来和字符数组chars内的chars_len个字符相较。
- 比较动作和前述的compare（str）相同。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。
- 如果chars_len等于string::npos，抛出length_error异常。

### 字符访问
char& string::operator [] (size_type idx)
const char& string::operator [] (size_type idx) const
- 两种形式都返回索引idx所指的字符（首字符索引为 0）。
- length（）和 size（）都是有效索引，本操作符会对此返回一个“由字符类型的default构造函数生成”的值（对 string 而言是'\0'）。在 C++11 之前，non-const string 的length（）或size（）都是无效索引。
- 无效索引会导致不明确的行为。
- 操作 non-const string 时，返回的 reference 会因为 string 被改动或重分配而失效
- 如果调用者无法确定索引是否有效，就应该采用at（）。

char& string::at (size_type idx)
const char& string::at (size_type idx) const
- 两种形式都返回索引idx所指的字符（首字符索引为 0）。
- 对于所有string，以length（）的结果为索引，都是无效的。
- 传递无效索引（小于0或大于等于length（）或size（））会导致out_of_range异常。
- 操作 non-const string 时，返回的 reference 会因为 string 被改动或重分配而失效
- 如果调用者确定索引是有效的，可改用操作符[]，速度更快。

char& string::front ()
const char& string::front () const
- 两种形式都返回第一字符。
- 对string调用 front（），会返回一个“由字符类型的default构造函数生成”的值（对string而言是'\0'）。
- 操作 non-const string 时，返回的 reference 会因为 string 被改动或重分配而失效

char& string::back ()
const char& string::back () const
- 两种形式都返回最末字符。
- 对空string调用back（），会导致不明确的行为。
- 操作 non-const string 时，返回的 reference 会因为 string 被改动或重分配而失效

### 产生C-String和字符数组（Character Array）
const char* string::c_str () const
const char* string::data () const
- 将string的内容以C-string（一个字符数组，尾部添加'\0'）形式返回。因此这可说是string对应的一个有效的C-string。
- 返回值隶属于该string，所以调用者不能修改、释放或删除该返回值。
- 只有当string尚且存在，并且用来处理该返回值的函数是个“常量型函数”时，这个返回值才保持有效。
- 在C++11之前，data（）的返回值保证内含string的所有字符但没有结束符'\0'，因此不能说是个有效的C-string。

size_type string::copy (char* buf,size_type buf_size) const
size_type string::copy (char* buf,size_type buf_size,size_type idx) const
- 两种形式都将string*this 内从索引idx 开始最多buf_size 个字符复制到字符数组buf中。
- 返回被复制的字符数。
- 不添加null字符。因此函数执行后的buf内容可能不是个有效的C-string。
- 调用者必须确保buf有足够内存；否则会导致不明确的行为。
- 如果idx＞size（），抛出out_of_range异常。

### “改动”之相关操作（Modifying Operation）
#### 赋值（Assignment）
string& string::operator= (const string& str) string& string::assign (const string& str)
- 所谓的copy assignment（拷贝赋值）操作符。
- 以上两种形式都将str的内容赋值给`*this`。
- 都返回`*this`。

string& string::operator= (string&& str)
string& string::assign (string&& str)
- 所谓的move assignment（搬移赋值）操作符。
- 将str的内容搬移至`*this`。
- 完成后，str的内容不可知（不明确）。
- 返回`*this`。
- 始自C++11。

string& string::assign (const string& str,size_type str_idx,size_type str_num)
- 将str内“从索引str_idx开始最多str_num个字符”赋值给`*this`。
- 返回`*this`。
- 如果str_idx＞str.size（），抛出out_of_range异常。

string& string::operator= (const char* cstr)
string& string::assign (const char* cstr)
- 两种形式都将C-string cstr的内容赋值给`*this`。
- 它们操作的是以'\0'结尾的cstr所有字符，但不包含'\0'。
- 都返回`*this`。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。
- 如果所得结果超出最大字符数，两函数都抛出length_error异常。

string& string::assign (const char* chars,size_type chars_len)
- 将数组chars内的chars_len个字符赋值给`*this`。
- 返回`*this`。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::operator= (char c)
- 将字符c赋值给`*this`。
- 返回`*this`。
- 调用后，*this只含这个单一字符。

string& string::assign (size_type num, char c)
- 将num个字符c赋值给`*this`。
- 返回`*this`。
- 如果num等于string::npos，抛出length_error异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::assign (InputIterator beg,InputIterator end)
- 赋值的来源是[beg，end）区间内的所有字符。
- 返回`*this`。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::operator= (initializer-list)
string& string::assign (initializer-list)
- 赋值的来源是initializer-list内的所有字符。
- 都返回`*this`。
- 如果所得结果超出最大字符数，两operations都抛出length_error异常。
- 始自C++11。

void string::swap (string& str)
void swap (string& str1, string& str2)
- 两种形式都用来交换string。第一版本（成员函数）交换`*this`和str的内容。第二版本（全局函数）交换str1和str2的内容。
- 应该尽可能使用这些函数取代赋值（assignment），因为它们更快。它们具有常量复杂度.

#### 添加字符（Appending Character）
string& string::operator+= (const string& str)
string& string::append (const string& str)
- 两种形式都将str的字符添加到`*this`尾部。
- 都返回`*this`。
- 如果所得结果超出最大字符数，两者都抛出length_error异常。

string& string::append (const string& str,size_type str_idx,size_type str_num)
- 将str内“从str_idx开始最长str_num个字符”添加到`*this`末尾。
- 返回`*this`。
- 如果str_idx＞str.size（），抛出out_of_range异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::operator+= (const char* cstr)
string& string::append (const char* cstr)
- 都将C-string的字符添加到`*this`末尾。
- 都返回`*this`。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。
- 如果所得结果超出最大字符数，两者都抛出length_error异常。

string& string::append (const char* chars,size_type chars_len)
- 将字符数组chars内的chars_len个字符添加到`*this`末尾。
- 返回`*this`。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::append (size_type num, char c)
- 将num个字符c添加到`*this`尾部。
- 返回`*this`。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::operator+= (char c)
void string::push_back (char c)
- 将字符c添加到`*this`尾部。
- Operator+=返回`*this`。
- 如果所得结果超出最大字符数，两者都抛出length_error异常。

string& string::append (InputIterator beg,InputIterator end)
- 将[beg，end）区间内的所有字符添加到`*this`尾部。
- 返回`*this`。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::operator+= (initializer-list)
void string::append (initializer-list)
- 都将initializer-list的字符添加到`*this`末尾。
- 都返回`*this`。
- 如果所得结果超出最大字符数，两者都抛出length_error异常。
- 始自C++11。

#### 安插字符（Inserting Character）
string& string::insert (size_type idx,const string& str)
- 将str插入`*this`内，从索引idx处开始安插新增字符。
- 返回`*this`。
- 如果idx＞size（），抛出out_of_range异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::insert (size_type idx,const string& str,size_type str_idx,size_type str_num)
- 将str内“从str_idx开始最多str_num个字符”插入`*this`，从索引idx处开始安插。
- 返回`*this`。
- 如果idx＞size（），抛出out_of_range异常。
- 如果str_idx＞str.size（），抛出out_of_range异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::insert (size_type idx,const char* cstr)
- 将C-string cstr插入`*this`，从索引idx处开始安插新增字符。
- 返回`*this`。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。
- 如果idx＞size（），抛出out_of_range异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::insert (size_type idx,const char* chars,size_type chars_len)
- 将字符数组chars内的chars_len个字符插入`*this`，从索引idx处开始安插新增字符。
- 返回`*this`。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。
- 如果idx＞size（），抛出out_of_range异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::insert (size_type idx,size_type num, char c)
iterator string::insert (const_iterator pos,size_type num, char c)
- 分别在idx或pos指定的位置上安插num个字符c。
- 第一形式将新字符插入str，从索引idx处开始。
- 第二形式在iterator pos所指字符之前方插入新字符。
- 第一形式返回`*this`。
- 第二形式返回被安插的第一个字符的位置，如果没有安插任何字符就返回pos。
- 这两个函数构成重载（overloaded）形式，因此可能导致歧义（模棱两可）。如果你以0为第一实参，由于0可被视为索引（通常被转换为 unsigned），也可被视为iterator（通常被转换为 char*），因而导致歧义。这种情况下你应该明确告知实参是个“索引”。例如：
- 如果idx＞size（），两种形式都抛出out_of_range异常。
- 如果最终结果超出最大字符数，抛出length_error异常。
- 在C++11之前，pos的类型是iterator，第二形式的返回类型是void。

iterator string::insert (const_iterator pos, char c)
- 在iterator pos所指字符之前方插入字符c的拷贝（副本）。
- 返回新被插入的字符的位置。
- 如果所得结果超出最大字符数，抛出length_error异常。
- 在C++11之前，pos的类型是iterator。

iterator string::insert (const_iterator pos,InputIterator beg,InputIterator end)
- 在iterator pos所指字符之前方插入[beg，end）区间的所有字符。
- 返回被安插的第一个字符的位置，如果没有安插任何字符就返回pos。
- 如果所得结果超出最大字符数，抛出length_error异常。
- 在C++11之前，pos的类型是iterator，返回类型是void。

iterator string::insert (const_iterator pos, initializer-list)
- 在iterator pos所指字符之前方插入initializer-list的所有字符。
- 返回被安插的第一个字符的位置，如果没有安插任何字符就返回pos。
- 如果所得结果超出最大字符数，抛出length_error异常。

#### 抹除字符（Erasing Character）
void string::clear ()
string& string::erase ()
- 两个函数都会删除（delete）string内的所有字符，因此调用后string成空。
- erase（）返回`*this`。

string& string::erase (size_type idx)
string& string::erase (size_type idx,size_type len)
- 两种形式都删除*this之内从索引idx开始的最多len个字符。
- 都返回`*this`。
- 如果未指定len，则删除idx之后的所有字符。
- 如果idx＞size（），两种形式都抛出out_of_range异常。

iterator string::erase (const_iterator pos)
iterator string::erase (const_iterator beg,const_iterator end)
- 分别删除pos所指的单一字符或[beg，end）区间内的所有字符。
- 都返回最后一个被删除字符的下一字符（因此第二形式返回的是end）。
- 在C++11之前，pos、beg和end的类型都是iterator。

void string::pop_back ()
- 删除最末字符。
- 对空string调用此函数，会导致不明确的行为。
- 始自C++11。

#### 改变大小
void string::resize (size_type num)
void string::resize (size_type num, char c)
- 两种形式都将`*this`的字符数改为 num。也就是说，如果num不等于目前的 size（），则在尾部添加或删除足够字符，使字符数等于新的大小num。
- 如果字符数增加，则以c为初值。如果未指定c，则使用“字符类型”的default构造函数为新字符设初值（对string而言将是'\0'）。
- 如果num等于string::npos，两者都抛出length_error异常。
- 如果最终结果超出最大字符数，抛出length_error异常。

#### 替换字符（Replacing Character）
string& string::replace (size_type idx,size_type len,const string& str)
string& string::replace (begin_iterator beg,begin_iterator end,const string& str)
- 第一种形式将`*this`内“从idx开始，最长为len”的字符替换为str内的所有字符。
- 第二种形式将[beg，end）区间内的字符替换为str的所有字符。
- 返回`*this`。
- 如果idx＞size（），两种形式都抛出out_of_range异常。
- 如果最终结果超出最大字符数，抛出length_error异常。
- 在C++11之前，beg和end的类型是iterator。

string& string::replace (size_type idx,size_type len,const string& str,size_type str_idx,size_type str_num)
- 将`*this`内“从idx开始，最长为 len”的字符替换为 str内“从str_idx开始，最长为str_num”的所有字符。
- 返回`*this`。
- 如果idx＞size（），抛出out_of_range异常。
- 如果str_idx＞str.size（），抛出out_of_range异常。
- 如果所得结果超出最大字符数，抛出length_error异常。

string& string::replace (size_type idx,size_type len,const char* cstr)
string& string::replace (const_iterator beg,const_iterator end,const char* cstr)
- 分别将`*this`中“以idx开始，最长为 len”的字符，或[beg，end）区间内的字符替换为C-string cstr的所有字符。
- 都返回`*this`。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。
- 如果idx＞size（），两种形式都抛出out_of_range异常。
- 如果最终结果超出最大字符数，抛出length_error异常。
- 在C++11之前，beg和end的类型是iterator。

string& string::replace (size_type idx,size_type len,const char* chars,size_type chars_len)
string& string::replace (const_iterator beg,const_iterator end,const char* chars,size_type chars_len)
- 分别将`*this`中“以idx开始，最长为 len”的字符或[beg，end）区间内的字符，替换为字符数组chars中的chars_len个字符。
- 都返回`*this`。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。
- 如果idx＞size（），两种形式都抛出out_of_range异常。
- 如果最终结果超出最大字符数，抛出length_error异常。
- 在C++11之前，beg和end的类型是iterator。

string& string::replace (size_type idx,size_type len,size_type num, char c)
string& string::replace (const_iterator beg,const_iterator end,size_type num, char c)
- 分别将`*this`内“从idx开始，最长为len”的字符，或[beg，end）区间内的字符，替换为num个字符c。
- 都返回`*this`。
- 如果idx＞size（），两种形式都抛出out_of_range异常。
- 如果最终结果超出最大字符数，抛出length_error异常。
- 在C++11之前，beg和end的类型是iterator。

string& string::replace (const_iterator beg,const_iterator end,InputIterator newBeg,InputIterator newEnd)
- 以[newBeg，newEnd）区间内的所有字符替换[beg，end）区间内的所有字符。
- 返回`*this`。
- 如果所得结果超出最大字符数，抛出length_error异常。
- 在C++11之前，beg和end的类型是iterator。

string& string::replace (const_iterator beg,const_iterator end,initializer-list)
- 以initializer-list内的所有字符替换[beg，end）区间内的所有字符。
- 返回`*this`。
- 如果所得结果超出最大字符数，抛出length_error异常。
- 始自C++11。

### 查找（Searching and Finding）
#### 查找单一字符（Find a Character）
size_type string::find (char c) const
size_type string::find (char c,size_type idx) const
size_type string::rfind (char c) const
size_type string::rfind (char c,size_type idx) const
- 这些函数（从索引idx开始）搜索第一个或最后一个字符c。
- 函数find（）正向（forward）查找，并返回找到的第一个substring。
- 函数rfind（）反向（backward）搜索，并返回找到的最后一个substring。
- 如果成功，就返回字符索引；否则返回string：：npos。

#### 查找子字符串（Find a Substring）
size_type string::find (const string& str) const
size_type string::find (const string& str,size_type idx) const
size_type string::rfind (const string& str) const
size_type string::rfind (const string& str,size_type idx) const
- 这些函数（从索引idx开始）查找第一个或最后一个substring str。
- 函数find（）正向（forward）查找，并返回找到的第一个substring。
- 函数rfind（）反向（backward）搜索，并返回找到的最后一个substring。
- 如果成功，就返回substring内的第一字符的索引；否则返回string：：npos。

size_type string::find (const char* cstr) const
size_type string::find (const char* cstr,size_type idx) const
size_type string::rfind (const char* cstr) const
size_type string::rfind (const char* cstr,size_type idx) const
- 这些函数（从索引 idx 开始）查找“与 C-string cstr 内容相同”的第一个或最后一个substring。
- 函数find（）正向（forward）查找，并返回找到的第一个substring。
- 函数rfind（）反向（backward）搜索，并返回找到的最后一个substring。
- 如果成功，就返回substring内的第一字符的索引；否则返回string：：npos。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。

size_type string::find (const char* chars,size_type idx,size_type chars_len) const
size_type string::rfind (const char* chars,size_type idx,size_type chars_len) const
- 这些函数（从索引idx开始）查找“与字符数组chars内的chars_len个字符内容相同”的第一个或最后一个子字符串。
- 函数find（）正向（forward）查找，并返回找到的第一个substring。
- 函数rfind（）反向（backward）搜索，并返回找到的最后一个substring。
- 如果成功，就返回substring内的第一字符的索引；否则返回string：：npos。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。

#### 查找第一个符合条件的字符
size_type string::find_first_of (const string& str) const
size_type string::find_first_of (const string& str,size_type idx) const
size_type string::find_first_not_of (const string& str) const
size_type string::find_first_not_of (const string& str,size_type idx) const
- 这些函数（从索引idx处开始）查找`*this`之中属于（或不属于） str的第一个字符。
- 如果成功就返回“找到的substring或字符”的索引；否则返回string：：npos。

size_type string::find_first_of (const char* cstr) const
size_type string::find_first_of (const char* cstr,size_type idx) const
size_type string::find_first_not_of (const char* cstr) const
size_type string::find_first_not_of (const char* cstr,size_type idx) const
- 这些函数（从索引idx处开始）查找`*this`之中属于（或不属于） C-string cstr的第一个字符。
- 如果成功就返回字符索引；否则返回string：：npos。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。

size_type string::find_first_of (const char* chars,size_type idx,size_type chars_len) const
size_type string::find_first_not_of (const char* chars,size_type idx,size_type chars_len) const
- 这些函数从索引idx处开始查找`*this`之中“属于（或不属于）字符数组chars内的前chars_len个字符”的第一个字符。
- 如果成功，就返回找到的字符的索引；否则返回string：：npos。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。

size_type string::find_first_of (char c) const
size_type string::find_first_of (char c,size_type idx) const
size_type string::find_first_not_of (char c) const
size_type string::find_first_not_of (char c,size_type idx) const
- 这些函数（从索引idx处开始）查找`*this`之中等于（或不等于）字符c的第一个字符。
- 如果成功，就返回找到的字符的索引；否则返回string：：npos。

#### 查找最后一个符合条件的字符
size_type string::find_last_of (const string& str) const
size_type string::find_last_of (const string& str,size_type idx) const
size_type string::find_last_not_of (const string& str) const
size_type string::find_last_not_of (const string& str,size_type idx) const
- 这些函数（从索引idx处开始）查找`*this`之中属于（或不属于） str的最后一个字符。
- 如果成功就返回“找到的substring或字符”的索引；否则返回string：：npos。

size_type string::find_last_of (const char* cstr) const
size_type string::find_last_of (const char* cstr,size_type idx) const
size_type string::find_last_not_of (const char* cstr) const
size_type string::find_last_not_of (const char* cstr,size_type idx) const
- 这些函数（从索引idx处开始）查找`*this`之中属于（或不属于） C-string cstr的最后一个字符。
- 如果成功就返回字符索引；否则返回string：：npos。
- cstr不可以是null pointer（nullptr或NULL），否则会导致不确定的行为。

size_type string::find_last_of (const char* chars,size_type idx,size_type chars_len) const
size_type string::find_last_not_of (const char* chars,size_type idx,size_type chars_len) const
- 这些函数从索引idx处开始查找`*this`之中“属于（或不属于）字符数组chars内的前chars_len个字符”的最后一个字符。
- 如果成功，就返回找到的字符的索引；否则返回string：：npos。
- chars必须至少包含chars_len个字符。这些字符可以为任意值，'\0'无特殊意义。

size_type string::find_last_of (char c) const
size_type string::find_last_of (char c,size_type idx) const
size_type string::find_last_not_of (char c) const
size_type string::find_last_not_of (char c,size_type idx) const
- 这些函数（从索引idx处开始）查找`*this`之中等于（或不等于）字符c的最后一个字符。
- 如果成功，就返回找到的字符的索引；否则返回string：：npos。

### 子字符串（Substring）及字符串接合（String Concate-nation）
string string::substr () const
string string::substr (size_type idx) const
string string::substr (size_type idx,size_type len) const
- 这几种形式都返回`*this`之中“从索引idx开始的最多len个字符”所组成的substring。
- 如果没有len，则将“余下的所有字符”当作substring返回。
- 如果没有idx和len，则返回string拷贝（副本）。
- 如果idx＞size（），则抛出out_of_range异常。

string operator+ (const string& str1,const string& str2)
string operator+ (string&& str1, string&& str2)
string operator+ (string&& str1,const string& str2)
string operator+ (const string& str1, string&& str2)
string operator+ (const string& str,const char* cstr)
string operator+ (string&& str,const char* cstr)
string operator+ (const char* cstr,const string& str)
string operator+ (const char* cstr, string&& str)
string operator+ (const string& str, char c)
string operator+ (string&& str, char c)
string operator+ (char c,const string& str)
string operator+ (char c, string&& str)
- 所有形式都接合两个操作数内的所有字符，并返回接合后的string。
- 只要任何实参是个rvalue reference，其move语义就会被用上，那意味着操作完成后该实参的内容不再明确。
- 操作数可以是下列任意一种：
  - 一个string。
  - 一个C-string。
  - 单一字符。
- 如果接合结果超出最大字符数，则所有形式都抛出length_error异常。

### I/O函数
ostream& operator<< (ostream&& strm,const string& str)
- 将str内的字符写入stream strm。
- 如果strm.width（）大于0，则至少写入width（）个字符，然后width（）被设为 0。
- ostream 的类型是 basic_ostream＜char＞，具体取决于字符类型（参见15.2.1 节第748页）。
- 在C++11之前，stream的类型是个lvalue reference。

istream& operator>> (istream&& strm, string& str)
- 从strm读取下一个string的所有字符，放入str。
- 如果strm的skipws flag被设置，则前导空格将忽略不计。
- 字符读取动作遇到下面的情形之一即结束：
  - strm.width（）大于0，且已存入width（）个字符。
  - strm.good（）为 false（这也可能导致相应异常）。
  - 对下一个字符c，isspace（c，strm.getloc（））为 true。
  - 已存入str.max_size（）个字符。
- 视情况重新分配内存。
- istream 的类型是 basic_istream＜char＞，具体取决于字符类型（参见 15.2.1 节第 748页）。
- 在C++11之前，stream的类型是个lvalue reference。

istream& getline (istream& strm, string& str)
istream& getline (istream&& strm, string& str)
istream& getline (istream& strm, string& str, char delim)
istream& getline (istream&& strm, string& str, char delim)
- 从strm读取下一整行的所有字符，放入string str。
- 读取所有字符（包括前导空格），直到下列情形之一发生：
  - strm.good（）为 false （这也可能导致相应异常）。
  - 读到delim或strm.widen（'\n'）。
  - 已读取str.max_size（）个字符。
- 行分隔符（line delimiter）从实参中获取。
- 视情况重新分配内存。
- istream 的类型是 basic_istream＜char＞，具体取决于字符类型（参见 15.2.1 节第 748页）。
- 针对rvalue reference而提供的那些重载版本，始自C++11。

### 数值转换（Numeric Conversion）
int stoi (const string& str,size_t* idxRet=nullptr,int base=10)
int stol (const string& str,size_t* idxRet=nullptr,int base=10)
int stoul (const string& str,size_t* idxRet=nullptr,int base=10)
int stoll (const string& str,size_t* idxRet=nullptr,int base=10)
int stoull (const string& str,size_t* idxRet=nullptr,int base=10)
int stof (const string& str,size_t* idxRet=nullptr,int base=10)
int stod (const string& str,size_t* idxRet=nullptr,int base=10)
int stold (const string& str,size_t* idxRet=nullptr,int base=10)
- 将str转至相应的返回类型。
- str是个string，其类型可以是string或wstring。
- 跳过前导的所有空白字符（whitespace）。
- 如果idxRet！=nullptr，返回“转换过程中第一个不被接受的字符”的索引。
- 实参base允许你指定一个基数（base number）。
- 如果转换不成功，抛出std：：invalid_argument，如果转换后的结果超出返回类型的合理范围，抛出std：：out_of_range。

string to_string (Type val)
wstring to_wstring (Type val)
- 转换val成为一个string或wstring。
- val的有效类型是int、unsigned int、long、unsigned long、long long、unsigned long long、float、double或long double。

### 生成Iterator
iterator string::begin ()
const_iterator string::begin () const
const_iterator string::cbegin ()
- 所有形式都返回一个random-access iterator指向string头部（首字符位置）。
- 如果string为空，以上调用等价于end（）或cend（）。

iterator string::end ()
const_iterator string::end () const
const_iterator string::cend ()
- 所有形式都返回一个random-access iterator指向string末尾（最末字符的下一位置）。
- end处并未定义字符，所以`*s.end（）`和`*s.cend（）`会导致不明确的行为。
- 如果string为空，以上调用等价于begin（）或cbegin（）。

reverse_iterator string::rbegin ()
const_reverse_iterator string::rbegin () const
const_reverse_iterator string::crbegin ()
- 所有形式都返回一个 reverse random-access iterator，指向倒数第一字符（亦即最末字符）。
- 如果string为空，以上调用等价于rend（）或crend（）。

reverse_iterator string::rend ()
const_reverse_iterator string::rend () const
const_reverse_iterator string::crend ()
- 所有形式都返回一个reverse random-access iterator，指向倒数最末元素的下一位置。
- rend处并未定义字符，所以`*s.rend（）`和`*s.crend（）`会导致不明确的行为。
- 如果string为空，以上调用等价于rbegin（）或crbegin（）。

### 对Allocator的支持
就像其他用上allocator的class一样，string也提供常见的allocator相关支持。

string::allocator_type
- Allocator的类型。
- 是basic_string＜＞的第三个template实参。
- 对string类型而言，等价于allocator＜char＞。

allocator_type string::get_allocator () const
- 返回string的内存模型（memory model）。

String的所有构造函数都可接受一个allocator实参。以C++standard为根据，下面列出了所有string构造函数，包括其可选性的allocator实参：
```cc
namespace std {
    template <typename charT,
              typename traits = char_traits<charT>,
              typename Allocator = allocator<charT> >
    class basic_string {
    public:
        // default constructor  // 默认构造函数
        explicit basic_string(const Allocator& a = Allocator());

        // copy and move constructor (with allocator)  // 拷贝和移动构造函数（带分配器）
        basic_string(const basic_string& str);
        basic_string(basic_string&& str);
        basic_string(const basic_string& str, const Allocator&);
        basic_string(basic_string&& str, const Allocator&);

        // constructor for substrings  // 子串构造函数
        basic_string(const basic_string& str,
                     size_type str_idx = 0,
                     size_type str_num = npos,
                     const Allocator& a = Allocator());

        // constructor for C-strings  // C 风格字符串构造函数
        basic_string(const charT* cstr,
                     const Allocator& a = Allocator());

        // constructor for character arrays  // 字符数组构造函数
        basic_string(const charT* chars, size_type chars_len,
                     const Allocator& a = Allocator());

        // constructor for num occurrences of a character  // 字符重复次数构造函数
        basic_string(size_type num, charT c,
                     const Allocator& a = Allocator());

        // constructor for a range of characters  // 字符范围构造函数
        template <typename InputIterator>
        basic_string(InputIterator beg, InputIterator end,
                     const Allocator& a = Allocator());

        // constructor for an initializer list  // 初始化列表构造函数
        basic_string(initializer_list<charT>,
                     const Allocator& a = Allocator());

        ...
    };
}
```
如果string系以另一个string为初值，来源端的allocator也会被复制。

# 正则表达式
本章介绍正则表达式（regular expression）程序库regex，它允许你使用通配符（wildcard）和pattern（模式）来查找和替换string中的字符。

你可以运用正则表达式完成以下工作：
- Match：将整个输入拿来比对（匹配）某个正则表达式。
- Search：查找“与正则表达式吻合”的pattern。
- Tokenize：根据“被指定为正则表达式”的切分器（separator）取得语汇单元（token）。
- Replace：将与正则表达式吻合之第一个（或后续所有）子序列替换掉。

你可以采用不同的文法来完成这些操作。所谓文法就是“用来定义正则表达式”的语法。

我将从介绍各种操作开始，然后讨论不同的文法，最后详列regex的各项操作。

## Regex的匹配和查找接口（Match and Search Interface）
首先让我们看看，如何检查某个字符序列（sequence of characters）是否匹配或局部匹配（match or partially match）某个正则表达式：
```cc
#include <regex>
#include <iostream>
using namespace std;

void out(bool b)
{
    cout << (b ? "found" : "not found") << endl;
}

int main()
{
    // find XML/HTML-tagged value (using default syntax):  // 查找 XML/HTML 标签值（使用默认语法）
    regex reg1("<(.*)>(.*)</\\1>");
    bool found = regex_match("<tag>value</tag>",  // data  // 要匹配的数据
                             reg1);                // regular expression  // 正则表达式
    out(found);

    // find XML/HTML-tagged value (tags before and after the value must match):  // 查找 XML/HTML 标签值（值前后的标签必须匹配）
    regex reg2("<(\\w+)>.*</\\1>");
    found = regex_match("<tag>value</tag>",  // data  // 要匹配的数据
                        reg2);                // regular expression  // 正则表达式
    out(found);

    // find XML/HTML-tagged value (using grep syntax):  // 查找 XML/HTML 标签值（使用 grep 语法）
    regex reg3("<\\(.*\\)>.*</\\1>", regex_constants::grep);
    found = regex_match("<tag>value</tag>",  // data  // 要匹配的数据
                        reg3);                // regular expression  // 正则表达式
    out(found);

    // use C-string as regular expression (needs explicit cast to regex):  // 使用 C 字符串作为正则表达式（需要显式转换为 regex）
    found = regex_match("<tag>value</tag>",  // data  // 要匹配的数据
                        regex("<(\\w+)>.*</\\1>"));  // regular expression  // 正则表达式
    out(found);
    cout << endl;

    // regex_match() versus regex_search():  // regex_match() 与 regex_search() 的对比
    found = regex_match("XML tag: <tag>value</tag>",
                        regex("<(\\w+)>.*</\\1>"));  // fails to match  // 匹配失败
    out(found);
    found = regex_match("XML tag: <tag>value</tag>",
                        regex(".*<(\\w+)>.*</\\1>.*"));  // matches  // 匹配成功
    out(found);
    found = regex_search("XML tag: <tag>value</tag>",
                         regex("<(\\w+)>.*</\\1>"));  // matches  // 匹配成功
    out(found);
    found = regex_search("XML tag: <tag>value</tag>",
                         regex(".*<(\\w+)>.*</\\1>.*"));  // matches  // 匹配成功
    out(found);
}
```

接下来，第一个例子展示了如何定义正则表达式并用它来检验字符序列是否匹配某个指定的pattern（样式）。我们声明reg1是个正则表达式，并给予初值：
```cc
regex reg1("<.*>.*</.*>");
```

# 以Stream完成I/O
用于I/O（输入/输出）的各个class，是C++标准库的重要组成。一个程序如果没有I/O，就没什么大用处。
C++标准库中的I/O class不仅局限于文件、屏幕或键盘，事实上它们形成了一套富有弹性的框架（framework），可用来将任意数据格式化，可处理（访问）任意外部表述（external representation）。

一如其名称所示，IOStream程序库提供了一系列I/O class。它们是唯一在标准化之前即已被广泛应用的一部分。
早期C++系统配送一套由AT&T开发的I/O class，可视为当时的一个“准标准”。虽然为了标准库的一致性和某些新需要，I/O class做了数度修改，但其基本原则始终如一。

本章先对其中最重要的组件和技术做一个总体介绍，然后实例说明IOStream程序库的实际应用。
其应用范围可从仅仅格式化延伸到新的外部表述（new external representation）整合（那是个常常被搞错的主题）。

本章并不打算讨论IOStream程序库的所有细节，因为那需要一整本书。如果想查询本章没有提到的细枝末节，请参考专门介绍I/O stream程序库的图书或C++标准库参考手册。

## C++11带来的最新变化
C++98已经指出IOStream程序库的几乎所有特性。下面是C++11之后最重要的新增特性：
- 加入了少量新增的操控器（manipulator）：hexfloat 和 defaultfloat ，以及 get_time() 和 put_time() ，get_money() 和put_money()
- 为提供更多异常信息，相关class如今都派生自 std::system_error，不再直接派生自std::exception.
- String stream和file stream class支持rvalue和move语义，所以你可以进行move construct、move assign以及“交换（swap）一个string stream或file stream”。
  - 这也提供了“针对I/O使用临时string或file stream”的能力。
- File stream 允许你传入一个 std::string 表示文件名，而非只能是个 const char*.
- Output和input操作符`<<`和`>>`被重载，可处理long long和unsigned long long。
- I/O stream部分支持“并发”.
- Character trait提供针对类型char16_t和char32_t的服务.
- 由于新的class wbuffer_convert的帮助，你可以令stream读/写不同的字符集（character set），例如UTF-8.

## I/O Stream的共通基础
具体讨论stream class之前，我简要阐述一下stream的基本概念，为读者提供一个共通基础。熟悉iostream基本知识的读者可以跳过本节。

### Stream对象
C++I/O由stream完成。所谓stream就是一条数据流（stream of data），字符序列在其中“川流不息”。
按照面向对象原则，stream是由某个class定义出来具有特定性质的对象。
输出动作被解读为“数据流进stream”，输入动作则是“数据流出stream”。
另外，还有一些全局对象，是为标准I/O通道（channel）而定义的。

### Stream Class
正如有不同种类的I/O（例如输入、输出、文件访问），对应地也有不同的stream class，其中最重要的是：
- Class istream定义input stream，用来读数据。
- Class ostream定义output stream，用来写数据。

两者分别具体实现自template class basic_istream<>或 basic_ostream<>，以 char作为字符类型。
事实上整个IOStream程序库不依赖任何特定的字符类型，而是以一个template实参替代之。
这样的参数化在string class也存在，并且也被运用于国际化议题.

以下各节集中讨论所谓narrow stream（亦即以char为字符类型）的I/O。后继讨论会扩展至其他字符类型。

### 全局的Stream对象
IOStream程序库定义了数个类型为istream和ostream的全局对象，它们对应于标准I/O通道（channel）：
- cin，隶属于istream，是供使用者输入用的标准输入通道，对应于C中的stdin。操作系统通常将它和键盘连接。
- cout，隶属于ostream，是供使用者输出用的标准输出通道，对应于C中的stdout。操作系统通常将它和监视器（屏幕）连接。
- cerr，隶属于 ostream，是所有报错信息所使用的标准报错输出通道，对应于C中的stderr。操作系统通常也将它和监视器（屏幕）连接。默认情况下 cerr无缓冲（not buffered）。
- clog，隶属于ostream，是标准日志通道，C中没有对应物。默认情况下操作系统将它连接于cerr所连接的设备，但clog有缓冲（is buffered）。

将“正常输出”和“报错信息输出”加以分离，可以让程序以不同的方式对待两种不同的输出。
例如可以将正常输出重新定向至某个文件，而同时仍然令报错信息显示于控制台（console）。
当然，前提是操作系统必须支持标准I/O通道的重定向功能（redirection，大部分操作系统的确可以）。

### Stream操作符
Operator>>和operator<<被相应的stream class重载，分别用于输入和输出。
于是C++的移位操作符（shift operator）摇身一变成了I/O操作符。
运用此二者，可把多个I/O操作串成一列。

下面这段程序从标准输入端读入两个整数（只能是整数），并写到标准输出端：
```cc
int a, b;
while (cin >> a >> b) {
    cout << a << b << endl;
}
```
### 操控器（Manipulator）
在大部分输出语句的末尾，我们都会写一个如下的东西，称为操控器（manipulator）：
```cc
cout << endl;
```
这种东西是“专门用来操控stream”的一种特殊对象，通常它只会改变“输入的解释方式”或“输出的格式化方式”，
例如数值的进制 dec（十进制）、hex（十六进制）、oct（八进制）。
用于ostream的操控器并不会凭空造出输出数据，用于istream的操控器也不会吃掉任何输入数据。
但有些操控器会引发立即动作，例如用于“刷新（flush）output缓冲区”或“跳过input缓冲区空格”的那些操控器。

操控器endl的意思是终止一行（end line）。它做两件事情：
- 1.输出换行符，也就是'\n'。
- 2.刷新output缓冲区（也就是对于给定的stream，应用其flush()强制输出缓冲区内所有数据）。

IOStream程序库定义的一些最重要的操控器见表。

表IOStream程序库中最重要的一些操控器（Manipulator）
| 操控器 | 类（Class） | 意义                             |
| ------ | ----------- | -------------------------------- |
| `endl` | `ostream`   | 输出 `'\n'` 并刷新 output 缓冲区 |
| `ends` | `ostream`   | 输出 `'\0'`                      |
| `flush`| `ostream`   | 刷新 output 缓冲区               |
| `ws`   | `istream`   | 读入并忽略空白字符（whitespace）|

### 一个简单例子
以下展示stream class的应用。此程序读入两个浮点数，输出其乘积：
```cc
#include <cstdlib>
#include <iostream>
using namespace std;

int main()
{
    double x, y;  // operands  // 操作数
    // print header string  // 输出标题字符串
    cout << "Multiplication of two floating point values" << endl;

    // read first operand  // 读取第一个操作数
    cout << "first operand: ";
    if (!(cin >> x)) {  // 输入错误
        // =>error message and exit program with error status  // 输出错误信息并以错误状态退出程序
        cerr << "error while reading the first floating value"
             << endl;
        return EXIT_FAILURE;
    }

    // read second operand  // 读取第二个操作数
    cout << "second operand: ";
    if (!(cin >> y)) {  // 输入错误
        // =>error message and exit program with error status  // 输出错误信息并以错误状态退出程序
        cerr << "error while reading the second floating value"
             << endl;
        return EXIT_FAILURE;
    }

    // print operands and result  // 输出操作数和结果
    cout << x << " times " << y << " equals " << x * y << endl;
}
```

## 基本Stream Class和其对象
### Class及其层次体系
IOStream程序库中的stream class形成了图所示的层次体系。图中所示的class template，上一行代表其名称，下一行是以字符类型 char和 wchar_t实例化（instantiated）后的名称。


                                    ┌───────────┐                               ┌────────────────────┐
                                    │ios_base   │                               │basic_streambuf     │
                                    └───────────┘                               │streambuf/wstreambuf│
                                          ▲                                     └────────────────────┘
                                          │
                                    ┌─────┴─────┐
                                    │basic_ios<>│
                                    │ios/wios   │
                                    └───────────┘
                                          ▲
                              ┌───────────┴────────────┐
                              │        virtual         │
                     ┌────────┴───────┐        ┌───────┴────────┐
                     │basic_istream<> │        │basic_ostream<> │
                     │istream/wistream│        │ostream/wostream│
                     └────────────────┘        └────────────────┘
                              ▲                        ▲
                              │                        │
                              └───────────┬────────────┘
                                  ┌───────┴──────────┐
                                  │basic_iostream<>  │
                                  │iostream/wiostream│
                                  └──────────────────┘



这个层次体系中的class分别扮演以下角色：
- 基类ios_base定义了stream class的所有“与字符类型及其相应之char trait无关”的属性，
  - 主要包含状态和格式标志（state and format flag）等组件和函数。
- 由ios_base派生的class template basic_ios<>，定义出“与字符类型及其相应之char trait 相依赖”的 stream class 共同属性，其中包括 stream 所用的缓冲器。
  - 缓冲器所属class 派生自 class template basic_streambuf<>，其实例化实参和 basic_ios<> 一致。
    - basic_streambuf<>负责实际的读/写操作。
- Class template basic_istream<>和basic_ostream<>两者都以virtual方式继承自basic_ios<>，分别定义出用于读/写的对象。
  - 和 basic_ios<>一样，它们以字符类型及其trait作为参数。
  - 如果无关乎国际化议题，一般使用由字符类型char实例化出来的istream和ostream就够了。
- Class template basic_iostream<>派生（多重继承）自basic_istream<>和basic_ostream<>，用来定义既可读亦可写的对象。
- Class template basic_streambuf<>是IOStream程序库的核心，定义出所有“可写的stream”或“可读的stream”的接口。
  - 其他stream class均利用它进行实际的字符读/写动作。程序中为处理某些外部表达（external representation），必须从 basic_streambuf<>派生一些可用class .

#### Stream Buffer Class的用途
IOStream程序库严格依照“职责分离”的原则来设计。
basic_ios派生类只处理数据的格式化，实际读/写动作由basic_ios派生类所维护的stream buffer完成。
Stream buffer提供读/写时所使用的字符缓冲区，并形成对外部表述（如文件和字符串）的一种抽象概念。

因此，对新的外部表述（例如socket或GUI组件）进行I/O操作，或是对stream重定向，或是组合stream 以形成pipeline （例如在涂写另一个stream 之前先压缩数据）时，stream buffer扮演着重要的角色。
此外，对同一个外部表述进行I/O操作时，stream buffer与I/O同步。

运用stream buffer，我们可以轻松定义出对于新的外部表述（例如某种新的存储设备）的访问动作。
我们需要做的仅仅是从basic_streambuf<>派生出一个新的stream buffer类（或其适当特化版本），并定义该外部表述的字符读/写函数即可。
如果某个stream对象初始化时使用了该stream buffer，则所有I/O格式化操作的选项均可自动生效。

#### 具体的Class定义
和IOStream程序库的所有class template一样，basic_ios<>有两个参数：
```cc
namespace std{
    template <typename charT,
            typename traits = char_traits<charT> >
            class basic_ios;
}
```
两个参数分别是stream class所使用的字符类型及其trait class。
在trait class中，end-of-file值和复制或移动字符序列的各个命令都属于trait的一部分。
字符类型的trait和字符类型本身通常密不可分，因此定义一个class template并针对特定类型实施特化也就合情合理。
针对字符类型charT，trait class默认为 char_traits＜charT＞。
关于char_traits，C++标准库提供了char、char16_t、char32_t和wchar_t等特化版本。

下面是两个最常使用的basic_ios<>实例化实现：
```cc
namespace std {
    typedef basic_ios<char> ios;
    typedef basic_ios<wchar_t> wios;
}
```
其中ios对应于旧式（起源于AT&T的）IOStream程序库的base class，用来保证对旧式C++程序的兼容性。
```cc
namespace std {
    template <typename charT,
            typename traits = char_traits<charT>>
            class basic_streambuf;
    typedef basic_streambuf<char> streambuf;
    typedef basic_streambuf<wchar_t> wstreambuf;
}
```
Class template basic_istream<>、basic_ostream<>和basic_iostream<>当然也以字符类型和trait class作为参数：
```cc
namespace std {
    template <typename charT,
            typename traits = char_traits<charT>>
    class basic_istream;

    template <typename charT,
            typename traits = char_traits<charT>>
    class basic_ostream;

    template <typename charT,
            typename traits = char_traits<charT>>
    class basic_iostream;
}
```
下面是针对两个最重要的字符类型（char和wchar_t）所做的类型定义：
```cc
namespace std {
    typedef basic_istream<char> istream;
    typedef basic_istream<wchar_t> wistream;

    typedef basic_ostream<char> ostream;
    typedef basic_ostream<wchar_t> wostream;

    typedef basic_iostream<char> iostream;
    typedef basic_iostream<wchar_t> wiostream;
}
```
类型istream和ostream常用于西方世界，在那儿 8-bit字符集足够用了。wchar_t允许你使用8 bit以上的字符集。
注意，C++标准库并未对类型char16_t和char32_t提供对应的实例化实现.

C++标准库另提供了一些class用来对file和string进行I/O格式化.

### 全局性的Stream对象
IOStream程序库定义了数个全局性的stream对象。先前已提过，它们分别以char或对应的wchar_t作为字符类型，用来访问标准I/O通道.

全局性的Stream对象
| 类型      | 名称   | 用途                                     |
| --------- | ------ | ---------------------------------------- |
| istream   | cin    | 从标准 input 通道读取数据                |
| ostream   | cout   | 将一般数据写至标准 output 通道           |
| ostream   | cerr   | 将报错信息写至标准 error 通道            |
| ostream   | clog   | 将日志信息写至标准 logging 通道          |
| wistream  | wcin   | 从标准 input 通道读取宽字符数据          |
| wostream  | wcout  | 将宽字符一般数据写至标准 output 通道     |
| wostream  | wcerr  | 将宽字符报错信息写至标准 error 通道      |
| wostream  | wclog  | 将宽字符日志信息写至标准 logging 通道    |

默认情况下，这些stream都和标准C stream同步（synchronized）。
也就是说，C++标准库确保在“混合使用C++stream和C stream”的情况下，顺序有保障。
任何标准C++stream缓冲区在写数据前，都会先刷新其所对应的C stream缓冲区，反之亦然。
当然，保持同步会占用一定时间，如果你不需要这样的功能，可以在输入或输出前调用sync_with_stdio（false），如此便可取消同步.

自C++11 开始，这些stream 对象有了若干关于并发（concurrency）的保证：
当对标准C stream同步化时，在多个并行线程（multiple parallel threads）中使用它们并不会引发不确定的行为。
因此，你可以写自或读至多个线程。然而请注意，这可能会导致字符交错（interleaved），或导致线程读到一个不确定的字符。
至于其他任何stream对象或那些不与C stream同步化的对象，并发读/写（concurrent reads or writes）会导致不明确的行为。

### 头文件
各个stream class的定义分散于以下数个头文件：
- ＜iosfwd＞内含stream class的前置声明。这个文件是必要的，因为前置声明不能只是简单地写一句诸如class ostream这样的声明。
- ＜streambuf＞内含stream buffer base class（basic_streambuf<>）的定义。
- ＜istream＞内含两种class定义，一种仅支持input（basic_istream<>），另一种同时支持input和output（basic_iostream<>）。
- ＜ostream＞内含output stream class（basic_ostream<>）的定义。
- ＜iostream＞内含全局性stream对象（例如cin和cout）的定义。

大部分头文件主要用于C++标准库的内部组织。
IOStream程序库使用者只需包含拥有各个stream class声明式的＜iosfwd＞，并在使用input或output功能时分别含入＜istream＞或＜ostream＞即可。
除非用到标准stream对象，否则不需要包含＜iostream＞。
是的，在某些实现版本中，每一个包含 ＜iostream＞的编译单元在启动（start-up）时都需要执行一段代码；虽说其执行负荷并不高，但却必须载入相应的执行分页，这项耗费可能不小。
一般来说，必须包含的头文件，我们才包含。这里只需要包含 ＜iosfwd＞，只有相应的实现文件（.cpp）才需要包含含有完整定义的头文件。

某些特殊的 stream 性质，例如参数化的操控器（manipulator）、file stream 或 string stream，需要包含其他头文件：＜iomanip＞、＜fstream＞、＜sstream＞和＜strstream＞。
介绍这些性质时我会详细说明它们对应的头文件。

## 标准的Stream操作符＜＜和＞＞
C/C++的操作符 ＜＜ 和 ＞＞ 分别用于整数中位的左移和右移，然而 basic_istream<> 和basic_ostream<>重载了它们，使之成为标准的I/O操作符。

### Output操作符<<
basic_ostream（ostream和wostream当然也算）将<<定义为output操作符，对所有基础（语言内建）类型均重载，不包括void和nullptr_t，但包括`char*`和`void*`。

Stream将其output操作符定义为：把第二实参按箭头方向发送到相应的stream去。例如：
```cc
int i = 89;
cout << i;
```
我们可以重载operator<<，使其第二实参为我们想要的任意数据类型，如此一来我们自己的数据类型就可以整合进入I/O系统。
编译器负责调用正确的函数以输出第二实参。当然这个“正确的函数”的本分应该是把第二实参转换成字符序列发送给stream。

C++标准库利用相同的机制提供针对string、bitset及complex的output操作符。下面是应用实例：
```cc
string s("hello");
s += ", world";
cout << s;

bitset<10> flags(7);
cout << flags;

complex<float> c(3.1, 3.1);
cout << c ;
```
输出机制的可扩展性，让用户自定义类型得以天衣无缝地融入I/O系统。
比起 C 的printf() I/O机制，这是一个巨大的进步：程序员不再需要指定待打印的类型，只要针对不同类型进行重载（overload），就可以保证编译器会自动推断出正确的打印函数。
这一机制并不局限于标准类型，因此程序员可以利用这一机制完成所有类型（包括自定义类型）的操作。

Operator<<还可在单一语句中打印多个对象。按规定它会返回第一实参，也就是output stream，这使我们得以按下列方式将输出动作串成一串：
```cc
cout << x << y << endl;
```
Operator<<的核定（evaluate）次序是由左到右.

注意，自C++11起，“并发输出（concurrent output）采用相同的stream对象”是可能的，但可能导致交错的（interleaved）字符.

### Input操作符>>
basic_istream（istream和wistream当然也算）将>>定义为input操作符。
和basic_ostream 类似，basic_istream 也对几乎所有基础类型重载了 operator >>，不包括 void 和nullptr_t，但包括char*和void*。
Stream input操作符被定义为：将读入值存储于第二实参，数据按箭头方向发送，如下：
```cc
int i;
cin >> i;
```
请注意，第二实参值会改变，因此它必须是个non-const reference。

和<<一样，我们也可对任意类型重载input操作符，并串连运用它们：
```cc
float f;
complex<double> c;
cin >> f >> c;
```
为了让这成为可能，默认会跳过一开始的空白字符（如果有的话），但这项功能也可以关闭.

注意，自C++11起，“并发输入（concurrent input）采用相同的stream对象”是可能的，但可能导致读入的字符并未在“读取它”的线程中有定义.

### 特殊类型的I/O
标准I/O操作符几乎为所有基础类型做了定义（不包括void和nullptr_t），包括char*和void*。此外我们还可以进一步扩展，将>>和<<运用在我们自己定义的类型身上。

#### 数值类型（Numeric Type）
当读取数值类型时，必须以至少一个数字（one digit）起头。否则数值会被设为 0 而failbit会被设置：
```cc
int x;
cin >> x; // 设置为0，如果输入不是数字字符
```
然而，如果没有输入，或如果failbit已被设置，调用input operator将不会改动x。这种情况也适用于bool。

#### bool
默认情况下，Boolean的读入和打印均以数字表示。
false对应 0，true对应 1。
如果读入值既非 0 亦非 1，就被认为错误，此时 ios::failbit 会设置，并可能抛出相应异常.

我们可以设置stream的格式化选项（formatting option），以char string形式对Boolean进行I/O操作。
这是属于国际化的一个议题。一般采用string＂true＂和＂false＂，但特殊的locale对象可能采用不同string，例如德国用的German locale对象会使用＂wahr＂和＂falsch＂。

#### char和wchar_t
经由>>读入一个 char或 wchar_t字符时，默认会跳过起头的空白字符。
如果你想读入所有字符（包括空白字符），可清除 skipws flag或利用成员函数get()。

#### char＊
C-string（亦即char*）只读入真正的文字，因此默认情况下读得的起头空白字符均会跳过，一直读到另一个空白字符或end-of-file为止。

“是否跳过起头的空白字符”可由flag skipws控制。

请注意，这意味着你可读入任意长的string。
C程序的一个常见错误就是许多人误以为string最长不得超过80个字符，于是如果实际string太长，只得贸然终止输入。
因此，通常采用以下做法设置string的最大读取长度：
```cc
char buf[81]; // 80个char 和 '\0'结尾
cin >> std::setw(81) >> buf;
```
C++标准库的 string可根据需要扩张，能够容纳下相当长的string。以string代替char*可以让程序更轻松也更安全。
此外string还提供了一个很方便的函数getline（），可以一行一行读入。
所以请尽量避免使用C-string，多使用string。

#### void＊
操作符>>和<<为pointer的打印和读取提供了一种可能。
如果一个类型为void*的实参被传递至output操作符，其地址将被打印出来——形式则视实现版本而定。
例如下面这段代码打印出一个C-string的内容和地址：
```cc
char *cstring = "hello";
cout << "string : " << cstring << " address : " << static_cast<void *>(cstring) << endl;
```
我们甚至可以借助input操作符读入一个地址。不过你得注意，地址往往是临时的；同一对象的地址在程序每次启动后可能不同。
地址的打印和读取的一个可能应用是：为了“对象识别”（object identification）目的而交换地址，或是为了共享内存。

#### Stream Buffer（串流缓冲区）
操作符>>和<<可以直接用于读或写stream buffer，这恐怕是运用C++I/O stream来复制文件的最快办法，

#### 用户自定义类型（User-Defined Type）
原则上，扩展I/O机制以对付自定义类型，可说相当容易，不过若要考虑所有可能的格式和错误状况，恐怕需要付出更多努力。

#### 货币和时间
自C++11开始，我们也可以使用操控器（manipulator）直接读或写货币或时间值。
例如，下面的程序允许你写出当前的日期和时间，并读入一个新日期：
```cc
#include <iostream>
#include <iomanip>
#include <chrono>
#include <cstdlib>
using namespace std;

int main ()
{
    //process and print current date and time:
    auto now = chrono::system_clock::now();
    time_t t = chrono::system_clock::to_time_t(now);
    tm* nowTM = localtime(&t);
    cout << put_time(nowTM,"date: %x\ntime: %X\n") << endl;

    //read date:
    tm* date;
    cout << "new date: ";
    cin >> get_time(date,"%x");  //read date
    if (!cin) {
        cerr << "invalid format read" << endl;
    }
}
```
在要求一个新日期之前，程序可能输出如下：
```bash
date: 09/14/11
time: 11:08:52
```
相应的操控器（manipulator）允许你把国际化纳入考量。

## Stream的状态（State）
Stream维护着一个状态（state），标识I/O是否成功，并能够指出不成功的原因。

### 表示“Stream状态”的常量
Stream定义了一些类型为iostate的常量，用以反映stream的状态。
iostate是class ios_base的一个成员，其具体类型由实现版本决定，也就是说iostate并未被限定是枚举类型、整数类型或class bitset的某种具体实现。

iostate类型的常量:
| 常量    | 意义                                   |
| ------- | -------------------------------------- |
| goodbit | 一切都好；没有任何其他 bit 被设置      |
| eofbit  | 遇到 end-of-file                       |
| failbit | 错误；某个 I/O 动作未成功              |
| badbit  | 毁灭性错误；造成不确定的状态           |

goodbit被定义为0，因此goodbit设置意味着其他bit均被清为0。
或许goodbit这名字有点儿让人迷惑，因为它并不意味着有哪个bit被设置，而是指所有位均被清为0。

failbit和badbit的区别主要在于后者代表更严重的错误：
- failbit：如果某项操作未能完成，但stream仍大体OK，那么这个bit就会设置。
  - 这通常是由于读取的格式错误，例如程序想读入一个整数，却遇到一个字母。
- badbit：如果stream因不明原因而损坏或丢失数据，这个bit就会设置。
  - 例如将一个stream定位（positioning）指向“某个文件的起点”的更前方。

注意，eofbit常常和failbit同时出现，因为在end-of-file之后再试图读取数据，会检测出end-of-file状态。
读取最后一个字符时，eofbit并未设置，但再一次试图读取字符时，就会导致eofbit和failbit同时被设置，因为读取动作也失败了。

有些早期实现版本还支持flag hardfail，但C++standard已不再支持它。

这些常量并非全局性的，而是定义于 class ios_base 内，因此我们得加上作用域（scope）操作符，或是和某个对象联袂使用。例如：
```cc
std::ios_base::eofbit;
```
当然，使用ios_base派生类也行。早期实现版本中，这些常量均定义于class ios内。由于ios派生自ios_base，还可以少打几个字，所以经常被这么使用：
```cc
std::ios::eofbit
```
这些flag由class basic_ios维护，所以可在 basic_istream和 basic_ostream的所有对象中使用。
不过stream buffer并无state flag（状态标志）。
一个stream buffer可被多个stream对象共享，所以上述所有flag都只能反映最后一次操作的stream状态（甚至即使在任何操作之前总是先设置goodbit），因为这些flag可能被某些更早发生的操作设置。

### 用来“处理Stream状态”的成员函数
表列出的成员函数可以设定“用来表示stream当前状态”的flag。

用以处理Stream状态的各个成员函数
| 成员函数       | 意义                                                         |
| -------------- | ------------------------------------------------------------ |
| good()         | 若 stream 正常无误，返回 true（表示 goodbit 设置）           |
| eof()          | 若遭遇 end-of-file，返回 true（表示 eofbit 设置）            |
| fail()         | 若发生错误，返回 true（表示 failbit 或 badbit 设置）         |
| bad()          | 若发生毁灭性错误，返回 true（表示 badbit 设置）              |
| rdstate()      | 返回当前已设置的所有 flag                                    |
| clear()        | 清除所有 flag                                                |
| clear(state)   | 清除所有 flag 后，设置 state flag                            |
| setstate(state)| 加设 state flag                                              |

表的前四个成员函数可设置stream状态并返回一个Boolean。
注意fail()返回的是“failbit或badbit两者之中是否有任一个设置”，这么做主要是因为历史因素，同时也有一个好处：一次测试即可确认是否有错误发生。

除此之外，flag 的状态还可由更一般的成员函数设定或修改。
如果调用不带参数的clear()，所有error flag（包括eofbit）均会被清除（这正是其名称clear的用意）：
```cc
// 清除所有的flags包括eofbit
strm.clear();
```
如果调用带有参数的 clear()，stream会把状态调整为该参数所代表的状态，也就是说，stream 会设置该 flag 并清除其他 flag。
唯一例外是，如果没有 stream buffer （也就是当rdbuf()==0时），badbit始终会被设立。

下面这个例子检查failbit是否设置，若设置则清除之：
```cc
if (strm.rdstate() & std::ios::failbit) {
    cout << "failed was set" << endl;
    // 只清理failbit
    strm.clear(strm.rdstate() & ~std::ios::failbit);
}
```
本例使用bit操作符&和～。～操作符对其实参的所有bit逐一求反相，因此：
```cc
~ios::failbit
```
会返回一个临时数值，其中每个bit均和failbit反相。&操作符会对其操作数的所有bit逐一进行“and”运算——两对应bit均设置时，该bit才得以保留。
因此，如果对于
（1）当前设置之所有flag（利用rdstate（）取得）和
（2）除failbit外的所有bit进行“and”运算，便能清除failbit并保留其他bit。

Stream 有可能被配置为“当某些 flag 被 clear() 或 setstate() 设置时便抛出异常。
是的，如果对应的flag被设置，那么当那些flag的操控函数结束之际，stream会抛出异常。

注意，我们必须明白地清除error bit。C语言可以在“格式错误”发生之后仍然读取字符。
例如虽然scanf()未能读入一个整数，我们仍能读入剩余字符，因此虽然读入动作失败，input stream的状态依然是好的。
但C++不同：如果设置了failbit，除非明白予以清除，否则无法进行下一个操作。

请注意，被设置的bit只是反映过去发生的事。如果某次操作后发现某个bit被设置了，我们无法确定究竟是这一次或先前操作导致这个结果。
因此，如果想借由flag了解错误，操作前应先设置goodbit（如果尚未设置的话）。
此外，清除flag之后，各项操作可能会得到不同的结果，
例如，纵使eofbit是被某个操作设置的，并不意味着清除eofbit之后该操作会再次设置eofbit。
例如当“两次调用之间，被处理的文件有所成长”时，就会发生这种情况。

### Stream状态与Boolean条件测试
Stream定义了两个可用于Boolean表达式的函数，如表所列。

可用于Boolean表达式的Stream操作符
| 成员函数          | 意义                              |
| ----------------- | --------------------------------- |
| operator bool ()  | Stream 是否未出错（相当于!fail()） |
| operator ! ()     | Stream 是否已出错（相当于fail()）   |

我们可以运用operator bool()在控制结构中简洁测出stream的当前状态：
```cc
while (cin) {
    ...
}
```
控制结构中的Boolean条件并不是非得直接转换为 bool不可，只要能够转换为某个整数类型（例如int或char）或pointer类型就够了。
转换为 bool常常是为了在同一表达式中读入对象并测试是否成功：
```cc
if (cin >> x) {
    // 读取x成功
    ...
}
```
正如先前所讨论，表达式
```cc
cin >> x
```
会返回cin，所以读入x后上述语句变为：
```cc
if (cin) {
    ...
}
```
此时的 cin 被用于条件判断，于是 cin 调用 operator bool，返回“stream 是否发生错误”。

以上技术的一个典型应用就是以循环读入对象并处理：
```cc
// 一旦可读取obj
while (cin >> obj) {
    // 就处理obj
    cout << obj << endl;
}
```
这是把古典的C filter framework用在C++对象身上。
如果failbit或badbit被设置，该循环立即终止——出现错误或读到end-of-file（会同时设置eofbit和failbit）就可能发生这种情况。
操作符 >> 的默认行为会跳过起头的空白字符，这往往正是我们所希望的。
但如果 obj 的类型是 char，空白字符就带有意义了，这时我们可以运用stream 的成员函数 put() 和 get() 或运用更方便的istreambuf_iterator实现I/O filter。

我们可以利用operator! 进行反相测试，它会返回“stream是否已发生错误”，也就是说，如果failbit或badbit被设置就返回true。用法如下：
```cc
if (! std::cin) {
    // the stream cin is ok
    ...
}
```
就像隐式转换为Boolean一样，这个操作符常用于“在同一表达式中读取对象并测试是否成功”：
```cc
if (! (std::cin >> x)) {
    // read failed
    ...
}
```
在这里，表达式
```cc
std::cin >> x
```
会返回cin，然后我们再对它运用operator!。 !之后的表达式必须以小括号括起来，这是为了运算优先级：如果没有小括号，operator！会先被估算。换句话说，表达式
```cc
!std::cin >> x
```
相当于：
```cc
(!std::cin) >> x
```
这可不是我们想要的。

尽管上述操作符用于Boolean运算时很方便，但是请注意：“两次！运算”并不能获得原始对象，因为：
- cin是个istream对象。
- !cin是一个描述cin状态的Boolean值。

就像使用C++的其他特性一样，使用“转换为 Boolean”的写法可能会引起编程风格的争论。通常，使用诸如fail()这样的成员函数可以使程序拥有较好可读性：
```cc
cin >> x;
if (!cin.fail()) {
    ...
}
```

### Stream的状态和异常
C++的异常处理机制用于处理差错（error）和异常（exception）。
不过那已是stream大行其道之后的事了。为保持向后兼容，stream于默认情况下并不抛出异常。
标准化之后的stream允许我们对任何一个state flag（状态标志）进行定义：
此flag被设置时是否引发异常。这可由成员函数exceptions()完成，如表所列。

Stream的异常相关函数
| 成员函数          | 意义                     |
| ----------------- | ------------------------ |
| exceptions(flags) | 设定“会触发异常”的 flag  |
| exceptions()      | 返回“触发异常”的 flag    |

调用无参数的exceptions()，可获得引发目前异常的那个flag。如果它返回goodbit，表示没有任何异常被抛出——这是为了向后兼容而设计的一种默认情况。

如果调用带唯一参数的exceptions()，那么一旦指定的那个flag被设置，立刻就会引发相应异常。

下面这个例子要求stream对所有flag均抛出异常：
```cc
strm.exceptions(std::ios::eofbit | std::ios::failbit | std::ios::badbit);
```
但如果传入0或goodbit，就不会引发异常：
```cc
// 不产生异常
strm.exceptions(std::ios::goodbit);
```
异常的抛出时机是在“程序调用clear()或setstate()之后”又设置某些flag之际。
如果某个标志已被设置但未被清除，也会抛出异常：
```cc
strm.exceptions(std::ios::failbit);
...
strm.setstate(std::ios::failbit);
```
抛出的异常是个std::ios_base::failure对象，自C++11 起该class派生自std::system_error：
```cc
namespace std {
    class ios_base::failure : public system_error {
        public:
            explicit failure (const string &msg, const error_code &ec = io_errc::stream);
            explicit failure (const char *msg,   const error_code &ec = io_errc::stream);
    };
}
```
实现方必须提供一个 error_code对象，用来提供失败原因。
事实上，一个出于操作系统的error，应该令其分类category()为 ＂system＂，且其 value()由操作系统描述。
而一个出自I/O stream library的error应该令其category()为 ＂iostream＂且其 value()所得结果为std::io_errc::stream。

“默认为不抛异常”，意味着“异常处理”意图在非预期事态（unexpected situation）下才被更多地使用。
既然称为异常处理而非差错处理，那么诸如“用户输入数据之格式化”等可预见的错误，都被认为是“正常”而非“异常”，可采用state flag做出更好的处理。

Stream异常主要在读取“格式化数据”（例如来自一个自动被写文件）方面显身手。不过即使使用异常仍然存在一些问题。

如果你希望读取数据至end-of-file为止，那么你不可能只获得错误发生时所抛出的异常，end-of-file带来的异常也会接踵而至，
这是因为检测到end-of-file时会设置failbit（意味着没能成功读入一个对象）。
要区分究竟是发生end-of-file或是发生输入错误，就得检查stream状态。

下例做了一个示范，有个函数从stream读取浮点数，一直读到end-of-file为止，然后返回浮点数的总和：
```cc
#include <istream>

namespace MyLib {
    double readAndProcessSum (std::istream& strm)
    {
        using std::ios;
        double value, sum;

        // save current state of exception flags
        ios::iostate oldExceptions = strm.exceptions();

        // let failbit and badbit throw exceptions
        // - NOTE: failbit is also set at end-of-file
        strm.exceptions (ios::failbit | ios::badbit);

        try {
            // while stream is OK
            // - read value and add it to sum
            sum = 0;
            while (strm >> value) {
                sum += value;
            }
        }
        catch (...) {
            // if exception not caused by end-of-file
            // - restore old state of exception flags
            // - rethrow exception
            if (!strm.eof()) {
                strm.exceptions(oldExceptions);  // restore exception flags
                throw;                            // rethrow
            }
        }

        // restore old state of exception flags
        strm.exceptions (oldExceptions);
        // return sum
        return sum;
    }
}
```
以上函数首先将原本设置的stream异常记录于oldExceptions，以便稍后恢复，然后要求stream在某些确定条件下抛出异常。
只要stream处于OK状态，就进入循环读取数值并累加。
如果读到end-of-file，stream不再处于OK状态，它会抛出相应异常——即使我们并未定义“当eofbit被设置时触发异常”。
这是因为，此处是借由“继续读取数据”的失败才检测出end-of-file，而这么一来，由于读取失败会设置failbit，于是也引发异常。
为了避免在这种情况下抛出异常，程序于局部（locally）捕捉异常后，先以eof()检查stream状态，如果返回false（表示这个异常不是因为end-of-file而引发）才将该异常传播出去。

注意，恢复原先的exception flag（异常标志）时（亦即调用exceptions()时），如果stream已设置相应flag，那么此时也会抛出异常。
因此，如果程序在进入上述函数之前原本就设定会因为 eofbit、failbit或badbit而抛出异常，那么这些异常也会被传播给调用者。

上述函数可以在main之中以下列最简单的方式被调用：
```cc
#include <iostream>
#include <exception>
#include <cstdlib>

namespace MyLib {
    double readAndProcessSum (std::istream&);
}

int main()
{
    using namespace std;
    double sum;

    try {
        sum = MyLib::readAndProcessSum(cin);
    }
    catch (const ios::failure& error) {
        cerr << "I/O exception: " << error.what() << endl;
        return EXIT_FAILURE;
    }
    catch (const exception& error) {
        cerr << "standard exception: " << error.what() << endl;
        return EXIT_FAILURE;
    }
    catch (...) {
        cerr << "unknown exception" << endl;
        return EXIT_FAILURE;
    }

    // print sum
    cout << "sum: " << sum << endl;
}
```
问题来了——这样做是否值得？
我们也可以让stream不抛出异常，只有在检测到错误时才抛出异常。
这么做带来的额外好处是可以使用“自定义的错误信息”和“自定义的错误相关class”：
```cc
#include <istream>

namespace MyLib {
    double readAndProcessSum (std::istream& strm)
    {
        double value, sum;

        // while stream is OK
        // - read value and add it to sum
        sum = 0;
        while (strm >> value) {
            sum += value;
        }

        if (!strm.eof()) {
            throw std::ios::failure
                ("input error in readAndProcessSum()");
        }

        // return sum
        return sum;
    }
}
```
这么做看起来是不是简单一些？

## 标准I/O函数
这一节让我们看看可以取代标准stream操作符（>>和<<）的成员函数。
它们均用于读/写无格式（unformatted）数据（和读/写格式化数据的>>或<<操作符不同）。
读取数据时它们并不跳过起始空白字符，这和operator>>不同，后者默认会跳过起始空白字符。这由一个所谓sentry对象来控制。
另外，这些函数处理异常的方式也不同于“格式化I/O操作符”：如果发生异常，不论源自哪个被调用函数，或由于哪个state flag被设置，badbit flag都会被设置。
如果异常屏蔽（exception mask）中包含badbit，就重抛该异常。

这些函数运用定义于`<ios>`中的streamsize类型来指定数量：
```cc
namespace std {
    typedef ... streamsize;
    ...
}
```
类型streamsize通常是带正负号的size_t，因为它需要表达负数。

### Input相关函数
接下来的文字解说中，istream只是个占位符，表示一个“用于读取”的stream class，可能是istream、wistream或template class basic_istream<>的其他实例化实现。
char也是个占位符，表示相应的字符类型，例如char之于istream或wchar_t之于wistream。
其余以斜体表示的类型或数值，取决于字符类型或“与stream关联之trait class”的确切定义。

C++标准库提供了数个用以读/写字符序列的成员函数，表列出了其间的比较（s表示由被读取字符所组成的字符序列）。

Stream函数读取字符序列的能力
| 成员函数        | 读取，直到……                  | 字符数       | 添加结束符 | 返回值  |
| --------------- | ----------------------------- | ------------ | ---------- | ------- |
| get(s,num)      | 不包括 newline 或 end-of-file | 最多 num - 1 | 是         | istream |
| get(s,num,t)    | 不包括 t 或 end-of-file       | 最多 num - 1 | 是         | istream |
| getline(s,num)  | 包括 newline 或 end-of-file   | 最多 num - 1 | 是         | istream |
| getline(s,num,t)| 包括 t 或 end-of-file         | 最多 num - 1 | 是         | istream |
| read(s,num)     | End-of-file                   | num          | 否         | istream |
| readsome(s,num) | End-of-file                   | 最多 num     | 否         | Count   |

int istream::get() 
- 读取下一字符。
- 返回读取的字符，或EOF。
- 通常返回类型是 traits::int_type。traits::eof()会返回EOF。对 istream而言，返回类型是 int， EOF则为常量 EOF。因此对 istream来说，此函数对应于C语言的getchar()或getc()。
- 注意，返回值不一定是字符类型，可以是范围更大的数值类型，否则就无法根据相应实值区分EOF和一般字符。

istream& istream::get (char& c)
- 把下一字符赋值给实参c。
- 返回stream；其状态可说明是否读取成功。

istream& istream::get (char* str,streamsize count)
istream& istream::get (char* str,streamsize count, char delim)
- 两种形式均可读取多达count-1个字符，并存入str所指的字符序列中。
- 第一形式的读取终止条件是，下一字符是相应字符集中的换行符，例如'\n'之于istream，wchar_t（'\n'）之于wistream（见16.1.5节第857页）。一般而言，用的是widen（'\n'） （见15.8节第790页）。
- 第二形式的读取终止条件是：下一字符是delim。
- 两种形式均返回stream；stream的状态可说明读取是否成功。
- 不会读取终止符delim。
- 读取的字符序列以一个代表结束的null字符为结尾。
- 调用者必须保证str足够存入count个字符。

istream& istream::getline (char* str,streamsize count)
istream& istream::getline (char* str,streamsize count, char delim)
- 两种形式和先前对应的get（）完全一样，只除了一点：终止读取时，读取内容包括换行符或delim，而非在两者之前就终止。
- 因此当换行符或delim位于count-1个字符内时，它们会被读取，但不被存储于str内。

istream& istream::read (char* str,streamsize count)
- 读取count个字符，并存入str中。
- 返回stream。Stream的状态可以说明读取是否成功。
- str内的string不会自动以“终止符null”结束。
- 调用者必须确保str有足够空间存储count个字符。
- 读入过程中如遇到end-of-file会出错，则failbit会被设置（当然eofbit也有份）。

streamsize istream::readsome (char* str,streamsize count)
- 可读取多达count个字符，存入str中。
- 返回读取的字符个数。
- str内的string不会自动以“终止符null”结束。
- 调用者必须确保str有足够空间存储count个字符。
- 与read（）相反，readsome（）会读入stream buffer内的所有有效字符（利用buffer的成员函数in_avail（）完成，见15.13.1节第827页）。当我们不希望等待输入时，这很有用，因为输入来自键盘或其他进程（process）。遭遇end-of-file并不算错，不会因此设置eofbit或failbit。

streamsize istream::gcount () const
- 返回上一次“非格式化读取操作”所读的字符个数。

istream& istream::ignore ()
istream& istream::ignore (streamsize count)
istream& istream::ignore (streamsize count, int delim)
- 所有形式均提取（extract）字符并舍弃不用。
- 第一形式忽略（ignore）一个字符。
- 第二形式可忽略多达count个字符。
- 第三形式可忽略多达count个字符，直到提取并舍弃delim。
- 如果count的值等于std：：numeric_limits＜std：：streamsize＞：：max（）（这是类型std：：streamsize的最大值，见5.3节第115页），那么delim或end-of-file之前的所有字符均被舍弃。
- 上述形式均返回stream。
- 举例：
  - 以下动作会弃置当前这一行的剩余部分：cin.ignore（numeric_limits＜std：：streamsize＞：：max（），'\n'）；
  - 以下动作会弃置cin的所有剩余内容：cin.ignore（numeric_limits＜std：：streamsize＞：：max（））；

int istream::peek ()
- 返回stream之内“下一个将被读取的字符”，但不真的把它读出来。下一次读取结果便是该字符（除非改变了读取位置）。
- 如果不再能够读入任何字符，返回EOF。
- EOF即traits：：eof（）的返回值；对istream来说就是常量EOF。

istream& istream::unget ()
istream& istream::putback (char c)
- 两者均把上一次读取字符放回stream，使之可被下次读取（除非改变了读取位置）。
- 两者的区别在于putback（）会检查传入的c是否确是上一次读取字符。
- 如果无法放回字符，或者putback（）发现待放字符不正确，就设置badbit，相应的异常可能因此被抛出（见15.4.4节第762页）。
- 两函数可放回的最大字符数，由实现版本决定。C++standard保证在两次读取之间允许你调用上述任一函数一次，并且具有可携性。

读入C-string时，本节的函数比操作符＞＞更安全，因为调用者必须向这些函数明确传入最大字符数作为实参。尽管操作符＞＞也可以限制字符个数（见15.7.3节第781页），但使用者很容易忘记那么做。

直接运用stream buffer往往比使用istream成员函数更好。由于不必构造 sentry对象（详见15.5.4节第772页），因而避免了相应的额外开销，因而使得stream buffer提供的成员函数在读取单一字符或字符序列时更高效。15.13节第826页详细说明了stream buffer的接口。另一种方法是使用template class istreambuf_iterator＜＞，它提供一个stream buffer iterator接口（见15.13.2节第828页）。

另有两个用以操控读取位置的函数：tellg（）和seekg（），主要和文件连用，所以我把相关描述延后到15.9.4节第799页。

### Output相关函数
接下来的文字解说中，ostream只是个占位符，表示用于涂写动作的一个stream class，可能是ostream、wostream或template class basic_ostream＜＞的其他实例化实现。
char也只是个占位符，表示相应的字符类型，例如char之于ostream，wchar_t之于wostream。
其余以斜体表示的类型或数值，取决于字符类型或“与stream关联的”trait class的确切定义。

ostream& ostream::put (char c)
- 将实参c写至stream。
- 返回stream。Stream的状态可说明涂写是否成功。

ostream& ostream::write (const char* str,streamsize count)
- 把str中的count个字符写入stream。
- 返回stream。Stream的状态可说明涂写动作是否成功。
- 终止符null并不会终止涂写动作，它本身也会被写进stream。
- 调用者必须确保str的确包含至少count个字符，否则可能导致无法预期的行为。

ostream& ostream::flush ()
- 刷新（flush）stream的缓冲区，也就是把所有缓冲数据强制写入其所属的设备或I/O通道。

另有两个用以改变写入位置的函数：tellp()和seekp()，它们主要与文件连用.

和input函数一样，在这里，我们直接运用stream buffer或template class ostreambuf_iterator<>进行“非格式化涂写动作”将更为合理。
因此这些非格式化输出函数少有着力点，不过在多线程环境下它们可能利用sentry对象来处理lock问题.

### 实例
下面是以C++完成的古典形式的C/UNIX filter framework，很单纯地输出所有读取字符：
```cc
#include <iostream>
using namespace std;

int main()
{
    char c;

    // while it is possible to read a character
    while (cin.get(c)) {
        // print it
        cout.put(c);
    }
}
```
每次调用
```cc
cin.get(c)
```
下一字符就被赋值给c（passed by reference）。get()返回一个stream，我们可直接用它来测试cin的状态是否正常。

为了精益求精，我们还可以直接操作stream buffer。

### sentry对象
I/O stream操作符和函数使用一种常见方案来提供机能：首先，若干“预处理”先准备好I/O stream，然后完成真正的I/O，随后是若干后处理。

为了实现这样的方案，class basic_istream 和 basic_ostream 都定义有一个辅助的sentry（岗哨）class，
其构造函数负责预处理，析构函数负责对应之后处理。
于是所有格式化或非格式化的I/O操作符和函数都在它们真正处理或运算之前先使用一个sentry对象，如下：
```cc
sentry se(strm);
if (se) {
    ...
}
```
sentry构造函数接受stream strm为实参。预处理和后处理都针对strm进行。
剩余工作取决于该对象的状态，该状态指示stream是否OK，可利用“sentry对象转换为 bool”加以检查。
对于input stream，sentry对象构造时可以加上一个选择性的Boolean值，表示是否“即使flag skipws设置仍然应该避免跳过空白字符”：
```cc
sentry se(strm, true); // 不跳过空白符
```
预处理和后处理将会执行“I/O以stream完成时”的所有一般性工作。
这些工作包括多个stream之间的同步化、检查stream是否正常、跳过空白字符，以及其他可能的实现版特定任务。
例如在多线程环境中可进行相应的锁定操作。

如果I/O操作符直接作用于stream buffer身上，第一件事就应该是构造其相应的sentry对象。

## 操控器（Manipulator）
stream操控器，那些对象如果和标准I/O操作符连用，便可用来修改stream，但这并不意味着会额外读取或涂写什么。
基本操控器定义于＜istream＞或＜ostream＞，

定义于＜istream＞或＜ostream＞中的操控器（Manipulator）
| 操控器 | 类              | 意义                                                 |
| ------ | --------------- | ---------------------------------------------------- |
| endl   | basic_ostream   | 向缓冲区插入换行符并刷新——其内容写至设备             |
| ends   | basic_ostream   | 向缓冲区插入终止用的 null 字符                       |
| flush  | basic_ostream   | 刷新 output 缓冲区——其内容写至输出设备               |
| ws     | basic_istream   | 读取时忽略空白字符（whitespace）                     |

### 带有实参的操控器（Manipulator with Argument）

有些操控器可以处理实参。
例如，你可以使用下面的方式设定下次输出的最小栏宽（field width）和填充字符：
```cc
std::cout << std::setw(6) << std::setfill('_');
```
带实参之标准操控器全部和格式化有关.

### 操控器概览
表对于C++标准库提供的所有操控器列出了一份概览，包含你可以在哪一页获得它们的详细说明。
以下数项始自C++11：hexfloat、defaultfloat、put_time()、get_time()、put_money()和get_money()。

C++标准库提供的操控器（Manipulator）
| 操控器            | 效果                                                         |
| ----------------- | ------------------------------------------------------------ |
| endl              | 写出一个换行符（newline）并清空输出（flush the output）      |
| ends              | 写出一个（表示结束的）null 字符                              |
| flush             | 清空输出（flush the output）                                 |
| ws                | 读入并且忽略空格（whitespace）                               |
| skipws            | 执行 operator>> 时跳过前导空格（leading whitespace）         |
| noskipws          | 执行 operator>> 时不跳过前导空格（leading whitespace）       |
| unitbuf           | 每次写操作（write operation）后清空输出缓冲区                |
| nounitbuf         | 每次写操作（write operation）后不清空输出缓冲区              |
| setiosflags(flags) | 将 flags 设为格式标志（format flag）                          |
| resetiosflags(m)  | 清除屏蔽（mask）m 所示分组中的所有 flag                       |
| setw(val)         | 设定下一次输入和输出 val 时的栏宽（field width）              |
| setfill(c)        | 填充字符（fill-character）设为 c                             |
| left              | 数值靠左（left-adjust value）                                |
| right             | 数值靠右（right-adjust value）                               |
| internal          | 正负号靠左（left-adjust sign）数值靠右（right-adjust value） |
| boolalpha         | 对 Boolean 值强制使用文本表示（textual representation）      |
| noboolalpha       | 对 Boolean 值强制使用数值表示（numeric representation）      |
| showpos           | 对正值强制写出正号（positive sign）                          |
| noshowpos         | 对正值强制不写出正号（positive sign）                        |
| uppercase         | 对于数值（numeric value）强制使用大写字母                    |
| nouppercase       | 对于数值（numeric value）强制使用小写字母                    |
| oct               | 以八进制（octal）读和写整数值                                |
| dec               | 以十进制（decimal）读和写整数值                              |
| hex               | 以十六进制（hexadecimal）读和写整数值                         |
| showbase          | 显示数值（numeric value）的基数（numeric base）              |
| noshowbase        | 不显示数值（numeric value）的基数（numeric base）            |
| showpoint         | 总为浮点数写出小数点（decimal point）                        |
| noshowpoint       | 不要求为浮点数写出小数点（decimal point）                    |
| setprecision(val) | 使用浮点数精度（precision of floating-point value）将 val 改设新值 |
| fixed             | 对浮点数使用十进制数表示法（decimal notation）               |
| scientific        | 对浮点数使用科学记号表示法（scientific notation）            |
| hexfloat          | 对浮点数使用十六进制科学表示法（hexadecimal scientific notation） |
| defaultfloat      | 使用常规浮点数表示法（normal floating-point notation）       |
| put_time(val,fmt) | 根据格式 fmt 写出 date/time 值                               |
| get_time(val,fmt) | 根据格式 fmt 读入 time/date 值                               |
| put_money(val)    | 使用本地货币符号写出货币值                                    |
| put_money(val,imt) | 根据 imt 的货币符号写出货币值                                 |
| get_money(val)    | 使用本地货币符号读入货币值                                    |
| get_money(val,imt) | 根据 imt 的货币符号读入货币值                                 |

### 操控器如何运作
操控器的实现借助一种很简单的技巧，这种技巧不仅让stream的操控更为方便，也是函数重载的一次绝好的威力示范。
作为 I/O操作符的实参，操控器其实就是一个被I/O操作符调用的函数。
例如“针对ostream运作”的output操作符，基本上被重载如下：
```cc
ostream & ostream::operater<<(ostream (*op)(ostream &)) {
    return (*op)(*this);
}
```
实参op是个pointer，指向某函数，该函数以ostream为实参并返回一个ostream（假设返回的就是作为实参的那个ostream）。
如果操作符<<的第二操作数（右操作数）是这样一个函数，就以<<的第一操作数（左操作数）为实参调用之。

听起来很复杂，实际上相对简单，举个例子就清楚不过了。用于 ostream 身上的endl()操控器（其实是个函数）的主要实现如下：
```cc
std::ostream & std::endl(std::ostream & strm) {
    strm.put('\n');
    strm.flush();
    return strm;
}
```
我们可以采用下列方式，在一个表达式中使用该操控器：
```cc
std::cout << std::endl;
```
这里的<<分别以cout和endl()为操作数，从前述做法可知，操作符<<把它本身的调用动作转换为一个以stream为实参的函数调用：
```cc
std::endl(std::cout);
```
由于stream class都是一些“以字符类型为template参数”的template class，所以endl（）实际实现如下：
```cc
template <typename charT, typename traits>
std::basic_ostream<charT, traits> & std::endl(std::basic_ostream<charT, traits> &strm) {
    strm.put(strm.widen('\n'));
    strm.flush();
    return strm;
}
```
成员函数 widen()用来将换行符转换成当前stream所用的字符.

C++标准库也提供了一些带参数的操控器，其运作方式视实现版本而定。
目前并无任何标准规范如何实现“带参数的用户自定义操控器”。

### 用户自定义的操控器
我们可以定义自己的操控器，所需做的不过是写一个像endl()一样的函数。例如以下函数定义了一个操控器，将end-of-line之前的所有字符（即当前一行的剩余部分）忽略掉：
```cc
#include <istream>
#include <limits>

template <typename charT, typename traits>
inline
std::basic_istream<charT, traits>&
ignoreLine (std::basic_istream<charT, traits>& strm)
{
    // skip until end-of-line
    strm.ignore(std::numeric_limits<std::streamsize>::max(),
                strm.widen('\n'));

    // return stream for concatenation
    return strm;
}
```
这个操控器简单地把任务交给函数ignore()去完成，这便会忽略end-of-line之前的所有字符.

这个操控器用起来很简单：
```cc
std::cin >> ignoreLine;
```
如果想忽略若干行，就多用几次：
```cc
std::cin >> ignoreLine >> ignoreLine;
```
这样之所以能够有效运作，乃是因为函数ignore（max，c）会略去input stream内“字符c之前的所有字符”
（如果c之前的字符多于max个，就略去max个字符；如果先遇到stream结尾，就全部忽略之）。字符c也会一并被忽略。

如前所述，有多种做法可以定义你自己的“带实参的操控器”。例如下面的代码就可以忽略n行：
```cc
#include <istream>
#include <limits>

class ignoreLine
{
private:
    int num;

public:
    explicit ignoreLine (int n=1) : num(n) {
    }

    template <typename charT, typename traits>
    friend std::basic_istream<charT, traits>&
    operator>> (std::basic_istream<charT, traits>& strm,
                const ignoreLine& ign)
    {
        // skip until end-of-line num times
        for (int i=0; i<ign.num; ++i) {
            strm.ignore(std::numeric_limits<std::streamsize>::max(),
                        strm.widen('\n'));
        }

        // return stream for concatenation
        return strm;
    }
};
```
此处的操控器ignoreLine是个class，初始化时接受一个实参，并重载了input操作符——令它针对此class之对象运作。

## 格式化（Formatting）
两个概念影响着I/O格式的定义：
最明显的是format flag（格式标志），它们可定义诸如数值精度、填充字符、进制（基底）等格式。
另一个概念是针对特定地域的习惯而调整格式（此即国际化议题）。

### Format Flag（格式标志）
Class ios_base提供数个成员，用来定义各种I/O格式，例如最小栏位宽度、浮点数精度、填充字符等。
成员中的类型ios::fmtflags用来存储configuration flag（配置标志），定义诸如“正数前是否加正号、Boolean以数字或文字方式打印”等选项。

某些flag甚至形成分组，例如用于整数八进制、十进制和十六进制的各个相应flag。使用特定的mask（屏蔽）便可轻松处理此类分组。

“用以访问Format Flag”的成员函数
以下是提取的表格内容，输出为 Markdown 格式：

| 成员函数       | 意义                                                         |
| -------------- | ------------------------------------------------------------ |
| `setf(flags)`    | 添设额外的 `flags` flag，返回所有 flag 的先前状态          |
| `setf(flags, grp)` | 添设分组 `grp` 中的 `flags` flag，返回所有 flag 的先前状态 |
| `unsetf(flags)`   | 清除 `flags`                                                 |
| `flags()`         | 返回所有目前设置的 format flag                              |
| `flags(flags)`    | 将 `flags` 设为新的 flag，返回所有 flag 的先前状态          |
| `copyfmt(stream)` | 从 `stream` 中复制所有的格式定义                             |

表所列的成员函数用于处理stream的所有格式定义。函数setf()和unsetf()分别设置和清除一或多个flag。
二元操作符“or”（也就是operator|）可将多个flag合并，从而一次操控多个flag。
函数setf()以第二实参作为mask（屏蔽），清除其所标示的所有flag，然后设置第一实参所代表的flag。
单实参版本的setf()则稍有不同。下面是运用实例：
```cc
cout.setf(std::ios::showpos | std::ios::uppercase);
// set only the flag hex in the group basefield
cout.setf(std::ios::hex , std::ios::basefield);
cout.unsetf(std::ios::uppercase);
```
使用flags()，我们得以一次操控所有format flag。
无参数的flags()会返回当前的format flag；
如果传给 flags() 一个实参，便以该实参作为所有 format flag 的新状态，并返回先前状态。
因此，带有一个实参的 flags()会清除所有flag，并将状态设置如同传入值。
flags()相当有用，例如可用以存储当前flag状态，适当时机再恢复。下面是个例子：
```cc
ios::fmtflags oldFlags = cout.flags();

cout.setf(ios::showpos | ios::showbase | ios::uppercase);
cout.setf(ios::internal | ios::adjustfield);
cout << std::hex << x << endl;

cout.flags(oldFlags);
```
copyfmt()可将stream的所有格式信息复制给另一个stream

表中的操控器也可用于设置和清除format flag。

用于“访问Format Flag”的两个操控器（Manipulator）
以下是提取的表格内容，输出为 Markdown 格式：

| 操控器              | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| `setiosflags(flags)` | 将 `flags` 设为 format flag（将会调用相应之 stream 的 `setf(flags)`） |
| `resetiosflags(mask)` | 清除 `mask` 所标示的一组 flag（将会调用相应之 stream 的 `setf(0, mask)`） |

操控器 setiosflags()或 resetiosflags()让我们得以在一个写语句（搭配operator <<）或读语句（搭配 operator >>）中设置或清除 flag。
欲使用这些操控器，首先必须包含＜iomanip＞，例如：
```cc
#include <iostream>
#include <iomanip>
...
cout << resetiosflags(std::ios::adjustfield) // clear adjustm flags
     << setiosflags(std::ios::left); // left-adjust value
```
某些“flag操控”可由专门的操控器完成，更方便更易读。下一节对此有详细讨论。

### Boolean的I/O格式
Flag boolalpha定义了Boolean的读/写格式：数字或文本。

用于“Boolean表示法”的Flag
以下是提取的表格内容，输出为 Markdown 格式：

| Flag      | 意义                                                 |
| --------- | ---------------------------------------------------- |
| `boolalpha` | 若被设置，便以文本表示，否则以数字表示 |

如果此flag未被设置（默认如此），Boolean便以数字表示：false始终是0，true始终是1。
如果以数字方式读入Boolean时遭遇0和1以外的数，就会出错（会设置stream身上的failbit）。

如果此flag被设置，Boolean便以文本表示。读入的字符串须为 true或false，其实际表述法还和stream locale对象有关。
标准的＂C＂locale对象使用字符串＂true＂和＂false＂来表示Boolean。

为了更方便操控这个flag，标准库还专门定义了两个操控器，见表。

用于“Boolean表示法”的操控器（Manipulator）
以下是提取的表格内容，输出为 Markdown 格式：

| 操控器      | 意义                                                 |
| ----------- | ---------------------------------------------------- |
| `boolalpha`  | 强制使用文本表示法（将会设置 `ios::boolalpha`）      |
| `noboolalpha` | 强制使用数字表示法（将会清除 flag `ios::boolalpha`） |

例如，下面的语句先后以数字和文本表示法来打印b：
```cc
bool b;
...
cout << std::noboolalpha << b << "=="
    << std::boolalpha << b << endl;
```

### 栏位宽度、填充字符、位置调整
成员函数width()和fill()分别用来定义栏位宽度和填充字符

用以设定和取得“栏位宽度”和“填充字符”的成员函数
以下是提取的表格内容，输出为 Markdown 格式：

| 成员函数    | 意义                                                 |
| ----------- | ---------------------------------------------------- |
| `width()`    | 返回当前的栏位宽度                                   |
| `width(val)` | 设置 `val` 为当前栏位宽度，并返回先前的栏位宽度       |
| `fill()`     | 返回当前的填充字符                                   |
| `fill(c)`    | 定义 `c` 为当前的填充字符，并返回先前的填充字符       |

在Output动作中使用栏位宽度、填充字符和位置调整对 output，width() 定义了最小栏位，该定义只应用于下一次格式化输出。
无参数的width() 会返回当前栏位宽度；如果传入一个整数，则可改变栏位宽度并返回先前宽度。
最小栏位宽度的默认值为 0，这意味着栏位可为任意长——任何一个数值被输出后栏位宽度值将恢复为 0（因为稍早才说过，栏位宽度的设定只到下一次格式化输出）。

请注意，栏位宽度从来不是被用来“将输出截断”。因此你无法指定一个“最大栏位宽度”。
如果你需要类似功能，应该自己写点程序，例如将运算结果写入一个string，再按需求决定输出的字符数。

成员函数fill()定义了用来填充“格式化表述”和最小栏位之间的填充字符。默认的填充字符是空格（space）。

有三个flag用来在栏位中对齐数值，如表所列。它们和相应的mask（屏蔽）均定义于class ios_base中。

用来“在栏位中对齐数值”的若干Mask（屏蔽）
| Mask（屏蔽） | Flag（屏蔽） | 意义                             |
| ------------ | ------------ | -------------------------------- |
| adjustfield  | left         | 靠左对齐                         |
|              | right        | 靠右对齐                         |
|              | internal     | 正负号靠左对齐，数值靠右对齐     |
|              | 无           | 靠右对齐（这是默认情况）         |

表显示了将上述函数和flag用于各种数值后的效果。填充字符为下画线（underscore）_。

位置调整实例
| 位置调整 | width() | -42    | 0.12   | "Q"    | 'Q'    |
| -------- | ------- | ------ | ------ | ------ | ------ |
| left     | 6       | -42___ | 0.12__ | Q_____ | Q_____ |
| right    | 6       | ___-42 | __0.12 | _____Q | _____Q |
| internal | 6       | -___42 | __0.12 | _____Q | _____Q |

执行了任何格式化I/O操作后，栏位宽度都会恢复为默认值；填充字符和位置调整方式不变，除非你明白地对它们做了修改。

C++标准库定义了数个操控器，用以处理栏位宽度、填充字符和位置调整。

用于“位置调整”的操控器（Manipulator）
| 操控器    | 意义                                   |
| --------- | -------------------------------------- |
| setw(val) | 令 val 为 I/O 栏位宽度，相当于 width() |
| setfill(c)| 将 c 定义为填充字符，相当于 fill()     |
| left      | 靠左对齐                               |
| right     | 靠右对齐                               |
| internal  | 正负号靠左对齐，数值靠右对齐           |

操控器setw()和setfill()需要一个实参，所以使用前必须先包含头文件＜iomanip＞。例如：
```cc
#include <iostream>
#include <iomanip>
...
cout << setw(8) << setfill('_') << -3.14 << ' ' << 42 << endl;
cout << setw(8) << "sum: " << setw(8) << 42 << endl;
```

输出结果如下：
```bash
___-3.14 42
___sum: ______42
```
### Input时使用栏位宽度
读入类型为char*的字符序列时，我们也可以运用栏位宽度来定义读取的最大字符数。
如果width()不是0，最多读取width()-1个字符。

由于一般C-string在读取时无法增长空间，所以当以操作符>>进行读取时，应该总是使用width()或setw()，例如：
```cc
char buf[81];
cin >> setw(sizeof(buf)) >> buf;
```
以上最多能读入80个字符，虽然sizeof（buffer）是81，但终止符null占一个字符（这是被自动添加上去的）。注意，下面是常见的错误：
```cc
char *s;
cin >> setw(sizeof(s)) >> s;
```
这是因为 s只是被声明为一个pointer，并无实际的存储空间。sizeof（s）仅仅是pointer大小，而非它所指的存储空间的大小。这是C-string的一个典型错误运用。如果使用string就不会遇到这类麻烦：
```cc
string s;
cin >> s;
```
### 正号与大写
两个format flag showpos和uppercase用来改变数值的一般表述：

影响“数值的正负号和字母大小写”的两个Flag
| Flag      | 意义                              |
| --------- | --------------------------------- |
| `showpos`  | 在正数前加上正号（positive sign） |
| `uppercase` | 使用大写字母                      |

ios::showpos规定必须打印出正数前的正号。
如果没有设置这个flag，那就只有负数之前会加上负号。
ios::uppercase规定数值中的字母采用大写；
此flag可用于“十六进位格式表述”的整数，以及“科学记号表述”的浮点数。
默认情况下字母为小写并省略正号。例如以下语句：
```cc
cout << 12345678.9 << endl;
cout.setf(std::ios::showpos | std::ios::uppercase);
cout << 12345678.9 << endl;
```
输出
```bash
1.234567e+07
+1.234567E+07
```
表的操控器可以设置或清除上述两个flag。

用来“操控数值正负号和字母大小写”的操控器（Manipulator）
| 操控器     | 意义                                      |
| ---------- | ----------------------------------------- |
| showpos    | 强制输出正数前的正号（也就是设置 ios::showpos）   |
| noshowpos  | 强制省略正数前的正号（也就是清除 ios::showpos）   |
| uppercase  | 强制字母大写（也就是设置 ios::uppercase）         |
| nouppercase| 强制字母小写（也就是清除 ios::uppercase）         |

### 数值基数（Numeric Base）
有一组（共三个） flag 用来设定I/O 的整数进制。它们和相应的mask （屏蔽）都定义于ios_base.

用来“定义整数进制”的若干Flag
| 屏蔽（Mask） | 标志（Flag） | 意义                                                 |
| ------------ | ------------ | ---------------------------------------------------- |
| basefield    | oct          | 以八进制进行读/写                                     |
|              | dec          | 以十进制进行读/写（这是默认情况）                     |
|              | hex          | 以十六进制进行读/写                                   |
|              | 无           | 以十进制输出，读取时则视起始字符而决定进制             |

进制被改变后，除非重新设置相关flag，会持续应用于后续的整数处理过程。
默认情况下使用十进制。
IOStream并不支持二进制，不过可借助class bitset以二进制方式读/写整数值.

如果没有设置上述任何flag，或同时设置了上述多个flag，输出时便采用十进制。

进制flag也会影响input。如果设置了上述任何一个进制flag，读得的所有数字便按该进制处理。
如果没有设置任何进制flag，则由起始字符决定进制：以0x或0X起始的是十六进制，以0起始的是八进制，其余被视为十进制数字。

两种方法可以切换上述flag：

1.清除某个flag，然后设置另一个：
```cc
cout.unsetf(std::ios::dec);
cout.setf(std::ios::hex);
```
2.设置某个flag，同时自动清理同组的其他flag：
```cc
cout.setf(ios::hex, ios::basefield);
```

此外另有一些操控器，可以简化flag的处理.

用来“定义整数进制”的一些操控器（Manipulator）
| 操控器 | 意义                     |
| ------ | ------------------------ |
| oct    | 以八进制进行读/写         |
| dec    | 以十进制进行读/写         |
| hex    | 以十六进制进行读/写       |

例如以下语句以十六进制输出x和y，以十进制输出z：
```cc
int x, y, z;
...
cout << std::hex << x << endl;
cout << y << " " << std::dec << z << endl;
```

另一个flag showbase可以C/C++惯例（如下所述）显示数值进制.

“用来显示数值进制”的Flag
| Flag（标志） | 意义                             |
| ------------ | -------------------------------- |
| showbase     | 如果设置，就显示数值的进制       |

如果设置了ios::showbase，八进制数字将以0开头，十六进制数字以0x开头（如果同时设置了ios::uppercase，则以OX开头）。例如以下语句：
```cc
std::cout << 127 <<'' << 255 << std::endl;

std::cout << std::hex << 127 <<'' << 255 << std::endl;

std::cout.setf(std::ios::showbase);
std::cout << 127 <<'' << 255 << std::endl;

std::cout.setf(std::ios::uppercase);
std::cout << 127 <<'' << 255 << std::endl;
```
输出如下：
```bash
输出如下:
127 255
7f ff
0x7f 0xff
0X7F 0XFF
```
表的操控器也可以用来操控ios::showbase。

用来“显示数值进制”的操控器（Manipulator）
| 操控器     | 意义                                                 |
| ---------- | ---------------------------------------------------- |
| showbase   | 显示数值进制（也就是设置 flag ios::showbase）         |
| noshowbase | 不显示数值进制（也就是清除 flag ios::showbase）       |

### 浮点数（Floating-Point）表示法
有若干stream flag和stream成员可用来控制浮点数的输出。
表的flag可决定输出时采用小数或科学记号。
它们和相应的mask（屏蔽）一起定义于class ios_base内。
如果设置ios::fixed，浮点数将以小数表示；如果设置ios::scientific，则以科学记号（指数方式）表示。

用于“浮点数表述法”的若干Flag
| Mask（屏蔽） | Flag（标志）      | 意义                                                 |
| ------------ | ----------------- | ---------------------------------------------------- |
| floatfield   | fixed             | 使用小数记数法                                       |
|              | scientific        | 使用科学记数法                                       |
|              | none              | 使用上述两者中最适合者（这是默认情况）               |
|              | fixedscientific   | 十六进制科学记数法（始自 C++11）                     |

自C++11开始，这可用来定义一个十六进制的科学记数法，这种表示法也可以在调用printf()时使用格式指定器%a获得：表示十六进制的2的幂（power of 2）。

Flag showpoint 强制 stream 写出小数点和尾部的 0，直到当前精度完全展现。

“强制显示小数点”的Flag
| Flag（标志） | 意义                                   |
| ------------ | -------------------------------------- |
| showpoint    | 总是出现小数点，并以 0 填充尾部         |

成员函数precision()用来定义精度。

用来“决定浮点数显示精度”的成员函数
| 成员函数           | 意义                                   |
| ------------------ | -------------------------------------- |
| `precision()`       | 返回当前的浮点数精度                   |
| `precision(val)`    | 令 `val` 为新的浮点数精度，并返回原设定值 |

如果使用科学记数法，precision()定义出小数位数，余数四舍五入而非直接截断。
无参数的precision()会返回当前精度；
但如果调用它时传入一个实参，则以传入值为新精度，并返回原精度。默认精度是6个十进制位（six decimal places）。

默认情况下，ios::fixed和ios::scientific均未被设置，这时使用的记数法取决于被输出值。
所有数值都有意义，但至多只能输出“precision()个”十进制位数，形式如下：
小数点之前有一个前导0，然后是所有必要的0。如果“precision()个”十进制位已足够表现，那么就使用十进制表示法，否则使用科学记号表示法。

表以两个具体数值为例，说明了标志和精度之间稍嫌复杂的相依关系。

对整数而言，ios::showpos可用来写出正号，ios::uppercase可用来指定科学记数法中使用大写E或小写e。

浮点数格式化实例
| 类别          | `precision()` | 4210        | 0.0123456789 |
| ------------- | ------------- | ----------- | ------------ |
| 一般情况(Normal) | 2             | 4.2e+02     | 0.012        |
|               | 6             | 421         | 0.012346     |
| 带有 showpoint  | 2             | 4.2e+02     | 0.012        |
|               | 6             | 421.000     | 0.012346     |
| fixed          | 2             | 421.00      | 0.01         |
|               | 6             | 421.000000  | 0.012346     |
| scientific     | 2             | 4.21e+02    | 1.23e-02     |
|               | 6             | 4.210000e+02| 1.234568e-02 |
| fixedscientific| 2             | 0x1.abp+8   | 0x1.95p-7    |
|               | 6             | 0x1.a50000p+8|0x1.948b10p-7 |

表的操控器可用来改变标志ios：：showpoint、记数法和精度。

用于“浮点数输出形式”的操控器
| 操控器          | 意义                                                 |
| --------------- | ---------------------------------------------------- |
| `showpoint`      | 总是输出小数点（也就是设置 flag ios::showpoint）      |
| `noshowpoint`    | 不需要小数点（也就是清除 flag ios::showpoint）        |
| `setprecision(val)` | 以 `val` 为新精度                                     |
| `fixed`          | 使用小数记数法                                       |
| `scientific`     | 使用科学记数法                                       |
| `hexfloat`       | 使用十六进制科学记号表示法（始自 C++11）              |
| `defaultfloat`   | 使用 normal 表示法，也就是清除 flag floatfield（始自 C++11） |

例如：
```cc
cout << std::scientific << std::showpoint
        << std::setprecision(8)
        << 0.123456789 << endl;
```
会产生以下输出：
```bash
1.23456789e-01
```
注意，setprecision()是带有实参的操控器，所以使用前必须先包含＜iomanip＞。

#### 一般格式（General Formatting）定义
剩下两个format flag还没介绍：skipws和unitbuf。

剩余的Formatting Flag
| Flag（标志） | 意义                                                 |
| ------------ | ---------------------------------------------------- |
| `skipws`      | 调用 `>>` 读取数值时，自动跳过起始的空白字符           |
| `unitbuf`     | 每次输出后，刷清 output 缓冲区                       |
| `nounitbuf`   | 每次输出后，不刷清 output 缓冲区（默认情况）           |

默认情况下ios::skipws会被设置，意味着读取数值时会跳过起始的（前导的）空白字符（whitespace）。
这通常很有用，因为数字间的空格（space）不需读取。不过这也意味着我们不能以>>读取空格（space），因为它们都被跳过了。

ios::unitbuf用来控制output缓冲区。如果它被设置，就不使用缓冲设备，每次写出后均刷清（flush）缓冲区。
默认情况下并未设置此flag，不过cerr和wcerr倒是预先设置了它。

上述两个flag也可由表的操控器控制之。

“对应于表15.29 Formatting Flag”的操控器（Manipulator）
| 操控器     | 意义                                                 |
| ---------- | ---------------------------------------------------- |
| `skipws`    | 调用 `>>` 时，跳过起始空白字符（亦即设置 flag ios::skipws） |
| `noskipws`  | 调用 `>>` 时，不跳过起始空白字符（亦即清除 flag ios::skipws） |
| `unitbuf`   | 每次写后，刷清 output 缓冲区（亦即设置 flag ios::unitbuf） |
| `nounitbuf` | 每次写后，不刷清 output 缓冲区（亦即清除 flag ios::unitbuf） |

## 国际化（Internationalization）
我们可以让I/O格式更符合各国家、地域、人民的习惯。为此，class ios_base定义了数个成员函数，见表.

“用于国际化”的成员函数
| 成员函数     | 意义                                   |
| ------------ | -------------------------------------- |
| `imbue(loc)`  | 设置 locale 对象                        |
| `getloc()`    | 返回当前的 locale 对象                  |

每个stream都使用某个相关locale对象。
默认情况下stream构造时会复制全局locale对象作为自己的locale对象。
Locale对象中定义有数字格式化细节，例如以哪一个字符作为小数点、以什么文本表示Boolean等。

和C的本地化（localization）设施相比，现在我们可为每个stream单独分配一个locale对象。
这样的功能很有用，例如我们可以采用美国格式读入一个浮点数，再以德国格式写出（德文的小数点是个逗号）。

某些字符（主要是一些特殊字符）常常为相应之stream字符集所需要。为此，stream提供了数个转换函数，如表所列。

“用于字符国际化”的两个Stream函数
| 成员函数          | 意义                                                 |
| ----------------- | ---------------------------------------------------- |
| `widen(c)`         | 把 `char` 类型的字符 `c` 转换为 stream 字符集内的字符  |
| `narrow(c, def)`   | 把 stream 字符集内的字符 `c` 转换为一个 `char` 字符（如果无对应的字符，则返回 `def`） |

例如，为了得到stream strm字符集内的换行符，可以这么办：
```cc
strm.widen('\n');
```

## 文件访问（File Access）
Stream可用来访问文件。本节讨论其所提供的相应性质。

### File Stream Class
C++标准库提供了四个class template，并预先定义了四个标准特化版本：
- 1.Template class basic_ifstream<>及其特化版本ifstream和wifstream，用来读取文件（是一种“input file stream”）。
- 2.Template class basic_ofstream<>及其特化版本ofstream和wofstream，用来将数据写至文件（是一种“output file stream”）。
- 3.Template class basic_fstream<>及其特化版本fstream和wfstream，用于读/写文件。
- 4.Template class basic_filebuf<>及其特化版本filebuf和wfilebuf，被其他file stream class用来进行实际的字符读/写工作。

这些class和stream base class的关系如图所示。这些class都被声明于头文件＜fstream＞，如下所示：

File Stream Class层次体系



                      ios_base                            basic_streambuf<>
                           ▲                              streambuf/wstreambuf
                           │                                      ▲
                           │                                      │
                      basic_ios<>                                 │
                      ios/wios                                    │
                           ▲                              basic_filebuf<>
             ┌─────────────┴──────────┐                   filebuf/wfilebuf
             │                        │
      basic_istream<>          basic_ostream<>
      istream/wistream         ostream/wostream
          ▲      ▲                  ▲     ▲
          │      └─────────┬────────┘     │
          │                │              │
          │           basic_iostream<>    │
          │           iostream/wiostream  │
          │                ▲              │
          │                │              │
          │                │              │
      basic_ifstream<>     │   basic_ofstream<>
      ifstream/wifstream   │   ofstream/wofstream
                           │
                           │
                     baisc_fstream<>
                     fstream/wfstream

和C的文件访问机制相比，C++file stream class的最大好处就是文件的自动管理。文件可在构造时期自动打开，析构时期自动关闭。这当然是因为定义了适当的构造函数和析构函数。

注意，对于可读又可写的stream，我们不能在读/写动作之间任意转换其读/写属性！
一旦开始读或写，如果一定需要转换，怎么办呢？必须进行一个seek动作，到达当前位置，再转换读/写属性。
唯一例外是，如果已经读到end-of-file，可立即接着写入字符。如果违背上述规则，可能导致各式各样稀奇古怪的结果。

如果file stream对象以某个C-string（char*类型）为构造函数实参，便会自动打开该string代表的文件，用于读和（或）写。
成功与否会反映在stream状态中。因此我们应该在构造stream之后检查其状态。

以下程序会打开文件charset.out，写入当前字符集（数值32～255的所有字符）：
```cc
// io/fstream1.cpp
#include <string>     // for strings
#include <iostream>   // for I/O
#include <fstream>    // for file I/O
#include <iomanip>    // for setw()
#include <cstdlib>    // for exit()
using namespace std;

// forward declarations
void writeCharsetToFile (const string& filename);
void outputFile (const string& filename);

int main ()
{
    writeCharsetToFile("charset.out");
    outputFile("charset.out");
}

void writeCharsetToFile (const string& filename)
{
    // open output file
    ofstream file(filename);

    // file opened?
    if (!file) {
        // NO, abort program
        cerr << "can't open output file \"" << filename << "\""
             << endl;
        exit(EXIT_FAILURE);
    }

    // write character set
    for (int i=32; i<256; ++i) {
        file << "value: " << setw(3) << i << "  "
             << "char:  " << static_cast<char>(i) << endl;
    }
    // closes file automatically
}

void outputFile (const string& filename)
{
    // open input file
    ifstream file(filename);

    // file opened?
    if (!file) {
        // NO, abort program
        cerr << "can't open input file \"" << filename << "\""
             << endl;
        exit(EXIT_FAILURE);
    }

    // copy file contents to cout
    char c;
    while (file.get(c)) {
        cout.put(c);
    }
    // closes file automatically
}
```
在writeCharsetToFile()函数中，class ofstream的构造函数把收到的string当作文件名称，打开它：
```cc
    ofstream file(filename);
```
接下来，确定stream是否处于良好状态：
```cc
if (! file) {
    ...
}
```
如果先前未能成功打开 stream，上述测试就会失败。测试成功后便以一个循环打印出32～255的数值及相应字符。

在outputFile()函数中，class ifstream的构造函数将input文件打开，然后将该文件内容一个字符一个字符地输出到cout。

上述两个函数结束时，其内的stream class对象会离开作用域（scope），被自动调用的ifstream析构函数和ofstream析构函数会关闭它们所开启的文件。

除了将文件中的字符逐一复制，我们还可以使用单一语句输出所有内容：将一个“指向file stream缓冲区”的pointer当作实参传给operator<<.
```cc
// 拷贝文件内容到cout
cout << file.rdbuf();
```

### File Stream的Rvalue和Move语义
自C++11开始，file stream提供了rvalue和move语义。
事实上ostream提供了一个output操作符而istream提供了一个input iterator，可接受一个指向stream的rvalue reference。
其影响是，如今你可以使用临时创建的stream对象，它们的行为一如预期。
例如你可以写至一个临时创建出来的file stream：
```cc
#include <iostream>
#include <fstream>
#include <string>

int main()
{
    // write string to a temporarily created file stream (since C++11)
    std::string s("hello");
    std::ofstream("fstream2.tmp") << s << std::endl;

    // write C-string to a temporarily created file stream
    // - NOTE: wrote a pointer value before C++11
    std::ofstream("fstream2.tmp", std::ios::app) << "world" << std::endl;
}
```
自C++11起，以上代码会把＂hello＂和＂world＂写至文件＂fstream2.tmp＂。

此外，file stream 如今有了 move 和 swap 语义，它提供一个 move 构造函数、一个 move assignment 操作符以及 swap()。
因此，你可以传一个 file stream 作为函数实参，或让某个函数返回一个file stream。
例如，假设有个file被使用乃是超过其“被创建时的作用域（scope）”，
那么C++11之后你可以这样返回它:
```cc
std::ofstream openFile (const std::string& filename)
{
    std::ofstream file(filename);
    ...
    return file;
}

std::ofstream file;
file = openFile("xyz.tmp");            // use returned file stream (since C++11)
file << "hello, world" << std::endl;
```

### File Flag（文件标志）
为了准确控制文件处理模式，class ios_base 定义了一组flag ，其类型都是openmode，这是类似fmtflags的一种bitmask（位屏蔽）类型：

用于“打开文件”的Flag
| Flag（标志） | 意义                                                 |
| ------------ | ---------------------------------------------------- |
| `in`          | 打开，用于读取（这是 `ifstream` 的默认模式）           |
| `out`         | 打开，用于涂写（这是 `ofstream` 的默认模式）           |
| `app`         | 涂写时始终添加于尾端                                   |
| `ate`         | 开启文件后令读/写位置移至文件尾端（flag 名称就是 “at end” 之意） |
| `trunc`       | 将先前的文件内容移除（remove）                         |
| `binary`      | 不要替换特殊字符                                       |

binary flag使得stream能够封锁特殊字符或特殊字符序列（例如end-of-line或end-of-file）的转换。
某些操作系统（例如Windows或OS/2）的文本文件，每一行结束时以两个字符（CR和LF）为记号。
正常模式下（未设置binary）进行读或写，newline（换行）字符会被上述两个字符替换，反之亦然。
如果处于二进制模式（设置了binary），就不会进行这样的转换。

如果文件内容是二进制数据而非字符序列，你应该设置binary。
例如复制文件，将来源端的文件字符逐一读入，不做任何修改地写至目标文件。
但如果将文件当作文本处理，则不应设置binary，因为此时需要特别处理换行符，改为两个字符。

某些实现版本还提供额外的flag，例如nocreate（“开启时文件必须存在”）和noreplace （“开启时文件必须不存在”）。
不过这些flag都不是标准规格的一部分，也不具可移植性。

这些flag可用操作符|组合起来，最终的openmode可作为构造函数的第二实参（此实参可有可无）。
例如以下语句以追加（appending）方式打开文件：
```cc
ofstream file("1.out", std::ios::out | std::ios::app);
```

表展示了“C++flag组合”和“C文件开启函数fopen()所使用之字符串”之间的关联。
Flag binary和ate的组合没有列出。是的，设置binary相当于在接口字符串末尾添加一个b，设置ate则相当于打开文件后立即跳至文件尾端。
其他未列于表15.34的组合，例如trunc|app，是不允许存在的。
C++11之前并未详细叙述app、in|app和in|out|app。

C++的“文件开启模式”的意义
| `ios_base` Flag | 意义                                                 | C 模式 |
| --------------- | ---------------------------------------------------- | ------ |
| `in`             | 读取（来源文件必须存在）                             | `"r"`  |
| `out`            | 清空而后涂写（有必要才创建）                         | `"w"`  |
| `out trunc`      | 清空而后涂写（有必要才创建）                         | `"w"`  |
| `out app`        | 追加（有必要才创建）                                 | `"a"`  |
| `app`            | 追加（有必要才创建）                                 | `"a"`  |
| `in out`         | 读和写；最初位置在起点（文件必须存在）               | `"r+"` |
| `in out trunc`   | 先清空，再读/写（有必要才创建）                       | `"w+"` |
| `in app`         | 在尾端更新（有必要才创建）                           | `"a+"` |
| `in out app`     | 在尾端更新（有必要才创建）                           | `"a+"` |

究竟文件是为 read而开或是为 write而开，这和相应的stream object class无关——该class只是在第二实参缺席的情况下定义出默认的开启模式。
这意味着只有被ifstream或ofstream使用的文件，才能用于read或write。
开启模式被传递给相应的stream buffer class，后者才是真正打开文件的。
然而，可能作用于对象身上的操作，则是由stream class决定。

File stream所拥有的文件也可以被明白地（explicitly）开启或关闭。
为此，C++standard定义了三个成员函数。
这些函数之所以有用，大部分是因为file stream创建时未被初始化。

用于“打开或关闭文件”的成员函数
| 成员函数         | 意义                             |
| ---------------- | -------------------------------- |
| `open(name)`      | 以默认模式打开 file stream       |
| `open(name,flags)` | 以 `flags` 模式打开 file stream  |
| `close()`         | 关闭 stream file                 |
| `is_open()`       | 判断文件是否被打开               |

为了示范它们的用法，下面的程序首先打开所有文件（文件名由实参指定），然后将其内容写出（相当于UNIX系统中的cat程序）。
```cc
// header files for file I/O
#include <fstream>
#include <iostream>
using namespace std;

// for all filenames passed as command-line arguments
// - open, print contents, and close file
int main (int argc, char* argv[])
{
    ifstream file;

    // for all command-line arguments
    for (int i=1; i<argc; ++i) {

        // open file
        file.open(argv[i]);

        // write file contents to cout
        char c;
        while (file.get(c)) {
            cout.put(c);
        }

        // clear eofbit and failbit set due to end-of-file
        file.clear();

        // close file
        file.close();
    }
}
```

注意，处理过文件之后，必须调用clear()清除当时被设于文件尾端的state flag。
这是必要的，因为这个stream对象由多个文件共享。
open()并不会清除任何state flag，因此，如果某个stream未处于良好状态，关闭并重新打开之后你还是必须调用clear()以取得一个良好状态。
即使你通过它开启另一个文件，情况也一样。

你也可以不采取“字符逐一处理”方式，改以单独一个语句打印整个内容，做法是将一个指向file stream缓冲区的pointer当作实参传给operator<<，如下：
```cc
cout << file.rdbuf();
```

### 随机访问（Random Access）
用于“Stream读/写位置”的成员函数
| Class             | 成员函数              | 意义                     |
| ----------------- | --------------------- | ------------------------ |
| `basic_istream<>`  | `tellg()`             | 返回读取位置             |
|                   | `seekg(pos)`          | 设置“绝对读取位置”       |
|                   | `seekg(offset, rpos)` | 设置“相对读取位置”       |
| `basic_ostream<>`  | `tellp()`             | 返回写入位置             |
|                   | `seekp(pos)`          | 设置“绝对写入位置”       |
|                   | `seekp(offset, rpos)` | 设置“相对写入位置”       |

表列出的成员函数，用来为C++stream确定读/写位置。这些函数以特殊的字尾区隔读或写（g表示get，p表示put）。
“用于read”的位置相关函数定义于basic_istream<>，而“用于write”的位置相关函数定义于basic_ostream<>。
并不是所有stream class都支持读/写定位，例如stream cin、cout和cerr就不支持。
File stream的定位函数之所以定义于base class内是因为它们总是会收到一个reference指向类型为istream或ostream的对象。

函数seekg()和seekp()可接受一个绝对位置或一个相对位置。
为了运用绝对位置，你必须用到 tellg()和 tellp()，它们都返回一个类型为 pos_type的绝对位置。
这个值并不是整数或一个形同索引的字符位置。这是因为逻辑位置和实际位置可能不同。
例如在Windows文本文件中newline是以两个字符表现，而在逻辑视角它只是一个字符。
如果文件以某种多字节（multibyte）来表现字符，情况会变得更糟。

pos_type的精确定义有点复杂：
C++标准库针对文件位置定义了一个全局性的class template fpos<>。
它被用来定义出streampos类型（针对char stream）和wstreampos类型（针对 wchar_t stream），这些类型被用来定义相应之char trait中的pos_type。
Trait class中的pos_type成员被用来定义相应的stream class的pos_type。
因此，你也可以使用streampos作为 stream的位置类型。
使用long或unsigned long则是错误的，因为 streampos无论如何不是个整数类型。
下面是运用实例：
```cc
// 获得当前位置
std::ios::pos_type pos = file.tellg();
...
// 定位到之前的位置
file.seekg(pos);
```
你可以将
```cc
std::ios::pos_type pos;
```
改为
```cc
std::streampos pos;
```
至于相对位置，偏移值（offset）可以和三个位置相关，如表所列。这些常量定义于class ios_base中，类型为seekdir。

用于“相对位置”的常量
| 常量 | 意义                                 |
| ---- | ------------------------------------ |
| beg  | 位置是相对于开头（beginning）而言   |
| cur  | 位置是相对于当前位置（current）而言 |
| end  | 位置是相对于结尾（end）而言         |

偏移值属于 off_type 类型，那是 streamoff 的一个间接定义。
和 pos_type 类似，streamoff被用来定义stream class和char trait的 off_type。
由于streamoff是一个带正负号的整数类型，所以你可以使用整数当作stream的偏移值。
例如：
```cc
// 移动到文件开头
file.seekg(0, std::ios::beg);
...
// 当前位置前移动20字符
file.seekg(20, std::ios::cur);
...
// 文件末尾后移动10字符
file.seekg(-10, std::ios::end);
```
不论哪一种情况，务请注意，读/写位置只在文件长度范围内有效。
如果某个位置在文件起头之前，或文件结尾之后，将导致不明确的行为。

下面的例子展示了seekg()的用法，以一个函数将文件内容写出两次：
```cc
// header files for file I/O
#include <iostream>
#include <fstream>
void printFileTwice (const char* filename)
{
    // open file
    std::ifstream file(filename);

    // print contents the first time
    std::cout << file.rdbuf();

    // seek to the beginning
    file.seekg(0);

    // print contents the second time
    std::cout << file.rdbuf();
}

int main (int argc, char* argv[])
{
    // print all files passed as a command-line argument twice
    for (int i=1; i<argc; ++i) {
        printFileTwice(argv[i]);
    }
}
```

注意，file.rdbuf() 被用来打印 file 内容。
此时你是直接操作 stream 缓冲区，并不会改变 stream 状态。
如果你通过 stream 接口函数（例如通过getline()）打印file内容，你必须先调用clear()清除file的状态——在它能够被任何方式处理之前（包括改变读取位置），
因为这些函数到达文件尾端时会设置ios::eofbit和ios::failbit。

“处理读/写位置”的函数有许多个，但对标准stream而言，同一个stream缓冲区内系以同一个位置指出（维护） reading位置和writing位置。
如果有多个stream共享同一个stream缓冲区，这一点便很值得注意。

### 使用文件描述器（File Descriptor）
某些实现版本提供这种可能性：将一个stream附着到一个已开启的I/O通道。
为了这么做，你必须以一个文件描述器（file descriptor）将file stream初始化。

文件描述器是个整数，用来辨识某个已开启的I/O通道。
在类UNIX操作系统中，文件描述器被用于低层接口：操作系统提供的I/O函数。
有三个文件描述器是预定义好的：
- 0代表标准输入通道（standard input channel）。
- 1代表标准输出通道（standard output channel）。
- 2代表标准错误信息通道（standard error channel）。

这些通道可能被连接至文件、控制台（console）、其他进程（process）或其他I/O设施。

很不幸，C++标准库并未提供“运用文件描述器将一个stream附着到某个I/O通道”的可能性。
这是因为这个语言被认为应该独立于任何操作系统。
事实上可能性依然存在，唯一的缺点是它们不具可移植性。
这里所缺乏的是一个存在于操作系统标准接口（例如POSIX或X/OPEN）上的相应规格。
这样的标准至今见不到曙光，但至少自C++11开始保留了posix这样一个命名空间。

不过，倒是有可能以一个文件描述器将某个stream初始化。

## 为String而设计的Stream Class
Stream class机制也可以用来读取string或将数据写至string。
String stream提供有缓冲区，但没有I/O通道；我们可以借着特殊函数来处理buffer/string。
这项技术的一个主要用途就是以“独立于真实I/O设备以外”的方式来处理I/O。
例如output的文字格式可以在string中设定，然后再将string发送至某个输出通道。
也可以逐行读取input，并以string stream处理每一行。

在C++98之前，string stream class使用类型 char*来表现一个string，现在则是使用string（或更泛化的basic_string＜＞）。旧式的string stream class仍然内含于C++标准库中，
但大家最好不要再使用。编写新程序时应该尽量少用它们，甚至老旧程序最好也能够将它们替换掉。不过本节末尾还是对这些老旧class做了扼要的描述。

### String Stream Class
下面是“针对string”（与“针对file”对应）而定义的stream class：
- basic_istringstream<>，以及特化版本 istringstream和 wistringstream，用于从string读取数据，是所谓的input string stream。
- basic_ostringstream<>，以及特化版本 ostringstream和 wostringstream，用于将数据写进string，是所谓的output string stream。
- basic_stringstream<>，以及特化版本stringstream和wstringstream，用于对string读/写数据。
- basic_stringbuf<>，以及特化版本stringbuf和wstringbuf，用来为其他string stream class执行字符的实际读/写动作。

这些class与stream base class之间的关系，就像file stream class与stream base class之间的关系一样。
图描绘了其间的继承体系。




                                                   ios_base
                                                       ▲                                                   basic_streambuf<>
                                                       │                                                   streambuf/wstreambuf
                                                   basic_ios<>                                                      ▲
                                                   ios/wios                                                         │
                                                       ▲                                                            │
                                                       │                                                            │
                                  ┌────────────────────┴──────────────────┐                                basic_stringbuf<>
                                  │               virtual                 │                                stringbuf/wstringbuf
                        basic_istream<>                             basic_ostream<>
                        istream/wistream                            ostream/wostream
                                      ▲                              ▲     ▲
                             ▲        └─────────────────┬────────────┘     │
                             │                          │                  │
                             │                     basic_iostream<>        │
                             │                     iostream/wiostream      │
                             │                          ▲                  │
                             │                          │                  │
                        basic_istringstream<>           │           basic_ostringstream<>
                        istringstream/wistringstream    │           ostringstream/wostringstream
                                                        │
                                                        │
                                                   basic_stringstream<>
                                                   stringstream/wstringstream
这些class统统声明于头文件＜sstream＞内：
```cc
namespace std {
    template <typename charT,
              typename traits = char_traits<charT>,
              typename Allocator = allocator<charT>>
    class basic_istringstream;
    typedef basic_istringstream<char> istringstream;
    typedef basic_istringstream<wchar_t> wistringstream;

    template <typename charT,
              typename traits = char_traits<charT>,
              typename Allocator = allocator<charT>>
    class basic_ostringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;

    template <typename charT,
              typename traits = char_traits<charT>,
              typename Allocator = allocator<charT>>
    class basic_stringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_stringstream<wchar_t> wstringstream;

    template <typename charT,
              typename traits = char_traits<charT>,
              typename Allocator = allocator<charT>>
    class basic_stringbuf;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_stringbuf<wchar_t> wstringbuf;
}
```
成员函数str()是string stream class最主要的一个函数，用来管理缓冲区.

String Stream的基础操作
| 成员函数     | 意义                             |
| ------------ | -------------------------------- |
| `str()`       | 将缓冲区内容当作一个 `string` 返回 |
| `str(string)` | 将 `string` 设为缓冲区内容         |

以下程序示范了如何使用string stream：
```cc
#include <iostream>
#include <sstream>
#include <bitset>
using namespace std;

int main()
{
    ostringstream os;

    // decimal and hexadecimal value
    os << "dec: " << 15 << hex << " hex: " << 15 << endl;
    cout << os.str() << endl;

    // append floating value and bitset
    bitset<15> b(5789);
    os << "float: " << 4.67 << " bitset: " << b << endl;
    // overwrite with octal value
    os.seekp(0);
    os << "oct: " << oct << 15;
    cout << os.str() << endl;
}
```
程序输出如下：
```bash
dec: 15 hex: f

oct: 17 hex: f
float: 4.67 bitset: 001011010011101
```
首先是一个十进制数和一个十六进制数写至 os，接下来增加一个浮点数和一个bitset。
然后运用seekp()将涂写位置设于stream起始处，这么一来后继的operator<<就把输出写到string头部，于是覆盖了原本的string stream头部内容。
未被覆盖的字符依然有效。如果你要删除stream的现有内容，可利用函数str()将崭新内容赋予缓冲区：
```cc
strim.str("")
```
最先写入os的文字行系以endl结尾，表示以换行符结束。由于打印string后紧跟着又输出endl，所以有两个相邻的新行符被写入，这也是输出文字中带有一个空行的原因。

在C++11之前，处理string stream时的一个典型的错误是：忘了使用str()提取string而直接往stream输出。
从编译器的角度看，这可接受并且合理，因为的确存在着一个转换动作可将实参转为 void*，于是stream的状态以地址形式被写出去。
来到了C++11，上述转换被一个显式转换（转为 bool）取代，于是，未先调用str()就把一个string stream传给operator<<不再可行。

“往output string stream写数据”的一个典型运用就是，定义“用户自定义类型”之output操作符.

Input string stream的主要用途是“格式化地从既有string中读取数据”。
例如我们可以轻易地逐行读取数据，然后分析每行数据。以下代码从string s中读得数值为 3的整数x，和数值为 0.7的浮点数f：
```cc
int x;
float f;
string s = "3.7";
istringstream is(s);
is >> x >> y;
```
创建string stream时，我们可以运用文件开启模式作为flag以及某个既有的string作为初值。如果使用ios::ate，写进string stream的字符便可附加于既有string之后：
```cc
string s("value: ");
...
ostringstream os(s, std::ios::out | std::ios::ate);
os << 77 << " " << std::hex << 77 << endl;
cout << os.str(); // write: value: 77 4d
cout << s; // write: value:
```
如你所见，str()返回的string是s的拷贝（副本）并尾附一个77十进制表述和一个77十六进制表述。字符串s本身并无改变。

### String Stream的Move语义
自C++11开始，string stream提供了rvalue和move语义。
事实上，ostream提供了一个output操作符，而istream提供了一个input iterator，可接受一个指向stream的rvalue reference。
其影响是，如今你可以使用临时创建的stream对象。例如你可以对一个临时创建出来的string stream执行安插动作：
```cc
#include <iostream>
#include <sstream>
#include <string>
#include <tuple>
#include <utility>
using namespace std;

tuple<string, string, string> parseName(string name)
{
    string s1, s2, s3;
    istringstream(name) >> s1 >> s2 >> s3;
    if (s3.empty()) {
        return tuple<string, string, string>(move(s1), "", move(s2));
    } else {
        return tuple<string, string, string>(move(s1), move(s2), move(s3));
    }
}

int main()
{
    auto t1 = parseName("Nicolai M. Josuttis");
    cout << "firstname: " << get<0>(t1) << endl;
    cout << "middle:    " << get<1>(t1) << endl;
    cout << "lastname:  " << get<2>(t1) << endl;
    auto t2 = parseName("Nico Josuttis");
    cout << "firstname: " << get<0>(t2) << endl;
    cout << "middle:    " << get<1>(t2) << endl;
    cout << "lastname:  " << get<2>(t2) << endl;
}
```
在C++11之前，你必须用
```cc
istringstream is(name);
is >> s1 >> s2 >> s3;
```
取代
```cc
istringstream(name) >> s1 >> s2 >> s3;
```
此外，string stream如今有了move和swap语义，它提供一个move构造函数、一个move assignment操作符以及swap()。
因此你可以传一个string stream作为函数实参，或让某个函数返回一个string stream。

### char＊Stream Class
char*stream class只是为了向后兼容才被保留下来。
它们的接口容易出错，不容易被正确使用。
但是既然曾经被广泛运用，所以这里还是为你做一个扼要介绍。
请注意这里所说的标准版本，已经对旧式接口做了一些修改。

本节采用术语字符序列而不说string。
因为 char*stream class所维护的字符序列并不总是以终止符null为结束，因此不能说它是一个真正的string。

char*stream class是特别为字符类型char而定义的，包括：
- Class istrstream，从字符序列中读取数据。是一种input string stream。
- Class ostrstream，将数据写入字符序列。是一种output string stream。
- Class strstream，对字符序列做读/写动作。
- Class strstreambuf，当作char*stream的缓冲区。

所有char*stream class都定义于头文件＜strstream＞。

istrstream的初始化有两种做法，一是“以终止符null 0为结尾”的字符序列，一是将字符数量当作实参传给构造函数。
istrstream的典型用途就是读取并处理一整行文字：
```cc
char buffer[1000];    // buffer for at most 999 characters

// read line
std::cin.get(buffer, sizeof(buffer));

// read/process line as stream
std::istrstream input(buffer);

...
input >> x;
```
“用于writing”的char*stream可包含一个应需求而扩展的字符序列，也可以在初始化时带一个定长缓冲区。
如果运用flag ios::app或ios::ate，可附加于缓冲区内既有的字符序列后面。

使用char*stream作为string时必须十分小心，因为它和string stream不同，它并不负责“字符序列所需的内存”。
利用成员函数str（），字符序列可以和其调用者一起共同管理内存。除非stream被初始化为定长缓冲区（这么一来stream就不必负责），否则必须遵守下面三条原则：
1.由于内存的拥有权转移给了调用者，所以如果stream未被初始化为定长缓冲区，那么字符序列将被释放。但我们无法确定内存如何被分配[17]，此情况下使用delete[]释放字符序列并不安全。最安全的做法是调用成员函数freeze（）并给予实参false，将内存还给stream（稍后有个实例）。
2.如果调用str（），stream便不能再修改字符序列。Stream会暗中调用成员函数freeze（），它会冻结字符序列。当缓冲区不够大以至于需要分配新缓冲区时，这么做可以避免事情变得复杂。
3.成员函数str（）不会附加终止符null（'\0'）。我们只有直接在stream内加上该特殊字符才能结束字符序列。这可通过操控器（manipulator） ends完成。某些实现版本会自动添加终止符null，但这种行为不具可移植性。

以下例子说明了char*stream的用法：
```cc
float x;
...
// create and fill char* stream
// - don't forget ends or '\0' !!!
std::ostrstream buffer;    // dynamic stream buffer
buffer << "float x: " << x << std::ends;
// pass resulting C-string to foo() and return memory to buffer
char* s = buffer.str();
foo(s);
buffer.freeze(false);
```
为了方便其他处理，被冻结的char*stream可以恢复其正常状态。要做到这一点，必须调用成员函数 freeze（）并传入实参 false。
这么一来字符序列的所有权就转给了stream对象。这也是释放字符序列内存的唯一安全做法。下面示范这个做法：
```cc
float x;
...
std::ostrstream buffer;    // dynamic char* stream

// fill char* stream
buffer << "float x: " << x << std::ends;

// pass resulting C-string to foo()
// - freezes the char* stream
foo(buffer.str());

// unfreeze the char* stream
buffer.freeze(false);

// seek writing position to the beginning
buffer.seekp(0, ios::beg);

// refill char* stream
buffer << "once more float x: " << x << std::ends;

// pass resulting C-string to foo() again
// - freezes the char* stream
foo(buffer.str());

// return memory to buffer
buffer.freeze(false);
```
String stream class之中已经不复再有与“冻结stream”相关的任何问题，主要是因为 string被复制了，而且string class负起了内存相关责任。

## “用户自定义类型”之I/O操作符
正如本章先前所说，和旧式的C语言I/O机制比较，stream的主要优势在于：stream机制可以扩及用户自定义类型（user-defined type）。
要做到这一点，你必须重载操作符＜＜和＞＞。以下各小节通过一个class Fraction（分数）进行说明。

### 实现一个Output操作符
在一个带有output操作符的表达式中，左操作数是stream，右操作数是待写对象：
```cc
stream << object
```
根据语法规则，上式有两种解释：
1.可解释为stream.operator＜＜（object）。
2.可解释为operator＜＜（stream，object）。

第一种方式适用于内建基础类型。用户自定义类型必须采用第二种方式，因为 stream class的扩展之门已经关闭。
你需要做的就是针对你的自定义类型实现出全局性的operator＜＜。这很简单，除非你需要访问对象的private成员（这一点稍后再来解决）。

举个例子，如果想以分子/分母格式打印Fraction对象，你可以编写以下函数：
```cc
#include <iostream>

inline
std::ostream& operator << (std::ostream& strm, const Fraction& f)
{
    strm << f.numerator() << '/' << f.denominator();
    return strm;
}
```
这个函数将分子和分母作为实参写入stream，其间以字符'/'隔开。这里的stream可以是file stream、string stream或其他任何stream。为了支持输出动作的串链（chaining）形式，或是为了在同一个语句中处理stream状态，上述函数必须返回当前的stream。

这种简单形式有两个缺点：
1.由于签名式（signature）中使用了ostream，所以这个函数只适用于“字符类型为char”的stream。如果这个函数在西欧或北美使用，当然毫无问题。回过头来说，要开发一个更通用的版本并不很费事，值得考虑。
2.如果栏位宽度（field width）被设定，会产生新问题：得到的结果可能和预期不同。栏位宽度会作用于紧随其后的write动作中，此处将作用于分子身上。因此，
```cc
Fraction vat(19, 100);  // I'm German and we have a uniform VAT of 19%
std::cout << "VAT: \"" << std::left << std::setw(8)
          << vat << "\"" << std::endl;
```
会导致以下输出：
```bash
VAT: "19 /100" 
```
下面这个版本可以同时解决上述两个问题：
```cc
#include <iostream>
#include <sstream>

template <typename charT, typename traits>
inline
std::basic_ostream<charT, traits>&
operator << (std::basic_ostream<charT, traits>& strm,
             const Fraction& f)
{
    // string stream
    // - with same format
    // - without special field width
    std::basic_ostringstream<charT, traits> s;
    s.copyfmt(strm);
    s.width(0);

    // fill string stream
    s << f.numerator() << '/' << f.denominator();

    // print string stream
    strm << s.str();

    return strm;
}

```
新版本的操作符已经成了一个“可适用于各种stream”的function template（函数模板）。
栏位宽度的问题获得了解决：先将分数写入一个string stream，不设任何栏位宽度；再将这个构造好的string作为实参传给stream。
这导致用以表现分数的那些字符仅以一次 write动作就完成，而栏位宽度就作用于该唯一的write动作上。
于是，
```cc
Fraction vat(19, 100);  // I'm German ...
std::cout << "VAT: \"" << std::left << std::setw(8)
          << vat << "\"" << std::endl;
```
产生如下结果：
```bash
VAT: "19/100 " 
```
注意，针对“命名空间std内的类型”而写出的用户自定义（重载的） operator＜＜，会有些局限。原因是它将无法在ADL（argument-dependent lookup，或谓Koenig lookup）情境下被找到。
当我们使用ostream iterator时就是这种情况。例如：
```cc
template <typename T1, typename T2>
std::ostream& operator << (std::ostream& strm, const std::pair<T1, T2>& p)
{
    return strm << "[" << p.first << "," << p.second << "]";
}

std::pair<int, long> p(42, 77777);
std::cout << p << std::endl;  // OK

std::vector<std::pair<int, long>> v;
// ...
// 以下是错误示例，仅展示用法，实际编译不通过
std::copy(v.begin(), v.end(),
          std::ostream_iterator<std::pair<int, long>>(std::cout, "\n"));
```

### 实现一个Input操作符
Input操作符的实现原则和output操作符相同，但input可能导致诸如“读取失败”等问题。一旦出现这种情况就需要做一些特殊处理。

实现read函数时，可以采用简单法或灵活法。以下函数采用简单法，不检测（不理会）差错状态，径自读取一个分数（fraction）：
```cc
// to/fracin.hpp
#include <iostream>

inline
std::istream& operator >> (std::istream& strm, Fraction& f)
{
    int n, d;
    strm >> n;        // 读取分子
    strm.ignore();    // 跳过 '/'
    strm >> d;        // 读取分母
    f = Fraction(n, d);  // 构造 Fraction 对象赋值给 f
    return strm;
}
```

这种做法只适用于“字符类型char所对应的stream”，而且也不检测两数字间的符号是否为'/'。

如果读取的是个未定义值，会引发另一个问题。当读入的分母值为0，读入的分数就没有意义。函数Fraction（n，d）所触发的Fraction构造函数可以检测出这个问题。但是在 class Fraction 内部处理此事，意味着一个“格式错误”会自动导致一个“差错处理”（error handling）。由于通常大家习惯在stream中记录格式错误，所以此时你最好设置ios_base：：failbit。

最后一点，即使读取不成功，以by reference方式传入的那个分数也可能被改动——当分子读取成功而分母读取失败时就可能发生这种情况。这种行为和“语言预定义的各种input操作符”惯例不符，所以最好避免，使读取动作“要么成功、要么完全无效（不带来任何影响）”。

下面是改进后的实现版本，避免了上述种种问题。由于函数已被参数化，适用于所有stream，所以更加灵活：
```cc
// io/fracin.hpp
#include <iostream>

template <typename charT, typename traits>
inline
std::basic_istream<charT, traits>&
operator >> (std::basic_istream<charT, traits>& strm, Fraction& f)
{
    int n, d;
    // 读取分子
    strm >> n;

    // 读取 '/'（若存在）和分母
    if (strm.peek() == '/') {
        strm.ignore();
        strm >> d;
    } else {
        d = 1;  // 无 '/' 时，分母默认设为 1
    }

    // 分母为 0 时设置流状态为失败
    if (d == 0) {
        strm.setstate(std::ios::failbit);
        return strm;
    }

    // 流状态正常时，构造 Fraction 对象
    if (strm) {
        f = Fraction(n, d);
    }
    return strm;
}
```


这里，只有当第一个数紧跟着字符'/'，才会继续读取分母，否则便假设分母为1，而先前读入的整数将被当作完整分数内容。所以实际输入时分母可有可无。

这个版本也会检查分母值是否为 0。如果真是0，ios_base：：failbit会被设置，那会触发相应异常（见15.4.4节第762页）。当然，如果分母为0，也可以执行别的动作，例如直接抛出异常，或直接跳开检查并令分数为0，后者将使class Fraction抛出相应的异常。

函数最终会检查stream状态，只有在无任何差错发生时才为分数赋予新值。这类最后检验工作总是应该实施，保证“只有读取成功，对象值才会被改变”。

当然，“读取整数并视之为分数”的做法是否合理，有待商榷，还有一些细节也需要改进。例如分子后面应该紧邻符号'/'，中间不能有空白字符（whitespace），但分母后面应该允许任意多个空白字符，因为它们通常会被忽略。要做到这


些，势必会增加reading的复杂度。

### 以辅助函数完成I/O
如果执行I/O操作符时需要访问对象的private成员，标准操作符应该将实际任务委派给辅助的成员函数。这种技术允许“具多态性（polymorphic）的读/写函数”，其具体实现可参考下例：
```cc
class Fraction {
public:
    virtual void printOn(std::ostream& strm) const;  // 输出逻辑
    virtual void scanFrom(std::istream& strm);       // 输入逻辑
    // ...（类内其他成员，如分子、分母等，需补充定义）
};

// 输出运算符重载：委派给 Fraction::printOn
std::ostream& operator<<(std::ostream& strm, const Fraction& f) {
    f.printOn(strm);
    return strm;
}

// 输入运算符重载：委派给 Fraction::scanFrom
std::istream& operator>>(std::istream& strm, Fraction& f) {
    f.scanFrom(strm);
    return strm;
}
```

一个典型的例子就是在输入时直接处理分子和分母：
```cc
void Fraction::scanFrom(std::istream& strm) {
    // ...（此处需补充读取分子、分母的逻辑，示例伪代码如下）
    int n, d;
    strm >> n >> d;  // 假设输入格式为“分子 分母”，实际需适配需求
    // 直接赋值给 Fraction 内部成员（需确保类内有 num、denom 等成员）
    num = n;  
    denom = d;
}
```

如果你的class并不打算被当作一个base class，那么你的I/O操作符可以设计为其friend。但要注意，一旦用上继承，这种方法就有很大的局限性。Friend函数不能成为virtual函数，所以你的程序可能会调用错误的函数。例如，如果某个base class reference实际指向一个derived class对象，并被当作input操作符的实参，则被调用的将是base class的操作符。为了避免出现这种情况，derived class不得实现自己的I/O操作符。因此，先前的实现手法比friend函数手法通用得多。所以，尽管在其他文档或书籍上看到的绝大多数例子都使用friend函数，你还是应该把前一种手法视为标准做法。

### 用户自定义之Format Flag（格式标志）
一旦“用户自定义操作符”被实现出来，程序往往需要一些formatting flag，用来对那些操作符提供指示。这或可借由相应的操控器（manipulator）完成。举个例子，先前所说的分数（fraction），其output操作符如果允许分子和分母之间的斜线两边有空格，那可漂亮了。

Stream对象提供一种机制，可将数据关联至stream身上。这样的机制可用来将相应数据关联起来（例如使用一个操控器），之后再取回。这一机制即可支持上述技术。Class ios_base定义有两个函数iword（）和pword（），两者都以其int实参为索引，分别访问特定的long&或void*&。其想法是以iword（）/pword（）分别访问存储于array（任意长度，伴随stream对象）中的long/void*对象；我们把stream formatting flag放到一个特定位置，该位置对所有stream而言都相同。Class ios_base的静态成员函数xalloc（）用来取得一个尚未被用于此目的的索引值。

一开始，被iword（）或pword（）访问的对象都被设为 0。这个值可以用来表现默认的formatting或表示“相应的数据尚未被访问”。下面是个例子：
```cc
// 获取新的 ostream 自定义数据索引
static const int iword_index = std::ios_base::xalloc();

// 定义 manipulator：设置“分子分母间是否空格”的标记
std::ostream& fraction_spaces(std::ostream& strm) {
    strm.iword(iword_index) = true;  // 标记为“需要空格”
    return strm;
}

// 增强版输出运算符：根据 iword 标记控制格式
std::ostream& operator<<(std::ostream& strm, const Fraction& f) {
    if (strm.iword(iword_index)) {
        // 若标记为 true，分子分母间加空格
        strm << f.numerator() << " / " << f.denominator();
    } else {
        // 否则用默认格式（无空格）
        strm << f.numerator() << "/" << f.denominator();
    }
    return strm;
}
```
本例只简单实现output操作符，因为本例的主要目的是揭示函数iword（）的用法。这里的format flag被视为一个Boolean，用来定义“分子和分母之间能否存在空格”。第一行调用的函数ios_base：：xalloc（）用来获取“可存储format flag”的索引值，所得结果绝不该被改动，所以我把它存在一个常量内。fraction_spaces（）是个操控器，用来设置int值为true（该值存储于“与stream strm对应”之整数array内“索引为 iword_index”之处）。Output操作符会重新获得该值，并根据它输出分数。如果其值为 false，采用默认的“不支持空格”格式。否则就在斜线两端加上空格。

iword（）和pword（）会返回一个reference指向int对象或void*对象。这些reference将持续有效，除非你针对相应的stream对象再次调用iword（）或pword（），或是你销毁了stream对象。通常iword（）和pword（）返回的结果无须保存。[18]一般的共识是：这是一个速度很快的访问动作，尽管并无明确要求非采用array不可。

函数copyfmt（）会复制所有的format信息（见15.7.1节第779页），包括iword（）和pword（）访问的array。这可能会给某些对象带来问题——那些对象系存储于某个曾经运用pword（）的stream内。举个例子，如果某值是个对象地址，那么被复制的将是地址而非对象。如果只复制地址，一旦stream格式发生改变，其他stream的格式也会受影响。此外，如果一个stream用上pword（），那么当它被销毁时，它所关联的对象最好一并销毁。所以对这样的对象而言，应该使用深拷贝（deep copy）而不是浅拷贝（shallow copy）。

ios_base定义了一个回调（callback）机制，用以支持两种行为：（1）必要时执行深拷贝，（2）销毁stream时连带删除某个对象。函数register_callback（）可用来注册某个函数，该函数会在某些特定动作发生于ios_base对象身上时被调用。其声明式如下：
```cc
namespace std {
    class ios_base {
    public:
        // kinds of callback events
        enum event { erase_event, imbue_event, copyfmt_event };
        // type of callbacks
        typedef void (*event_callback) (event e, ios_base& strm, int arg);

        // function to register callbacks
        void register_callback (event_callback cb, int arg);

        // 此处省略的内容用...表示，实际完整代码需补充
        ...
    };
}
```
register_callback（）的第一实参和第二实参分别是一个function pointer和一个 int值。这个int值将成为已注册函数（被调用时）的第三实参，可（例如）用来表现一个索引，标示 pword（）要处理的array元素。回调函数的第二实参strm是个ios_base对象，正是该对象引发了对回调函数的调用。第一实参e用来区分回调的原因。表15.39列出了所有（三种）回调原因。

表15.39 回调事件（Callback Event）的发生原因
| 事件（Event）          | 发生原因                                                 |
| ---------------------- | -------------------------------------------------------- |
| `ios_base::imbue_event` | 程序运用 `imbue()` 设了一个 `locale`                     |
| `ios_base::erase_event` | Stream 被摧毁，或 `copyfmt()` 被使用                     |
| `ios_base::copy_event`  | `copyfmt()` 被使用                                       |


如果copyfmt（）被执行，则执行者（某对象）会进行两次回调动作。首先在复制前进行第一次回调并携带实参erase_event，用以完成必要的清除工作（例如删除array内的对象），此时调用的是针对该对象注册好的回调函数。其次是format flag 复制完毕后（其中包括随实参而来的stream的callback list），再次调用回调函数并携带实参copy_event。这一次动作可以用来洽商对存储于pword（） array中的对象的深拷贝（deep copy）。注意此时整个callback list也被复制了，原先的list被移除。所以第二次回调动作所激发的就是刚被复制过来的回调函数。

这个回调机制非常简朴（primitive）。所有回调函数都必须先注册，除非你使用copyfmt（）并携带一个实参而其中无任何注册函数。此外，如果你将某个回调函数注册两次，那么即使是带有相同实参，也会导致它被调用两次。回调次序肯定和注册次序相反。这导致一个问题：如果回调函数B是在回调函数A内注册的，那么B在A下次被回调之前，绝不可能被回调起来。

### 用户自定义I/O操作符的规约（Convention）
运用自定义之I/O操作符时，有些规约应该遵循。这些规约和预定义之I/O操作符的典型操作是对应的，总结如下：

· 你的output 格式应该让其他使用者能够以一个input 操作符无损地读取数据。尤其是string，由于空白字符的问题，几乎不可能实现这一点。是的，“string内的空白字符”很难和“两个string之间的空白字符”区分开来。

· 进行I/O时，应考虑现有的stream格式规范，尤其在处理涂写宽度的时候。

· 如果产生错误，应设置相应的状态位（state flag）。

· 如果发生错误，原对象不该有任何改动。如果读取多笔数据，读取的数据应该在被设为“被当作实参传递”的对象前先存储于辅助对象中。

· Output不应该以换行符（newline）结束，否则就不能在同一行输出其他对象了。

· 即使数值太大，也应完全读取。读完后再设置相应的错误标志。此时的返回值应具备特定意义，例如返回“可容许之最大值”。

· 如果检测到某个format error，应尽可能不读取任何字符。

## 连接Input和Output Stream
常常你会需要连接两个stream。例如，你可能想在读取数据之前确保屏幕上已经打印出提示文字。或者你可能希望对同一个stream读和写——这种情况主要发生在file stream身上。有时候你也可能需要以不同的格式处理同一个stream。本节讨论所有这些技术。

### 以tie（）完成松耦合（Loose Coupling）
你可以把一个stream连接到一个output stream身上。这意味着两者的缓冲区是同步的，其具体做法是：output stream将在另一个stream执行输入或输出动作前先清空自己的缓冲区。也就是说，对output stream而言，其flush（）函数会被调用。表15.40列出了basic_ios定义的数个成员函数，它们用来将某个stream连接到另一个stream身上。

表15.40 将一个Stream连接到另一个Stream身上
| 成员函数              | 意义                                                         |
| --------------------- | ------------------------------------------------------------ |
| `tie()`               | 返回一个 pointer 指向一个 output stream，该 output stream 将被连接到当前 stream 身上 |
| `tie(ostream* strm)`  | 将 `strm` 所指的 output stream 连接到当前 stream 身上，并返回一个 pointer 指向先前所连接的 output stream（如果有的话） |

无参数的那个 tie（）会返回一个pointer，指向当前连接的output stream。如果要把某个output stream A连接到某个stream B身上，那就必须把指向A的pointer当作实参传给单一参数的 tie（）。之所以拿pointer作为实参，是因为这样可把 0或 NULL也当作实参，表示“不连接”，用以解除任何被连接的output stream。如果未曾连接output stream，tie（）会返回0。每个stream只能连接一个output stream，但你可以把一个output stream连接到多个stream身上。

默认情况下，标准input设备以下列方式被连接到标准output设备：
```cc
// predefined connections:
std::cin.tie(&std::cout);
std::wcin.tie(&std::wcout);
```
这样就保证了在真正请求输入之前，一定会先清空output缓冲区。例如：
```cc
std::cout << "Please enter x: ";
std::cin >> x;
```
程序读取x之前会先暗自（implicitly）对cout调用函数flush（）。

如果想要解除两个stream间的连接，可传递0或NULL给tie（）。例如：
```cc
// decouple cin from any output stream
std::cin.tie(nullptr);
```

这么做或许可以提高程序效能，因为或许避免了非必要的stream缓冲区清空动作。关于stream效能的讨论，参见15.14.2节第846页。

你也可以将一个output stream连接到另一个output stream。例如以下语句就保证了在对error stream写东西之前，先清空正常的output缓冲区：
```cc
// tieing cout to cerr
std::cerr.tie(&std::cout);
```
### 以Stream缓冲区完成紧耦合（Tight Coupling）
通过函数 rdbuf（），可以使不同的stream共享同一个缓冲区，从而实现stream的紧耦合。表15.41所列函数适用于不同目的，分别在本节和接下来的小节中讨论。

表15.41 Stream缓冲区的访问
| 成员函数          | 意义                                                         |
| ----------------- | ------------------------------------------------------------ |
| `rdbuf()`         | 返回一个 pointer 指向 stream 缓冲区                          |
| `rdbuf(streambuf*)` | 将实参所指的 stream 缓冲区安装（install）到当前 stream 身上，并返回一个 pointer 指向先前安装的 stream 缓冲区 |

成员函数 rdbuf（） 允许数个stream 对象从同一个input 通道读取信息，或者对同一个output 通道写入信息，而不必困扰于I/O 次序。由于I/O 操作被施以缓冲措施，所以同时使用多个 stream 缓冲区是很麻烦的。因为，对同一个 I/O 通道使用不同的 stream，而这些 stream 的缓冲区又各不相同，意味着 I/O 得传递给其他 I/O。basic_istream 和basic_ostream各有构造函数接受一个stream缓冲区作为实参，以此将stream初始化。下面是运用实例：

```cc
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
    // stream for hexadecimal standard output
    ostream hexout(cout.rdbuf());
    hexout.setf(ios::hex, ios::basefield);
    hexout.setf(ios::showbase);

    // switch between decimal and hexadecimal output
    hexout << "hexout: " << 177 << " ";
    cout  << "cout: " << 177 << " ";
    hexout << "hexout: " << -49 << " ";
    cout  << "cout: " << -49 << " ";
    hexout << endl;
}
```

注意，basic_istream和basic_ostream的析构函数并不删除相应的stream缓冲区（毕竟该缓冲区并非由这些class打开）。因此你可以传递一个pointer指向stream缓冲区，而不必使用stream reference：
```cc
#include <iostream>
#include <fstream>

void hexMultiplicationTable(std::streambuf* buffer, int num)
{
    std::ostream hexout(buffer);
    hexout << std::hex << std::showbase;

    for (int i = 1; i <= num; ++i) {
        for (int j = 1; j <= 10; ++j) {
            hexout << i * j << ' ';
        }
        hexout << std::endl;
    }
} // does NOT close buffer

int main()
{
    using namespace std;
    int num = 5;

    cout << "We print " << num
         << " lines hexadecimal" << endl;

    hexMultiplicationTable(cout.rdbuf(), num);

    cout << "That was the output of " << num
         << " hexadecimal lines " << endl;
}
```
这种方法的优点在于格式被修改后不必恢复其原先状态，因为格式乃是针对stream对象而不是针对stream缓冲区。上述程序输出如下：
```bash
We print 5 lines hexadecimal
0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xa 
0x2 0x4 0x6 0x8 0xa 0xc 0xe 0x10 0x12 0x14 
0x3 0x6 0x9 0xc 0xf 0x12 0x15 0x18 0x1b 0x1e 
0x4 0x8 0xc 0x10 0x14 0x18 0x1c 0x20 0x24 0x28 
0x5 0xa 0xf 0x14 0x19 0x1e 0x23 0x28 0x2d 0x32 
That was the output of 5 hexadecimal lines 
```

但是此法也有缺点：stream对象的构造和析构会有更多额外开销，不仅仅是设置和恢复一些format flag而已。同时也请注意，stream对象析构时并不清空缓冲区。要确保output缓冲区被清空，就必须手工进行。

只有basic_istream和basic_ostream不销毁stream缓冲区。其他stream都会销毁它们最初分配的stream缓冲区，但它们不会销毁以rdbuf（）设置的缓冲区。

### 将标准Stream重定向（Redirecting）
IOStream程序库的早期实现版本中，全局性的stream如 cin、cout、cerr和 clog都是隶属于istream_withassign和ostream_withassign的全局对象。因此我们才有可能把这些stream赋值给其他stream，用以将stream重定向。C++标准库已经剔除这种可能性，但仍然保留重定向的可能性，并扩及所有stream。现在，只要通过“设置stream缓冲区”就可以重定向某个stream。

“设置stream缓冲区”意味着I/O stream的重定向可由程序控制，不必借助操作系统。例如以下语句做了些设置，使得写入 cout的信息不被送到标准output通道，而是被送到cout.txt去：
```cc
std::ofstream file ("cout.txt");
std::cout.rbuf (file.rdbuf());

```
函数copyfmt（）用来将某个stream的所有格式信息赋值给另一个stream对象：
```cc
std::ofstream file ("cout.txt");
file.copyfmt (std::cout);
std::cout.rdbuf (file.rdbuf());
```

小心！上述的file是局部对象，将在上述程序区段结束时被销毁，相应的stream缓冲区也一并被销毁。这和标准的stream不同，因为通常file stream在构造过程分配stream缓冲区，并于析构时销毁它们。所以本例中的cout不能再被用于writing。事实上，它甚至无法在程序结束时被安全销毁。因此我们应该保留旧缓冲区并于事后恢复！下例的函数redirect（）就负责这事：
```cc
#include <iostream>
#include <fstream>
#include <memory>
using namespace std;

void redirect(ostream&);

int main()
{
    cout << "the first row" << endl;

    redirect(cout);

    cout << "the last row" << endl;
}

void redirect(ostream& strm)
{
    // save output buffer of the stream
    // - use unique pointer with deleter that ensures to restore
    //   the original output buffer at the end of the function
    auto del = [&](streambuf* p) {
        strm.rdbuf(p);
    };
    unique_ptr<streambuf, decltype(del)> origBuffer(strm.rdbuf(), del);

    // redirect output into the file redirect.txt
    ofstream file("redirect.txt");
    strm.rdbuf(file.rdbuf());

    file << "one row for the file" << endl;
    strm << "one row for the stream" << endl;
} // closes file AND its buffer automatically
```

借着使用一个unique pointer（见5.2.5节第98页），我们可以确保，甚至当resize（）由于异常而丢下，被存储于origBuffer的原先输出缓冲区还是会还原。[19]

程序输出如下：
```bash
the first row
the last row
```

文件redirect.txt的内容如下：
```bash
one row for the file
one row for the stream
```

如你所见，redirect（） 中写至 cout （通过实参名 strm）的输出信息被送到文件去了。main（）执行redirect（）后，接下来的输出再次被送到（已恢复了的）输出通道。

### 可读可写的Stream
本节列出“连接两个stream”的最后一例：运用同一个stream进行读/写操作。通常我们可以利用class fstream打开一个文件进行读/写：
```cc
std::fstream file ("example.txt", std::ios::in | std::ios::out);
```

也可以采用两个不同的stream对象，一个用于读，一个用于写。例如：
```cc
std::ofstream out ("example.txt", ios::in | ios::out);
std::istream in (out.rdbuf());
```

out声明式会开启文件。in声明式使用out的stream缓冲区，从中读取数据。注意out必须同时允许读和写，如果仅能写，则从它身上读数据会导致不明确的行为。也请注意，in并非隶属 ifstream类型，而是隶属 istream类型——是的，文件被打开后，就有相应的stream缓冲区，此时唯一需要的只是另一个stream对象。一如前例，file stream对象out被销毁时，文件也被关闭。

你也可以产生一个file stream缓冲区，并将它安装在两个stream对象上，例如：
```cc
std::filebuf buffer;
std::ostream out (&buffer);
std::istream in (&buffer);
buffer.open("example.txt", std::ios::in | std::ios::out);
```

其中的filebuf是class basic_filebuf＜＞对字符类型char的特化实体，它定义出了file stream所用的缓冲区类（buffer class）。

以下程序是个完整实例。循环中对一个文件写入四行。每写完一行，文件的所有内容就被写到标准输出设备上：
```cc
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
    // open file "example.dat" for reading and writing
    filebuf buffer;
    ostream output(&buffer);
    istream input(&buffer);
    buffer.open ("example.dat", ios::in | ios::out | ios::trunc);

    for (int i=1; i<=4; ++i) {
        // write one line
        output << i << ". line" << endl;

        // print all file contents
        input.seekg(0);          // seek to the beginning
        char c;
        while (input.get(c)) {
            cout.put(c);
        }
        cout << endl;
        input.clear();           // clear eofbit and failbit
    }
}
```
尽管两个不同的stream对象分别用于读和写，读/写位置还是“紧耦合”（tightly coupled）。seekg（）和seekp（）都调用stream缓冲区的同一个成员函数。[20]这样一来，为保证能完整写出文件的全部内容，必须把读取位置置于文件起始处。文件的全部内容被写出后，读/写位置再次到达文件尾部，于是新行就可以追加到文件上。

有一点非常重要：除非读至文件尾部，否则必须在读和写之间进行一次 seek（查找）操作。若不如此极有可能导致一个被篡改的文件，甚至可能带来更致命的错误。

一如先前所说，你可以不必逐字处理，可以运用单一语句打印出全部内容，只要将一个“指向file stream缓冲区”的pointer当作实参，传给operator＜＜即可（详见15.14.3节第846页）：
```cc
std::cout << input.rdbuf();
```

## Stream Buffer Class
一如15.2.1节第749页的介绍，stream并不执行实际读/写操作，而是委托给stream buffer （缓冲区）完成。

处理stream缓冲区的一般性接口十分简单（见15.12.2节第820页）：

· rdbuf（）取得一个pointer指向某个stream的缓冲区。

· Stream的构造函数和rdbuf（）允许在构造时期设立一个stream缓冲区，或在stream存在期间改变stream缓冲区。不论哪种情况，你都必须传递一个pointer指向stream缓冲区，那个pointer正是rdbuf（）所返回。

这个能力可被用来让多个stream写至相同的输出设备（见15.12.2节第820页），或是重定向（redirect） stream（见15.12.3节第822页），或是读自和写至同一个缓冲区（见15.12.4节第824页），或使用其他字符编码（character encoding）如UTF-8或UTF-16/UCS-2作为输入和输出格式（见16.4.4节第903页）。

本节说明缓冲区如何运作。如此一来不仅能加深理解stream 的运用结果，也为“定义新的I/O通道”提供技术基础。在详细介绍stream缓冲区的操作之前，本节先为“只对stream缓冲区之运用”感兴趣的人介绍其public接口。

### Stream缓冲区接口
对于 stream 缓冲区的使用者来说，class basic_streambuf＜＞ 只是发送（sent）或提取（extracted）字符的地方。表15.42列出了两个public函数，用来写入字符。

表15.42 用来“写入字符”的Public成员函数
| 成员函数     | 意义                                      |
| ------------ | ----------------------------------------- |
| `sputc(c)`   | 将字符 `c` 送入 stream 缓冲区             |
| `sputn(s, n)` | 将字符序列 `s` 内的 `n` 个字符送入 stream 缓冲区 |  

如果发生错误，函数 sputc（）会返回 traits_type：：eof（），这里的 traits_type是class basic_streambuf内的一个类型定义。函数sputn（）会写进第二实参指定的字符数，除非stream缓冲区无法耗尽（consume）它们。这个函数并不考虑终止符null；它返回的是实际写出的字符数。

“从stream缓冲区读取字符”的接口比较复杂（见表15.43）。这是因为对input而言，必须时时观察字符但不耗用（consuming）它。解析（parsing）时字符最好能被送回stream缓冲区。为此，stream buffer class特别提供了相应函数。

表15.43 用来“读取字符”的Public成员函数
| 成员函数       | 意义                                                 |
| -------------- | ---------------------------------------------------- |
| `in_avail()`   | 返回有效字符的下界（lower bound）                    |
| `sgetc()`      | 返回当前字符，不耗之（without consuming it）         |
| `sbumpc()`     | 返回当前字符并耗用之（consuming it）                 |
| `snextc()`     | 耗用当前字符并返回下一字符                           |
| `sgetn(b, n)`  | 读取 `n` 个字符并将它们存储到缓冲区 `b`              |
| `sputbackc(c)` | 将字符 `c` 返回 stream 缓冲区                        |
| `sungetc()`    | 退回至前一字符                                       |  

函数in_avail（）用来确定至少有多少个有效字符。这可用来（例如）确定从键盘读取数据时不会被阻塞（block）。不过实际上可能有更多有效字符。

除非stream缓冲区已经到达stream尾部，否则始终存在一个当前（current）字符。函数sgetc（）可以不必移至下一字符就获得当前字符。函数sbumpc（）读取当前字符并移至下一字符，使之成为当前字符。函数snextc（）将下一字符视为当前字符然后读取之。这三个函数如果失败都会返回traits_type：：eof（）。函数sgetn（）读取字符序列并送至缓冲区，其实参可表示欲读取的字符数，返回的则是实际读取的字符数。

函数 sputbackc（） 和 sungetc（） 被用来退一步，使前一字符成为当前字符。函数sputbackc（）可将前一字符替换为其他字符。使用这两个函数必须谨慎。通常它们只能退一个字符。

还有一些函数用来访问地域对象（locale object）、改变位置或影响缓冲区，见表15.44。

pubimbue（）和getloc（）用于国际化议题（见15.8节第790页）。pubimbue（）在stream缓冲区中安装一个新的locale对象，并返回前一个安装的locale对象；getloc（）返回当前安装好的locale对象。

函数pubsetbuf（）试图对stream缓冲区的缓冲策略进行某种控制，是否有效则取决于具体的stream buffer class。例如对string stream缓冲区运用pubsetbuf（）就毫无意义。即使将它用于file stream缓冲区，也只能在第一个I/O完成后

表15.44 难以分类的Stream缓冲区接口中的Public函数
| 成员函数                        | 意义                                                 |
| ------------------------------- | ---------------------------------------------------- |
| `pubimbue(loc)`                 | 为 stream 缓冲区安装 locale `loc`                    |
| `getloc()`                      | 返回当前（current）locale                            |
| `pubseekpos(pos)`               | 将当前（current）位置重新设定为某绝对位置             |
| `pubseekpos(pos, which)`        | 与上同，并可指定 I/O 方向                            |
| `pubseekoff(offset, rpos)`      | 重设当前位置，使它与另一位置有关                       |
| `pubseekoff(offset, rpos, which)` | 与上同，并可指定 I/O 方向                            |
| `pubsetbuf(buf, n)`             | 影响缓冲行为                                         |  

以pubsetbuf（nullptr，0）（意即不采用缓冲区）方式调用才能起作用。如果出错，函数返回0，否则返回该stream缓冲区。

函数pubseekoff（）和pubseekpos（）控制读/写动作的当前位置（current position）。究竟控制的是读或写，取决于最后实参（其类型为ios_base：：openmode），如果没有特别指定，实参默认值为 ios_base：：in|ios_base：：out。一旦设置ios_base：：in，读的位置就会跟着改变；一旦设置 ios_base：：out，写的位置也会跟着变化。函数 pubseekpos（）会把stream当前位置移至其第一实参指示的绝对位置上，函数pubseekoff（）则把stream当前位置移至某个相对位置，偏移量由第一实参决定，起始位置由第二实参决定，可以是ios_base：：cur、ios_base：：beg或ios_base：：end（详见15.9.4节第800页）。两个函数都返回stream所在位置或一个无效位置。将函数结果拿来和对象pos_type（off_type（-1））比较（pos_type和off_type是处理stream位置时所用的类型，参见15.9.4节第799页），可以检测出无效的stream位置。如果希望获得stream当前位置，可使用pubseekoff（）：
```cc
sbuf.pubseekoff(0, std::ios::cur);
```

### Stream缓冲区的Iterator
针对“无格式I/O”而采用stream成员函数，另一种做法就是：采用stream缓冲区的iterator class。这些class所提供的iterator （1）符合input iterator和output iterator的规格，（2）用来从stream缓冲区读或写单一字符。这么一来就能够将字符层级的I/O纳入C++标准库算法的管辖范围内了。

Class template istreambuf_iterator＜＞和ostreambuf_iterator＜＞用来从类型为basic_streambuf＜＞的对象中读或写单一字符。这些class定义于头文件＜iterator＞：
```cc
namespace std {
    template <typename charT,
              typename traits = char_traits<charT>>
    class istreambuf_iterator;

    template <typename charT,
              typename traits = char_traits<charT>>
    class ostreambuf_iterator;
}
```
这些iterator是9.4.3节第460页描述的stream iterator的特殊形式，唯一区别在于它们的元素是字符（character）。

Output Stream缓冲区（Buffer）的Iterators

以下使用ostreambuf_iterator将一个string写入一个stream缓冲区内：
```cc
// create iterator for buffer of output stream cout
std::ostreambuf_iterator<char> bufWriter(std::cout);

std::string hello("hello, world\n");
std::copy(hello.begin(), hello.end(),  // source: string
          bufWriter);                  // destination: output buffer of cout
```

第一行根据 cout 构造出一个 output iterator，类型为 ostreambuf_iterator。除了传递output stream外，你也可以直接传递一个pointer指向stream缓冲区。其余代码构造出一个string对象，并将其内字符复制到上述output iterator。

表15.45列出了output stream缓冲区的iterator的所有操作函数。其实现方法与ostream iterator近似（见9.4.3节第460页）。此外，你也可以拿一个缓冲区将iterator初始化，并调用 failed（） 检查这个 iterator 能否用于输出。只要有任何一个字符的预写动作失败，failed（）就会返回true，于是以operator=进行的任何写入动作都无效。

表15.45 Output Stream Buffer Iterator的各项操作
| 表达式                              | 效果                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| `ostreambuf_iterator<char>(ostream)`  | 为 `ostream` 产生一个 output stream buffer iterator          |
| `ostreambuf_iterator<char>(buffer_ptr)` | 为 `buffer_ptr` 所指的缓冲区产生一个 output stream buffer iterator |
| `*iter`                             | 无动作（no-op），返回 `iter`                                 |
| `iter = c`                          | 调用 `sputc(c)`，对缓冲区写入字符 `c`                        |
| `++iter`                            | 无动作（no-op），返回 `iter`                                 |
| `iter++`                            | 无动作（no-op），返回 `iter`                                 |
| `failed()`                          | 判断 output stream iterator 能否执行写入动作                 |  



#### Input Stream缓冲区（Buffer）的Iterator

表15.46列出了input stream buffer iterator的所有操作函数。其实现方法和istream iterator近似（见9.4.3节第462页）。此外你可以拿一个缓冲区来初始化iterator。成员函数equal（）用来判断两个input stream buffer iterator是否相等。当两个stream buffer iterator都是（或不是） end-of-stream iterator时，两者被视为相等。

表15.46 Input Stream Buffer Iterator的各项操作
| 表达式                              | 效果                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| `istreambuf_iterator<char>()`        | 建立一个 end-of-stream iterator                              |
| `istreambuf_iterator<char>(istream)` | 为 `istream` 建立一个 input stream buffer iterator，并可能调用 `sgetc()` 读取第一个字符 |
| `istreambuf_iterator<char>(buffer_ptr)` | 为 `buffer_ptr` 所指的 input stream 建立一个 input stream buffer iterator，并可能调用 `sgetc()` 读取第一个字符 |
| `*iter`                             | 返回当前字符，也就是先前以 `sgetc()` 读取的字符（若构造函数没把第一字符读掉，这儿会读掉它） |
| `++iter`                            | 以 `sbumpc()` 读取下一字符，并返回其位置                     |
| `iter++`                            | 以 `sbumpc()` 读取下一字符，返回一个 iterator 指向前一字符位置 |
| `iter1.equal(iter2)`                | 判断两个 iterator 是否相等                                   |
| `iter1==iter2`                      | 判断两个 iterator 是否相等                                   |
| `iter1!=iter2`                      | 判断两个 iterator 是否不相等                                 |  



让人不明白的是“类型为 istreambuf_iterator的两个对象”相等到底是什么意思。如果两个istreambuf_iterator iterator都是（或都不是） end-of-stream iterator，则两者被视为相等（至于其output缓冲区是否相同并不影响）。获得一个end-of-stream iterator的可行方法是以default构造函数创建一个iterator。此外，如果试图将iterator移至stream尾部之外（也就是如果sbumpc（）返回traits_type：：eof（）），istreambuf_iterator就会成为一个end-of-stream iterator。这种行为有两个主要含义：

1.从“stream 当前位置”到“stream 尾部”之间的范围，由以下两个 iterator 定义出来：istreambuf_iterator＜charT，traits＞（stream）（此乃针对当前位置）和istreambuf_iterator＜charT，traits＞（）（此乃针对stream尾部），其中stream的类型是basic_istr eam＜charT，traits＞或basic_streambuf＜charT，traits＞。

2.不可能使用istreambuf_iterator建立子区间（subrange）。

#### Stream缓冲区迭代器（Buffer Iterator）运用实例

下面的例子是一个典型的筛检框架（filter framework），它用stream缓冲区迭代器简单地写出所有被读入的字符，是15.5.3节第772页所列例子的一个改进版本：
```cc
#include <iostream>
#include <iterator>
using namespace std;

int main()
{
    // input stream buffer iterator for cin
    istreambuf_iterator<char> inpos(cin);

    // end-of-stream iterator
    istreambuf_iterator<char> endpos;

    // output stream buffer iterator for cout
    ostreambuf_iterator<char> outpos(cout);

    // while input iterator is valid
    while (inpos != endpos) {
        *outpos = *inpos;  // assign its value to the output iterator
        ++inpos;
        ++outpos;
    }
}
```
你也可以传递stream buffer iterator给算法，用以处理读自input stream的所有字符（完整例子见io/countlines1.cpp）：
```cc
int countLines(std::istream& in)
{
    return std::count(
        std::istreambuf_iterator<char>(in),
        std::istreambuf_iterator<char>(),
        '\n'
    );
}
```
14.6节第732页有一个例子，就是使用读自标准输入设备的所有字符，将一个string初始化。

### 用户自定义之Stream缓冲区
Stream缓冲区是一种I/O缓冲区，其接口由class basic_streambuf＜＞定义。针对字符类型char和 wchar_t，标准库分别提供了预先定义好的 streambuf和 wstreambuf。实现特殊I/O通道上的通信时，以上class可被拿来当作base class。要做到这一点，首先得对stream缓冲区的操作有所了解。

缓冲区的主要接口由三个 pointer （指向两个缓冲区）构成。函数 eback（）、gptr（）和 egptr（）返回的pointer构成了read（input）缓冲区的接口。函数 pbase（）、pptr（）和epptr（）返回的pointer构成了write（output）缓冲区的接口。这些pointer分别由I/O动作操控，后者可能导致相关I/O通道上的相关回应。精确操作将分read和write两方面讨论。

#### 用户自定义之Output缓冲区

Output缓冲区由三个pointer维护，这三个pointer分别由函数pbase（）、pptr（）和epptr（）取得（如图15.4所示）。它们表示的意义如下：

1.pbase（）（意指“put base”）是output stream缓冲区的开始。

2.pptr（）（意指“put pointer”）是当前写入位置。

3.epptr（） （意指“end put pointer”）是output 缓冲区的结尾，指向“得被缓冲（can be buffered）之最末字符”的下一位置。

pbase（）至pptr（）之间的字符（不包括pptr（）所指字符）已被写至相应的输出通道，但尚未清空（flush）。


          pbase()         pptr()             epptr()
           │               │                   │
           ▼               ▼                   ▼
         ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬ ─ ┐
         │   │   │   │   │   │   │   │   │   │   │
         └───┴───┴───┴───┴───┴───┴───┴───┴───┴ ─ ┘
         Output缓冲区的接口

成员函数sputc（）可以写入一个字符；如果当时有个空的涂写位置，字符就被复制到该位置上。然后，指向当前涂写位置的那个pointer值会加1。如果缓冲区是空的（pptr（）==epptr（）），就调用virtual函数overflow（）将output缓冲区的内容发送到对应的输出通道去。这个函数能有效地把字符送至某种“外部表述”（但实际上也可能是内部的，例如string stream）。Base class basic_streambuf所实现的overflow（）只返回end-of-file，表示没有更多字符可以被写。

成员函数sputn（）可用来一次写入多个字符。这个函数把实际任务委派给virtual函数xsputn（），后者可针对“多个字符”做出更高效动作。

Class basic_streambuf中的xsputn（）根本上对每个字符调用sputc（），因此覆盖xsputn（）并非必要。但通常“同时写入多个字符”会比“一次写入一个字符”效率高得多，所以sputn（）可用来优化对字符序列的处理。

对一个stream缓冲区写数据时不必一定采取缓冲行为，可以令字符一到达就写入。此时default构造函数会自动将“维护write缓冲区”的pointer设为 0或NULL。

利用上述信息，我们可以实现出以下的stream缓冲区简单示例。这个stream缓冲区并未采取缓冲行为，所以对每个字符都调用overflow（）——我们唯一要做的就是实现出这个函数：

```cc
#include <streambuf>
#include <locale>
#include <cstdio>

class outbuf : public std::streambuf
{
protected:
    // central output function
    // - print characters in uppercase mode
    virtual int_type overflow(int_type c) {
        if (c != EOF) {
            // convert lowercase to uppercase
            c = std::toupper(c, getloc());

            // and write the character to the standard output
            if (std::putchar(c) == EOF) {
                return EOF;
            }
        }
        return c;
    }
};
```
本例中，每一个被发送到stream缓冲区的字符，都以C函数putchar（）写入。但是写入之前这些字符都被toupper（）转换成大写（见16.4.4节第895页）。函数getloc（）用来取得和stream缓冲区有关的locale对象（见15.8节第790页）。

本例的output缓冲区是特别针对字符类型char实现的（是的，streambuf就是特别针对字符类型char的一个basic_streambuf＜＞特化版本）。如果你还用到其他字符类型，就必须运用char trait（详见16.1.4节第853页）来实现这个函数。

这种情况下 end-of-file 和 c 的比较动作应该有所不同，返回的应该是 traits：：eof（）而不是 EOF。如果实参 c 是 EOF，则应该返回 traits：：not_eof（c） （其中 traits 是basic_streambuf的第二个template实参）。情况大致如下：
```cc
#include <streambuf>
#include <locale>
#include <cstdio>

template <typename charT,
          typename traits = std::char_traits<charT>>
class basic_outbuf : public std::basic_streambuf<charT, traits>
{
protected:
    // central output function
    // - print characters in uppercase mode
    virtual typename traits::int_type
    overflow(typename traits::int_type c) {
        if (!traits::eq_int_type(c, traits::eof())) {
            // convert lowercase to uppercase
            c = std::toupper(c, this->getloc());

            // convert the character into a char (default: '?')
            char cc = std::use_facet<std::ctype<charT>>(
                this->getloc()
            ).narrow(c, '?');

            // and write the character to the standard output
            if (std::putchar(cc) == EOF) {
                return traits::eof();
            }
        }
        return traits::not_eof(c);
    }
};

typedef basic_outbuf<char>    outbuf;
typedef basic_outbuf<wchar_t> woutbuf;
```

注意，现今你必须以 this-＞修饰对 getloc（）的调用，因为 base class取决于template参数。同时，在我们把字符传给putchar（）之前必须先窄化它，因为 putchar（）只接受char （见16.4.4节第891页）。

以下是上面这个stream缓冲区的运用情况：
```cc
#include <iostream>
#include "outbuf1.hpp"

int main()
{
    outbuf ob;                      // create special output buffer
    std::ostream out(&ob);          // initialize output stream with that output buffer

    out << "31 hexadecimal: " << std::hex << 31 << std::endl;
}
```

输出如下：
```bash
31 HEXADECIMAL: 1F
```

相同方法可用于对其他任意目标的涂写动作。例如stream缓冲区的构造函数可能接受一个文件描述器（file descriptor），或一个socket连接名，或另两个stream缓冲区（用来在对象初始化时同步写入）。若要向目标端写数据，我们只需实现相应的overflow（）即可。此外最好也能实现xsputn（），这样有助于提升效率。

为求方便构造stream缓冲区，我们也可以实现一个特殊class，用来将构造函数实参传递给相应的stream缓冲区。下例说明了这一点，它定义了一个以文件描述器（file descriptor）初始化的stream缓冲区class，文件描述器的字符由函数write（）写入（write（）是类UNIX操作系统使用的一个低层I/O函数）。另外它还定义了一个继承自ostream的class，用以维护这样一个stream缓冲区；文件描述器就是在那儿被传递的。

```cc
#include <cstdio>
#include <streambuf>

// for write():
#ifdef _MSC_VER
# include <io.h>
#else
# include <unistd.h>
#endif

class fdoutbuf : public std::streambuf {
protected:
    int fd;  // file descriptor

public:
    // constructor
    fdoutbuf(int _fd) : fd(_fd) {}

protected:
    // write one character
    virtual int_type overflow(int_type c) {
        if (c != EOF) {
            char z = c;
            if (write(fd, &z, 1) != 1) {
                return EOF;
            }
        }
        return c;
    }

    // write multiple characters
    virtual std::streamsize xsputn(const char* s, std::streamsize num) {
        return write(fd, s, num);
    }
};

class fdostream : public std::ostream {
protected:
    fdoutbuf buf;

public:
    fdostream(int fd) : std::ostream(0), buf(fd) {
        rdbuf(&buf);
    }
};
```
这个stream缓冲区也实现了函数xsputn（），避免发送字符序列到该stream缓冲区时对每个字符都调用 overflow（）。此函数在一次调用过程中将整个字符序列写至由文件描述器 fd指定的文件，并返回成功写进的字符数。下面是一个运用实例：
```cc
#include <iostream>
// 假设 outbuf2.hpp 包含上述 outbuf/fdoutbuf 等定义
#include "outbuf2.hpp"

int main()
{
    // 测试 fdostream：输出到文件描述符 1（标准输出）
    fdostream out(1);
    out << "31 hexadecimal: " << std::hex << 31 << std::endl;
}
```


这个程序产生一个以文件描述器（file descriptor） 1初始化的output stream。通常这样的文件描述器代表标准输出通道，所以本例只是很单纯地打印字符。如果你有其他文件描述器可用（例如表示文件或socket），也可以将它作为构造函数的实参。

如果要实现出具备缓冲能力的stream缓冲区，write缓冲区必须以函数setp（）初始化。以下例子说明了这一点：
```cc
class outbuf : public std::streambuf {
protected:
    static const int bufferSize = 10;  // size of data buffer
    char buffer[bufferSize];           // data buffer

public:
    // constructor
    // - initialize data buffer
    // - one character less to let the bufferSize-th character cause a call of overflow()
    outbuf() {
        setp(buffer, buffer + (bufferSize - 1));
    }

    // destructor
    // - flush data buffer
    virtual ~outbuf() {
        sync();
    }

protected:
    // flush the characters in the buffer
    int flushBuffer() {
        int num = pptr() - pbase();
        if (write(1, buffer, num) != num) {
            return EOF;
        }
        pbump(-num);  // reset put pointer accordingly
        return num;
    }

    // buffer full
    // - write c and all previous characters
    virtual int_type overflow(int_type c) {
        if (c != EOF) {
            // insert character into the buffer
            *pptr() = c;
            pbump(1);
        }
        // flush the buffer
        if (flushBuffer() == EOF) {
            // ERROR
            return EOF;
        }
        return c;
    }

    // synchronize data with file/destination
    // - flush the data in the buffer
    virtual int sync() {
        if (flushBuffer() == EOF) {
            // ERROR
            return -1;
        }
        return 0;
    }
};
```


其中，构造函数运用setp（）将write缓冲区初始化：
```cc
setp(buffer, buffer + (size - 1))
```

我们所建立的这个write缓冲区，只要还剩一个字符空间，就调用overflow（）。如果不是以EOF为实参调用overflow（），那么，由于指向涂写位置的pointer增加后并未超过尾端，所以字符会被写入当前位置。一旦将overflow（）的实参放在正确位置上，整个缓冲区就可以被清空（emptied）了。

成员函数flushBuffer（）正负责此事。它使用函数write（）将字符写向标准输出通道（文件描述器1）。Stream缓冲区的成员函数pbump（）用来将涂写位置移回缓冲区起始处。

函数overflow（）将“引发调用”且“非EOF字符”安插到缓冲区。然后运用pbump（）移动涂写位置，形成“被缓冲字符”的新尾端。这样会把涂写位置暂时移到结束位置（epptr（））之后。

这个class也实现了virtual函数sync（）——它可以造成stream缓冲区的当前状态和相应的存储介质同步。通常，唯一需要做的动作就是清空（flush）缓冲区。对于无缓冲行为的stream缓冲区来说，由于没有必要清空缓冲区，所以不必覆盖这个virtual函数。

Virtual析构函数可确保当stream缓冲区被销毁时，缓冲区内的数据仍会被写入目标区。

对大多数stream缓冲区而言，这些函数都会被覆盖（overridden）。如果外部表述结构比较复杂，覆盖其他函数也可能带来帮助。例如你可能会覆盖函数seekoff（）和seekpos（），以便实现对涂写位置的控制。

#### 用户自定义的Input缓冲区

Input机制和output机制的工作原理基本相同。但是对input而言，有可能不进行最后的读取动作。函数sungetc（）（由input stream的unget（）调用）或sputbackc（）（由input stream的putback（）调用）可用来存储stream缓冲区最后一次读取前的状态。此外也可能需要读取下一字符而不移动读取位置。所以如果你要实现出“从stream缓冲区中读取”动作，那么和实现出“向stream缓冲区写进数据”的动作相比，你必须覆盖（override）更多函数。

Stream缓冲区以三个pointer维护一个read缓冲区，这些pointer可经由三个成员函数eback（）、gptr（）和egptr（）取得（如图15.5所示）：

1.eback（）（意指“end back”）是input缓冲区的起始位置，或者回退区（putback area）的尾端（这是其名称的由来）。若不采取特殊措施，字符最多只能被回退（putback）到这个位置。

2.gptr（）（意指“get pointer”）是当前的“读取位置”。

3.egptr（）（意指“end get pointer”）是input缓冲区的尾端。

读取位置和结束位置之间的字符已经从外部表述（external representation）被传至程序内存中，但仍然等待着程序的处理。

函数 sgetc（）或 sbumpc（）可以读取单一字符。两者的差别在于后者会令read pointer前进，而前者不会。如果缓冲区读取完毕（gptr（）==egptr（）），就不再有可用字符了，此时缓冲区必须重新获得补给。这项工作可由virtual函数underflow（）完成，它会负责读取数据。如果没有可用字符，函数sbumpc（）会调用virtual函数uflow（），而 uflow（） 的默认行为就是调用 underflow（） 并移动（前进） read pointer。Base class basic_streambuf之中对underflow（）的默认做法就是令它返回EOF，意味着不可能以此默认版本读取字符。


          eback()      gptr()                       egptr()
            │            │                            │
            ▼            ▼                            ▼
         ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬ ─ ─ ┐
         │     │     │     │     │     │     │     │     │
         └─────┴─────┴─────┴─────┴─────┴─────┴─────┴ ─ ─ ┘
图15.5 “从Stream缓冲区读取”的接口

函数sgetn（）用于一次读取多个字符。这个函数把任务委派给virtual函数xsgetn（），后者的默认做法是简单地对每个字符调用sbumpc（）。但就像“用于涂写”的函数xsputn（）一样，我们也可以改进xsgetn（）以优化对多个字符的读取。

和output截然不同的是，对input而言，仅仅覆盖一个函数是不够的。你要么就建立一个缓冲区，要么就至少实现出underflow（）和uflow（）。这是因为 underflow（）不会将read pointer移到当前字符之后，但它可以被sgetc（）调用。移至下一字符，需要以缓冲区操作函数或 uflow（）完成。无论如何，任何一个具备字符读取功能的stream缓冲区，都必须实现出underflow（）。如果underflow（）和uflow（）都实现了，就没有必要建立缓冲区。

成员函数setg（）可设定一个read缓冲区。该函数有三个实参，依次如下：

1.一个pointer指向缓冲区头部（eback（））。

2.一个pointer指向当前读取位置（gptr（））。

3.一个pointer指向缓冲区尾部（egptr（））。

和 setp（） 不同，setg（） 有三个实参。这是必要的，以便能定义出用来存储“将被回退（putback）给stream”的字符空间。因此，一旦“指向read缓冲区”的pointer已被设定好，就会有一些（至少一个）字符已被读取但仍存放于缓冲区内。

 前面已经说过，运用sputbackc（）和sungetc（）便可将字符回退（putback）到read缓冲区。sputbackc（）以待退字符为实参，并确保该字符确实是被读取的字符。如果可能，这两个函数都会将read pointer退回一步。当然这只有在read pointer不指向read缓冲区头部的时候才能办到。如果到达缓冲区头部后你还试图回退一个字符，virtual函数 pbackfail（）就会被调用。只要覆盖该函数就可以实现出“即使在这种情况下也能恢复原读取位置”的机制。Base class basic_streambuf并未定义相应操作，因此实际上不可能回退任意个字符。对于不使用缓冲区的stream而言，函数pbackfail（）应该被实现出来，因为这些stream通常假设至少有一个字符可被回退（putback）。

如果新缓冲区只用于read，会产生另一个问题：要是缓冲区没有将旧数据保存下来，那就连一个字符也无法回退。因此，实现underflow（）时经常把当前缓冲区的最后数个字符（譬如4个字符）移到头部，然后才尾附（append）新读取的字符。这么一来就允许在调用pbackfail（）之前回退一些字符了。

下例说明上述做法的一种可能模样。Class inbuf实现出了一个拥有10个字符空间的input缓冲区，前4个字符空间作为回退区，后6个字符空间作为常规的input缓冲区。
```cc
#include <cstdio>
#include <cstring>
#include <streambuf>

// for read():
#ifdef _MSC_VER
# include <io.h>
#else
# include <unistd.h>
#endif

class inbuf : public std::streambuf {
protected:
    // data buffer:
    // - at most, four characters in putback area plus
    // - at most, six characters in ordinary read buffer
    static const int bufferSize = 10;  // size of the data buffer
    char buffer[bufferSize];           // data buffer

public:
    // constructor
    // - initialize empty data buffer
    // - no putback area
    // => force underflow()
    inbuf() {
        setg(buffer + 4,    // beginning of putback area
             buffer + 4,    // read position
             buffer + 4);   // end position
    }

protected:
    // insert new characters into the buffer
    virtual int_type underflow() {
        // is read position before end of buffer?
        if (gptr() < egptr()) {
            return traits_type::to_int_type(*gptr());
        }

        // process size of putback area
        // - use number of characters read
        // - but at most four
        int numPutback;
        numPutback = gptr() - eback();
        if (numPutback > 4) {
            numPutback = 4;
        }

        // copy up to four characters previously read into
        // the putback buffer (area of first four characters)
        std::memmove(buffer + (4 - numPutback), gptr() - numPutback,
                     numPutback);

        // read new characters
        int num;
        num = read(0, buffer + 4, bufferSize - 4);
        if (num <= 0) {
            // ERROR or EOF
            return EOF;
        }

        // reset buffer pointers
        setg(buffer + (4 - numPutback),  // beginning of putback area
             buffer + 4,                // read position
             buffer + 4 + num);         // end of buffer

        // return next character
        return traits_type::to_int_type(*gptr());
    }
};
```


构造函数会初始化所有pointer，这样就可以令缓冲区完全清空（如图15.6所示）。如果这个stream缓冲区被读取一个字符，函数underflow（）会被调用，它总是被stream缓冲区用来读取下一字符。一开始它会先检查input缓冲区内的字符，如果确实存在字符，就通过函数 memcpy（） 把这些字符移到回退区（putback area）。因此input缓冲区至多留有最后4个字符。接下来运用POSIX的低层I/O函数read（）从标准输入通道读取下一字符。一旦缓冲区调整至新状态，返回读取的第一个字符。


       eback()         gptr()         egptr() 
          │              │             │
          └──────────────┼─────────────┘
                         ▼
     ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬ ─ ─ ┐  
     │     │     │     │     │     │     │     │     │  
     └─────┴─────┴─────┴─────┴─────┴─────┴─────┴ ─ ─ ┘  
图15.6 初始化后的缓冲区

举个例子。假设第一次调用read（）读得'H'、'a'、'l'、'l'、'o'和'w'，input缓冲区的状态发生变化，如图15.7所示。由于第一次总是填入缓冲区，所以回退区的内容是空的，没有任何字符可被回退（putback）。

        eback()         gptr()                              egptr()
          │              │                                     │
          └──────────────┤                                     │
                         ▼                                     ▼
     ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─ ─ ─ ┐
     │     │     │     │ H   │ a   │ l   │ l   │ o   │ w   │      │
     └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─ ─ ─ ┘

图15.7 读入Hallow后的缓冲区

这些字符被提取后，最后4个字符被移到回退区，然后新字符又被读取。假设再次调用read（）读入'e'、'e'、'n'和'\n'，结果如图15.8所示。

      eback()                gptr()                    egptr()          
        │                      │                        │
        ▼                      ▼                        ▼
     ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬ ─ ─ ┐
     │ l   │ l   │ o   │ w   │ e   │ e   │ n   │ \n  │     │     │
     └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴ ─ ─ ┘
图15.8 续读4个字符后的缓冲区

下面是这个stream缓冲区的运用实例：
```cc
#include <iostream>
#include "inbuf1.hpp"

int main()
{
    inbuf ib;                         // create special stream buffer
    std::istream in(&ib);             // initialize input stream with that buffer

    char c;
    for (int i = 1; i <= 20; ++i) {
        // read next character (out of the buffer)
        in.get(c);

        // print that character (and flush)
        std::cout << c << std::flush;

        // after eight characters, put two characters back into the stream
        if (i == 8) {
            in.unget();
            in.unget();
        }
    }
    std::cout << std::endl;
}
```
程序在循环中读取并写出字符。读得第8个字符后，放回2个字符。所以，第7个字符和第8个字符被打印两次。

## 关于效能（Performance）
本节着重于效能（performance）上的讨论。一般而言stream class已经十分高效，但当I/O是程序效能的关键时，我们还可以进一步强化这些class。

15.2.3节第752页已经讨论过效能：你应该只包含编译时需要的头文件。尤其当你并没有使用标准stream对象时，应该避免包含＜iostream＞。

15.14.1 与 C 标准串流同步（Synchronization with C’s Stan-dard Streams）
默认情况下，八个C++标准stream（四个窄字符stream：cin、cout、cerr和clog，以及相应的四个宽字符版本）和C标准库的相应文件（stdin、stdout和stderr）是同步的。clog和wclog默认采用与cerr和wcerr相同的stream缓冲区，因此它们也默认与stderr同步，虽然在C标准库中并无其直接对应物。

视实际做法之不同，同步（synchronization）可能带来某些不必要的开销（额外负担）。举个例子，如果标准C++stream是以标准C文件实现出来，基本上就会限制相应的stream缓冲区的缓冲行为。然而，对于某些优化，尤其是对“格式化读取”的优化（参见15.14.2节第845 页），stream 缓冲区的缓冲行为非常必要。C++标准库为 ios_base 定义了一个static成员函数sync_with_stdio（） （见表15.47），允许我们改用更好的实现。

表15.47 令“标准C++Stream”和“标准C Stream”同步
| Static 函数                | 意义                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `sync_with_stdio()`        | 判断标准的 stream 对象是否与标准的 C stream 同步             |
| `sync_with_stdio(false)`   | 取消 C++ stream 和 C stream 的同步；前提是必须在任何 I/O 动作之前先被调用 |

sync_with_stdio（）以一个可有可无的Boolean为实参，用以决定是否和标准C stream同步。如果要取消同步，可以false为实参：
```cc
std::ios::sync_with_stdio(false)
```

注意，你必须在任何I/O操作之前取消同步。如果你在任何I/O发生之后才调用这个函数，其所导致的行为将视实现版本而定。

这个函数返回前一次被调用时的实参。如果先前不曾被调用过，返回的是true，反映出默认的标准stream。

注意，自 C++11 起，将“同步于标准 C stream （synchronization with the standard C streams）”取消，意味着将“并发支持（concurrency support）”取消（并发能力允许你在多线程中使用标准stream对象）——虽然可能出现插叙字符（interleaved character，见4.5节第56页）。

### Stream缓冲区内的缓冲机制
I/O是否具备缓冲能力，很大程度上影响到了效率。原因之一是，通常系统调用比较耗资源，应该尽可能避免。但在C++中还有许多更微妙的原因使我们至少应该在stream缓冲区中对input进行缓冲，这些原因包括：格式化I/O动作所使用的函数乃是“以stream buffer iterator访问stream”；而对stream buffer iterator做动作比对pointer做动作要慢。虽然差别不大，但也足够证明有必要对频繁的操作（例如格式化读取）进行改善。

因此，所有I/O动作都以stream缓冲区完成，后者实现了某种缓冲机制。但是仅仅依赖缓冲机制还不够，因为高效缓冲有三个冲突因素：

1.不采用缓冲机制来实现stream缓冲区，往往更简单。如果stream并不常被使用，或只用于output，那么缓冲机制倒也不那么重要（对output而言，stream buffer iterator和pointer之间的差异不如input那么严重）。但是一旦面对被大量使用的stream缓冲区，就应该毫不犹豫地实现缓冲机制。

2.每次output动作完成后，flag unitbuf会提示output stream清空自己的stream。操控器flush and endl也会清空各自的stream。若为求得最佳效能，三者都应避免。但是（举例）当写向控制台（console）时，写完一整行后还是可能需要清空stream。如果你的程序被迫频繁使用unitbuf、flush或endl，就要考虑采用某种特殊的stream缓冲设备，后者并不调用sync（）清空stream缓冲区，而是在适当时候调用其他函数。

3.运用函数 tie（）绑定某个stream（详见15.12.1节第819页），也会造成非必要地清空stream。因此非必要时请勿绑定stream。

实现一个新的stream缓冲区时，我们可以先不考虑缓冲机制。然后万一该stream缓冲区成了效率瓶颈，仍然可以在不影响程序其他部分的情况下实现缓冲。

### 直接使用Stream缓冲区
Class basic_istream和 basic_ostream之中，所有用于读/写字符的成员函数都以同样方式运作：首先构造相应的sentry对象，然后执行实际操作。sentry对象的构造可能导致：暴露潜在的绑定对象、忽略空白字符（对input而言）、某些“依赖于实现”的行为（例如多线程环境中的锁定，见15.5.4节第772页）。

对于无格式（unformatted） I/O，大多数操作通常都是无益的。如果在多线程环境中运用stream，只有locking操作可用。因此，进行无格式I/O时，最好直接使用stream缓冲区。

欲支持这种行为，你可以对stream缓冲区使用operator＜＜和＞＞：

· 将指向stream缓冲区的pointer传给operator＜＜，你便可以输出该stream内的所有输入。这可能是“通过C++I/O stream复制文件”的最快方法。例如：
```cc
#include <iostream>
int main()
{
    std::cout << std::cin.rdbuf();
}
```

这里的rdbuf（）取得cin的缓冲区（见15.12.2节第820页）。这么一来程序就将所有标准输入复制到了标准输出。

· 将指向stream缓冲区的pointer传给operator＞＞，你便可以将数据直接读进该stream缓冲区内。例如你可以通过以下方法把所有标准输入复制到标准输出：
```cc
#include <iostream>
int main()
{
    std::cin >> std::noskipws >> std::cout.rdbuf();
}
```

注意，必须清除flag skipws，否则会漏掉输入时的起始空格（见15.7.7节第789页）。

即使是格式化I/O，也可以直接使用stream缓冲区。举个例子，某循环读取了许多数值，整个循环生命期间只需构造一个 sentry对象就够，于是在循环内，便可手工略去空格（使用ws操控器也可以构造出一个sentry对象），然后可使用facet num_get（参见16.4.1节第873页）直接读取数值。

注意，stream缓冲区本身并无所谓差错状态，也不知道自己和哪些input stream或output stream相连接。所以在以下语句中：
```cc
out << in.rdbuf();
```

如果出错或到达文件末尾，没有什么办法可以改变差错状态。

# 分配器
allocator（分配器），它代表一种特定内存模型（memory model），并提供一种抽象概念，将对内存的索求最终转变为对内存的直接调用。
本章描述allocator及其相应的用以处理内存的低层特性。

## 以应用程序开发者的角度使用Allocator
就应用程序开发者而言，使用不同的allocator应该不成问题。你只需将allocator当作一个template实参即可。下面使用一个特殊allocator MyAlloc<>，创建容器和string：
```cc
// a vector with special allocator
std::vector<int, MyAlloc<int>> v;

// an int/float map with special allocator
std::map<int, float, std::less<int>,
         MyAlloc<std::pair<const int, float>>> m;

// a string with special allocator
std::basic_string<char, std::char_traits<char>, MyAlloc<char>> s;
```
如果打算使用自己开发的allocator，先制定一些类型定义以避免冗长代码，通常会比较好。例如：
```cc
// special string type that uses special allocator
typedef std::basic_string<char, std::char_traits<char>,
                          MyAlloc<char>> MyString;

// special string/string map type that uses special allocator
typedef std::map<MyString, MyString, std::less<MyString>,
                 MyAlloc<std::pair<const MyString, MyString>>> MyMap;

// create object of this type
MyMap mymap;
```
自C++11起，你可以使用alias template（也就是template typedef；见3.1.9节第27页）定义allocator的类型，但仍留下元素类型未决：
```cc
template <typename T>
using Vec = std::vector<T, MyAlloc<T>>;  // vector using own allocator

Vec<int> coll;  // equivalent to: std::vector<int, MyAlloc<int>>
```
使用non-default allocator分配出来的对象，并不会引起你什么异样感觉。

你可以运用operator==和！=比较两个allocator是否使用相同的内存模型。如果它返回true，表示其中一个allocator分配的存储空间可由另一个allocator收回。所有“以allocator为 template参数”的类型都会提供一个 get_allocator（）函数，我们可借此得到对应的allocator。例如：
```cc
if (mymap.get_allocator() == s.get_allocator()) {
    // OK, mymap and s use the same or interchangeable allocators
    ...
}
```
此外，自C++11起提供一个type trait（见5.4节第122页），用来检测被传入的allocator是否可转换为某类型T的allocator_type：
```cc
std::uses_allocator<T, Alloc>::value  // true if Alloc is convertible 
                                       // into T::allocator_type
```
## 用户自定义的Allocator
Allocator提供一份接口，可满足分配、生成、销毁和回收对象（见表19.1）。借由allocator容器和算法的元素存储方式因而得以被参数化。例如你可以实现出运用共享内存（shared memory）的allocator，或是让map的元素存储于持久性数据库（persistent database）。

Allocator基本操作
| 表达式            | 效果                                                 |
| ----------------- | ---------------------------------------------------- |
| `a.allocate(num)`   | 为 `num` 个元素分配内存                             |
| `a.construct(p,val)` | 将 `p` 所指的元素初始化为 `val`                     |
| `a.destroy(p)`       | 销毁 `p` 所指的元素                                 |
| `a.deallocate(p,num)` | 回收 `p` 所指的“可容纳 `num` 个元素”的内存空间     |

写一个属于自己的allocator并不很难。最重要的问题是你如何分配和回收空间，剩下的大多有默认行为并且往往已由C++11提供。（在C++11之前你必须实现“剩下的”那些内容。）下面是个例子，让我们看一个“行为就像default allocator”的allocator：
```cc
#include <cstddef>  // for size_t

template <typename T>
class MyAlloc {
public:
    // type definitions
    typedef T value_type;

    // constructors
    // - nothing to do because the allocator has no state
    MyAlloc() noexcept {
    }
    template <typename U>
    MyAlloc(const MyAlloc<U>&) noexcept {
        // no state to copy
    }

    // allocate but don't initialize num elements of type T
    T* allocate(std::size_t num) {
        // allocate memory with global new
        return static_cast<T*>(::operator new(num * sizeof(T)));
    }

    // deallocate storage p of deleted elements
    void deallocate(T* p, std::size_t num) {
        // deallocate memory with global delete
        ::operator delete(p);
    }
};

// return that all specializations of this allocator are interchangeable
template <typename T1, typename T2>
bool operator==(const MyAlloc<T1>&, const MyAlloc<T2>&) noexcept {
    return true;
}

template <typename T1, typename T2>
bool operator!=(const MyAlloc<T1>&, const MyAlloc<T2>&) noexcept {
    return false;
}
```
正如此例所示，你必须提供以下性质：
· 一个value_type类型定义，它只是用来代表被传入的template参数类型。
· 一个构造函数。
· 一个template构造函数，用来在类型有所改变时复制内部状态。注意，template构造函数并不会抑制copy构造函数（见3.2节第36页）。
· 一个成员函数allocate（），用来提供新的内存。
· 一个成员函数deallocate（），用来释放不再用到的内存。
· 构造函数和析构函数（如果必要的话），用来初始化、复制、清理内部状态。
· 操作符==和！=。

无须提供construct（）或destroy（），因为它们的默认实现（使用placement new初始化内存，以及明白调用析构函数以完成清理工作）通常已经足够。

使用这一基本实现，你应该看得出来，实现自己的allocator其实很容易。你可以使用最核心函数allocate（）和deallocate（）完成你自己的内存分配策略，像是重复使用内存而非立即释放内存，或是将内存映射至一个面向对象数据库段（a segment of an object-oriented database），或只是对内存分配行为调试（just debugging memory allocation）。此外你可以提供相应的构造函数和析构函数，用来提供和释放“allocate（）和deallocate（）所需履行之任务”。

注意，在C++11之前，你必须为 allocator提供更多成员——虽然那并不困难。相应的完整例子见alloc/myalloc03.hpp，这份资料涵盖于http：//www.cppstdlib.com所提供的allocator补充篇章中。

19.3 以程序库开发者的角度使用Allocator
本节以另一种人的视角看allocator的用法，那些人使用allocator来实现容器或其他组件，而那些容器或组件可掌握不同的allocator。本节由Bjarne Stroustrup的The C++Programming Language，3rd edition一书19.4节（见[Stroustrup：C++]）发展而来——当然是经过授权的。

让我以一个简单的vector实现方案为例。Allocator被当作template实参或构造函数实参传递给vector，然后被保存在其内部某处：
```cc
namespace std {
    template <typename T,
              typename Allocator = allocator<T>>
    class vector {
    private:
        Allocator alloc;       // allocator
        T*        elems;       // array of elements
        size_type numElems;    // number of elements
        size_type sizeElems;   // size of memory for the elements

    public:
        // constructors
        explicit vector(const Allocator& = Allocator());
        explicit vector(size_type num, const T& val = T(),
                        const Allocator& = Allocator());
        template <typename InputIterator>
        vector(InputIterator beg, InputIterator end,
               const Allocator& = Allocator());
        vector(const vector<T,Allocator>& v);
        // ... 其他成员（省略）
    };
}
```
上述第二个构造函数，根据元素个数num及数值val将vector初始化，可实现如下：

```cc
namespace std {
    template <typename T, typename Allocator>
    vector<T, Allocator>::vector(size_type num, const T& val,
                                 const Allocator& a)
        : alloc(a)  // initialize allocator
    {
        // allocate memory
        sizeElems = numElems = num;
        elems = alloc.allocate(num);

        // initialize elements
        for (size_type i = 0; i < num; ++i) {
            // initialize i-th element
            alloc.construct(&elems[i], val);
        }
    }
}
```

表19.2 针对“未初始化之内存”的若干便捷函数
| 表达式                        | 效果                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| `uninitialized_fill(beg,end,val)` | 以 `val` 初始化 `[beg,end)` 区间的元素                       |
| `uninitialized_fill_n(beg,num,val)` | 以 `val` 初始化 `beg` 开始的 `num` 个元素                 |
| `uninitialized_copy(beg,end,mem)` | 以 `[beg,end)` 区间的各元素，初始化自 `mem` 开始的对应位置元素 |
| `uninitialized_copy_n(beg,num,mem)` | 以始自 `beg` 的 `num` 个元素，初始化自 `mem` 开始的元素（C++11 起支持 ） |

为了初始化那些尚未初始化的内存，C++标准库提供了若干便捷函数，如表19.2所列。有了这些函数，构造函数的实现就更简单了：
```cc
namespace std {
    template <typename T, typename Allocator>
    vector<T, Allocator>::vector(size_type num, const T& val,
                                 const Allocator& a)
        : alloc(a)  // initialize allocator
    {
        // allocate memory
        sizeElems = numElems = num;
        elems = alloc.allocate(num);

        // initialize elements
        uninitialized_fill_n(elems, num, val);
    }
}
```

成员函数reserve（）的目的是在“不改变元素个数”的前提下保留更多内存（见7.3.1节第271页），可实现如下：
```cc
namespace std {
    template <typename T, typename Allocator>
    void vector<T, Allocator>::reserve(size_type size)
    {
        // reserve() never shrinks the memory
        if (size <= sizeElems) {
            return;
        }

        // allocate new memory for size elements
        T* newmem = alloc.allocate(size);

        // copy old elements into new memory
        uninitialized_copy(elems, elems + numElems, newmem);

        // destroy old elements
        for (size_type i = 0; i < numElems; ++i) {
            alloc.destroy(&elems[i]);
        }

        // deallocate old memory
        alloc.deallocate(elems, sizeElems);

        // update size and element pointer
        sizeElems = size;
        elems = newmem;
    }
}
```
#### 原始存储区的迭代器（Raw Storage Iterator）

C++标准库还提供了一个class raw_storage_iterator，用来在未初始化的内存中遍历并进行初始化工作。你可以借助它，使用任何算法并以该算法的结果作为内存的初值。

例如以下语句以[x.begin（），x.end（））区间内的元素值初始化elems所指的存储区：
```cc
// 假设 x 是某个容器（如 vector<T>），elems 是未初始化的内存指针（T*）
copy(x.begin(), x.end(),
     raw_storage_iterator<T*, T>(elems));
```
第一个template实参（上述的 T*）必须是一个对应于元素类型的output迭代器。第二个template实参（上述的T）必须是元素类型。

#### 临时缓冲区（Temporary Buffer）

也许你曾经在某些程序里头发现它们使用了两个函数get_temporary_buffer（）和return_temporary_buffer（）。这两个函数用来处理一些未初始化的内存，以供函数短暂需求。注意，get_temporary_buffer（）返回的内存可能少于预期，所以其返回值是个pair，内含所获得的内存地址和实际大小（以元素为单位）。下面是个用例：
```cc
void f()
{
    // allocate memory for num elements of type MyType
    pair<MyType*, std::ptrdiff_t> p 
        = get_temporary_buffer<MyType>(num);
    
    if (p.second == 0) {
        // could not allocate any memory for elements
        ...
    }
    else if (p.second < num) {
        // could not allocate enough memory for num elements
        // however, don't forget to deallocate it
        ...
    }

    // do your processing
    ...

    // free temporarily allocated memory, if any
    if (p.first != 0) {
        return_temporary_buffer(p.first);
    }
}
```
不过，使用get_temporary_buffer（）和return_temporary_buffer（）很难写出“异常发生时仍安全”（exception-safe）的代码，所以基本上它们已不再被用于程序库中。

# 并发
现代化体系结构（modern system architecture）通常支持同时执行多个任务（task）和多个线程（thread）。特别是如果采用多处理器内核（multiple processor core），那么程序执行时间可在多线程情况下获得大幅改善。

然而，并行（in parallel）处理也带来了新挑战：不再是完成一个语句后进行另一语句，而是多语句同时执行，于是可能导致并发访问（concurrently accessing）同一资源，造成创建、读取、涂写、删除等动作不在预期次序下发生，形成不可预测的结果。事实上多线程并发访问数据很容易变成噩梦，带来诸如死锁之类的问题，而“线程之间彼此等待”只能算是最单纯的一种情况。

在C++11之前，不论语言或标准库，对并发处理没有任何支持，纵使实现（implementa-tion）可自由给予若干承诺。随着C++11到来，这种情况有了改变，不论语言自身或标准库都得到强化，可支持并发编程（concurrent programming）（见4.5节第55页）：

· 语言核心定义了一个内存模型，保证当你更改“被两个不同线程使用”的两个object时，它们彼此独立，并引入了一个新关键字thread_local用以定义“变量带有thread专属值”。

· 标准库提供的支持允许你启动多线程，包括得以传递实参、返回数值、跨线程边界传递异常、同步化（synchronize）等，使我们能够对“控制流程”和“数据访问”实现同步化。

标准库在不同的层面分别提供支持。它提供一个高级接口，允许你启动线程，包括传递实参、处理结果和异常，而那是架构在若干与之对应的低层接口上。换句话说，标准库也提供一组低层接口，像是mutex或atomic，用来对付放宽的内存次序（relaxed memory order，RMO）。

本章将介绍上述标准库特性。请注意，“并发”这一主题及标准库对此提供的描述，足以填满好几本书。所以这里我只针对一般应用程序开发者介绍总体观念和典型范例，并且主要焦点放在高级接口。

至于细节，特别是微妙的低层问题和特性，请参考我所提及的书籍和文章。关于“并发”这个大主题，我的最高推荐是C++Concurrency in Action，作者Anthony Williams（见[Williams：C++Conc]）。

Anthony 是这个主题的世界级专家，没有他的参与，本章无法完成。他不但允许我预先拜读他的书籍，还提供标准并发库（standard concurrency library）的第一份实现（见[Just-Thread]），撰写数篇文章，并给予我极有价值的反馈，这一切都帮助我以一种（但愿是）有用的方式呈现本主题。此外，我也要感谢帮助我写下本章的其他专家：Hans Boehm、Scott Meyers、Bartosz Milewski、Lawrence Crowl和Peter Sommerlad。

本章组织如下：

· 首先介绍各式各样的多线程启动办法。介绍了高级和低层接口后，开始介绍启动线程的细节。

· 18.4节第982页对于同步化线程（synchronizing thread）所引发的问题提供了一份详细讨论。最主要的问题就是数据的并发访问（concurrent data access）。

· 最后，探讨用以“同步化线程”和“并发数据访问”的各种特性：

-Mutex和lock（互斥体和锁，见18.5节第989页），包括call_once（）（见18.5.3节第1000页）。

-Condition variable（条件变量；见18.6节第1003页）。

-Atomic（见18.7节第1012页）。

## 高级接口：async（）和Future
对初学者而言，“以多线程运行程序”的最佳起点就是C++标准库中由 std：：async（）和class std：：future＜＞提供的高级接口：

· async（）提供一个接口，让一段机能（a piece of functionality）或说一个callable object（见4.4节第54页）若是可能的话在后台运行，成为一个独立线程。

· Class future＜＞允许你等待线程结束并获取其结果（一个返回值，或者也许是一个异常）。

本节详细介绍这一高级接口，并延伸至class std：：shared_future＜＞，它允许你在多个地点等待和处理线程结果。

### async（）和Future的第一个用例
假设我们需要计算两个操作数的总和，而这两个操作数是两个函数的返回值。寻常做法如下：
```cc
func1() + func2()
```

这意味着对操作数的处理是循序发生的。程序首先调用func1（）然后调用func2（），或是颠倒过来（根据语言规则，这一次序无法预期）。不论哪种情况，整体处理时间是func1（）所花时间加上func2（）所花时间，再加上计算总和所花的时间。

近年来，使用多处理器（multiprocessor）的硬件几乎处处可见，我们因此可以将上述计算做得更好，可以尝试并行运行func1（）和func2（），使其整体运行时间只需是“func1（）和func2（）运行时间中的较大者”加上计算总和的时间。

下面是第一个示范程序：
```cc
// concurrency/async1.cpp
#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>
using namespace std;

int doSomething(char c)
{
    // random-number generator (use c as seed to get different sequences)
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    // loop to print character after a random period of time
    for (int i = 0; i < 10; ++i) {
        this_thread::sleep_for(chrono::milliseconds(id(dre)));
        cout.put(c).flush();
    }

    return c;
}

int func1()
{
    return doSomething('.');
}

int func2()
{
    return doSomething('+');
}

int main()
{
    cout << "starting func1() in background"
         << " and func2() in foreground:" << endl;

    // start func1() asynchronously (now or later or never):
    future<int> result1(async(func1));

    int result2 = func2();  // call func2() synchronously (here and now)

    // print result (wait for func1() to finish and add its result to result2)
    int result = result1.get() + result2;

    cout << "\nresult of func1()+func2(): " << result
         << endl;
}
```

为了让事情视觉化，我将func1（）和func2（）内的繁复处理简化为对doSomething（）的调用，它不时打印一个被当作实参传递进去的字符[1]并最终返回该字符的int值。所谓“不时”是借由一个“随机数生成器”（用以指定时间间隔）实现，其中std：：this_thread：：sleep_for（）作为当前线程的暂停时间（见17.1节第907页对随机数的详细说明以及18.3.7节第981页对 sleep_for（）的详细说明）。注意，我们需要一个独一无二的seed（种子）交给“随机数生成器”构造函数，此处采用被传入的字符c，确保产生出不同的随机数序列。

现在，不再这么调用：
```cc
int result = func1() + func2();
```
改而这么调用：
```cc
std::future<int> result1(std::async(func1));
int result2 = func2();
int result = result1.get() + result2;
```

首先使用 std::async（） 尝试启动 func1（） 于后台，并将结果赋值给某个 std：：future object：
```cc
std::future<int> result1(std::async(func1));
```

在这里，async（） 尝试将其所获得的函数立刻异步启动于一个分离线程内。因此概念上func1（）在这里被启动了，不会造成main（）停滞。基于两个原因，返回future object是必要的：

1.它允许你取得“传给async（）的那个函数”的未来结果——也许是个返回值，也许是个异常。这个future object已受到“被启动函数”返回类型的特化，如果被启动的是个返回“无物”的后台任务（background task），这就会是std：：future＜void＞。

2.它必须存在，确保“目标函数”或快或慢终会被调用。注意先前我说async（）尝试启动目标函数。如果这样的事情没发生，稍后我们需要这个future object才能强迫启动之（当我们需要函数的运行结果或当我们想要确保该函数被执行时）。

因此，即使你对启动于后台的那个函数的结果不感兴趣，还是需要握有这个 future object。

为了能够在“启动及控制函数”处与“返回之future object”之间交换数据，二者都指向一个所谓的shared state（见18.3节第973页）。

当然，你可以（并且通常会）使用 auto来声明future object（上例我之所以写出其类型，是为了明确展示其类型）：
```cc
auto result1(std::async(func1));
```

接下来我们启动func2（）于前台（foreground），这是个正常的同步化调用，于是程序在此停滞：
```cc
int result2 = func2();
```

如果先前func1（）成功地被async（）启动且尚未结束，现在func1（）和func2（）就是并行运作。

接下来处理总和。这就是需要func1（）成果的时刻。为了获得它，我们对先前返回的future object调用get（）：
```cc
int result = result1.get() + result2;
```

随着get（）被调用，以下三件事情之一会发生：

1.如果func1（）被async（）启动于一个分离线程中并且已结束，你会立刻获得其结果。

2.如果func1（）被启动但尚未结束，get（）会引发停滞（block）待func1（）结束后获得结果。

3.如果func1（）尚未启动，会被强迫启动如同一个同步调用；get（）会引发停滞直至产生结果。

这样的行为很重要，因为这确保了在单线程环境中，或是当 async（）无法启动新线程时（不论基于任何理由），程序仍能有效运作。

调用async（）并不保证传入的函数一定会被启动和结束。如果有个线程处于可用状态，那么它的确会被启动，但如果不是这样（也许你的环境不支持多线程，或者也许当时无线程可用），这一调用会被推迟至你明确说你需要其结果（也就是当调用get（））或只是希望目标函数完成其任务（也就是调用wait（）；见18.1.1节第953页）。

因此，
```cc
std::future<int> result1(std::async(func1));
```
和
```cc
result1.get()
```
的组合允许你以某种方式优化程序：（1） 如果可能，当main 线程的下一个语句被处理时func1（）被并行运行，（2）如果无法并行运行，那么 func1（）会在 get（）被调用时被循序调用（called sequentially）。这就意味着无论如何都能保证至少在get（）执行后一定会调用func1（）——不是异步就是同步。

于是，这个程序的输出有两种可能。如果async（）成功启动func1（），输出结果可能如下：
```bash
starting func1() in background and func2() in foreground:
++.++++.+.+.....
result of func1()+func2(): 89
```
如果async（）无法启动func1（），后者会在“func2（）结束后且get（）被调用时”执行起来，于是有类似下面的输出：
```bash
starting func1() in background and func2() in foreground:
+++++++++.………
result of func1()+func2(): 89
```
所以，根据第一个例子，我们可以定义让程序更快速的一般性做法：你可以修改程序使它受益于并行处理（如果低层平台对此有所支持），但仍能够在单线程环境中正确运作。为了达到这个目标，你必须这么做：

·#include ＜future＞

· 传递某些可并行执行的函数，交给 std：：async（） 作为一个可调用对象（callable ob-ject）。

· 将执行结果赋值给一个future＜ReturnType＞object。

· 当你需要那个被启动函数的执行结果，或当你想确保该函数结束，就对future＜＞object调用get（）。

然而请注意，这只适用于不发生data race（数据竞争）的情况下。Data race意指两个线程并发使用同一笔数据而导致不可预期的行为（见18.4.1节第982页）。

注意，如果没调用get（）就不保证func1（）一定会被调用。一如我所说，如果async（）无法立刻启动它所收到的函数，就会推迟调用，使得当程序“调用get（）意欲明确索求目标函数的结果”（或是调用wait（）；见第953页）才被调用。如果没有那样一个明确请求，即使main（）终止造成程序结束，也不会唤醒后台线程。

也请注意，你必须确保只在最必要时才索取“被async（）启动”的那个函数的执行结果。例如以下优化或许不是你要的：
```cc
std::future<int> result1(std::async(func1));
int result = func2() + result1.get(); // 可能再func1后调用func2
```

由于上述第二个语句右侧的核算顺序不明确，result1.get（）有可能在func2（）之前被调用，于是你又一次获得了循序式处理（sequential processing）。

为了获得最佳效果，一般而言你的目标应该将调用 async（）和调用 get（）之间的距离最大化。或者，以[N3194：Futures]的术语来说：早调用而晚返回（Call early and return late）。

如果传给async（）的函数不返回任何东西，async（）会产出一个future＜void＞，那是future＜＞的一个偏特化版，这种情况下get（）返回“无物”：
```cc
std::future<void> f(std::async(func)); // 尝试异步调用func
...
f.get(); //等待func结束
```

最后请注意，传给async（）的东西可以是任何类型的callable object：可以是函数、成员函数、函数对象（function object）或lambda（见4.4节第54页）。你可采用inline形式将“应该在专属线程中运行”的函数写成一个lambda（见3.1.10节第28页）并传递之：
```cc
std::async([] {...});
```

#### Launch（发射）策略

你也可以强迫async（）绝不推延目标函数的执行，只要明确传入一个launch策略用以指挥async（），告诉它当它被调用时应明确地以异步方式启动目标函数：
```cc
// force func1() to start asynchronously now or throw std::system_error
std::future<long> result1 = std::async(std::launch::async, func1);
```

如果异步调用在此处无法实现，程序会抛出一个 std：：system_error异常（见4.3.1节第43页）并带差错码resource_unavailable_try_again，它相当于POSIX的errno EAGAIN （见4.3.2节第45页）。

有了这个async发射策略，就不必非得调用get（）了，因为如果返回的future生命即将结束，这个程序必会等待func1（）结束。因此，如果你不调用get（），当离开future object作用域时（此处是指main（）结束），程序会等待后台任务（background task）结束。尽管如此，程序结束前调用get（）会让行为更加清晰。

如果你不将std：：async（std：：launch：：async，...） 的结果赋值出去，调用者会在此停滞（block）到目标函数结束，那就相当于一个完完全全的同步调用（synchronous call）。

与此类似，你可以强制延缓执行（deferred execution）：以std：：launch：deferred为发射策略传给async（）。下面的做法允许你延缓func1（）直到你对f调用get（）：
```cc
std::future<...> f(std::async(std::launch::deferred,
                              func1));  // defer func1 until get()
```

这保证func1（）绝不会在没有get（）（或wait（）；见第953页）的情况下启动。这个策略的特别在于允许你写出lazy evaluation（缓式求值）。例如：
```cc
auto f1 = std::async(std::launch::deferred, task1);
auto f2 = std::async(std::launch::deferred, task2);
//...
auto val = thisOrThatIsTheCase()? f1.get() : f2.get();
```
此外，明确申请deferred发射策略也许有助于在一个单线程环境中模拟async（）的行为，或是简化调试——除非需要考虑race condition（竞争形势）。

#### 处理异常

目前已讨论的是线程和后台任务（background task）成功执行的情况。然而万一出现异常将如何？

好消息是：没有什么特别事情会发生；“对future调用get（）”也能处理异常。事实上当get（）被调用，且后台操作已经（或随后由于异常）而终止，该异常不会在此线程内被处理，而是会再次被传播出去。因此，欲处理后台操作所生的异常，你只需要偕同get（）做出“以同步方式调用该操作”所做的相同动作即可。

举个例子，我们启动一个后台任务（background task），带有一个无限循环（endless loop），其内分配内存，为list安插一个新元素：[5]
```cc
#include <future>
#include <list>
#include <iostream>
#include <exception>
using namespace std;

void task1()
{
    // endless insertion and memory allocation
    // - will sooner or later raise an exception
    // - BEWARE: this is bad practice
    list<int> v;
    while (true) {
        for (int i = 0; i < 1000000; ++i) {
            v.push_back(i);
        }
        cout.put('.').flush();
    }
}

int main()
{
    cout << "starting 2 tasks" << endl;
    cout << "- task1: process endless loop of memory consumption" << endl;
    cout << "- task2: wait for <return> and then for task1" << endl;

    auto f1 = async(task1);  // start task1() asynchronously (now or later or never)

    cin.get();  // read a character (like getchar())

    cout << "\nwait for the end of task1: " << endl;
    try {
        f1.get();  // wait for task1() to finish (raises exception if any)
    }
    catch (const exception& e) {
        cerr << "EXCEPTION: " << e.what() << endl;
    }
}
```
这个无限循环迟早会出现异常（也许是个bad_alloc异常；见4.3.1节第43页），该异常会终止线程，因为它未被捕获。Future object会保持这一状态直到get（）被调用。搭配get（）后这个异常在main（）内被进一步传播。

现在我总结async（）接口和future如下：async（）提供一种编程环境，让我们有机会并行启动某些“稍后（当get（）被调用时）才会用到其结果”的动作。换句话说，如果你有某个独立机能（函数） f，你有可能受益于并行机制（parallelization），做法是在你需要调用f时改而把f传给async（），然后在你需要f的结果时改为“对async（）返回的future调用get（）”。于是，你拥有相同的行为，但是有机会获得较佳效率，因为 f有可能并行运行——在f的执行结果被索取之前。

#### 等待和轮询（Waiting and Polling）

一个future＜＞只能被调用get（）一次。在那之后future就处于无效状态，而这种状态只能借由“对future调用valid（）”来检测。此情况下对它的任何调用（析构除外）会导致不可预期的行为（详见18.3.2节第975页）。

但是future也提供一个接口，允许我们等待后台操作完成而不需要处理其结果。这个接口可被调用一次以上；也可以结合一个duration（时间段）或timepoint（时间点）以限制等待时间。

只要对某个future调用wait（），就可以强制启动该future象征的线程并等待这一后台操作终止：
```cc
std::future<...> f(std::async(func));  // try to call func asynchronously
...
f.wait();  // wait for func to be done (might start background task)
```

另外还有两个类似函数，但它们并不强制启动线程（如果线程尚未启动的话）：

1.使用wait_for（）并给予一个时间段，就可让“异步、运行中”的操作等待一段有限时间：
```cc
std::future<...> f(std::async(func));  // try to call func asynchronously
...
f.wait_for(std::chrono::seconds(10));  // wait at most 10 seconds for func
```

2.使用wait_until（），就可以等待直至达到某特定时间点：
```cc
std::future<...> f(std::async(func));  // try to call func asynchronously
...
f.wait_until(std::system_clock::now() + std::chrono::minutes(1));
```

不论wait_for（）或wait_until（）都返回以下三种东西之一：

· std：：future_status：：deferred——如果 async（）延缓了操作而程序中又完全没有调用wait（）或get（）（那会强制启动）。这种情况下上述两个函数都会立刻返回。

· std：：future_status：：timeout——如果某个操作被异步启动但尚未结束，而waiting又已逾期（对于给定的时间段而言）。

· std：：future_status：：ready——如果操作已完成。

wait_for（）或 wait_until（）特别让我们得以写出所谓的speculative execution（投机性运行）。举个例子，考虑这样的情景：我们必须在某个时间段内获得某一运算之尚堪可用的结果（usable result），而如果有精确结果（accurate answer）更好。[6]
```cc
#include <future>
#include <chrono>

// 函数声明
int quickComputation();     // process result "quick and dirty"
int accurateComputation();  // process result "accurate but slow"

std::future<int> f;  // Outside declared because lifetime of accurateComputation()
                     // might exceed lifetime of bestResultInTime()

int bestResultInTime()
{
    // 定义获取答案的时间槽（1分钟后）
    auto tp = std::chrono::system_clock::now() + std::chrono::minutes(1);

    // 启动快速计算和精确计算
    f = std::async(std::launch::async, accurateComputation);
    int guess = quickComputation();

    // 给精确计算分配剩余的时间槽
    std::future_status s = f.wait_until(tp);

    // 返回当前能拿到的最佳计算结果
    if (s == std::future_status::ready) {
        return f.get();
    } else {
        return guess;  // accurateComputation() 会继续执行
    }
}


```

注意future f不能是声明于bestResultInTime（）内的local对象，那样的话若时间太短以至于无法完成 accurateComputation（），future析构函数会停滞（block）直到异步操作结束。

如果传入一个zero时间段，或一个过去时间点，就可以仅轮询（poll）是否有个后台任务已被启动，和/或是否它正在运行中：
```cc
    std::future<void> f(async(task));  // try to call task asynchronously
    ...
    // 在 task 未完成时做些事（可能永远不会结束！）
    while (f.wait_for(std::chrono::seconds(0)) != std::future_status::ready) {
        //...
```
然而请注意，如此循环有可能不会结束，因为（例如）在单线程环境中，这一调用将被推迟直至 get（）被调用。因此，你若非调用 async（）并以其第一实参指定发射策略为std：：launch：：async，就该明确检查是否wait_for（）返回std::future_status::deferred：
```cc
    // 尝试异步调用 task
    std::future<void> f = std::async(task);  
    ...
    // 检查任务是否是延迟执行（deferred）
    if (f.wait_for(std::chrono::seconds(0)) != std::future_status::deferred) {
        // 如果不是延迟执行，在任务未完成时做一些事
        while (f.wait_for(std::chrono::seconds(0)) != std::future_status::ready) {
            // 这里可插入任务未完成时的逻辑，比如打印等待提示、执行其他操作等
            //...
        }
    }
    ...
    // 强制执行任务（若为 deferred 则触发执行）并等待结果（或异常）
    auto r = f.get();  
```

引发无限循环的另一个可能原因是，运行此循环的线程完全占用处理器（processor），其他线程无法获得丝毫时间来备妥future。这会巨幅降低程序速度。最简单的修正就是在循环内调用yield（）（见18.3.7节第981页）：
```cc
std::this_thread::yield(); // 暗示重新调度
```
以及/或是睡眠一小段时间。

关于时间段和时间点（duration and timepoint），详见5.7节第143页，它们可成为wait_for（）和wait_until（）的实参。注意，当面对system-time调整时，wait_for（）和wait_un til（）往往不同（详见5.7.5节第160页）。

### 实例：等待两个Task
第三个程序示范了刚才提及的一些能力：
```cc
#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>
using namespace std;

void doSomething(char c)
{
    // 随机数生成器（用 c 作为种子获取不同序列）
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    // 循环：随机延迟后打印字符
    for (int i = 0; i < 10; ++i) {
        this_thread::sleep_for(chrono::milliseconds(id(dre)));
        cout.put(c).flush();
    }
}

int main()
{
    cout << "starting 2 operations asynchronously" << endl;

    // 在后台启动两个循环，分别打印 '.' 和 '+'
    auto f1 = async([] { doSomething('.'); });
    auto f2 = async([] { doSomething('+'); });

    // 如果至少有一个后台任务不是延迟执行
    if (f1.wait_for(chrono::seconds(0)) != future_status::deferred || 
        f2.wait_for(chrono::seconds(0)) != future_status::deferred) {

        // 轮询直到至少一个循环完成
        while (f1.wait_for(chrono::seconds(0)) != future_status::ready && 
               f2.wait_for(chrono::seconds(0)) != future_status::ready) {
            // 提示调度器切换到下一个线程
            this_thread::yield(); 
        }
    }

    cout.put('\n').flush();

    // 等待所有循环完成并处理异常
    try {
        f1.get();
        f2.get();
    }
    catch (const exception& e) {
        cout << "\nEXCEPTION: " << e.what() << endl;
    }

    cout << "\ndone" << endl;
}
```

再一次，我们有个操作函数doSomething（）不时打印一个被传为实参的字符（见18.1.1节第948页）。

现在，借由async（），我们在后台启动doSomething（）两次，打印两种不同字符，使用不同的延迟时间，后者由相应的随机数序列（random-number sequence）产生：
```cc
auto f1 = std::async([]{doSomething('.');});
auto f2 = std::async([]{doSomething('+');});
```

在多线程环境中，此时将同时运行起两个操作，不定时打印出不同的字符。

接下来，轮询（poll）是否其中一个操作已完成：
```cc
// 轮询任务状态，直到至少一个任务完成（ready）
while (f1.wait_for(chrono::seconds(0)) != future_status::ready && 
       f2.wait_for(chrono::seconds(0)) != future_status::ready) {
    // 提示调度器切换线程（给其他线程执行机会）
    this_thread::yield(); 
}

```

然而万一 async（）被调用时上述两个task都未被在后台启动，这个循环将永远不会结束，所以我们首先必须检查是否至少有一个操作未被推迟（not deferred）：
```cc
// 额外的防御性条件判断：检查是否至少有一个任务不是延迟执行（deferred）
if (f1.wait_for(chrono::seconds(0)) != future_status::deferred || 
    f2.wait_for(chrono::seconds(0)) != future_status::deferred) {
    // 这里可补充任务未被延迟时的逻辑
    //...
}
```

另一种做法是，调用async（）并给予发射策略std：：launch：async。

一旦至少有一个后台操作已完成，或两个操作都没被启动，我们就写出一个newline字符，然后等待两个循环（在doSomething（）内）结束：
```cc
f1.get();
f2.get();
```

这里使用get（）处理可能发生的任何异常。

在一个多线程环境中，此程序可能有以下输出：
```bash
starting 2 operations asynchronously
++.++.+.+.++.+.+
..
done
```
注意，程序输出的三种字符.、+和newline，其次序没有任何保证。典型情况是，首先出现字符.，它来自第一个被启动的操作（因此也就稍早一些启动），但是正如此处所见，第一个出现的也可能是+。字符.和+可能混杂，但也不一定。事实上，如果你移除sleep_for（）语句（它会在每次打印字符时强制推迟），第一循环会在首次context switch （切换至其他线程）前全部做完，那么程序的输出比较可能像下面这样：
```bash
starting 2 operations asynchronously
..........
++++++++++
done
```
如果环境不支持多线程，这份输出还是会出现，因为这种情况下对doSomething（）的两次调用将会借由对get（）的调用而被同步调用。

Newline字符何时被打印？这同样不明确，有可能发生于任何其他字符被写出之前——如果两个后台任务被推迟“直至get（）被调用”才执行，那么被推迟的任务（deferred task）将会“结束一个后才进行另一个”（译注：因为这种情况下它们其实是同步运行）：
```cc
starting 2 operations asynchronously
..........++++++++++
done
```

我们唯一确知的是，newline绝不会在两个循环中的某一个完成前被打印出。我们甚至无法保证newline紧邻于“序列之最末字符”之后（译注：意思是可能会接上另一序列的若干字符然后才出现newline），因为“循环之一结束后记录相应的future object”以及“该future被核值（evaluated）”可能需要花费一些时间（注意，这并非实时处理）。基于这个原因，说不定你会获得一份如下的输出，其中若干+字符被写在最后一个.之后且newline字符之前：

```bash
starting 2 operations asynchronously
.+.+.+.+.+.+..++
+++
done
```
#### 传递实参（Passing Argument）

前一个例子示范了“传递实参给后台任务”的一种做法：使用一个lambda（见3.1.10节第28页）并让它调用后台函数：
```cc
auto f1 = std::async([]{doSomething('.'); });
```

当然，也可以传递“在async（）语句之前就已存在”的实参。一如以往，可采用by value方式或by reference方式传递它们：
```cc
char c = '@';
auto f = std::async([=] {  // 按值捕获作用域内对象
    doSomething(c);  // 传递 c 的拷贝给 doSomething
});
```

由于定义 capture 为 [=]，因此传递给 lambda 的是 c 的拷贝（copy）及所有其他 visible object，所以在lambda内你可以传递那个c拷贝给doSomething（）。

然而另有其他办法可以传递实参给 async（），因为 async（） 提供了 callable object （见4.4节第54页）的惯常接口。举个例子，如果你传递function pointer作为第一实参给async（），你可以传递更多实参，它们将成为被调用的那个函数的参数：
```cc
char c = '@';
auto f = std::async(doSomething, c);  // 异步调用 doSomething(c)
```

也可以采用by reference方式传递实参，但这么做的风险是，被传递值甚至可能在后台任务启动前就变得无效。这对于lambda及“直接被调用的函数”都适用：
```cc
char c = '@';
auto f = std::async([&] { doSomething(c); });  // 按引用捕获，风险：c 可能提前销毁

char c = '@';
auto f = std::async(doSomething, std::ref(c));  // 用 ref 传递引用，风险同上
```

但如果你控制实参寿命，使它超越后台任务的生命，就可以那么做。例如：
```cc
void doSomething(const char& c);  // 假设函数声明
...
char c = '@';
auto f = std::async([&] { doSomething(c); });  // 按引用传递
...
f.get();  // 需保证 c 生命周期到此处
```

但是，当心，如果你“以by reference方式传递实参”只是为了可在另一个线程中改动它们，你可能轻易落入不明确行为（undefined behavior）之中。考虑下面的例子，在试图启动一个输出循环（于后台打印一个字符）后，你改变该字符：
```cc
void doSomething(const char& c);  // 假设函数声明
...
char c = '@';
auto f = std::async([&] { doSomething(c); });  // 按引用传递
...
c = '_';  // 可能改变后台任务输出（若任务仍在运行）
f.get();  // 需保证 c 生命周期到此处
```

首先，“这里”以及“在doSomething（）内”对c的处理，其次序无法预期。因此，该字符的变换可能发生于输出循环之前、之中或之后。更糟的是，我们在某一线程中改动 c，在另一个线程中读取c，这是对同一对象的异步并发处理（所谓data race，见18.4.1节第982页），将导致不可预期的行为，除非你使用mutex（互斥体，见18.5节第989页）或atomic （见18.7节第1012页）保护并发处理动作。

所以，让我们说清楚：如果你使用async（），就应该以by value方式传递所有“用来处理目标函数”的必要object，使async（）只需使用局部拷贝（local copy）。如果复制成本太高，请让那些object以const reference的形式传递，且不使用mutable。其他所有情况请阅读18.4节第982页，并且确定你了解你的做法蕴涵的意义和牵连。

你也可以传给async（）一个“指向成员函数”的pointer。这种情况下，位于该成员函数名称之后的第一个实参必须是个reference或pointer，指向某个object，后者将调用该成员函数：


### Shared Future
正如我们已看到的，class std：：future提供了“处理并发运算之未来结果”的能力。然而你只能处理该结果一次。第二次调用get（）会导致不可预期的行为（根据C++标准库的说法，通常是鼓励（但不强制）抛出一个std：：future_error）。

然而有时候，多次处理“并发运算之未来结果”是合理的，特别当多个其他线程都想处理这份结果时。基于这个目的，C++标准库提供了class std：：shared_future，于是你可以多次调用get（），导致相同结果，或导致抛出同一个异常：
```cc
#include <future>  // 需包含此头文件以使用 std::async

class X
{
public:
    void mem(int num);
    // 可根据需求补充其他成员（如构造、析构等），这里省略...
};

X x;
// 异步调用 x 的 mem 成员函数，参数为 42
auto a = std::async(&X::mem, x, 42);  
// 若需等待异步任务完成或获取结果，可调用 a.get() 等，这里省略后续逻辑...
```
考虑下面这个例子：
```cc
#include <future>
#include <thread>
#include <iostream>
#include <exception>
#include <stdexcept>
using namespace std;

int queryNumber()
{
    // 读取数字
    cout << "read number: ";
    int num;
    cin >> num;

    // 若读取失败，抛出异常
    if (!cin) {
        throw runtime_error("no number read");
    }
    return num;
}

void doSomething(char c, shared_future<int> f)
{
    try {
        // 等待获取 queryNumber 的结果
        int num = f.get();  
        // 根据结果循环打印字符
        for (int i = 0; i < num; ++i) {
            this_thread::sleep_for(chrono::milliseconds(100));
            cout.put(c).flush();
        }
    }
    catch (const exception& e) {
        // 捕获并打印线程中的异常
        cerr << "EXCEPTION in thread " << this_thread::get_id() 
             << ": " << e.what() << endl;
    }
}

int main()
{
    try {
        // 启动一个线程读取数字
        shared_future<int> f = async(queryNumber);  

        // 启动三个线程，用不同字符处理数字
        auto f1 = async(launch::async, doSomething, '.', f);
        auto f2 = async(launch::async, doSomething, '+', f);
        auto f3 = async(launch::async, doSomething, '*', f);

        // 等待所有线程完成
        f1.get();
        f2.get();
        f3.get();
    }
    catch (const exception& e) {
        // 捕获并打印主函数中的异常
        cout << "\nEXCEPTION: " << e.what() << endl;
    }
    cout << "\ndone" << endl;
}
```
此例之中有个线程调用queryNumber（）查询一个整数值，该值随后被其他已执行的多个线程使用。为执行这份任务，用以启动“查询线程”的那个std：：async（）的执行结果被赋值给一个shared_future object，后者以返回值为template参数：
```cc
shared_future<int> f = async(queryNumber);
```
也就是说，shared future可以寻常的future为初值，于是future的状态（state）会被搬移到shared future身上。为了能在上述声明式中使用auto，你可以改而调用成员函数share（）：
```cc
auto f = async(queryNumber).share();
```
就内部而言，所有shared future object共享所谓shared state，后者由async（）建立，用来存放目标函数的运行结果（也存放函数本身——如果它被推迟执行的话）。

这个shared future随后被传给其他线程，它们启动doSomething（）并以该shared future作为第二实参：
```cc
auto f1 = async(launch::async, doSomething, '.', f);
auto f2 = async(launch::async, doSomething, '+', f);
auto f3 = async(launch::async, doSomething, '*', f);
```
每一次 doSomething（）被调用，便通过传入之第二参数shared future的成员函数get（），等待及处理queryNumber（）的执行结果：
```cc
void doSomething (char c, shared_future<int> f)
{
    try {
        int num = f.get();  // get result of queryNumber()
        ...
    }
    catch (const exception& e) {
        cerr << "EXCEPTION in thread " << this_thread::get_id()
             << ": " << e.what() << endl;
    }
}
```
如果queryNumber（）抛出异常（当程序未能读到整数时），那么对doSomething（）的每一次调用都会获得因f.get（）而来的异常，于是对应的异常处理（exception handling）便会发生。

因此，在读取了数值5之后，有可能输出：
```bash
read number: 5
*+.*.+.*.++.*.+
done
```
如果输入'x'，有可能输出：
```bash
read number: x
EXCEPTION in thread 3: no number read
EXCEPTION in thread 4: no number read
EXCEPTION in thread 2: no number read

done
```

注意，上述的线程输出次序以及线程ID不可预期（关于线程ID，详见18.2.1节第967页）。也请注意，future和shared_future的get（）声明式存在一个小小差异：

· Class future＜＞提供的get（）如下（T是返回值类型）：
```cc
T future<T>::get();  // general get()
T& future<T&>::get();  // specialization for references
void future<void>::get();  // specialization for void
```

其中第一形式返回“搬移后之执行结果”或“该结果的一份拷贝”。

· Class shared_future＜＞提供的get（）如下：
```cc
const T& shared_future<T>::get();  // general get()
T& shared_future<T&>::get();  // specialization for references
void shared_future<void>::get();  // specialization for void
```
其中第一形式返回一个reference，指向存放于“被共享之shared state”的结果值。

或者，如[N3194：Futures]所述：

“单一使用值（single-use value） get（） 被最有效地搬动（例如 std：：vector＜int＞ v=f.get（））。……而const reference get（）则被最有效地处理（例如int i=f.get（）[3]）。”如果返回值被改动的话，这一设计会导致生命期（lifetime）或数据竞争（data race）主题上的某些风险（详见18.3.3节第977页）。

你也可以采用by reference方式传递shared future（也就是说，将它声明为一个reference并使用std：：ref（）传递它）：
```cc
#include <future>  // 需包含此头文件以使用 async、shared_future 等

// 函数声明（假设 doSomething 已定义，完整代码需补充函数体）
void doSomething (char c, const shared_future<int>& f);  

// 创建 shared_future<int> 对象（示例中未完整初始化，需结合实际场景）
shared_future<int> f;  
// 异步启动 doSomething，用 std::ref 传递 f 的引用
auto f1 = async(launch::async, doSomething, '.', std::ref(f));  
}
```

这就不再是“使用多个shared future object而由它们共享同一个shared state”，而是“使用shared future object执行多次 get（）（每个线程一次）”。然而这种做法风险较高。作为一个程序员，你必须确保f的寿命（是的，是f，而不是它所指向的shared state）不短于被启动的线程。此外请注意，shared future的成员函数并不与它们自身同步（synchronize）——虽然被共享的shared state是同步的。所以，如果你的作为比“只是读取数据”更多，你或许需要外部的同步化技术（见18.4节第982页）以避免data race，因为那会导致不可预期的行为。抑或如Lawrence Crowl——一位并发库（concurrency library）作者——在某次私下联络中所言：“如果代码紧紧保持着高度协调，以by reference方式传递是好的。但如果代码进入一个对于目标和限制都不甚了解的地带，那么还是以by value方式传递较佳。复制shared future虽然带来高昂的成本，毕竟比不上在一个大系统中挑出一个潜伏bug来得昂贵。”

关于class shared_future的更进一步细节，请见18.3.3节第976页。

## 低层接口：Thread和Promise
除了高级接口async（）和（shared） future，C++标准库还提供了一个启动及处理线程的低层接口。

### Class std::thread
欲启动某个线程，只需先声明一个class std：：thread对象，并将目标任务（task）当作初始实参，然后要么就等待它结束，要么就将它卸离（detach）：
```cc
void doSomething();

std::thread t(doSomething); // 后台启动doSomething
...
t.join(); // 等待t完成
```

就像对待async（）一样，你可以传入任何callable object（可以是function、member function、function object、lambda；见4.4节第54页），并可夹带任何可能的实参。然而请注意，除非你真的知道你在做什么，否则面对“处理目标函数所必须”的所有object都应该以by value方式传递，使得thread只使用local copy（18.4节第982页提出了“若不这么做便可能发生”的若干问题）。

此外，这是个低层接口，所以我们会感兴趣这一接口和高级的async（）（见18.1节第946页）相比之下不提供哪些性质：

· Class thread没有所谓发射策略（launch policy）。C++标准库永远试着将目标函数启动于一个新线程中。如果无法做到会抛出std：：system_error（见4.3.1节第43页）并带着差错码resource_unavailable_try_again（见4.3.2节第45页）。

· 没有接口可处理线程结果。唯一可获得的是一个独一无二的线程ID（见18.2.1节第967页）。

· 如果发生异常，但未被捕捉于线程之内，程序会立刻中止并调用 std：：terminate（） （见5.8.2节第162页）。若想将异常传播至线程外的某个context，必须使用exception_ptr（见4.3.3节第52页）。

· 你必须（像个调用者般地）声明是否“想要等待线程结束”（那就调用join（））或打算“将它自母体卸离（detach）使它运行于后台而不受任何控制”（那就调用 detach（））。如果你在thread object寿命结束前不这么做，或如果它发生了一次 move assignment，程序会中止并调用std：：terminate（）（见5.8.2节第162页）。

· 如果你让线程运行于后台而main（）结束了，所有线程会被鲁莽而硬性地终止。

下面是第一个完整例子：
```cc
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>
using namespace std;

void doSomething(int num, char c)
{
    try {
        // 随机数生成器（用 c 计算种子，确保不同字符序列不同）
        default_random_engine dre(42 * c);
        uniform_int_distribution<int> id(10, 1000);

        // 循环：随机延迟后打印字符
        for (int i = 0; i < num; ++i) {
            this_thread::sleep_for(chrono::milliseconds(id(dre)));
            cout.put(c).flush();
        }
    }
    // 捕获标准异常
    catch (const exception& e) {
        cerr << "THREAD-EXCEPTION (thread " 
             << this_thread::get_id() << "): " << e.what() << endl;
    }
    // 捕获未知异常
    catch (...) {
        cerr << "THREAD-EXCEPTION (thread " 
             << this_thread::get_id() << ")" << endl;
    }
}

int main()
{
    try {
        // 启动前台线程 t1，打印 5 个 '.'
        thread t1(doSomething, 5, '.');
        cout << "- started fg thread " << t1.get_id() << endl;

        // 启动 5 个后台线程，分别打印 'a' 到 'e'，各打印 10 个字符
        for (int i = 0; i < 5; ++i) {
            thread t(doSomething, 10, 'a' + i);
            cout << "- detach started bg thread " << t.get_id() << endl;
            t.detach();  // 分离线程，后台运行
        }

        cin.get();  // 等待用户输入（回车）

        // 等待前台线程 t1 结束
        cout << "- join fg thread " << t1.get_id() << endl;
        t1.join();
    }
    // 捕获 main 函数中的异常
    catch (const exception& e) {
        cerr << "EXCEPTION: " << e.what() << endl;
    }
}
```
本例的main（）启动若干线程，让它们都执行doSomething（）。基于以下原因不论main（）或是doSomething（）都有try-catch子句：

· 在main（）中，“创建线程”这个动作有可能抛出一个夹带差错码resource_unavailable_try_again的异常std：：system_error（见4.3.1节第43页）。

· 在doSomething（）中，由于此函数被启动为 std：：thread，任何异常若未被捕捉都会造成程序终止。

main（）所启动的第一个线程，稍后我们便“等待它结束”：
```cc
thread t1(doSomething,5,'.');  // print five dots in separate thread
//...（此处省略可能的中间代码，原内容有省略标识）
t1.join();  // wait for t1 to finish
```

其他线程则是启动之后便被卸离（detached），所以有可能main（）结束时它们还在执行：
```cc
for (int i=0; i<5; ++i) {
    thread t(doSomething,10,'a'+i);  // print 10 chars in separate thread
    t.detach();  // detach thread into the background
}
```

一旦main（）结束，程序会立刻终止所有后台线程。本例就出现了类似情况：cin.get（）负责读取某个输入，而后t1.join（）导致等待打印第五个dot（此即doSomething（5，'.'）的最后一个输出）。“等待输入”和“打印dot”并行运行（run in parallel），谁先发生并不重要。

举个例子，如果我在第二个dot被打印后按下Return键，这个程序有可能输出如下：
```bash
- started fg thread 1
- detach started bg thread 2
- detach started bg thread 3
- detach started bg thread 4
- detach started bg thread 5
- detach started bg thread 6
ecad.dbceabd.a
- join fg thread 1
b.ceade.bbcadbe.
```

#### 当心Detached Thread（卸离后的线程）

Detached thread（卸离后的线程）很容易形成问题——如果它们使用nonlocal资源的话。问题出在你丧失了对detached thread的控制，没有轻松的办法可以得知它是否运行，以及运行多久。因此，请确定绝不要让一个detached thread访问任何寿命已结束的object。基于这个理由，“以by reference方式传递变量和object”给线程，总是带有风险。强烈建议以by value方式传递。

请注意，寿命问题一样困扰global和static object，因为当程序退离（exit），detached thread可能还在运行，意味着它仍有可能访问“已被销毁”或“正在析构”的global或static object，这会导致不可预期的行为。[8]

所以，请考虑以下数点作为detached thread的一般性规则：

· Detached thread应该宁可只访问local copy。

· 如果detached thread用上了一个global or static object，你应该做以下事情之一：

-确保这些global/static object在“对它们进行访问”之所有detached thread都结束（或都不再访问它们）之前不被销毁。一种做法就是使用condition variable（见18.6节第1003 页），它让detached thread 用来发信号说它们已结束。离开 main（） 或调用exit（）之前你必须先设置妥这些condition variable，然后发信号（to signal）说可进行析构了。[9]

-以调用quick_exit（）的方式结束程序。这个函数之所以存在完全是为了以“不调用global和static object析构函数”的方式结束程序（见5.8.2节第162页）。

由于 std：：cin、std：：cout和 std：：cerr及其他global stream object （见15.2.2节第751页）按标准所说乃是“在程序运行期间不会被销毁”，所以detached thread访问这些object应该不会导致不可预期的行为。然而，其他问题像是“interleaved character”却有可能发生。

尽管如此，请牢记一个经验法则：终止detached thread的唯一安全方法就是搭配“...at_thread_exit（）”函数群中的某一个。这会“强制main thread等待detached thread真正结束”。或者你也可以选择忽略这一性质而相信某位评论家所言：“Detached thread应该被移到‘危险性质’的篇章中，几乎没有人需要它。”

#### Thread ID

如你所见，程序打印thread ID时，若非借由thread object，就是在一个thread内使用name-space this_thread（此亦由＜thread＞提供）：
```cc
void doSomething (int num, char c)
{
    //...（此处省略函数内其他逻辑，原内容有省略）
    cerr << "THREAD-EXCEPTION (thread " 
         << this_thread::get_id() << ")" << endl;
    //...（此处省略函数内其他逻辑，原内容有省略）
}
```


这所谓thread ID隶属于特殊类型 std：：thread：：id，其值独一无二。此外，class id有个default构造函数，会产生一个独一无二的ID用来表现“no thread”：
```cc
thread t(doSomething,5,'.');  // print five dots in separate thread
cout << "- started fg thread " << t.get_id() << endl;
```

唯一允许对thread ID进行的操作是“比较”，以及调用output操作符输出至某个stream。你不该有任何进一步假设，像是“‘no thread’拥有ID 0”或“main thread拥有ID 1”之类的想象。事实上实现（implementation）有可能在被申请时才动态生成这些ID，而不是在thread被启动时就生成之，那么main thread的编号就取决于先前对thread ID的申请次数。以下代码：
```cc
std::thread t1(doSomething,5,'.');
std::thread t2(doSomething,5,'+');
std::thread t3(doSomething,5,'*');
std::cout << "t3 ID:       " << t3.get_id() << std::endl;
std::cout << "main ID:     " << std::this_thread::get_id() << std::endl;
std::cout << "nothread ID: " << std::thread::id() << std::endl;
```

可能打印出：
```bash
t3 ID:       1
main ID:     4
nothread ID: 0
```

或：
```bash
t3 ID:       3
main ID:     4
nothread ID: 0

```
或：
```bash
t3 ID:       1
main ID:     2
nothread ID: 3
```

或甚至以字符为thread ID。

因此，识别线程（例如主线程master thread）的唯一办法是，将线程启动时的ID存储下来，以此为唯一识别值：
```cc
#include <thread>  // 需包含此头文件以使用 thread、id 等
using namespace std;

// 定义线程 ID 变量，用于标识主线程（master thread）
thread::id masterThreadID;  

void doSomething()
{
    // 检查当前线程是否是主线程
    if (this_thread::get_id() == masterThreadID) {  
        //...（可补充主线程专属逻辑）
    }
    //...（可补充其他逻辑）
}

// 创建主线程，执行 doSomething
thread master(doSomething);  
// 记录主线程的 ID
masterThreadID = master.get_id();  
...
// 创建从线程（slave thread），执行 doSomething
thread slave(doSomething);  
...

```


注意，已结束的线程的ID可能会被系统拿去重复使用。

关于class thread的进一步讨论，请看18.3.6节第979页。

### Promise
现在，新问题来了：如何在线程之间传递参数和处理异常（也就是高级接口如async（）如何实现这一技术）。欲传递数值给线程，你可以仅仅把它们当作实参来传递。如果你需要线程的运行结果，可用by reference方式传递，就像async（）描述的那样（见18.1.2节第958页）。

然而，另一个用来传递运行结果和异常（亦被视为一种结果）的一般性机制是：class std：：promise。所谓promise object 是future object 的配对兄弟，二者都能暂时持有一个shared state （用来表现一个结果值或一个异常）。但 future object 允许你取回数据（借由get（）），promise object却是让你提供数据（借由set_...（）函数群中的一个）。下面是个例子：
```cc
#include <thread>
#include <future>
#include <iostream>
#include <string>
#include <exception>
#include <stdexcept>
#include <functional>
#include <utility>
using namespace std;

void doSomething(promise<string>& p)
{
    try {
        // 提示用户输入字符，'x' 会触发异常
        cout << "read char ('x' for exception): ";
        char c = cin.get();
        if (c == 'x') {
            // 抛出异常
            throw runtime_error(string("char ") + c + " read");
        }

        // 处理字符，生成结果
        string s = string("char ") + c + " processed";
        // 将结果存入 promise
        p.set_value(move(s));  
    }
    catch (...) {
        // 捕获所有异常，存入 promise
        p.set_exception(current_exception());  
    }
}

int main()
{
    try {
        // 创建 promise 用于传递结果/异常
        promise<string> p;  
        // 启动线程，传递 promise 的引用
        thread t(doSomething, ref(p));  
        // 分离线程（后台运行）
        t.detach();  

        //...（可补充其他逻辑，原代码用...省略）

        // 通过 promise 获取 future
        future<string> f(p.get_future());  
        // 获取结果（会等待线程完成，或抛出异常）
        cout << "result: " << f.get() << endl;  
    }
    catch (const exception& e) {
        // 捕获并打印标准异常
        cerr << "EXCEPTION: " << e.what() << endl;
    }
    catch (...) {
        // 捕获未知异常
        cerr << "EXCEPTION " << endl;
    }
}
```
在包含＜future＞（其中有promise的声明）之后，你可以声明一个promise object，令它针对“持有值”或“返回值”特化（如果两者都是none，就特化为 void）：
```cc
std::promise<std::string> p;  // hold string result or exception
```

Promise内部会建立一个shared state（见18.3节第973页），在这里被用来存放一个相应类型的值或一个异常，并可被future object取其数据当作线程结果。

这个promise随后被传给一个在分离线程（separate thread）中运行的任务（task）：
```cc
std::thread t(doSomething,std::ref(p));
```

借由std：：ref（）（见5.4.3节第132页）我们确保这个promise以by reference方式传递，使其状态得以被改变（copying不适用于promise）。

然后在线程内调用 set_value（）或 set_exception（），便得以在promise中存放一个值或一个异常：
```cc
void doSomething (std::promise<std::string>& p)
{
    try {
        //...（省略中间可能的逻辑，原内容有省略）
        p.set_value(std::move(s));  // store result
    }
    catch (...) {
        p.set_exception(std::current_exception());  // store exception
    }
}
```

此处用上了定义于＜exception＞内的辅助函数std：：current_exception（）（见4.3.3节第52页），它会将当前异常以类型std：：exception_ptr生成出来，如果当前并无异常就生成nullptr。这个异常会被存放于promise object内部。

一旦shared state存有某值或某个异常，其状态就转变为ready。于是你可以在他处取出其内容。但是“取出”动作需要借助一个“共享相同shared state”的future object。为此，我们在main（）内对promise object调用get_future（），建立起这一相应的future object，它拥有18.1节第946页介绍过的语义。也可以在启动线程之前先建立该future object：
```cc
std::future<std::string> f(p.get_future());
```

现在，通过get（），我们可以取得“被存储的结果”，或是令“被存储的异常”再次被抛出（内部乃是针对被存储的exception_ptr调用std：：rethrow_exception（））：
```cc
f.get();  // process the outcome of the thread
```

注意，get（）会停滞（block）直到shared state成为ready——当promise的set_value（）或set_exception（）执行后便是如此。这并非意味着设定此promise的线程已经结束；该线程可能仍执行着其他语句，甚至存储其他结果放进其他promise内。

如果想令shared state在线程确实结束时变成ready——以确保线程的local object及其他材料在“结果被处理之前”有所清除——你就不该调用set_value（）或set_exception（），必须改调用set_value_at_thread_exit（）或set_exception_at_thread_exit（）：
```cc
void doSomething (std::promise<std::string>& p)
{
    try {
        //...（省略中间可能的逻辑，原内容有省略）
        p.set_value_at_thread_exit(std::move(s));
    }
    catch (...) {
        p.set_exception_at_thread_exit(std::current_exception());
    }
}
```


Promise和future并不仅限于解决多线程问题。在单线程程序中我们也可以使用promise持有一个结果值或一个异常（并且稍后通过一个future来处理）。

也请注意，我们不能够既存储值又存储异常。企图这么做会导致std：：future_error并夹带差错码std：：future_errc：：promise_already_satisfied（见4.3.1节第43页）。

关于class promise的更多细节，请见18.3.4节第977页。

### Class packaged_task＜＞
async（）予你一个权柄，使你得以处理task的成果，该task是你尝试立刻启动于后台的。然而有时候虽然你需要处理一个后台task的成果，你其实不需要立刻启动该task。举个例子，thread pool（线程池）可控制何时运行以及多少个后台task同时运行，此情况下我们不再这么写：
```cc
double compute(int x, int y);

// 启动后台任务
std::future<double> f = std::async(compute, 7, 5);  
// 等待任务完成并获取结果/异常
double res = f.get();  
```

而是写成
```cc
double compute(int x, int y);

// 创建任务
std::packaged_task<double(int, int)> task(compute);  
// 获取关联的 future
std::future<double> f = task.get_future();  

...
// 执行任务（通常在独立线程中）
task(7, 5);  
...

// 等待任务完成并获取结果/异常
double res = f.get();  
```

其中的task通常（但非一定）启动于某一分离线程中。

上述的class std：：packaged_task＜＞定义于＜future＞内，持有目标函数及其可能结果（也就是该函数的shared state，见18.3节第973页）。

关于class packaged_task的更多细节，请见18.3.5节第977页。

## 细说启动线程（Starting a Thread）
介绍完“启动线程”和“处理返回值或异常”之高级及低层接口后，让我们总结所有概念，并提供若干尚未提及的细节。


以下是提取的表格内容，包含各线程相关操作及对应返回值/异常处理方式：

| Starting the Thread                          | Returning Values                                                                 | Returning Exceptions                                                                 | use a shared state |
|----------------------------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|--------------------|
| call `std::async()`                          | return values or exceptions automatically are provided by a `std::future<>`    | return values or exceptions automatically are provided by a `std::future<>`        | ✔️                   |
| call task of class `std::packaged_task`     | return values or exceptions automatically are provided by a `std::future<>`    | return values or exceptions automatically are provided by a `std::future<>`        | ✔️                  |
| create object of class `std::thread`        | set return values or exceptions in a `std::promise<>` and process it by a `std::future<>` | set return values or exceptions in a `std::promise<>` and process it by a `std::future<>` | ✔️                  |
| create object of class `std::thread`        | use shared variables (synchronization required)                                | through type `std::exception_ptr`                                                   | ❌                  | 
图18.1 Thread接口层级

概念上，我们有数个层面可以启动线程并处理其返回值或异常（见图18.1）：

· 低层接口 class thread 让我们得以启动线程。为了“返回数据”，我们需要可共享的变量（global或static变量，或是以实参传递的变量）。为了“返回异常”，可利用类型std：：exception_ptr（它被std：：current_exception（）返回并可被std：：rethrow_ex ception（）处理（见4.3.3节第52页）。

· Shared state的概念使我们能够以一种较便捷的方法处理返回值或异常。搭配低层接口所提供的promise我们可以建立一个shared state然后通过一个future来处理它。

· 在高级层面中，class packaged_task或async（）会自动建立一个shared state，它会因为一个return语句或一个未被捕获的异常（uncaught exception）而设置妥。

· packaged_task允许我们建立一个“带着shared state”的object，但我们必须明确写出何时启动该线程。

· 若是使用std：：async（），我们无须关心线程何时真正启动。我们唯一确知的是当需要结果时就调用get（）。

Shared State

如你所见，上述几乎所有性质都用到一个中心概念：shared state。它允许“启动及控制后台机能”的object（一个promise、packaged task或是async（））能够和“处理其结果”的object（一个future或shared future）相互沟通。因此，shared state必须能够持有被启动之目标函数以及某些状态（state）和结果（一个返回值或一个异常）。

Shared state如果持有其函数运行结果，我们说它是ready（也就是返回值或异常已备妥待取）。Shared state通常被实现为一个reference-counted object——当它被最后一个使用者释放时即被销毁。

18.3.1 细说async（）
一般而言，就像18.1节第946页所介绍，std：：async（）是个辅助函数，用来在分离线程中启动某个函数（如果可能的话）。因此，如果低层平台支持多线程，你可以让函数并发运转；如果低层平台不支持，也没有任何损失。

然而async（）的真实行为复杂得多，且高度取决于launch（发射）策略，后者可作为第一实参。基于这个因素，以下便以应用程序开发者的角度描述async（）的三个标准调用形式。

future async (std::launch::async, F func, args...)

· 尝试启动 func 并给予实参 args，形成一个异步任务（asynchronous task；一个并行线程）。

· 如果以上办不到，就抛出std：：system_error异常，带着差错码std：：errc：：resource_unavailable_try_again（见4.3.1节第43页）。

· 被启动的线程保证在程序结束前完成，除非程序中途失败（abort）。

· 以下情况会结束线程（完成工作）：

-对返回的future调用get（）或wait（）。

-如果最后一个指向“返回之future所代表的shared state”的object被销毁。

· 这意味着对async（）的调用会造成停滞（block）直到func完成——如果async（）的返回值未被使用的话。

future async (std::launch::deferred, F func, args...)

· 传递func并夹带实参args，形成一个推迟任务（deferred task）。当我们对返回的future调用wait（）或get（），那个推迟任务即被同步调用（synchronously called）。

· 如果未曾如上调用wait（）和get（），那个推迟任务（deferred task）绝不会启动。

future async (F func, args...)

· 相当于调用 async（）并携带“std：：launch：async和 std：：launch：：deferred组合而成”的launch（发射）策略。系统会根据当前形势选择其中一个发射策略。也就是说，如果“立即发射”策略行不通的话，会造成func被推迟调用。

· 也就是说，如果async（）可以为 func启动一个新线程，就那么做，否则func就会被推迟，直到我们对返回的future调用get（）或wait（）。

· 这个调用的唯一保证是，一旦我们对返回的future调用get（）或wait（），func就一定会被调用并且完成。

· 如果没有对返回的future调用get（）或wait（），func有可能永不被调用。

· 注意，如果无法异步调用func，本形式的async（）不会抛出system_error异常（但有可能因为其他原因而抛出system error）。

所有 async（） 形式都只要求 func 是个 callable object （不论 function、member function、function object、lambda都可以；见4.4节第54页）。18.1.2节第958页有一些例子。


将发射策略 std：：launch：：async|std：：launch：：deferred传递给 async（），其后果和不传递任何发射策略是一样的。发射策略设为0会导致不可预期的行为（C++标准库未涵盖此情况，不同的实现可能行为互异）。

### 细说Future
Class future＜＞[10]曾经出现于18.1节第946页，用来表现某一操作的成果（outcome）：可能是个返回值或是一个异常，但不会二者都是。这份成果被管理于一个shared state内，后者可被std：：async（）或一个std：：packaged_task或一个promise创建出来。这份成果也许尚未存在，因此future持有的也可能是“生成该成果”的每一件必要东西。

如果future是被async（）（见18.3.1节第974页）返回且其相关的task受到推迟，对它调用get（）或wait（）会同步启动该task。注意，wait_for（）和wait_until（）都不会令一个被推迟任务（deferred task）启动。

成果只能被取出一次。因此future可能处于有效（valid）或无效（invalid）状态：有效意味着“某一操作的成果或爆发的异常”尚未被取出。

表18.1列出了class future＜＞可用的操作。

注意，get（）的返回值取决于future＜＞的特化类型：

· 如果它是void，get（）获得的就是void，也就是“无物”。

· 如果future的template参数是个reference类型，get（）便返回一个reference指向返回值。

· 否则get（）返回返回值的一份copy，或是对返回值进行move assign动作——取决于返回类型是否支持move assignment语义。

注意，只可调用get（）一次，因为 get（）会令future处于无效状态。

面对无效状态的future，调用其析构函数、move assignment操作符或valid（）以外的任何操作，都会导致不可预期的行为。这种情况下C++standard推荐（但并未强制）抛出一个future_error异常（见4.3.1节第43页）并夹带差错码std：：future_errc：：no_state。

注意，future既不提供copy构造函数也不提供copy assignment操作符，确保绝不会有两个object共享某一后台操作之状态（state）。“将某个future object状态搬移至另一个”的唯一办法是，调用move构造函数或move assignment操作符。

表18.1 Class future＜＞的操作函数
以下是提取的表格内容，包含 `future` 各类操作及对应效果说明：

| 操作               | 效果                                                                                          |
|--------------------|-----------------------------------------------------------------------------------------------|
| `future f`         | Default 构造函数，建立一个 future，带着无效状态（invalid state）                              |
| `future f(rv)`     | Move 构造函数，建立一个新的 future，状态取自 `rv`，并令 `rv` 状态失效                        |
| `f.~future()`      | 销毁状态也销毁 `*this`                                                                        |
| `f = rv`           | Move assignment；销毁 `f` 的旧状态，取 `rv` 状态填之，并令 `rv` 状态失效                     |
| `f.valid()`        | 如果 `f` 具备有效状态就获得 `true`，然后你才可以调用以下各成员函数                            |
| `f.get()`          | 阻塞（block）直到后台操作完成。它会迫使被推迟的线程（deferred thread）同步启动（start synchronously），产出结果（如果有的话）或发出异常，并令其状态失效 |
| `f.wait()`         | 阻塞（block）直到后台操作完成。它会迫使被推迟的线程（deferred thread）同步启动（start synchronously） |
| `f.wait_for(dur)`  | 阻塞（block）`dur` 时间段，或直到后台操作完成。但被推迟的线程（deferred thread）并不会被强制启动 |
| `f.wait_until(tp)` | 阻塞（block）直至到达时间点 `tp`，或直到后台操作完成。但被推迟的线程（deferred thread）并不会被强制启动 |
| `f.share()`        | 产生一个 `shared_future` 带有当前状态，并令 `f` 的状态失效                                    | 

然而通过使用shared_future object也可以令后台任务的状态被共享，其share（）会释出控制权。

如果调用析构函数的那个future是某一shared state的最后拥有者，而相关的task已启动但尚未结束，析构函数会造成堵塞（block），直到任务结束。

18.3.3 细说Shared Future
Class shared_future＜＞（18.1.3节第960页曾有介绍）提供的语义和接口与class future相同（见18.3.2节第975页），但有以下差异：

· 允许多次调用get（）。因此get（）必不令其状态失效。

· 支持copy语义（copy构造函数和copy assignment操作符）。

· get（） 是个 const 成员函数，返回一个 const reference 指向“存储于 shared state”的值（这意味着你必须确定“被返回的 reference”的寿命短于 shared state）。但 class std：：future 的 get（） 却是个non-const 成员函数，返回一个move-assigned 拷贝（如果此性质未获支持则返回一个 copy），除非这个 class “被一个 reference 类型实现特化”。

· 不提供share（）。

“get（）的返回值不是拷贝”这一事实造成了若干风险。除了生命期需要考虑，还可能形成data race（数据竞争）——当“作用于相同数据”而又“互相冲突”的动作有着“不明确的次序”时就会发生，例如多线程发出的异步读/写（nonsynchronized read and write），导致不明确的行为。（见18.4.1节第982页）。

相同问题也发生在异常身上。标准化期间曾经讨论过这样一个例子，有个异常被“by reference捕获”而后被改动：

```cc
    try {
        // 启动异步任务，用 shared_future 接收结果（无返回值）
        shared_future<void> sp = async(f);  
        // 等待任务完成，传播异常
        sp.get();  
    }
    // 捕获 E 类型异常
    catch (E& e) {  
        // 注意：修改异常对象可能引发数据竞争（未同步时）
        e.modify();  
    }
```
如果另一个线程正在处理这个异常，上述代码会导致data race。为解决这个问题，建议最好使用 current_exception（） 和 rethrow_exception（），它们被内部用来在线程之间传递异常、建立异常拷贝。然而这样的改变成本太高。所以，程序员在不同的线程内处理non-const reference时，一定要很清楚他们在做些什么。

### 细说Class std::promise
18.2.2节第969页介绍过class std：：promise，其对象用来临时持有一个值或一个异常。一般而言promise可持有一个shared state（见18.3节第973页）。如果那个shared state持有一个值或一个异常，我们就说它是ready。表18.2列出了class promise的操作函数。

注意，你只能调用get_future（）一次。第二次调用会抛出std：：future_error异常并带着差错码 std：：future_errc：：future_already_retrieved。如果没有相应的shared state，则该调用会抛出std：：future_error异常并带着差错码std：：future_errc：：no_sta te。

所有用来设定数值或异常的成员函数都是线程安全的（thread safe），也就是说，犹如有个mutex确保每次只有某一个成员函数可以修改shared state。

### 细说Class std：：packaged_task
Class std：：packaged_task＜＞被用来同时持有目标函数及其“成果”（也就是所谓的shared state，见18.3节第973页）。“成果”也许是个返回值或是目标函数所触发的异常。你可以拿相应的目标函数来初始化packaged task，而后通过对packaged task实施operator （）调用该目标函数。最后，你可以对此packaged task取一个future以便处理其成果。表18.3列出了class packaged_task的操作函数。

由于此 task 之构造函数而发生的任何异常，例如“缺乏可用内存”，也会被存放于shared state。

表18.2 Class promise的操作函数
以下是提取的表格内容，包含 `promise` 各类操作及对应效果说明：

| 操作                             | 效果                                                                                          |
|----------------------------------|-----------------------------------------------------------------------------------------------|
| `promise p`                      | Default 构造函数；建立一个带 shared state 的 promise                                          |
| `promise p(allocator_arg, alloc)` | 建立一个带 shared state 的 promise，以 `alloc` 为分配器                                      |
| `promise p(rv)`                  | Move 构造函数；建立一个新的 promise，它取 `rv` 的状态并从 `rv` 手中移走 shared state         |
| `p.~promise()`                   | 释放 shared state，并且如果它不是 ready（也就是无值亦无异常），就存储一个 `std::future_error` 异常并夹带 `broken_promise` |
| `p = rv`                         | Move assignment；move assign `rv` 的状态至 `p`。如果 `p` 不是 ready，就存储一个 `std::future_error` 异常并夹带 `broken_promise` |
| `swap(p1, p2)`                   | 互换 `p1` 和 `p2` 的状态                                                                      |
| `p1.swap(p2)`                    | 互换 `p1` 和 `p2` 的状态                                                                      |
| `p.get_future()`                 | 产生一个 future object 用以取回 shared state（那是线程的执行成果）                           |
| `p.set_value(val)`               | 设 `val` 为值并令状态为 ready（或是抛出 `std::future_error`）                                |
| `p.set_value_at_thread_exit(val)` | 设 `val` 为值并令状态为 ready——在当前线程结束时（或是抛出 `std::future_error`）              |
| `p.set_exception(e)`             | 设 `e` 为异常并令状态为 ready（或是抛出 `std::future_error`）                                |
| `p.set_exception_at_thread_exit(e)` | 设 `e` 为异常并令状态为 ready——在当前线程结束时（或是抛出 `std::future_error`）              |

如果调用task或调用 get_future（） 却没有可用状态，会抛出 std：：future_error异常（见4.3.1节第43页）并带着差错码 std：：future_errc：：no_state。第二次调用get_future（）会抛出std：：future_error异常并带着差错码std：：future_errc：：future_already_retrieved。第二次调用 task 会抛出 std：：future_error 异常并带着差错码std：：future_errc：：promise_already_satisfied。

析构函数和reset（）会抛弃shared state，意思是packaged task会释放shared state，并且如果shared state尚未ready就令它变成ready，然后将一个std：：future_error异常并夹带差错码std：：future_errc：：broken_promise存储起来当作成果。

一如往常，make_ready_at_thread_exit（）函数用来确保在task的成果被处理之前，终结该task的线程的局部对象（local object）和其他材料会先被妥善清理。

表18.3 Class packaged_task＜＞的操作函数
以下是提取的表格内容，清晰呈现 `packaged_task` 的操作及对应效果：

| 操作                             | 效果                                                                                          |
|----------------------------------|-----------------------------------------------------------------------------------------------|
| `packaged_task pt`               | Default 构造函数；建立一个 packaged task，不带 shared state 也不带 stored task               |
| `packaged_task pt(f)`            | 为 task `f` 建立一个对象                                                                      |
| `packaged_task pt(alloc, f)`     | 为 task `f` 建立一个对象，使用分配器 `alloc`                                                 |
| `packaged_task pt(rv)`           | Move 构造函数；将 packaged task `rv`（task 和 state）移至 `pt`（其后 `rv` 将不拥有 shared state） |
| `pt.~packaged_task()`            | 销毁 `*this`（也许会导致 shared state 变成 ready）                                          |
| `pt = rv`                        | Move assignment；将 packaged task `rv`（task 和 state）move assign 移至 `pt`（其后 `rv` 将不拥有 shared state） |
| `swap(pt1, pt2)`                 | 两个 packaged task 互换                                                                       |
| `pt1.swap(pt2)`                  | 两个 packaged task 互换                                                                       |
| `pt.valid()`                     | 如果 `pt` 有一个 shared state 就产生 `true`                                                 |
| `pt.get_future()`                | 产出一个 future object，用来取回 shared state（内放 task 的成果）                            |
| `pt(args)`                       | 调用 task（带着可能的实参）并令 shared state 成为 ready                                     |
| `pt.make_ready_at_thread_exit(args)` | 调用 task（带着可能的实参）并且在线程退离（exit）时令 shared state 成为 ready                |
| `pt.reset()`                     | 为 `pt` 建立一个新的 shared state（也许会导致旧的 shared state 变成 ready）                 |

### 细说Class std：：thread
18.2.1节第964页曾介绍过class std：：thread，其对象用来启动和表现线程。这些对象和操作系统提供的线程呈现一对一映射关系。表18.4列出了class thread的操作函数。

Thread object和线程之间的关联始于您将一个callable object（见4.4节第54页）指派为初值（或是move copy/assign）给它，并夹带可能有的实参。这个关联的结束有两个情况：一是由于join（）（它将等待线程成果）或是由于detach（）（它将明确失去对线程的关联）。不论哪一个函数都必须在thread object生命结束前或在一个新的thread object被move assigned之前被调用。否则程序就会因std：：terminate（）（见5.8.2节第162页）而中止。

如果thread object关联至某个线程，它就是所谓joinable（可连接的）。此情况下调用joinable（）会获得true，调用get_id（）会获得thread ID，其值不同于std：：thread：：id（）所得。

Thread ID有自己的类型std：：thread：：id。其default构造函数会产出一个独一无二的ID用以表示“非线程”。如果没有任何线程被关联，调用thread：：get_id（）获得的便是那个特殊值，如果thread object关联至某个线程（也就是joinable），调用thread：：get_id（）便会获得另一个独一无二的ID。

表18.4 Class thread的操作函数
以下是提取的表格内容，清晰展示 `thread` 各类操作及对应效果：

| 操作                | 效果                                                                                          |
|---------------------|-----------------------------------------------------------------------------------------------|
| `thread t`          | Default 构造函数；创建一个 nonjoinable thread object                                        |
| `thread t(f, ...)`  | 创建一个 thread object，表示 `f` 将被启动于一个线程中（也许带有实参），或是抛出 `std::system_error` |
| `thread t(rv)`      | Move 构造函数；创建一个新的 thread object，取 `rv` 的状态并令 `rv` 变成 nonjoinable         |
| `t.~thread()`       | 销毁 `*this`；如果 object 是 joinable 则调用 `std::terminate()`                             |
| `t = rv`            | Move assignment；将 `rv` 的状态 move assign 至 `t`，如果 `t` 是 joinable 则调用 `std::terminate()` |
| `t.joinable()`      | 如果 `t` 有一个关联线程（也就是说它是 joinable）便产出 `true`                               |
| `t.join()`          | 等待关联线程完成工作（如果该线程不是 joinable 就抛出 `std::system_error`），然后令此 object 变成 nonjoinable |
| `t.detach()`        | 解除 `t` 和线程之间的关联并且让线程继续运行（如果该线程不是 joinable 便抛出 `std::system_error`），并令 object 变成 nonjoinable |
| `t.get_id()`        | 如果 joinable 就返回独一无二的 `std::thread::id`，如果不是 joinable 就返回 `std::thread::id()` |
| `t.native_handle()` | 返回一个依赖于平台的类型 `native_handle_type`，用于不具可移植性的扩展（nonportable extension） |

唯一可对thread ID执行的操作是对它们进行比较，或是将它们写至一个output stream。此外有个hash函数用来在非定序（unordered）容器（见7.9节第356页）中管理thread ID。一个已结束的线程的thread ID可被系统取回重复运用。除了以上这些，不要对thread ID存有任何假设，特别是不要对其数值有所猜想。详见18.2.1节第968页。

注意，detached thread不应该访问生命已结束的object。这意味着当我们结束程序时，必须确定detached thread不会访问global/static object（见18.2.1节第967页）。

此外，class std：：thread还提供一个static成员函数，用来查询并行线程的可能数量（只是一个参考值）：

unsigned int std::thread::hardware_concurrency ()

· 返回可能的线程数量。

· 该数量只是个参考值，不保证准确。

· 如果数量不可计算或不明确，返回值是0。

### Namespace this_thread
针对任何线程（包括主线程main thread），＜thread＞声明一个命名空间std：：this_thread，用以提供线程专属的global函数，列于表18.5。

表18.5 命名空间std：：this_thread提供的线程专属操作
| 操作                            | 效果                                                 |
|-------------------------------|----------------------------------------------------|
| `this_thread::get_id()`       | 获得当前线程的 ID                                        |
| `this_thread::sleep_for(dur)` | 将某个线程阻塞（block）`dur` 时间段                          |
| `this_thread::sleep_until(tp)` | 将某个线程阻塞（block）直到时间点 `tp`                       |
| `this_thread::yield()`        | 建议释放控制以便重新调度（reschedule），让下一个线程能够执行            |

注意，当处理系统时间调整（system-time adjustment，详见5.7.5节第160页）时，sleep_for（）和sleep_until（）往往不同，

函数this_thread：：yield（）用来告诉系统，放弃当前线程的时间切片（time slice）余额是有好处的，这将使运行环境得以重新调度（reschedule）以便允许其他线程执行。“放弃控制”的一个典型例子是，当等待或轮询（wait or poll）另一线程（见18.1.1节第955页），或等待或轮询“某个atomic flag被另一线程设定”（见18.4.3节第986页）：[11]
```cc
while (!readyFlag) {  // loop until data is ready
    std::this_thread::yield();
}
```
另一个例子是，当你尝试锁定多个lock/mutex却无法取得其中一个lock或mutex，那么在尝试不同次序的lock/mutex之前你可以使用yield（），这会让你的程序更快些。[12]
## 线程同步化与Concurrency（并发）问题
使用多线程（multiple thread）几乎总是会伴随“数据的并发访问”（concurrent data access）。多个线程彼此毫无关系地运行是很罕见的。线程有可能提供数据给其他线程处理，或是备妥必要的先决条件（precondition）用以启动其他进程（process）。

这就是多线程棘手的原因。许多事情有可能往错误的方向走。或者换个角度说，许多事情也许和新手甚至经验丰富的程序员的预期不同。

因此，讨论同步化线程（synchronize thread）和并发数据处理的技术之前，我们必须先了解问题所在。然后我们就可以开始讨论以下的线程同步化技术：

· Mutex和lock（互斥体和缩，见18.5节第989页），包括 call_once（）（见18.5.3节第1000页）。

· Condition variable（条件变量，见18.6节第1003页）。

· Atomic（见18.7节第1012页）。

### 当心Concurrency（并发）
在详细讨论concurrency引发的问题之前，让我先制定第一条规则，为的是可能你已经打算直接动手干了而不深入此节。如果你只学一条“如何面对多线程”的规则，应该就是这一条了：

多个线程并发处理相同的数据而又不曾同步化（synchronization），那么唯一安全的情况就是：所有线程只读取数据。

所谓“相同的数据”，我的意思是使用相同内存区（same memory location）。如果不同的线程并发处理它们手上不同的变量或对象或成员，不会有问题，因为自C++11起每个变量都保证拥有自己的内存区。[13]唯一例外是bitfield；由于不同的bitfield有可能共享同一块内存区，因此访问不同的bitfield其实意味着彼此分享对同一块数据的访问。

然而，当两个或更多线程并发处理相同的变量或对象或成员，而且至少其中一个线程改动了它，而你又不曾同步化（synchronize）该处理动作，你就可能有了深深的麻烦。这就是C++所谓的data race。C++11标准中定义的data race是“不同线程中的两个互相冲突的动作，其中至少一个动作不是atomic（不可切割的），而且无一个动作发生在另一动作之前”。Data race总是导致不可预期的行为。

就像处于data race情况一样，我们的问题在于，代码也许经常能够如你所愿，但却不是永远如此，这正是编程时面对的最难缠问题之一。也许，使用其他数据，或进入生产模式，或换到另一个平台，你的程序突然就完蛋了。所以，如果使用多线程，要特别小心concurrent data access。

### Concurrent Data Access为什么造成问题
为了解concurrent data access造成的问题，我们必须了解当我们使用concurrecy时C++给了什么保证。注意，一个编程语言如C++，总是个抽象层，用以支持不同的平台和硬件，后者根据其体系结构和目的提供不同的能力和接口。因此，一个像C++这样的标准具体描述了语句和操作的影响，但并非等同于其所产生的汇编码（assembler code）。标准描述的是what而不是how。

一般而言，行为不会被定义得太谨慎以至于只能有一种实现。事实上行为甚至有可能不被明确定义，例如函数调用时其实参核值（argument evaluation）次序就没有具体说明。如果程序对此有特定的期待，会导致不可预期的行为。

因此，重要的问题是：语言给了什么保证？在该范围内程序员不该期望更多，即使某些额外的保证似乎很明显。事实上关于所谓as-if规则，每个编译器都可以将代码无限优化，只要程序行为外观上相同。因此，被生成的代码是个黑盒子，是可以变化的，只要可观测行为保持稳定。以下摘自C++standard：

任何实现（implementation）可以自由忽视国际标准（International Standard）的任何规定，只要最终成果貌似遵守了那些规定——这可由程序的可观测行为加以判断。例如，一个现实实现（actual implementation）不需要核算表达式的某一部分——如果它可以推演而知其值未被使用且又不至于影响程序所产生的可观测行为。

未定义行为之所以存在，是为了给予编译器和硬件厂商以自由度和能力去生成最佳代码，不论他们的“最佳”标准在哪里。是的，它适用于两端：编译器有可能展开循环（loop），重新安排语句，去除无用代码（dead code），预先获取数据，而在现代化体系结构中，一个以硬件实现的buffer有可能重新安排（reorder） load或store。

重新安排次序（reordering）对于改善程序速度也许有帮助，但它们亦有可能产生破坏行为。为了受益于“最快的速度”，“安全性”也许不在默认考虑范围内。因此，特别针对concurrent data access，我们必须了解我们手上有些什么保证。

### 什么情况下可能出错
为了给予编译器和硬件以足够的自由度完成优化，C++一般并不给予许多“你或许期待”的保证。原因是，在所有情况中（而非仅仅那些有用的地方）实施这些保证，会带来太高的效率成本。事实上，在C++中我们可能会遭遇以下问题：

· Unsynchronized data access（未同步化的数据访问）：并行运行的两个线程读和写同一笔数据，不知道哪一个语句先来。

· Half-written data（写至半途的数据）：某个线程正在读数据，另一个线程改动它，于是读取中的线程甚至可能读到改了一半的数据，读到一个半新半旧值。

· Reordered statement（重新安排的语句）：语句和操作有可能被重新安排次序（reordered），也许对于每一个单线程正确，但对于多个线程的组合却破坏了预期的行为。

Unsynchronized Data Access（未同步化的数据访问）

以下代码确保以val的绝对值为实参调用f（），如果val是负数就将它反相：
```cc
if (val >= 0) {
    f(val);  // pass positive val
}
else {
    f(-val);  // pass negated negative val
}
```

在单线程环境中上述代码没问题。然而在一个多线程环境中，这段代码不一定能成功运作。如果多个线程处理val，val的值有可能在“if子句”和“调用f（）”之间被改变，造成负值被传给f（）。

基于相同理由，以下代码：
```cc
std::vector<int> v;
//...（省略可能的容器赋值等逻辑，原内容有省略）
if (!v.empty()) {
    std::cout << v.front() << std::endl;
}
```

也可能形成问题。如果 v 被多个线程共享，由于 v 有可能在“调用 empty（）”和“调用front（）”之间变成空（empty），导致不可预期的行为（见7.3.2节第275页）。

注意这个问题也可能出现在“以C++标准库提供的函数完成”的代码。例如：

```cc
v.at(5);
```
“如果v没有足够元素就会抛出异常”这个保证不再成立，因为当at（）被调用时另一个线程有可能改动v。因此，请牢记以下文字：

除非另有说明，C++标准库提供的函数通常不支持“写或读”动作与另一个“写”动作（写至同一笔数据）并发执行。[14]

也就是说，除非另有说明，来自多线程“对同一object的多次调用”会导致不可预期的行为。

然而C++标准库对于线程安全（见4.5节第56页）还是提供了若干保证。例如：

· 并发处理同一容器内的不同元素是可以的（但vector＜bool＞例外）。因此，不同的线程可以并发读和/或写同一容器内的不同元素。例如，每个线程可以处理某些事然后将结果存储于一个共享的vector内专属该线程的某元素。

· 并发处理string stream、file stream或stream buffer会导致不可预期的行为。但是一如进入本章之前我们所见的，格式化输入自和输出至某个标准stream（它和C I/O同步化了，见15.14.1节第845页）是可以的，虽然这可能导致插叙的字符。

#### Half-Written Data（写至半途的数据）

考虑我们有一个变量：[15]
```cc
long long x = 0;
```

某个线程对它写入数值：
```cc
x = -1;
```

另一个线程读取它：
```cc
cout << x;
```

程序的输出是什么？也就是说当第二线程输出x时它读到哪个值？以下皆有可能：

· 0（x的旧值）——如果第一线程尚未赋予它-1。

·-1（x的新值）——如果第一线程已经赋予它-1。

· 任何其他值——如果第二线程在“第一线程对x赋值-1的过程中”读取x。

上述最后一项在一台32-bit计算机上很可能发生——如果赋值操作导致两个store，而来自第二线程的读取操作发生在“第一个store已完成且第二个store尚未完成”之际。

注意，以上仅仅不适用于long long。即使基本数据类型如int或bool，标准也不保证读或写是atomic（不可切割的），意指独占而不可被打断（exclusive noninterruptable）。Data race不是那么有可能发生，但如果你想完全消除其可能性，就必须采取手段。

相同情况也适用于繁复的数据结构，即使它们由C++标准库提供。例如面对std：：list＜＞（见7.5节第290页），程序员有权决定是否确保“当某个线程正在安插或删除元素时，容器不会被另一个线程改动”。否则其他线程便有可能用到这个list的不一致状态（inconsistent state），例如“前向指针”已修改但“后向指针”尚未被改。

#### Reordered Statement（重新安排的语句）

让我们讨论另一个简单例子。[16]假设有两个共享对象，一个是long，用来将data从某个线程传递到另一个线程，另一个是bool readyFlag，用来表示第一线程是否已提供数据：
```cc
long data;
bool readyFlag = false;
```

一种天真做法是，将“某线程中对data的设定”和“另一线程中对data的消费”同步化（synchronize）。于是，供应端这么调用：
```cc
data = 42;
readyFlag = true;
```

而消费端这么调用：
```cc
while (!readyFlag) {  // loop until data is ready
    ;
}
foo(data);
```

在不知任何细节的情况下，几乎每个程序员一开始都会认为第二线程必是在data有值42之后才调用foo（），他们认为“对foo（）的调用”只有在readyFlag是true的前提下才能触及，而那又唯有发生在第一线程将42赋值给data之后，因为赋值之后才令readyFlag变成true。

但其实这并非必要。事实上第二线程的输出有可能是data“在第一线程赋值42之前”的旧值（甚至任何值，因为42赋值动作有可能只做一半）。
也就是说，编译器和/或硬件有可能重新安排语句，使得实际执行以下动作：
```cc
readyFlag = true;
data = 42;
```

一般而言，基于C++规则，这样的重新安排（reordering）是允许的，因为 C++只要求编译所得的代码在单一线程内的可观测行为（observable behavior inside a thread）正确。对于第一线程，并不在意先改变readyFlag还是data；从这个线程的角度看，两个语句毫不相干。因此，重新安排语句是被允许的，只要单一线程的可视效果相同。

基于相同理由，甚至第二线程也可能被重新安排语句，前提是不影响该线程的行为：
```cc
foo(data);
while (!readyFlag) {  // loop until data is ready
    ;
}
```
但是请注意，这样的重新排列有可能在foo（）抛出异常时影响其可观测行为。因此是否允许这样的重新排列，取决于细节，原则上说它是有问题的。

再强调一次，允许如此更改，原因是默认情况下C++编译器应该有能力生成高度优化代码，而某些优化行为可能需要重新排列语句。默认情况下这些优化并未被要求在意“是否存在其他线程”，这样能让优化更容易些，因为这种情况下只需要局部分析（local analysis）便足够。

### 解决问题所需要的性质（Feature）
为解决concurrent data access的三个主要问题，我们需要先建立以下概念：

· Atomicity（不可切割性）：这意味着读或写一个变量，或是一连串语句，其行为是独占的、排他的，无任何打断，因此一个线程不可能读到“因另一线程而造成的”中间状态。

· Order（次序）：我们需要一些方法保证“具体指定之语句”的次序。

C++标准库提供了多种办法来处理这些概念，让程序在concurrent access方面获得额外的保证：

· 你可以使用future（见18.1节第946页）和promise（见18.2.2节第969页），它们都保证atomicity和order：一定是在形成成果（返回值或异常）之后才设定shared state，这意味着读和写不会并发发生。

· 你可以使用mutex和lock（见18.5节第989页）来处理critical section或protected zone，借此得以授予独占权力，使得（例如）一个“检验动作”和一个“依赖该检验结果的操作”之间不会发生任何事。Lock提供atomicity，它会阻塞（blocking）所有“使用second lock”的处理行为，直到作用于相同资源身上的first lock被释放。更精准地说，被某个线程获得的lock object，它“被另一线程获得”之前必须先被成功释放。然而如果两个线程使用lock来处理数据，每次运行的次序都有可能发生变化。

· 你可以使用condition variable（见18.6节第1003页）有效地令某线程等待若干“被另一线程控制的”判断式（predicate）成为true。这有助于应付多线程间的次序，允许一或多个线程处理其他一或多个线程所提供的数据或状态。[17]

· 你可以使用atomic data type（见18.7节第1012页）确保每次对变量或对象的访问动作都是不可切割的（atomic）——只要atomic type上的操作次序保持稳定（stable）。

· 你可以使用 atomic data type 的低层接口（见18.7.4节第1019页），它允许专家放宽

（relax） atomic语句的次序或针对内存访问使用手制藩篱（manual barrier，所谓fence）。原则上，这份清单由高级排列至低层。高级特性如future和promise或mutex和lock很容易使用，风险较低。

低层特性如atomic和（特别是）其低层接口，也许能提供较佳效能，因为它们有较低的潜在因素并因此有较高的可伸缩性（scalability），但也大幅增加了误用的风险。尽管如此，低层特性有时候可以为某些特定的高级问题提供简单解法。

有了atomic，我们得以进入lock-free（免锁）编程，而那是专家偶尔也会出错的领域。以下文字摘自Herb Sutter的[Sutter：LockFree]：“[Lock-free code]即使对专家都很困难。我们很容易写出似乎可运作的lock-free code，但很难写出不但正确且运行良好的lock-free code。甚至优秀的杂志和期刊都曾刊出大量lock-free code而实际上却在微妙处失败。”

#### volatile和Concurrency

注意，我并没有说volatile是个“用来解决concurrent data access问题”的性质（feature），虽然你可能因为以下原因而有那样的期盼：

· volatile是个C++关键字，用来阻止“过度优化”。

· 在Java中，volatile对于atomicity和order提供了某些保证。

在C++中，volatile“只”具体表示对外部资源（像是共享内存）的访问不该被优化掉。如果没有volatile，编译器也许会消除对同一块共享内存区看似多余的load，只因它在整个程序中看不到这个区域的任何改变。但是在C++，volatile既不提供atomicity也不提供特别的order。[18]因此volatile的语义在C++和Java之间如今有些差异。

请看18.5.1节第998页，那儿探讨了“当mutex被用来在一个循环（loop）内读取数据”时为什么通常不要求使用volatile。

## Mutex和Lock
Mutex全名mutual exclusion（互斥体），是个object，用来协助采取独占排他（exclusive）方式控制“对资源的并发访问”。这里所谓“资源”可能是个object，或多个object的组合。为了获得独占式的资源访问能力，相应的线程必须锁定（lock） mutex，这样可以防止其他线程也锁定mutex，直到第一个线程解锁（unlock）mutex。

### 使用Mutex和Lock
我们打算保护“许多地方都会用到的”object val的并发访问动作（concurrent access）：
```cc
int val;
```

将concurrent access同步化的一个粗浅做法是，引入mutex，用来赋予独占性并加控制：
```cc
int val;
std::mutex valMutex;  // control exclusive access to val
```

此后每次访问都必须锁定这个mutex以求独占。例如某个线程可能会这么做（注意这是低劣做法，我们正是要改善它）：
```cc
valMutex.lock();  // request exclusive access to val
if (val >= 0) {
    f(val);    // val is positive
}
else {
    f(-val);  // pass negated negative val
}
valMutex.unlock();  // release exclusive access to val
```

另一个线程可能这样访问同一资源：
```cc
valMutex.lock();  // request exclusive access to val
++val;
valMutex.unlock();  // release exclusive access to val
```

有一点很重要：凡是可能发生concurrent access的地方都该使用同一个mutex，不论读或写皆如此。

这个简单的办法有可能演变得十分复杂。举个例子，你应该确保异常——它会终止独占——也解除（unlock）相应的mutex，否则资源就有可能被永远锁住。此外也可能出现deadlock情景：两个线程在释放它们自己的lock之前彼此等待对方的lock。

C++标准库试图处理这些问题（但目前仍无法从概念上根本解决）。举个例子，面对异常你不该自己lock/unlock mutex，应该使用RAII守则（Resource Acquisition Is Initialization），循此，构造函数将获得资源，而析构函数——甚至当“异常造成生命期结束”它也总是会被调用——则负责为我们释放资源。为了这个目的，C++标准库提供了class std：：lock_guard：
```cc
int val;
std::mutex valMutex;  // control exclusive access to val

//...
std::lock_guard<std::mutex> lg(valMutex);  // lock and automatically unlock
if (val >= 0) {
    f(val);    // val is positive
}
else {
    f(-val);  // pass negated negative val
}
```
然而请注意，这样的lock应该被限制在可能之最短周期内，因为它们会阻塞（block）其他代码的并行运行机会。由于析构函数会释放这个lock，你或许会想明确安插大括号，令lock在更进一步语句被处理前先被释放：
```cc
int val;
std::mutex valMutex;  // control exclusive access to val

...
{
    std::lock_guard<std::mutex> lg(valMutex);  // lock and automatically unlock
    if (val >= 0) {
        f(val);    // val is positive
    }
    else {
        f(-val);  // pass negated negative val
    }
} // ensure that lock gets released here
...
```

或者这么写：
```cc
...
{
    std::lock_guard<std::mutex> lg(valMutex);  // lock and automatically unlock
    ++val;
} // ensure that lock gets released here
...
```

这只是第一个例子，但你可以看出，整个主题很容易变得很繁复。一如既往，程序员应该知道在并发模式（concurrent mode）下他们的所有作为。此外，C++存在着不同的mutex和lock，这将在稍后的小节中讨论。

#### Mutex和Lock的第一个完整用例

我们来看第一个完整例子：
```cc
// concurrency/mutex1.cpp
#include <future>
#include <mutex>
#include <iostream>
#include <string>

std::mutex printMutex;  // enable synchronized output with print()

void print(const std::string& s)
{
    std::lock_guard<std::mutex> l(printMutex);
    for (char c : s) {
        std::cout.put(c);
    }
    std::cout << std::endl;
}

int main()
{
    auto f1 = std::async(std::launch::async,
                         print, "Hello from a first thread");
    auto f2 = std::async(std::launch::async,
                         print, "Hello from a second thread");
    print("Hello from the main thread");
}
```

这里的print（）把它接收的string的所有字符写至标准输出设备。如果没有lock，输出可能是：[19]

```bash
HHelHello from a second thread
ello from a first thread
lo from the main thread
```

或是：
```bash
HelloHello fHello from a second ro from am th fthe main irrethreadstad
thr
ead
```

所谓将输出同步化（synchronize）就是令每次对print（）的调用都独占地写出所有字符，为此我们引入一个mutex给print（）使用，以及一个lock guard用来锁定被保护区：
```cc
std::mutex printMutex;  // enable synchronized output with print()
...
void print (const std::string& s)
{
    std::lock_guard<std::mutex> l(printMutex);
    ...
}
```

现在，输出会是这样（很好）：
```bash
Hello from a first thread
Hello from the main thread
Hello from a second thread
```

这样的输出在不使用lock时也可能出现，但不保证。

在这里，lock guard的构造函数会调用mutex的lock（），如果资源（亦即mutex）已被取走，它会block（阻塞），直到“对保护区的访问”再次获得允许。然而lock的次序仍旧不明确，因此上述三行输出有可能以任何次序出现。

#### 递归的（Recursive） Lock

有时候，递归锁定（to lock recursively）是必要的，典型例子是active object或monitor，它们在每个public函数内放一个mutex并取得其lock，用以防止data race腐蚀对象的内部状态。例如一个数据库接口可能像这样：
```cc
class DatabaseAccess
{
private:
    std::mutex dbMutex;
    ...  // state of database access
public:
    void createTable (...)
    {
        std::lock_guard<std::mutex> lg(dbMutex);
        ...
    }
    void insertData (...)
    {
        std::lock_guard<std::mutex> lg(dbMutex);
        ...
    }
    ...
};
```

当我们引入一个public成员函数而它可能调用其他public成员函数，情况变得复杂：
```cc
void createTableAndInsertData (...)
{
    std::lock_guard<std::mutex> lg(dbMutex);
    ...
    createTable(...);  // ERROR: deadlock because dbMutex is locked again
}
```

调用createTableAndInsertData（）会造成deadlock（死锁），因为它锁住dbMutex之后调用createTable（），造成后者尝试再次lock dbMutex，那将会block（阻塞）直到dbMutex变为可用，而这绝不会发生，因为 createTableAndInsertData（）会block （阻塞）直到createTable（）完成。

如果平台侦测到类似上述的deadlock，C++标准库允许第二次lock抛出异常std：：sys tem_error（见4.3.1节第43页）并带差错码resource_deadlock_would_occur（见4.3.2节第45页）。但这并非必然而且情况往往不是如此。

借着使用recursive_mutex，上述行为不再有问题。这个mutex允许同一线程多次锁定，并在最近一次（last）相应的unlock（）时释放lock：
```cc
class DatabaseAccess
{
private:
    std::recursive_mutex dbMutex;
    ...  // state of database access
public:
    void insertData (...)
    {
        std::lock_guard<std::recursive_mutex> lg(dbMutex);
        ...
    }
    void createTableAndInsertData (...)
    {
        std::lock_guard<std::recursive_mutex> lg(dbMutex);
        ...
        createTable(...);  // OK: no deadlock
    }
    ...
};
```

#### 尝试性的Lock以及带时间性的Lock

有时候程序想要获得一个lock但如果不可能成功的话它不想永远block（阻塞）。针对这种情况，mutex提供成员函数try_lock（），它试图取得一个lock，成功就返回true，失败则返回false。

为了仍能够使用lock_guard（使当下作用域的任何出口都会自动unlock mutex），你可以传一个额外实参adopt_lock给其构造函数：
```cc
std::mutex m;

// try to acquire a lock and do other stuff while this isn't possible
while (m.try_lock() == false) {
    doSomeOtherStuff();
}
std::lock_guard<std::mutex> lg(m, std::adopt_lock);
```

注意，try_lock（）有可能假性失败，也就是说即使lock并未被他人拿走它也有可能失败（返回false）。[20]

为了等待特定长度的时间，你可以选用（带时间性的）所谓 timed mutex。有两个特殊 mutex class std：：timed_mutex 和 std：：recursive_timed_mutex 额外允许你调用try_lock_for（）或 try_lock_until（），用以等待某个时间段，或直至抵达某个时间点。这对于实时需求（real-time requirement）或避免可能的deadlock或许有帮助。例如：
```cc
std::timed_mutex m;

// try for one second to acquire a lock
if (m.try_lock_for(std::chrono::seconds(1))) {
    std::lock_guard<std::timed_mutex> lg(m, std::adopt_lock);
    ...
}
else {
    couldNotGetTheLock();
}
```
注意，处理系统时间调整（system-time adjustment，详见5.7.5节第160页）时，try_lock_f or（）和try_lock_until（）往往有异。

#### 处理多个Lock

通常一个线程一次只该锁定一个mutex。然而有时候必须锁定多个mutex（例如为了传送数据，从一个受保护资源到另一个）。

这种情况下若以目前介绍过的lock机制来应付，可能变得复杂且具风险：你或许取得第一个lock却拿不到第二个lock，或许发生deadlock——如果以不同的次序去锁住相同的lock。

C++标准库为此提供了若干便捷函数，让你锁定多个mutex。例如：
```cc
std::mutex m1;
std::mutex m2;

{
    std::lock(m1, m2);  // lock both mutexes (or none if not possible)
    std::lock_guard<std::mutex> lockM1(m1, std::adopt_lock);
    std::lock_guard<std::mutex> lockM2(m2, std::adopt_lock);
    ...
} // automatically unlock all mutexes
```

全局函数std：：lock（）会锁住它收到的所有mutex，而且阻塞（blocking）直到所有mutex都被锁定或直到抛出异常。如果是后者，已被成功锁定的mutex都会被解锁。一如以往，成功锁定之后你可以并且应该使用lock guard，并以adopt_lock作为初始化的第二实参，确保任何情况下这些mutex在离开作用域时会被解锁。注意这个lock（）提供了一个deadlock回避机制，但那也意味着多个lock的锁定次序并不明确。

以此相同方式你可以尝试“取得多个lock”且“若并非所有lock都可用也不至于造成阻塞（blocking）”。全局函数std：：try_lock（）会在取得所有lock情况下返回-1，否则返回第一个失败的lock 的索引（从0 开始计），且如果这样的话所有成功的lock 会又被unlocked。例如：
```cc
std::mutex m1;
std::mutex m2;

int idx = std::try_lock(m1, m2);  // try to lock both mutexes
if (idx < 0) {  // both locks succeeded
    std::lock_guard<std::mutex> lockM1(m1, std::adopt_lock);
    std::lock_guard<std::mutex> lockM2(m2, std::adopt_lock);
    ...
}
else {
    // idx has zero-based index of first failed lock
    std::cerr << "could not lock mutex m" << idx+1 << std::endl;
} // automatically unlock all mutexes
```

注意，这个try_lock（）不提供deadlock回避机制，但它保证以出现于实参列的次序来试着完成锁定。

请注意，通常我们不会“只调用 lock（） 或 try_lock（）”却“不把那些 lock 过继（adopt）给一个 lock guard”。虽然代码看起来好像建立了“离开作用域时会自动解锁”的lock，其实并非如此，那些mutex仍然保持锁定：
```cc
std::mutex m1;
std::mutex m2;

{
    std::lock(m1, m2);  // lock both mutexes (or none if not possible)
    // no lock adopted
    ...
} // OOPS: mutexes are still locked !!!
```

#### Class unique_lock

除了class lock_guard＜＞，C++标准库还提供了class unique_lock＜＞，它对付mutex更有弹性。Class unique_lock＜＞提供的接口和class lock_guard＜＞相同，而又允许明确写出“何时”以及“如何”锁定或解锁其mutex。因此其object可能（但也可能不）拥有一个被锁住的mutex（或者就说拥有一个mutex）。这和lock_guard＜＞不同，后者的object生命中总是锁定一个mutex。[21]此外，对unique lock你可以调用 owns_lock（）或 bool（）来查询其mutex目前是否被锁住。

这个class的主要优点仍然是，如果析构时mutex仍被锁住，其析构函数会自动调用unlock（）。如果当时没有锁住mutex，则析构函数不做任何事。

与class lock_guard相较，class unique_lock添加了以下三个构造函数：

· 你可以传递try_to_lock，表示企图锁定mutex但不希望阻塞（blocking）：
```cc
std::mutex mutex;

std::unique_lock<std::mutex> lock(mutex, std::try_to_lock);
if (lock) {  // if lock was successful
    ...
}
```

· 你可以传递一个时间段或时间点给构造函数，表示尝试在一个明确的时间周期内锁定：
```cc
std::timed_mutex mutex;

std::unique_lock<std::timed_mutex> lock(mutex,
    std::chrono::seconds(1));
```

· 你可以传递defer_lock，表示初始化这一lock object但尚未打算锁住mutex：
```cc
std::mutex m1;
std::mutex m2;

std::unique_lock<std::mutex> lockM1(m1, std::defer_lock);
std::unique_lock<std::mutex> lockM2(m2, std::defer_lock);

...
std::lock(m1, m2);  // lock both mutexes (or none if not possible)
```

上述的defer_lock flag可以（例如）用来建立一或多个lock并于稍后才锁住它们：


此外，class unique_lock提供release（）用来释放mutex，或是将其mutex拥有权转移给另一个lock。详见18.5.2节第1000页。

有了 lock_guard和 unique_lock作为工具，现在我们可以实现一个粗浅例子，以轮询（polling）某个ready flag的方式，令一个线程等待另一个线程：
```cc
#include <mutex>
#include <thread>
#include <chrono>

bool readyFlag;
std::mutex readyFlagMutex;

void thread1()
{
    // do something thread2 needs as preparation
    ...
    std::lock_guard<std::mutex> lg(readyFlagMutex);
    readyFlag = true;
}

void thread2()
{
    // wait until readyFlag is true (thread1 is done)
    {
        std::unique_lock<std::mutex> ul(readyFlagMutex);
        while (!readyFlag) {
            ul.unlock();
            std::this_thread::yield();  // hint to reschedule to the next thread
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            ul.lock();
        }
    } // release lock

    // do whatever shall happen after thread1 has prepared things
    ...
}
```

面对这段代码可能会有的典型疑虑，我有以下两点解释：

· 如果你惊讶为什么我使用mutex来控制readyFlag的读和写，请回忆本章一开始介绍的准则：任何“带有至少一个write”的并发处理（concurrent access）都应该被同步化。详见18.4节第982页和18.7节第1012页。

· 如果你惊讶为什么声明readyFlag时竟不需要volatile（如此便是允许thread2（）中对其多次读取可被优化掉），那么请注意：这些“对readyFlag的读取”发生在critical section内（也就是在某个lock的设立和解除之间）。这样的代码不得以“读/写动作被移出critical section之外”的形式被优化。所以对readyFlag的读取动作一定实效地发生在：

-循环（loop）起始处，在“声明ul”和“第一次调用unlock（）”之间。

-循环之内，在lock（）和unlock（）的任何调用之间。

-循环末尾，在lock（）的最后一次调用和ul的析构之间，后者会解锁mutex——如果它被锁住的话。

尽管如此，这样对于“某一满足条件”的轮询（polling）通常不是好办法。更好的做法是使用condition variable（条件变量），详见18.6.1节第1003页。

### 细说Mutex和Lock
细说Mutex

C++标准库提供了以下mutex class（见表18.6）：

· Class std：：mutex，同一时间只可被一个线程锁定。如果它被锁住，任何其他 lock（）都会阻塞（block），直到这个mutex再次可用，且try_lock（）会失败。

· Class std：：recursive_mutex，允许在同一时间多次被同一线程获得其lock。其典型应用是：函数捕获一个lock并调用另一函数而后者再次捕获相同的lock。

表18.6 各种Mutex及其能力概览
| 操作                | mutex       | recursive_mutex | timed_mutex       | recursive_timed_mutex |
|---------------------|-------------|-----------------|-------------------|-----------------------|
| lock()              | 捕获 mutex（若无所捕获则阻塞） | 捕获 mutex（若无所捕获则阻塞） | 捕获 mutex（若无所捕获则阻塞） | 捕获 mutex（若无所捕获则阻塞） |
| try_lock()          | 捕获 mutex（若无所捕获则返回 false） | 捕获 mutex（若无所捕获则返回 false） | 捕获 mutex（若无所捕获则返回 false） | 捕获 mutex（若无所捕获则返回 false） |
| unlock()            | 解除被锁定的 mutex | 解除被锁定的 mutex | 解除被锁定的 mutex | 解除被锁定的 mutex |
| try_lock_for()      | -           | -               | 试着在时间段内捕获一个 lock | -                     |
| try_lock_until()    | -           | -               | 试着捕获一个 lock 直到某个时间点 | -                     |
| 多个 lock           | 否          | 是（同一线程） | 否                | 是（同一线程） |


· Class std：：timed_mutex额外允许你传递一个时间段或时间点，用来定义多长时间内它可以尝试捕捉一个lock。为此它提供了try_lock_for（）和try_lock_until（）。

· Class std：：recursive_timed_mutex允许同一线程多次取得其lock，可指定期限。

表18.7列出了mutex的操作函数。

表18.7 Mutex Class的操作函数
| 操作                     | 效果                                                                                          |
|--------------------------|-----------------------------------------------------------------------------------------------|
| `mutex m`                | Default 构造函数，建立一个未锁定的（unlocked）mutex                                          |
| `m.~mutex()`             | 销毁 mutex（它必须未被锁定）                                                                 |
| `m.lock()`               | 尝试锁住 mutex（会造成阻塞）                                                                 |
| `m.try_lock()`           | 尝试锁定 mutex。如果锁定成功就返回 `true`                                                   |
| `m.try_lock_for(dur)`    | 尝试在时间段 `dur` 内锁定。如果锁定成功就返回 `true`                                       |
| `m.try_lock_until(tp)`   | 尝试在时间点 `tp` 之前锁定。如果锁定成功就返回 `true`                                      |
| `m.unlock()`             | 解除 mutex。如果它未曾被锁定则行为不明确                                                    |
| `m.native_handle()`      | 返回一个因平台而异的类型 `native_handle_type`，这是为了不具可移植性的扩展                  |

lock（）有可能抛出std：：system_error（见4.3.1节第43页）并夹带以下差错码（见4.3.2节第45页）：

· operation_not_permitted——如果线程的特权级（privilege）不足以执行此操作。

· resource_deadlock_would_occur——如果平台侦测到有个deadlock即将发生。

· device_or_resource_busy——如果mutex已被锁定而又无法形成阻塞（blocking）。

如果程序解除（unlock）一个并非它所拥有的mutex object，或是销毁一个被任何线程拥有的mutex object，或是线程拥有mutex object但却结束了生命，将导致不明确的行为。

注意，处理系统时间调整（system-time adjustment，详见5.7.5节第160页）时，try_lo ck_for（）和try_lock_until（）通常有异。

#### 细说Class lock_guard

18.5.1 节第989 页引入的class std：：lock_guard 提供了一个很小的接口，用以确保一个locked mutex在离开作用域时总是会被释放（见表18.8）。它的整个生命期间总是与一个lock相关联（associated）——也许是被明白申请，也许是在构造期间接受（adopted）。

表18.8 Class lock_guard的操作函数
| 操作                             | 效果                                                 |
|----------------------------------|------------------------------------------------------|
| `lock_guard lg(m)`              | 为 mutex `m` 建立一个 lock guard 并锁定之               |
| `lock_guard lg(m,adopt_lock)`  | 为已经被锁定的 mutex `m` 建立一个 lock guard             |
| `lg.~lock_guard()`              | 解锁（unlock）mutex 并销毁 lock guard                   |

#### 细说Class unique_lock

18.5.1节第996页引入的class std：：unique_lock，为一个不一定得锁定（或曰拥有）的mutex提供一个lock guard。它提供的接口列于表18.9。如果它在析构期间仍旧锁定（或曰拥有）mutex，它会调用unlock（）。但你可以明确控制是否它有一个关联的mutex以及是否这个mutex被锁住。你也可以限期或无限期地尝试锁定mutex。

lock（） 可能抛出 std：：system_error （见4.3.1节第43页），其所夹带的差错码和mutex的lock（）所引发的相同（见第999页）。unlock（）可能抛出std：：system_error并夹带差错码operation_not_permitted——如果这个unique lock并未被锁的话。

18.5.3 只调用一次
有时候某些机能初次被某个线程使用过后，其他线程再也不需要它。典型例子是 lazy initialization（缓式初始化）：第一次某个线程需要某数据而该数据必须备妥，于是此时处理它（但不在先前处理，因为你想节省时间；如果非必要的话就不处理它）。

单线程环境中的习惯做法很简单：以一个bool flag表示此机能是否已被调用。
```cc
bool initialized = false;  // global flag
...
if (!initialized) {        // initialize if not initialized yet
    initialize();
    initialized = true;
}
```

或
```cc
static std::vector<std::string> staticData;

void foo()
{
    if (staticData.empty()) {
        staticData = initializeStaticData();
    }
    ...
}

```

表18.9 Class unique_lock的操作函数
以下是提取的 `unique_lock` 操作及效果的表格内容：

| 操作                             | 效果                                                                                          |
|----------------------------------|-----------------------------------------------------------------------------------------------|
| `unique_lock l`                 | Default 构造函数，建立一个 lock 但不关联任何 mutex                                          |
| `unique_lock l(m)`              | 为 mutex `m` 建立一个 lock guard 并锁定它                                                   |
| `unique_lock l(m,adopt_lock)`  | 为已锁定的 mutex `m` 建立一个 lock guard                                                   |
| `unique_lock l(m,defer_lock)`  | 为 mutex `m` 建立一个 lock guard 但是不锁定它                                              |
| `unique_lock l(m,try_lock)`    | 为 mutex `m` 建立一个 lock guard 并试图锁定它                                              |
| `unique_lock l(m,dur)`         | 为 mutex `m` 建立一个 lock guard 并试图在时间段 `dur` 内锁定它                             |
| `unique_lock l(m,tp)`          | 为 mutex `m` 建立一个 lock guard 并试图在时间点 `tp` 之前锁定它                            |
| `unique_lock l(rv)`            | Move 构造函数；将 lock state 从 `rv` 搬到 `l`（`rv` 从此不再关联任何 mutex）                |
| `l.~unique_lock()`             | 解锁（unlock）mutex（如果它被锁定的话）并销毁 lock guard                                   |
| `unique_lock l = rv`           | Move assignment；将 lock state 从 `rv` 搬到 `l`（`rv` 从此不再关联任何 mutex）              |
| `swap(l1,l2)`                  | 交换 lock                                                                                     |
| `l1.swap(l2)`                  | 交换 lock                                                                                     |
| `l.release()`                  | 返回一个 pointer 指向关联的 mutex 并释放之                                                 |
| `l.owns_lock()`                | 如果关联的 mutex 被锁定则返回 `true`                                                       |
| `if (l)`                       | 检查关联的 mutex 是否被锁定                                                                 |
| `l.mutex()`                    | 返回一个 pointer 指向关联的 mutex                                                          |
| `l.lock()`                     | 锁住关联的 mutex                                                                            |
| `l.try_lock()`                 | 尝试锁住关联的 mutex（如果成功就返回 `true`）                                             |
| `l.try_lock_for(dur)`          | 尝试在时间段 `dur` 内锁住关联的 mutex（如果成功就返回 `true`）                             |
| `l.try_lock_until(tp)`         | 尝试在时间点 `tp` 之前锁住关联的 mutex（如果成功就返回 `true`）                            |
| `l.unlock()`                   | 解除关联的 mutex                                                                            |

但是这样的代码在多线程环境下行不通，因为如果两个或多个线程检查初始化是否尚未发生然后启动初始化，就可能发生data race。你必须针对concurrent access保护“检查及初始化”程序区。

一如既往，你可以使用mutex，但C++标准库为此提供了一个特殊解法。只需使用一个std：：once_flag以及调用std：：call_once（它也由＜mutex＞提供）：
```cc
std::once_flag oc;  // global flag
...
std::call_once(oc, initialize);  // initialize if not initialized yet
```

或
```cc
static std::vector<std::string> staticData;

void foo()
{
    static std::once_flag oc;
    std::call_once(oc, []{
        staticData = initializeStaticData();
    });
    ...
}
```
如你所见，传给call_once（）的第一实参必须是相应的once_flag。下一个实参代表可调用对象（callable object）如function、member function、function object或lambda，还可再加上其他实参给被调用的函数使用（见4.4节第54页）。因此，多线程环境中的缓式初始化（lazy initialization）应该像这样：
```cc
class X {
private:
    mutable std::once_flag initDataFlag;
    void initData() const;
public:
    data getData() const {
        std::call_once(initDataFlag, &X::initData, this);
        ...
    }
};
```

原则上你可以使用同一个once flag调用不同的函数。之所以把once flag当作第一实参传给call_once（）就是为了确保传入的机能只被执行一次。因此，如果第一次调用成功，下一次调用又带着相同的once flag，传入的机能就不会被调用——即使该机能与第一次有异。

被调用函数所造成的任何异常会被call_once（）抛出。此情况下第一次调用被视为不成功，因此下一次 call_once（）还可以再调用它所接受的机能。[22]

## Condition Variable（条件变量）
有时候，被不同线程执行的task必须彼此等待。所以对“并发操作”实现同步化除了data race之外还有其他原因。

你可能会争辩说我们已经引入这样一个机制：Future（见18.1节第946页）允许你停下来（to block）直到另一线程提供某笔数据或直到另一线程结束。然而future从某线程传递数据到另一线程只能一次。事实上future的主要目的是处理线程的返回值或异常。

本节将介绍condition variable（条件变量），它可用来同步化线程之间的数据流逻辑依赖关系（logical dependencies in data flow between threads）。

### Condition Variable（条件变量）的意图
18.5.1节第997页介绍了“让某线程等待另一线程”的一个粗浅办法，就是使用ready flag之类的东西。当某线程已有准备，或它已经为另一线程提供了某个东西，上述flag就发出信号。这通常意味着等待中的线程（waiting thread）需要轮询（poll）其所需要的数据或条件是否已达到：
```cc
bool readyFlag;
std::mutex readyFlagMutex;

// wait until readyFlag is true:
{
    std::unique_lock<std::mutex> ul(readyFlagMutex);
    while (!readyFlag) {
        ul.unlock();
        std::this_thread::yield();  // hint to reschedule to the next thread
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        ul.lock();
    }
} // release lock
```

然而这样“针对目标条件而轮询”的动作通常不是好的解决办法。正如[Williams：C++Conc]指出：

等待中的线程（waiting thread）消耗宝贵的CPU时间重复检验flag，且当它锁住mutex时“负责设置ready flag”的那个线程会被阻塞（blocked）。……此外我们也很难找出适当的sleep周期：两次检查若间隔太短则线程仍旧太浪费CPU时间于检查动作上，若太长则也许等待的task已完成而线程却还继续sleeping，导致发生延误。

一个较好的做法是使用condition variable（条件变量），C++标准库在＜condition_variable＞中提供了它。它是个变量，借由它，一个线程可以唤醒（wake up）一或多个其他等待中的线程（waiting thread）。

原则上，condition variable运作如下：

· 你必须同时包含 ＜mutex＞和 ＜condition_variable＞，并声明一个mutex和一个condi-tion variable：
```cc
#include <mutex>
#include <condition_variable>

std::mutex readyMutex;
std::condition_variable readyCondVar;
```

· 那个激发“条件终于满足”的线程（或多线程之一）必须调用

```cc
// 通知一个等待线程
readyCondVar.notify_one();  // notify one of the waiting threads

```
或
```cc
// 或通知所有等待线程
readyCondVar.notify_all();  // notify all the waiting threads

```

· 那个“等待条件被满足”的线程必须调用
```cc
std::unique_lock<std::mutex> l(readyMutex);
readyCondVar.wait(l);
```

因此，“提供或准备某东西”的那个线程只需对 condition variable 调用 notify_one（） 或notify_all（），便会唤醒一个或所有等待中的线程（waiting thread）。

目前为止一切都好，听起来很简单。但是还有更多需要注意。首先，为了等待这个condition variable，你需要一个 mutex 和一个 unique_lock （介绍于18.5.1节第996页）。lock_guard是不够的，因为等待中的函数（waiting function）有可能锁定或解除mutex。

此外，condition variable也许有所谓假醒（spurious wakeup）。也就是某个condition vari-able的wait动作有可能在该condition variable尚未被notified时便返回。以下引自Anthony Williams的[Williams：CondVar]：“假醒无法被测定，以使用者的观点来看它们实质上是随机的。然而它们通常发生于thread library无法可靠确定某个waiting thread不遗漏任何notifi-cation时。由于遗漏notification便代表condition variable无用，thread library宁愿在线程的wait之中唤醒它而不愿承受风险。”

因此，发生 wakeup 不一定意味着线程所需要的条件已经掌握了。更确切地说，在wakeup之后你仍然需要代码去验证“条件实际已达成”。因此（例如）我们必须检查数据是否真正备妥，或是我们仍需要诸如ready flag之类的东西。为了设立和查询他端供应的数据或ready flag，可使用同一个mutex。

### Condition Variable（条件变量）的第一个完整例子
以下代码完整示范了如何使用condition variable：
```cc
#include <condition_variable>
#include <mutex>
#include <future>
#include <iostream>

bool readyFlag;
std::mutex readyMutex;
std::condition_variable readyCondVar;

void thread1()
{
    // do something thread2 needs as preparation
    std::cout << "<return>" << std::endl;
    std::cin.get();

    // signal that thread1 has prepared a condition
    {
        std::lock_guard<std::mutex> lg(readyMutex);
        readyFlag = true;
    } // release lock
    readyCondVar.notify_one();
}

void thread2()
{
    // wait until thread1 is ready (readyFlag is true)
    {
        std::unique_lock<std::mutex> ul(readyMutex);
        readyCondVar.wait(ul, []{ return readyFlag; });
    } // release lock

    // do whatever shall happen after thread1 has prepared things
    std::cout << "done" << std::endl;
}

int main()
{
    auto f1 = std::async(std::launch::async, thread1);
    auto f2 = std::async(std::launch::async, thread2);
}
```

在包含必要的头文件之后，我们需要三个东西以便在线程之间通信；

1.一个“用以存放待处理数据”的对象，或一个“用以表示条件真的满足了”的flag（也就是此处的readyFlag））。

2.一个mutex（这里是readyMutex）。

3.一个condition variable（这里是readyCondVar）。

数据供应者（线程） thread1（）锁住mutex readyMutex，更新条件（也就是更新数据或更新ready flag），解锁mutex，然后通知condition variable：
```cc
{
    std::lock_guard<std::mutex> lg(readyMutex);
    readyFlag = true;
} // release lock
readyCondVar.notify_one();
```

注意，通知动作不需要被安排在lock保护区内。

等待者（线程）则是以一个unique_lock（见18.5.1节第996页）锁住mutex，一面检查条件一面等待被通知，然后释放锁：
```cc
{
    std::unique_lock<std::mutex> ul(readyMutex);
    readyCondVar.wait(ul, []{ return readyFlag; });
} // release lock
```

在这里，condition variable的wait（）成员函数是这么被使用的：你把mutex readyMutex的lock ul当作第一实参，把一个lambda当作第二实参，用来二次检测条件是否真的满足。其效果是wait（）内部会不断调用该第二实参，直到它返回true。因此这段代码的效果相当于以下代码，其中的循环很明显是用来处理假醒（spurious wakeups）的：
```cc
{
    std::unique_lock<std::mutex> ul(readyMutex);
    while (!readyFlag) {
        readyCondVar.wait(ul);
    }
} // release lock
```

再次提醒，这里必须使用unique_lock，不可使用lock_guard，因为 wait（）的内部会明确地对mutex进行解锁和锁定。

你也许会说这个例子不好，因为使用future会造成blocking（阻塞）直到某些数据到达。那么我来展示第二个例子。

### 使用Condition Variable（条件变量）实现多线程Queue
本例中，三个线程都把数值推入（push）某个queue，另两个线程则是从中读取数据：
```cc
#include <condition_variable>
#include <mutex>
#include <future>
#include <thread>
#include <iostream>
#include <queue>

std::queue<int> queue;
std::mutex queueMutex;
std::condition_variable queueCondVar;

void provider(int val)
{
    // push different values (val til val+5 with timeouts of val milliseconds into the queue
    for (int i = 0; i < 6; ++i) {
        {
            std::lock_guard<std::mutex> lg(queueMutex);
            queue.push(val + i);
        } // release lock
        queueCondVar.notify_one();

        std::this_thread::sleep_for(std::chrono::milliseconds(val));
    }
}

void consumer(int num)
{
    // pop values if available (num identifies the consumer)
    while (true) {
        int val;
        {
            std::unique_lock<std::mutex> ul(queueMutex);
            queueCondVar.wait(ul, []{ return !queue.empty(); });
            val = queue.front();
            queue.pop();
        } // release lock
        std::cout << "consumer " << num << ": " << val << std::endl;
    }
}

int main()
{
    // start three providers for values 100+, 300+, and 500+
    auto p1 = std::async(std::launch::async, provider, 100);
    auto p2 = std::async(std::launch::async, provider, 300);
    auto p3 = std::async(std::launch::async, provider, 500);

    // start two consumers printing the values
    auto c1 = std::async(std::launch::async, consumer, 1);
    auto c2 = std::async(std::launch::async, consumer, 2);
}
```

这里我们有一个global queue（见12.2节第638页）被并发使用，它被一个mutex和一个condition variable保护着：
```cc
std::queue<int> queue;
std::mutex queueMutex;
std::condition_variable queueCondVar;

```

其中mutex确保读和写是atomic，而condition variable用来在“有新元素可用”时激发和唤醒另一个线程：

现在，三个线程各自提供数值推入queue之中：
```cc
{
    std::lock_guard<std::mutex> lg(queueMutex);
    queue.push(val + i);
} // release lock
queueCondVar.notify_one();
```

借由notify_one（），它们唤醒了某一个等待者（线程），让对方处理。再请注意这个调用不需要位于保护区内，所以我们先封闭了先前“声明lock guard”的那个区域。

下面这个线程等待新值然后处理：
```cc
int val;
{
    std::unique_lock<std::mutex> ul(queueMutex);
    queueCondVar.wait(ul, []{ return !queue.empty(); });
    val = queue.front();
    queue.pop();
} // release lock
...
```

根据queue的接口（见12.2节第638页），我们需要三个调用才能从queue手中取得下一个值：empty（）负责检查是否还有可用数值。调用empty（）是个两次检查的动作，用以对付 wait（）可能出现的假醒。front（）询问下一个值，pop（）移除该值。这三个函数都在unique lock ul所形成的保护区内，而对 front（）返回值的处理则放在更后面，为的是将lock的持续时段最小化。

此程序的一个可能输出如下：
```bash
consumer 1: 300
consumer 1: 100
consumer 2: 500
consumer 1: 101
consumer 2: 102
consumer 1: 301
consumer 2: 103
consumer 1: 104
consumer consumer 1: 105
2: 501
consumer 1: 302
consumer 2: 502
consumer 1: 303
consumer 2: 304
consumer 1: 503
consumer 2: 305
consumer 1: 504
consumer 2: 505
```


注意，两个consumer的输出并非同步，所以字符有可能交错。也请注意，并发等待者（线程）的被通知次序是不确定的。

如果有多个 consumer 必须处理相同数据，你也可以调用 notify_all（）。典型的例子是事件驱动系统（event-driven system），其事件（event）必须被发布给所有曾经登录的consumer。

也请注意，condition variable也提供给你一个接口允许你等待某个最大时间量：wait_fo r（）用来等待一个时间段，wait_until（）用来等待直到某个时间点。


### 细说Condition Variable（条件变量）
头文件＜condition_variable＞针对condition variable提供了两个对应的class，分别是class condition_variable和class condition_variable_any。

#### Class condition_variable

正如18.6节第1003页所说，class std：：condition_variable由C++标准库提供，用来唤醒一或多个等待某特定条件（意指某些必须由他人提供或执行的东西）获得满足的线程。多个线程可等待同一条件发生。一旦条件满足，线程就可以通知（notify）所有（或某个）等待者（线程）。

由于可能发生假醒（spurious wakeup），当条件满足，仅仅通知是不够的，等待者（线程）还必须在苏醒（wakeup）之后两次检查该条件。

表18.10列出了C++标准库为class condition_variable提供的接口细节。另一个class condition_variable_any提供相同的接口但不含native_handle（）和notify_all_at_thr ead_exit（）。

如果无法建立condition variable，构造函数会抛出 std：：system_error异常（见4.3.1节第43页）并夹带差错码 resource_unavailable_try_again，这相当于 POSIX errno EAGAIN（见4.3.2节第45页）。复制和赋值（copy and assignment）都是不允许的。

表18.10 Class condition_variable的操作函数
以下是提取的关于`condition_variable`操作及效果的表格内容：

| 操作 | 效果 |
| ---- | ---- |
| `condvar cv` | Default 构造函数；建立一个 condition variable |
| `cv.~condvar()` | 销毁 condition variable |
| `cv.notify_one()` | 唤醒一个等待者（线程）——如果有的话 |
| `cv.notify_all()` | 唤醒所有等待者（线程） |
| `cv.wait(ul)` | 使用 unique lock `ul` 来等待通知 |
| `cv.wait(ul,pred)` | 使用 unique lock `ul` 来等待通知，并且直到 `pred` 在一次苏醒之后结果为 `true` |
| `cv.wait_for(ul,duration)` | 使用 unique lock `ul` 来等待通知，等待期限是 `duration` |
| `cv.wait_for(ul,duration,pred)` | 使用 unique lock `ul` 来等待通知，等待期限是 `duration`，或直到 `pred` 在一次苏醒之后结果为 `true` |
| `cv.wait_until(ul,timepoint)` | 使用 unique lock `ul` 来等待通知，直到时间点 `timepoint` |
| `cv.wait_until(ul,timepoint,pred)` | 使用 unique lock `ul` 来等待通知，直到时间点 `timepoint`，或直到 `pred` 在一次苏醒之后结果为 `true` |
| `cv.native_handle()` | 返回一个因平台而异的类型 `native_handle_type`，为的是不具可移植性的扩展 |
| `notify_all_at_thread_exit(cv,ul)` | 在调用所在之本线程（calling thread）唤醒所有使用 unique lock `ul` 来等待 `cv` 的线程 |

所有通知（notification）都会被自动同步化，所以并发调用notify_one（）和notify_all（）不会带来麻烦。

所有等待某个condition variable的线程都必须使用相同的mutex；当wait（）家族的某个成员被调用时该mutex必须被unique_lock锁定，否则会发生不明确的行为。

注意，condition variable的消费者总是在“被锁住的mutex”基础上操作。只有等待函数（waiting function）会执行以下三个atomic步骤暂时解除mutex：[23]

1.解除（unlocking） mutex然后进入等待状态（waiting state）。

2.解除因等待而造成的阻塞（Unblocking the wait）。

3.再次锁住mutex。

这意味着传给wait函数的那个判断式（predicate）总是在lock情况下被调用，所以它们可以安全地处理受mutex保护的对象。[24]用来将mutex锁定和解锁（lock and unlock）的动作有可能抛出对应的异常（见18.5.2节第1000页）。

wait_for（）和wait_until（）各有一个不接受判断式（predicate）的版本，它们的返回值都属于以下枚举类（enumeration class，见3.1.13节第32页）：

· std：：cv_status：：timeout——如果发生不容置疑的超时（timeout）。

· std：：cv_status：：no_timeout——如果发生通知（notification）。

wait_for（）和 wait_until（）亦各有一个“接受判断式（predicate）作为第三实参”的版本，它们会返回判断式的执行结果。

全局函数notify_all_at_thread_exit（cv，l）用来在其调用者（线程）退场（exit）时调用notify_all（）。为此它暂时锁住对应的lock l，后者必须使用所有等待线程（waiting thread）共享的同一个mutex。为避免死锁（deadlock），线程调用notify_all_at_thread_exit（）之后应该直接退场。因此这个调用只是为了在通知waiting thread之前先完成清理工作，而且这个清理工作绝不该造成阻塞（block）。[25]

Class condition_variable_any

除了class std：：condition_variable，C++标准库还提供一个class std：：condition_vari able_any，它不要求使用 std：：unique_lock对象当作lock。正如C++标准库所言：“如果你使用的lock不是标准mutex类型，或如果你使用标准mutex类型的一个unique_lock wrapper（外覆器）并搭配condition_variable_any，那么使用者必须确保实现condition_variable_any实例对象所关联之predicate（判断式）的任何必要同步化（synchronization）”。事实上该实例对象必须履行所谓的BasicLockable规定，该规定要求提供同步化的 lock（）和unlock（）成员函数。

## Atomic
在condition variable的第一个例子中（见18.6.1节第1003页）我们使用bool readyFlag让任意线程激发（signal），表示某件事情已为另一线程备妥或提供。你也许会惊讶为什么仍然需要mutex。如果我们有个bool值，为什么不能并发地（concurrently）让某线程改变它而让另一线程检验（读取）它？在供应端（线程）将bool设为 true的那个时刻，观测端（线程）应能够看到它并执行随之发生的处理才是。

正如18.4节第982页所介绍，这里我们需要面对两个问题：

1.一般而言，即使面对基本数据类型，读和写也不是atomic（不可切割的）。因此本例你可能读到一个被写一半的bool值，C++standard说这会带来不明确的行为。

2.编译器生成的代码有可能改变操作次序，所以供应端（线程）有可能在供应数据之前就先设置ready flag，而消费端（线程）亦有可能在侦测ready flag之前就处理该数据。

借由mutex，两个问题迎刃而解，但是从必要的资源和潜藏的独占访问来看，mutex也许是个相对昂贵的操作，所以也许值得以atomic取代mutex和lock。

本节中我首先介绍atomic的高层接口，它所提供的操作将使用默认保证，不论内存访问次序如何。这个默认保证提供了顺序一致性（sequential consistency），意思是在线程之中atomic操作保证一定“像代码出现的次序”那样地发生。因此18.4.3节第986页所说的重排语句也就不会出现。本节末尾将展示atomic的低层接口：带有“放宽之次序保证”的操作。

注意，C++标准库并不区分atomic的高层或低层接口。低层是Hans Boehm说的，他是这个程序库的作者之一。某些时候atomic低层接口也被称为 weak或relaxed接口，而高层接口被称为normal或strong接口。

### Atomic用例
让我们改写18.6.1节第1003页的例子，改用atomic：

```cc
#include <atomic>  // for atomic types

std::atomic<bool> readyFlag(false);
void thread1()
{
    // do something thread2 needs as preparation
    ...
    readyFlag.store(true);
}
void thread2()
{
    // wait until readyFlag is true (thread1 is done)
    while (!readyFlag.load()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    // do whatever shall happen after thread1 has prepared things
    ...
}
```
然后使用std：：atomic＜＞class template声明一个atomic object：
```cc
std::atomic<bool> readyFlag(false);
```


原则上你可以使用任何一般类型、整数类型，或pointer类型作为template参数。

注意你总是应该将atomic object 初始化，因为其default 构造函数并不完全初始化它（倒不是其初值不明确，而是其lock未被初始化）。[26]面对一个static-duration atomic对象，你应该使用一个常量作为初值。如果只使用default构造函数，接下来唯一允许的操作是如
```cc
atomic<bool> readyFlag; 
...
atomic_init(&readyFlag, false);
```

这种初始化方式之所以出现，是为了让你写出C编译器可接受的代码（见18.7.3节第1019页）。

处理atomic的两个最重要语句是store（）和load（）：

· store（）赋予一个新值。

· load（）取当前值。

重点是，这些操作都保证是atomic（不可切割的），所以我们不需要像以前（无atomic的时代）那样“需要mutex的保护才能设置ready flag”。于是，第一线程中不再这么写：
```cc
{
    lock_guard<std::mutex> lg(readyMutex);
    readyFlag = true;
} // release lock
```

而是简单写成这样：
```cc
readyFlag.store(true)
```

第二线程中不再这么写：
```cc
{
    std::unique_lock<std::mutex> l(readyFlagMutex);
    while (!readyFlag) {
        l.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        l.lock();
    }
} // release lock
```

而是简单写成这样：
```cc
while (!readyFlag.load()) {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}
```

然而，使用condition variable时我们仍然需要mutex才能保护对condition variable的消费（即使它现在是个atomic object）：
```cc
// wait until thread1 is ready (readyFlag is true)
{
    std::unique_lock<std::mutex> l(readyMutex);
    readyCondVar.wait(l, []{ return readyFlag.load(); });
} // release lock
```

对于atomic类型，你可以继续使用有用而寻常的操作，像是赋值、自动转换为整型、递增、递减等：
```cc
// 布尔型原子变量
std::atomic<bool> ab(false);
ab = true;
if (ab) {
    ...
}

// 整型原子变量
std::atomic<int> ai(0);
int x = ai;
ai = 10;
ai++;
ai -= 17;
```

然而请注意，为了提供atomicity（不可切割性），某些惯常行为可能会出现轻微差异。例如赋值操作返回的是被赋予值（assigned value），而不是返回一个reference指向“接受该值”的atomic。详见18.7.2节第1016页）。

让我们看一个使用atomic的完整例子：
```cc
#include <atomic>    // for atomics
#include <future>    // for async() and futures
#include <thread>    // for this_thread
#include <chrono>    // for durations
#include <iostream>

long data;
std::atomic<bool> readyFlag(false);

void provider()
{
    // after reading a character
    std::cout << "<return>" << std::endl;
    std::cin.get();

    // provide some data
    data = 42;

    // and signal readiness
    readyFlag.store(true);
}

void consumer()
{
    // wait for readiness and do something else
    while (!readyFlag.load()) {
        std::cout.put('.').flush();
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    // and process provided data
    std::cout << "\nvalue : " << data << std::endl;
}

int main()
{
    // start provider and consumer
    auto p = std::async(std::launch::async, provider);
    auto c = std::async(std::launch::async, consumer);
}
```

这里，线程provider（）首先提供若干数据，然后使用store（）表示数据已提供：
```cc
// provide some data
data = 42;

// and signal readiness
readyFlag.store(true);
```

store（）会对影响所及的内存区执行一个所谓release操作，确保此前所有内存操作（all prior memory operations）不论是否为 atomic，在store发挥效用之前都变成“可被其他线程看见”。

与此相关，线程consumer（）不断执行load（）然后处理data：
```cc
// loop until ready
while (!readyFlag.load()) {
    ...
}

// and process provided data
std::cout << data << std::endl;
```

load（） 会对影响所及的内存区执行一个所谓acquire 操作，确保随后所有内存操作（all following memory operations）不论是否为 atomic，在 load 之后都变成“可被其他线程看见”。

于是，由于data的设值发生在provider（）将readyFlag存储（store）为 true之前，而对data的处理发生在consumer（）将true载入（loaded）放进readyFlag之后，因此对data的处理保证发生在data已提供之后。

这项保证之所以存在，是因为所有atomic操作默认使用一个特别的内存次序（memory order），名为 memory_order_seq_cst，它代表sequential consistent memory order（顺序一致的内存次序）。低层的atomic操作能够放宽这一次序保证（详见18.7.4节第1019页）。

### 细说Atomic及其高级接口
在＜atomic＞中，class template std：：atomic＜＞提供“atomic类型之普遍能力”，这种类型可套用于任何一般类型身上。另有特化版本针对bool、所有整数类型及pointer：
```cc
template<typename T> struct atomic;  // primary class template
template<> struct atomic<bool>;      // explicit specializations
template<> struct atomic<int>;
...
template<typename T> struct atomic<T*>;  // partial specialization for pointers
```

表18.11列出了atomic 的高层操作。如果可能它们将直接映射至相关的CPU 命令。纵列triv表示针对std：：atomic＜bool＞及“其他普通类型之atomic”提供的操作；纵列int type表示“针对 std：：atomic＜＞ 且使用整数类型”而提供的操作；纵列 ptr type 表示“针对std：：atomic＜＞且使用pointer类型”而提供的操作。

注意，我对这个表有几点补充：

· 一般而言，这些操作获得的是copy而不是reference。

· Default构造函数并未能够完全将object初始化。Default构造函数之后唯一合法的操作就是调用atomic_init（）完成初始化（见18.7.1节第1013页）。

· 接受相关类型值（a value of the corresponding type）的那个构造函数并不是atomic。

· 所有函数，除了构造函数，都被重载为 volatile和non-volatile两个版本。

表18.11 Atomic的高层操作
以下是提取的表格内容，整理为清晰的 markdown 格式：

| 操作 | triv type | int type | ptr type | 效果 |
| --- | --- | --- | --- | --- |
| `atomic a=val` | Yes | Yes | Yes | 以 `val` 为 `a` 的初值（这不是个 atomic 操作） |
| `atomic a; atomic_init(&a,val)` | Yes | Yes | Yes | 同上（若无后继的 `atomic_init()`，`a` 便初始化不完整） |
| `a.is_lock_free()` | Yes | Yes | Yes | 如果类型内部不使用 lock 便返回 `true` |
| `a.store(val)` | Yes | Yes | Yes | 赋值 `val`（返回 `void`） |
| `a.load()` | Yes | Yes | Yes | 返回数值 `a` 的旧值（`copy`） |
| `a.exchange(val)` | Yes | Yes | Yes | 赋值 `val` 并返回 `a` 的拷贝 |
| `a.compare_exchange_strong(exp, des)` | Yes | Yes | Yes | CAS 操作（见下） |
| `a.compare_exchange_weak(exp, des)` | Yes | Yes | Yes | Weak CAS 操作 |
| `a = val` | Yes | Yes | Yes | 赋值并返回 `val` 的拷贝（`copy`） |
| `a.operator atomic()` | Yes | Yes | Yes | 返回数值 `a` 的拷贝（`copy`） |
| `a.fetch_add(val)` |  | Yes | Yes | 不可切割之 `t+=val`（返回新值的拷贝） |
| `a.fetch_sub(val)` |  | Yes | Yes | 不可切割之 `t-=val`（返回新值的拷贝） |
| `a += val` |  | Yes | Yes | 等同于 `t.fetch_add(val)` |
| `a -= val` |  | Yes | Yes | 等同于 `t.fetch_sub(val)` |
| `++a, a++` |  | Yes | Yes | 调用 `t.fetch_add(1)` 并返回 `a` 或 `a+1` 的拷贝 |
| `--a, a--` |  | Yes | Yes | 调用 `t.fetch_sub(1)` 并返回 `a` 或 `a-1` 的拷贝 |
| `a.fetch_and(val)` |  |  | Yes | 不可切割之 `a&=val`（返回新值的拷贝） |
| `a.fetch_or(val)` |  |  | Yes | 不可切割之 `a\|=val`（返回新值的拷贝） |
| `a.fetch_xor(val)` |  |  | Yes | 不可切割之 `a^=val`（返回新值的拷贝） |
| `a &= val` |  |  | Yes | 等同于 `a.fetch_and(val)` |
| `a \|= val` |  |  | Yes | 等同于 `a.fetch_or(val)` |
| `a ^= val` |  |  | Yes | 等同于 `a.fetch_xor(val)` | 

（注：`triv type` 可理解为“ trivial type（简单类型，如基础原子类型 ）”，`int type` 对应整型相关原子类型，`ptr type` 对应指针类型的原子特化 ，表格描述反映了 C++ 中 `std::atomic` 各类操作在不同特化场景下的支持情况和功能 。 ）

举个例子，atomic＜int＞之内声明了以下赋值操作：
```cc
namespace std {
    // specialization of std::atomic<> for int:
    template<> struct atomic<int> {
    public:
        // ordinary assignment operators are not provided:
        atomic& operator=(const atomic&) = delete;
        atomic& operator=(const atomic&) volatile = delete;
        // but assignment of an int is provided, which yields the passed argument:
        int operator=(int) volatile noexcept;
        int operator=(int) noexcept;
        ...
    };
}
```

借由is_lock_free（），你可以检查atomic类型内部是否由于使用lock才成为atomic。如果不是，你的硬件就是拥有对atomic操作的固有支持（那是“在signal handler内使用atomic”的一个必要条件）。

compare_exchange_strong（） 和 compare_exchange_weak（） 都是所谓 compare-and-swap （CAS）操作。CPU 常常提供这个atomic 操作用以比较“某内存区内容”和“某给定值”，并且唯有在它们相同时才将该内存区内容更新为另一给定的新值。这可保证新值乃根据最新信息计算出来。这样的效果有点像以下伪码（pseudocode）：
```cc
bool compare_exchange_strong (T& expected, T desired)
{
    if (this->load() == expected) {
        this->store(desired);
        return true;
    }
    else {
        expected = this->load();
        return false;
    }
}
```

因此，如果数值就在这一段时间里被另一线程更新，它会返回false并以expected承载新值。

上述两种形式中，weak形式有可能出现假失败（spuriously fail），亦即期望值出现它仍然返回false。但是weak形式有时候比strong形式更高效。

### Atomic的C-Style接口
针对C++的atomic提案，C有一份对应提案，它应该提供相同语义但是（当然）不使用诸如template、reference和member function等C++特性。整个atomic接口有一个C-style对等品，成为C standard的一份扩充。

例如，你可以声明atomic_bool取代atomic＜bool＞，并替换store（）和load（），改用global函数，后者接受一个pointer指向对象：
```cc
std::atomic_bool ab;                  // equivalent to: std::atomic<bool> ab
std::atomic_init(&ab, false);         // see 18.7.1 节第 1013 页

std::atomic_store(&ab, true);         // equivalent to: ab.store(true)

if (std::atomic_load(&ab)) {          // equivalent to: if (ab.load())
    ...
}
```

然而C另有一个接口，采用_Atomic和_Atomic（），因此C-style接口一般只用于“需要在C和C++之间保持兼容”的代码身上。

然而在C++中使用C-style atomic类型并不罕见。表18.12列出了最重要的atomic类型名称，除此之外还有更多，适用于较不常见的类型，例如atomic_int_fast32_t乃是针对atomic＜int_fast32_t＞。

针对shared pointer （见5.2.1 节第76 页）还提供了特殊的atomic 操作。原因是诸如atomic＜shared_ptr＜T＞＞这样的声明不被允许，因为shared pointer并非可被复制（copyable）。Atomic操作遵循C-style接口的命名规范（naming convention）。详见5.2.4节第96页。

### Atomic的低层接口
Atomic低层接口意味着使用atomic操作时不保证顺序一致性（sequential consistency）。因此编译器和硬件有可能（局部）重排对atomic的处理次序（见18.4.3节第986页）。

再请小心：虽然我给了一个实例，本区域仍然地雷重重。你需要很多专家经验才能知道何时值得在内存重排（memory reordering）上花心力——即便是专家对此也常常犯错。[27]

任何使用此低层特性的专家都应该熟悉[N2480：MemMod]和[BoehmAdve：MemMod]所提及的材料，或[Boehm：C++MM]列出的所有材料。

表18.12 若干已有确切名称的std：：atomic＜＞类型
| 已确切命名的类型 | 对应的类型 |
| ---- | ---- |
| atomic_bool | atomic<bool> |
| atomic_char | atomic<char> |
| atomic_schar | atomic<signed char> |
| atomic_uchar | atomic<unsigned char> |
| atomic_short | atomic<short> |
| atomic_ushort | atomic<unsigned short> |
| atomic_int | atomic<int> |
| atomic_uint | atomic<unsigned int> |
| atomic_long | atomic<long> |
| atomic_ulong | atomic<unsigned long> |
| atomic_llong | atomic<long long> |
| atomic_ullong | atomic<unsigned long long> |
| atomic_char16_t | atomic<char16_t> |
| atomic_char32_t | atomic<char32_t> |
| atomic_wchar_t | atomic<wchar_t> |
| atomic_intptr_t | atomic<intptr_t> |
| atomic_uintptr_t | atomic<uintptr_t> |
| atomic_size_t | atomic<size_t> |
| atomic_ptrdiff_t | atomic<ptrdiff_t> |
| atomic_intmax_t | atomic<intmax_t> |
| atomic_uintmax_t | atomic<uintmax_t> |

#### Atomic低层接口实例

考虑18.7.1节第1014页介绍过的第二个atomic运用范例，那里我们声明了一个atomic flag，用来控制对某些数据的处理：
```cc
long data;
std::atomic<bool> readyFlag(false);
```

另有一个线程负责供应数据：
```cc
// provide some data
data = 42;

// and signal readiness
readyFlag.store(true);
```

还有一个线程负责消费此数据：
```cc
while (!readyFlag.load()) {  // loop until ready
    ...
}
std::cout << data << std::endl;
```

我们使用默认的内存处理次序（default memory order），于是保证顺序一致性（sequential consistency），以上将如同18.7.1节第1015页所描述地运行。事实上，我们真正调用的是：
```cc
data = 42;
readyFlag.store(true, std::memory_order_seq_cst);
```

和
```cc
while (!readyFlag.load(std::memory_order_seq_cst)) {
    ...
}
std::cout << data << std::endl;
```

也就是说，上述操作都有一个可有可无的实参用来指定内存次序（memory order），默认实参值是std：：memory_order_seq_cst（代表sequential consistent memory order）。

如果指定另一种内存处理次序（memory order），我们就可以削弱（weaken）对次序的保证，在我们的例子中这就足以（例如）要求provider（数据供应者）不推迟atomic store之后的操作（not delay operations past the atomic store），而consumer（数据消费者）不会在atomic load之后带来向前操作（not bring forward operations following the atomic load）：
```cc
data = 42;
readyFlag.store(true, std::memory_order_release);
```

和
```cc
while (!readyFlag.load(std::memory_order_acquire)) {
    ...
}
std::cout << data << std::endl;
```

然而如果放宽（relaxing）atomic操作次序上的所有约束，会导致不明确的行为：
```cc
// error 不明确行为
data = 42;
readyFlag.store(true, std::memory_order_relaxed);

```

原因是 std：：memory_order_relaxed 不保证此前所有内存操作（all prior memory opera-tions）在store发挥效用前都变得“可被其他线程看见”。因此provider线程有可能在设置ready flag之后才写 data，于是consumer线程有可能在 data正被写时读它，这就会造成data race。

你也可以让data成为atomic并以std：：memory_order_relaxed作为内存次序：
```cc
std::atomic<long> data(0);
std::atomic<bool> readyFlag(false);

// providing thread:
data.store(42, std::memory_order_relaxed);
readyFlag.store(true, std::memory_order_relaxed);

// consuming thread:
while (!readyFlag.load(std::memory_order_relaxed)) {
    ...
}
std::cout << data.load(std::memory_order_relaxed) << std::endl;
```


严格地说，这并非不明确行为（undefined behavior），因为我们并未遭遇data race。然而这却也难以如预期般地运作，因为 data的结果值有可能（尚还）不是42（memory order对此仍无保证）。其行为会导致data拥有一个无法具体说明的值（unspecified value）。

只有当我们在atomic变量上的读/写动作彼此独立，memory_order_relaxed才能显出用途。例如一个global计数器，不同的线程可能会对它累加或递减，而我们只需在所有线程终结之后获得该计数器的最终值即可。

低层操作概览

表18.13列出了atomic低层操作的补充材料。如你所见，load、store、exchange、CAS及fetch等操作提供了一个增补能力：它们允许你额外传递一个内存次序（memory order）实参。

表18.13 Atomic低阶操作补充


另有若干函数被额外提供出来，用以手动控制内存访问。例如atomic_thread_fence（）和 atomic_signal_fence（） 被用来手动编写 fence，那是“内存访问重安排”（memory-access reordering）的界线。

没有更多细节

我不打算更详细解释这些低层接口，因为它们是为真正的并发（concurrency）专家或想成为专家的人准备的。

一个良好出发点是Anthony Williams的著作C++Concurrency in Action（见[Williams：C++Conc]），尤其是第5和第7章。另一个起点是Hans Boehm的一系列URL，都是关于内存模型（memory model）的文章（见[Boehm：C++MM]）。
