# 基础

## const 和基础类型
const 修饰的变量必须初始化
```cc
const int a = 10;
const int b;      // ERROR
```
## const 和指针

```cc
int a;
// 常量指针：(*p) 为 const
const int *p1 = &a;
int const *p1 = &a;

// 指针常量: p 为const
int * const p2 = &a;
```

## C和C++中对const修饰变量的核心差异

### C语言中的const特性
- 本质是只读变量
  - C语言中const修饰的变量称为“常变量”，其值在运行时确定。虽然语法上禁止直接修改，但可以通过指针间接修改其内存中的值。
- 编译处理方式
  - C的const变量在汇编层面仍被视为普通变量，编译器不会进行常量替换优化。即使声明为const，其地址仍可被获取，且允许通过指针修改。
- 应用限制
  - 不能用于定义数组长度（如`int arr[a]`会报错）。
  - 不能作为switch语句的常量表达式。

### C++中的const特性
C++的const行为取决于初始化方式，分为两种情况：

1. 用常量初始化时（编译时常量）
```c
const int a = 10; // 编译时确定了常量的值
int *p = (int *)&a;
*p = 30;  // p的确指向了符号a对应的内存空间，并进行了修改

cout << "*p : " << *p << endl; // 30
cout << "a : " << a << endl;  // 10      // 直接替换常量
cout << "*&a : " << *&a << endl; // 10   // 直接替换常量
// &a 和 p 的值都为变量a的地址
cout << "&a : " << &a << endl; // &a
cout << "p : " << p << endl;   // &a

```
行为类似宏替换, 是真正的常量
编译器直接将a替换为字面值10，不会为其分配内存（除非取地址操作触发临时内存分配）。
示例中，`cout << a`被优化为`cout << 10`，因此即使通过指针修改内存，a的输出仍为10，而*p显示修改后的值30。

严格常量性
无法通过非const指针直接指向const变量（需强制类型转换），且修改临时内存不影响符号表中的常量值。

汇编探究
```asm
	const int a = 10;
  1c:	mov	r3, #10
  20:	str	r3, [fp, #-20]	; 0xffffffec  // 初始化栈变量 a = 10
	int *pa = (int *)&a;
  24:	sub	r3, fp, #20       // 取a的地址
  28:	str	r3, [fp, #-16]     // 将a的地址赋值给pa
	int b;

	*pa = 20;
  2c:	ldr	r3, [fp, #-16]    // 取pa的值
  30:	mov	r2, #20           
  34:	str	r2, [r3]          // 设置 pa指向的内存，为20

	b = a;                    // *****
  38:	mov	r3, #10           // 常量a，直接赋值给b
  3c:	str	r3, [fp, #-12]
	b = *pa;
  40:	ldr	r3, [fp, #-16]
  44:	ldr	r3, [r3]
  48:	str	r3, [fp, #-12]
```

2. 用变量初始化时（运行时常量）
```c
int b = 10;
const int a = b;   // 运行时确定常量的值
int *p = (int *)&a;
*p = 30;
printf("%d", a);   // 30   可以通过指针间接修改
printf("%d", *p);  // 30
```
退化为C风格的只读变量, 也称常变量
此时a的值在运行时确定，行为与C语言一致。通过指针修改其内存后，a和*p均输出30。

内存分配
编译器会为a分配内存空间，且允许通过指针间接修改（尽管语法上不建议）。

### 关键差异总结
| 特性         | C语言                     | C++（常量初始化时）               |
|--------------|--------------------------|----------------------------------|
| 本质         | 运行时只读变量            | 编译时常量（可能触发宏替换）      |
| 内存分配     | 始终分配内存              | 无内存分配（除非取地址操作）      |
| 指针修改     | 允许通过指针间接修改      | 修改临时内存，不影响常量值        |
| 类型安全     | 弱（允许const到非const转换） | 强（需显式强制类型转换）          |
| 应用场景     | 无法用于数组长度等常量表达式 | 可替代#define定义常量             |
# 高级

## 左值右值

### 左值（Lvalue）
- 定义
  - 左值指具有明确内存地址的表达式，通常可以出现在赋值运算符=的左侧。其名称中的"L"最初表示"Left"，但更准确的理解是"Location"（可寻址）。
- 核心特性
  - 可寻址：可通过&运算符获取地址（如&a）。
  - 持久性：生命周期较长，如变量、对象或数组元素。
  - 可修改性：非const左值可被赋值（如a = 10）。

### 右值（Rvalue）
- 定义
  - 右值指临时数据或无法寻址的表达式，通常出现在赋值运算符右侧。其名称中的"R"可理解为"Read"（仅可读）或"Register"（可能存储在寄存器中）。
- 核心特性
  - 不可寻址：无法通过&获取地址（如&(a + b)会报错）。
  - 临时性：生命周期短暂，如字面量或表达式结果。
  - 不可修改：不能直接赋值（如10 = a无效）。
- 常见示例
  - 字面量：int x = 5;中的5。
  - 算术表达式结果：a + b。
  - 函数返回非引用值：int func()的返回值。
  - 临时变量

#### 临时变量为右值的示例
```c
string func() { return string("aaa"); } 
```
按值返回的临时对象
该函数通过 `return string("aaa")` 按值返回一个临时构造的 `string` 对象。根据 C++ 的规则，传值返回的函数会生成一个临时对象，而临时对象属于右值。
右值的定义与特性
右值表示临时对象或无法取地址的值（如字面量、表达式结果等）。此处的 `string("aaa")` 是一个显式构造的临时对象，其生命周期仅限于函数返回时生成的临时对象，无法通过取地址操作获取其内存位置。

```c
auto&& r1 = func();  // 合法：右值引用可以绑定到右值
string s1 = func();  // 合法：右值用于初始化对象（可能触发移动构造）
string& s2 = func(); // 非法：左值引用不能绑定到右值
```
该函数的返回值是右值，适用于移动语义优化场景（如被右值引用接收或触发移动构造函数）。


## const和右值
### 左值const引用/指针绑定右值
```cc
`int * const &p = (int *)0x00000000; ` 
```
引用类型：`int * const &` 表示一个对常量指针的引用（即 p 是`int * const` 类型的别名）。
右值绑定：右侧的 `(int *)0x00000000` 是一个右值（临时指针），而C++允许常量左值引用（const &）绑定到右值，这是语言规则的特殊设计。
匿名变量生成：由于右值本身没有内存地址，编译器会隐式创建一个匿名栈变量来存储 0x00000000，然后将引用 p 绑定到此匿名变量。

```c
// 以下示例都是常引用，都会生成临时对象

// 引用非指针类型时，const int和 int const语义相同，const都是修饰 b 本身
const int &b = 0;
int const &b = 0;

// 引用指针类型时，const int *和 int *const语义不相同
int *const &a = (int *)0x0;
```
### 匿名变量的实现原理
```cc
int * const &p = (int *)0x00000000;
// mov    r3, #0
// str    r3, [fp, #-20]    ; 初始化匿名变量: 将0存入匿名变量（地址为fp-20）
// sub    r3, fp, #20       ; 获取匿名变量地址
// str    r3, [fp, #-16]    ; 将匿名变量的地址存入引用p（p位于fp-16）

*p = 0;
// ldr    r3, [fp, #-16]    ; 第一次解引用：获取p的值（即匿名变量地址）
// ldr    r3, [r3]          ; 第二次解引用：获取匿名变量的值（即0x00000000）
// mov    r2, #0
// str    r2, [r3]          ; 将0写入匿名变量指向的内存

int *a = p;
// ldr    r3, [fp, #-16]    ; 获取p的值（匿名变量地址）
// ldr    r3, [r3]          ; 获取匿名变量的值（0x00000000）
// str    r3, [fp, #-12]    ; 将值赋给指针a
```

## const绑定的常见错误

示例1：
```c
int a = 10;
int* const p = &a;  // p是常量指针（指针不可变，指向的值可变）
int* &q = p;        // 错误！无法将int* const*绑定到int**上
                    // 错误原因：p是顶层const（指针本身不可变），而q是非常量引用，无法绑定到常量对象。
// 正确做法：
int* const &q = p;  // 正确：引用必须同样包含顶层const
```
示例2：
```c
int a = 10;
const int* p = &a;  // p是底层const（指向的值不可变）
int*& q = p;        // 错误！无法将const int**绑定到int**上
                    // 错误原因：p的底层const属性要求引用必须同样包含底层const。
// 正确做法：
const int*& q = p;  // 正确：引用必须匹配底层const
```
示例3：
```c
int* p = &a;

// 错误
// 原因: 希望获得对指针p指向空间的只读属性，但是可以修改指针本身，这样是容易出bug的
// p 是 int* 类型（指向非常量整型的指针），而 q 是 const int*& 类型（指向常量整型的指针的引用）。C++不允许将非 const 指针的引用直接绑定到 const 指针上，因为这可能导致通过非 const 指针间接修改 const 数据，破坏类型安全性
// 虽然 int* 可以隐式转换为 const int*（即允许将非常量指针赋值给指向常量的指针），但这种转换仅适用于指针本身，不适用于指针的引用。引用的类型必须严格匹配，否则会破坏引用的“别名”特性。
const int* &q = p;
  
// 正确
// 获得指针本身的只读属性
int* const &q = p;  
// 获得指针本身的只读属性和指向空间的只读属性
// 双重 const 确保了类型安全，但此时 qq 只能作为只读指针的只读引用使用。
const int* const &q = p;  
```
### 扩展思考
右值引用与移动语义
在C++11后，通过&&右值引用可以安全绑定到临时对象，但需注意与const引用的区别。
智能指针的const应用
`std::unique_ptr<const T>`表示指向常量对象的独占指针，比原始指针更安全。

