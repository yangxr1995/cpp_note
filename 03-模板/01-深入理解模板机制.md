# 基础
## 函数模板

## 类模板
### 类模板的特化
你可以用模板实参来特化类模板。和函数模板的重载类似，通过特化类模板，你可以优化基于某种特定类型的实现，或者克服某种特定类型在实例化类模板时所出现的不足。
另外，如果要特化一个类模板，你还要特化该类模板的所有成员函数。虽然也可以只特化某个成员函数，但这个做法并没有特化整个类，也就没有特化整个类模板。

为了特化一个类模板，你必须在起始处声明一个 `template<>`，接下来声明用来特化类模板的类型。这个类型被用作模板实参，且必须在类名的后面直接指定：

```cc
template<>
class Stack<std::string> {
...
}
```
进行类模板的特化时，每个成员函数都必须重新定义为普通函数，原来模板函数中的每个T也相应地被进行特化的类型取代：
```cc
void Stack<std::string>::push (std::string const& elem)
{
    elems.push_back(elem);　 //附加传入实参elem的拷贝
}
```
下面是一个用std::string特化Stack<>的完整例子：
```cc

//basics/stack2.hpp
#include <deque>
#include <string>
#include <stdexcept>
#include "stack1.hpp"

template<>
class Stack<std::string> {
    private:
        std::deque<std::string> elems;　　// 包含元素的容器
    public:
        void push(std::string const&);　　// 压入元素
        void pop();　　　　　　　　　　　　// 弹出元素
        std::string top() const;　　　　　 // 返回栈顶元素
        bool empty() const {　　　　　　　 // 返回栈是否为空
            return elems.empty();
        }
};
void Stack<std::string>::push (std::string const& elem)

{

elems.push_back(elem);　 // 把传入的实参elem附加到末端

}

void Stack<std::string>::pop ()
{
    if (elems.empty()) {
        throw std::out_of_range
        ("Stack<std::string>::pop(): empty stack");
    }
    elems.pop_back();　　　　// 删除末端元素
}

std::string Stack<std::string>::top () const
{
    if (elems.empty()) {
        throw std::out_of_range
        ("Stack<std::string>::top(): empty stack");
        }
    return elems.back();　　 // 返回末端元素的拷贝
}
```

### 局部特化
类模板可以被局部特化。你可以在特定的环境下指定类模板的特定实现，并且要求某些模板参数仍然必须由用户来定义。例如类模板：
```cc

template <typename T1, typename T2>
class MyClass {
    ...
};
```

就可以有下面几种局部特化：
```cc
//局部特化：两个模板参数具有相同的类型
template <typename T>
class MyClass<T,T> {
    ...
};
//局部特化：第2个模板参数的类型是int
template<typename T>
class MyClass<T,int> {
    ...
};
//局部特化：两个模板参数都是指针类型。
template<typename T1,typename T2>
class MyClass<T1*,T2*>{
    ...
};
```

下面的例子展示各种声明会使用哪个模板：
```cc
Myclass<int,float> mif;　　　//使用MyClass<T1,T2>
MyClass<float,float> mff;　　//使用MyClass<T,T>
MyClass<float,int>　 mfi;　　 //使用MyClass<T,int>
MyClass<int*,float*> mp;　　 //使用MyClass<T1*,T2*>
```
如果有多个局部特化同等程度地匹配某个声明，那么就称该声明具有二义性：
```cc
MyClass<int,int> m;　　　//错误:同等程度地匹配MyClass<T,T>
//　　　 和MyClass<T,int>
MyClass<int*,int*> m;　　//错误:同等程度地匹配MyClass<T,T>
//　　　 和MyClass<T1*,T2*>
```
为了解决第2种二义性，你可以另外提供一个指向相同类型指针的特化：
```cc
template<typename T>
class MyClass<T*,T*> {
    ...
};
```


### 缺省模板实参
对于类模板，你还可以为模板参数定义缺省值；这些值就被称为缺省模板实参；而且，它们还可以引用之前的模板参数。
例如，在类 Stack<>中，你可以把用于管理元素的容器定义为第2个模板参数，并且使用std::vector<>作为它的缺省值：

```cc
//basics/stack3.hpp
#include <vector>
#include <stdexcept>

template <typename T, typename CONT = std::vector<T> >
class Stack {
    private:
        CONT elems;　　　　　　　 // 包含元素的容器
    public:
        void push(T const&);　　　// 压入元素
        void pop();　　　　　　　 // 弹出元素
        T top() const;　　　　　　// 返回栈顶元素
        bool empty() const {　　　// 返回栈是否为空
            return elems.empty();
        }
};

template <typename T, typename CONT>
void Stack<T,CONT>::push (T const& elem)
{
    elems.push_back(elem);　　// 把传入实参elem附加到末端
}

template <typename T, typename CONT>
void Stack<T,CONT>::pop ()
{
    if (elems.empty()) {
        throw std::out_of_range("Stack<>::pop(): empty stack");
    }
    elems.pop_back();　　　　 // 删除末端元素
}

template <typename T, typename CONT>
T Stack<T,CONT>::top () const
{
    if (elems.empty()) {
        throw std::out_of_range("Stack<>::top(): empty stack");
    }
    return elems.back();　　 // 返回末端元素的拷贝
}
```
可以看到：我们的类模板含有两个模板参数，因此每个成员函数的定义都必须具有这两个参数：
```cc
template <typename T,typename CONT>
void Stack<T,CONT>::push(T const& elem)
{
    elems.push_back(elem);　 //附加传入实参elem的拷贝
}
```
你仍然可以像前面例子一样使用这个栈（stack）；就是说，如果你只传递第一个类型实参给这个类模板，那么将会利用vector来管理stack的元素：
```cc
template<typename T,typename CONT = std::vector<T> >
class Stack {
    private:
        CONT elems;　　　//包含元素的容器
        ...
};
```
另外，当在程序中声明Stack对象的时候，你还可以指定容器的类型：
```cc
//basics/stack3test.cpp
#include <iostream>
#include <deque>
#include <cstdlib>
#include "stack3.hpp"

int main()
{
    try {
        // int栈:
        Stack<int> intStack;
        // double栈，它使用std::deque来管理元素
        Stack<double,std::deque<double> > dblStack;
        // 使用int栈
        intStack.push(7);
        std::cout << intStack.top() << std::endl;
        intStack.pop();
        // 使用double栈
        dblStack.push(42.42);
        std::cout << dblStack.top() << std::endl;
        dblStack.pop();
        dblStack.pop();
    }
    catch (std::exception const& ex) {
        std::cerr << "Exception: " << ex.what() << std::endl;
        return EXIT_FAILURE; // 退出程序，且有ERROR标记
    }
}
```
使用
```cc
Stack<double,std::deque<double> >
```
你可以声明一个“元素类型为double，并且使用std::deque<>在内部管理元素”的栈。


## 非类型模板参数
对于函数模板和类模板，模板参数并不局限于类型，普通值也可以作为模板参数。在基于类型参数的模板中，你定义了一些具体细节未加确定的代码，直到代码被调用时这些细节才被真正确定。
然而，在这里，我们面对的这些细节是值（value），而不是类型。当要使用基于值的模板时，你必须显式地指定这些值，才能够对模板进行实例化，并获得最终代码。

### 非类型的类模板参数
较之前一章stack例子的实现，你也可以使用元素数目固定的数组来实现stack。这个方法（用固定大小的数组）的优点是：无论是由你来亲自管理内存，还是由标准容器来管理内存，都可以避免内存管理开销。然而，决定一个栈（stack）的最佳容量是很困难的。如果你指定的容量太小，那么栈可能会溢出；如果指定的容量太大，那么可能会不必要地浪费内存。一个好的解决方法就是：让栈的用户亲自指定数组的大小，并把它作为所需要的栈元素的最大个数。

为了做到这一点，你需要把数组大小定义为一个模板参数：
```cc
//basics/stack4.hpp
#include <stdexcept>
template <typename T, int MAXSIZE>
class Stack {
    private:
        T elems[MAXSIZE];　　　 // 包含元素的数组
        int numElems;　　　　　// 元素的当前总个数
    public:
        Stack();　　　　　　　　// 构造函数
        void push(T const&);　 // 压入元素
        void pop();　　　　　　 // 弹出元素
        T top() const;　　　　　// 返回栈顶元素
        bool empty() const {　 // 返回栈是否为空
            return numElems == 0;
        }
        bool full() const {　　// 返回栈是否已满
            return numElems == MAXSIZE;
        }
};

// 构造函数
template <typename T, int MAXSIZE>
Stack<T,MAXSIZE>::Stack ()
: numElems(0)　　　　　　 // 初始时栈不含元素
{
    // 不做任何事情
}

template <typename T, int MAXSIZE>
void Stack<T,MAXSIZE>::push (T const& elem)
{
    if (numElems == MAXSIZE) {
        throw std::out_of_range("Stack<>::push(): stack is full");
    }
    elems[numElems] = elem;　 // 附加元素
    ++numElems;　　　　　　 // 增加元素的个数
}

template<typename T, int MAXSIZE>
void Stack<T,MAXSIZE>::pop ()
{
    if (numElems <= 0) {
        throw std::out_of_range("Stack<>::pop(): empty stack");
    }
    --numElems;　　　　　　 // 减少元素的个数
}

template <typename T, int MAXSIZE>
T Stack<T,MAXSIZE>::top () const
{
    if (numElems <= 0) {
        throw std::out_of_range("Stack<>::top(): empty stack");
    }
    return elems[numElems-1];　// 返回最后一个元素
}
```

MAXSIZE是新加入的第2个模板参数，类型为int；它指定了数组最多可包含的栈元素的个数：
```cc
template<typename T, int MAXSIZE>
class Stack {
    private:
        T elems[MAXSIZE];　　//包含元素的数组
        ...
};
```
另外，我们使用push()来检查该栈是否已经满了：
```cc
template <typename T, int MAXSIZE>
void Stack<T, MAXSIZE>::push (T const& elem)
{
    if (numElems = = MAXSIZE ){
        throw std::out_of_range ("Stack<>::push():stack is full")
    }
    elems [numElems] = elem;　//附加元素
    ++numElems;　　　　　　　 //增加元素的个数
}
```
为了使用这个类模板，你需要同时指定元素的类型和个数（即栈的最大容量）：
```cc
//basics/stack4test.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include "stack4.hpp"

int main()
{
    try {
        Stack<int,20>　int20Stack;　// 可以存储20个int元素的栈
        Stack<int,40>　int40Stack;　// 可以存储40个int元素的栈
        Stack<std::string,40> stringStack; // 可存储40个string元素的栈
        // 使用可存储20个int元素的栈
        int20Stack.push(7);
        std::cout << int20Stack.top() << std::endl;
        int20Stack.pop();
        // 使用可存储40个string的栈
        stringStack.push("hello");
        std::cout << stringStack.top() << std::endl;
        stringStack.pop();
        stringStack.pop();
    }
    catch (std::exception const& ex) {
        std::cerr << "Exception: " << ex.what() << std::endl;
        return EXIT_FAILURE; // 退出程序且有ERROR标记
    }
}
```
可以看出，每个模板实例都具有自己的类型，因此 int20Stack 和 int40Stack 属于不同的类型，而且这两种类型之间也不存在显式或者隐式的类型转换；所以它们之间不能互相替换，更不能互相赋值。
同样，我们可以为模板参数指定缺省值：
```cc
template<typename T = int, int MAXSIZE = 100>
class Stack {
    ...
};
```
然而，如果从优化设计的观点来看，这个例子并不适合使用缺省值。缺省值应该是直观上正确的值。但是对于栈的类型和大小而言，int类型和最大容量100从直观上看起来都不是正确的。因此，在这里最好还是让程序员显式地指定这两个值。因此我们可以在设计文档中用一条声明来说明这两个属性（即类型和最大容量）。

### 非类型的函数模板参数
你也可以为函数模板定义非类型参数。例如，下面的函数模板定义了一组用于增加特定值的函数：
```cc
//basics/addval.hpp
template<typename T, int VAL>
T addValue(T const& x)
{
    return x + VAL;
}
```
如果需要把函数或者操作用作参数的话，那么这类函数就是相当有用的。譬如，借助于标准模板库（STL），你可以传递这个函数模板的实例化体给集合中的每一个元素，让它们都增加一个整数值：
```cc
std::transform (source.begin(), source.end(), //源集合的起点
//和终点
dest.begin(),　　　　　　　　　//目标集合的起点
addValue<int,5>);　　　　　　　//操作（或者函数）
```
在上面的调用中，最后一个实参实例化了函数模板addValue()，它让int元素增加5。源集合source中的每一个元素都会调用实例化后的addValue()函数，并把调用结果放入目标集合dest。
另一方面，这个例子有一个问题：addValue<int,5>是一个函数模板实例，而函数模板实例通常被看成是用来命名一组重载函数的集合（即使该组只有一个函数）。然而，根据现今的标准，重载函数的集合并不能被用于模板参数的演绎。

于是，你必须将这个函数模板的实参强制类型转换为具体的类型：
```cc
std::transform (source.begin(), source.end(), //源集合的起点
//和终点
dest.begin(),　　　　　　　　 //目标集合的起点
(int(*)(int const&)) addValue<int,5>);　　//操作
```
现在有一个提议，建议C++标准解决这个问题，从而在这种情况下不需要进行强制类型转换（细节请见[CoreIssue115]）。如果这个提议被通过的话，那么只有在考虑可移植性的情况下，才需要使用这种强制转型。


### 非类型模板参数的限制
我们还应该知道：非类型模板参数是有限制的。通常而言，它们可以是常整数（包括枚举值）或者指向外部链接对象的指针。

浮点数和类对象（class-type） 是不允许作为非类型模板参数的：

```cc
template<double VAT>　　 //ERROR:浮点数不能作为非类型模板参数
double process (double v)
{
    return v * VAT;
}

template<std::string name>　 //ERROR:类对象不能作为非类型模板参数
class MyClass {
    ...
};
```
之所以不能使用浮点数（包括简单的常量浮点表达式）作为模板实参是有历史原因的。然而，该特性的实现并不存在很大的技术障碍；因此，将来的C++版本可能会支持这个特性。
由于字符串文字是内部链接对象（因为两个具有相同名称但处于不同模块的字符串，是两个完全不同的对象），所以你不能使用它们来作为模板实参：
```cc
template<char const* name>
class MyClass {
};

MyClass<”hello”> x;　　　//ERROR:不允许使用字符串文字”hello”
```
另外，你也不能使用全局指针作为模板参数：
```cc
template <char const* name>
class MyClass {
};

char const* s = ”hello”;
MyClass<s> x;　　　　　　//s是一个指向内部链接对象的指针
```

然而，你可以这样使用：
```cc
template <char const* name>
class MyClass {
};

extern char const s[] = ”hello”;
MyClass<s> x;　　　　//OK
```
全局字符数组s由“hello”初始化，是一个外部链接对象。


## 技巧性基础知识
本章给出模板的一些更深入的基础知识，它们都是和模板的实际应用密切相关的，包括关键字 typename 的另一种用法、把成员函数和嵌套类也定义成模板、模板的模板参数（template template parameters）、零初始化和使用字符串作为模板实参时所要注意的一些细节。

### 关键字typename
在C++标准化过程中，引入关键字typename是为了说明：模板内部的标识符可以是一个类型。譬如下面的例子：
```cc
template <typename T>
class MyClass {
    typename T::SubType * ptr;
    ...
};
```
上面程序中，第2个typename被用来说明：SubType是定义于类T内部的一种类型。因此，ptr是一个指向T::SubType类型的指针。
如果不使用typename，SubType就会被认为是一个静态成员，那么它应该是一个具体的变量或对象，于是，下面表达式：
```cc
T::SubType * ptr
```
会被看作是类T的静态成员SubType和ptr的乘积。
通常而言，当某个依赖于模板参数的名称是一个类型时，就应该使用typename。我们将在9.3.2小节详细讨论这个问题。
让我们来考虑一个typename的典型应用，即在模板代码中访问STL容器的迭代器：
```cc
//basics/printcoll.hpp
#include <iostream>

// 打印STL容器的元素
template <typename T>
void printcoll (T const& coll)
{
    typename T::const_iterator pos; // 用于迭代coll的迭代器
    typename T::const_iterator end(coll.end()); // 结束位置
    for (pos=coll.begin(); pos!=end; ++pos) {
        std::cout << *pos << ' ';
    }
    std::cout << std::endl;
}
```
在这个函数模板中，调用参数是一个T类型的STL容器。为了迭代容器中的所有元素，我们借助于迭代器类型；而在每个STL容器类中，都声明有迭代器类型const_iterator：

```cc
class stlcontainer {
    typedef ...iterator;　　　　 //可以读写访问的迭代器
    typedef ...　const_iterator;　//只能读访问的迭代器
    ...
};
```
因此，为了访问模板类型为T的const_iterator类型，你需要在声明开始处使用关键字typename来加以限定，如下：
```cc
typename T::const_iterator pos;
```

**.template**构造

我们在引入typename之后，发现了一个很相似的问题。考虑下面这个使用标准bitset类型的例子：

```cc
template <int N>
void printBitset (std::bitset<N> const& bs)
{
    std::cout<<bs.template to_string<char,char_traits<char>, allocator<char> >();
}
```
本例中有一个奇怪的构造：.template。如果没有使用这个template，编译器将不知道下列事实：
bs.template后面的小于号（<）并不是数学中的小于号，而是模板实参列表的起始符号；
那么只有在编辑器判断小于号（<）之前，存在依赖于模板参数的构造，才会出现这种问题。
在这个例子中，传入参数bs就是依赖于模板参数N的构造。

总之，只有当该前面存在依赖于模板参数的对象时，我们才需要在模板内部使用.template标记（和类似的诸如->template的标记），而且这些标记也只能在模板中才能使用。

### 使用this->
对于具有基类的类模板，自身使用名称x并不一定等同于this->x。即使该x是从基类继承获得的，也是如此。例如：
```cc
template <typename T>
class Base {
    public:
        void exit();
};

template <typename T>
class Derived : Base<T> {
    public:
        void foo() {
            exit();　　　//调用外部的exit()或者出现错误
        }
};
```
在这个例子中，在foo()内部决定要调用哪一个exit()时，并不会考虑基类Base中定义的exit()。因此，你如果不是获得一个错误，就是调用了另一个exit()。

我们将在9.4.2小节详细讨论这个问题。现在建议你记住一条规则：
对于那些在基类中声明，并且依赖于模板参数的符号（函数或者变量等），你应该在它们前面使用 `this->或者Base<T>::`。
如果希望完全避免不确定性，你可以（使用诸如`this->和Base<T>::`等）限定（模板中）所有的成员访问。

### 成员模板
类成员也可以是模板。嵌套类和成员函数都可以作为模板。我们可以通过一个 `Stack<>`类模板来说明这种（作为模板的）能力的优点和应用方法。
通常而言，栈之间只有在类型完全相同时才能互相赋值，其中类型指的是元素的类型。就是说，对于元素类型不同的栈，你不能对它们进行相互赋值，即使这两种（元素的）类型之间存在隐式类型转换。譬如：
```cc
Stack<int> intStack1, intStack2; //int栈
Stack<float> floatStack;　　　　　//float栈
...
intStack1 = intStack2;　　　 //OK:具有相同类型的栈
floatStack = intStack1;　　　//ERROR:两边栈的类型不同
```
缺省赋值运算符要求两边具有相同的类型，当元素类型不同时，两个栈的类型显然不同，不能符合缺省赋值运算符的要求。
然而，通过定义一个身为模板的赋值运算符，针对元素类型可以转换的两个栈就可以进行相互赋值。为了达到这个目的，你需要这样声明Stack<>：
```cc
//basics/stack5decl.hpp
template <typename T>
class Stack {
    private:
        std::deque<T> elems;　　　// 存储元素的容器
    public:
        void push(T const&);　　　// 压入元素
        void pop();　　　　　　　 // 弹出元素
        T top() const;　　　　　　// 返回栈顶元素
        bool empty() const {　　　// 返回栈是否为空
            return elems.empty();
        }

        // 使用元素类型为T2的栈进行赋值
        template <typename T2>
        Stack<T>& operator= (Stack<T2> const&);
};
```
在这里，我们进行了两处改动：
1.我们增加了一个赋值运算符的声明，它可以把元素类型为T2的栈赋值给原来的栈。
2.栈现在改用deque（队列）作为元素的内部容器。事实上，这是为了满足新赋值运算符实现的要求。

新赋值运算符的实现大致如下：
```cc
//basics/stack5 assign.hpp
template <typename T>
template <typename T2>
Stack<T>& Stack<T>::operator= (Stack<T2> const& op2)
{
    if ((void*)this == (void*)&op2) {　 //赋值给自身吗
        return *this;
    }

    Stack<T2> tmp(op2);　　　　　　// 产生一个赋值栈的拷贝
    elems.clear();　　　　　　　　 //删除现存的元素

    while (!tmp.empty()) {　　　　　// 拷贝所有的元素
        elems.push_front(tmp.top());
        tmp.pop();
    }

    return *this;
}
```
让我们先来看定义成员模板的语法，在定义有模板参数T的模板内部，还定义了一个含有模板参数T2的内部模板：
```cc
template <typename T>
template <typename T2>
...
```
在成员函数内部，你可能只需要访问赋值栈op2内部的一些数据，而没有必要再初始化另一个栈；然而，因为赋值栈和原栈具有不同的类型（如果你用两种类型来实例化同一个类模板，那么你将得到两种不同的新类型），所以你就不能使用栈本身所提供的公共接口。于是，唯一的办法就是调用top()，这样一来每个元素都必须要成为栈顶元素。因此，我们必须先创建一份op2的拷贝，然后调用拷贝的top()方法和pop()方法从该拷贝获取元素。由于top()返回最后一个入栈的元素，因此我们必须使用一个支持在（栈顶的）另一端插入元素的容器。基于这个原因，我们选择了deque，它提供了push_front（）方法，可以在集合的另一端插入元素。

实现了上面的成员模板之后，现在你就可以把一个int栈赋值给一个float栈：
```cc
Stack<int>　　　 intStack;　　　　//int栈
Stack<float>　　 floatStack;　　　//float栈
...
floatStack = intStack;　　　　　　//OK:虽然是具有不同类型的栈，
                                  //　但int可以转换为float
```
当然，这个赋值并没有改变原栈的类型和它所含元素的类型。在赋值以后，floatStack的元素仍然是float（浮点数）类型，因此它的top()依然返回一个浮点数。

这个赋值函数好像屏蔽了类型检查，看起来你可以用任意类型的栈来对目标栈进行赋值；但实际情况并非如此，类型检查仍然存在。
当源栈（的拷贝）的元素被移入到目标栈的时候，就要执行必要的类型检查，即类型检查发生在如下语句执行时：
```cc
elems.push_front(tmp.top());
```
例如，如果把一个字符串栈赋值给一个浮点数栈，那么编译器在这一行将会报告一个错误信息，说明tmp.top()返回的字符串不能作为elems.push_front()的实参（这个错误信息可能会根据编译器的不同而有所不同，但大体意思就是这样）：
```cc
Stack<std::string> stringStack;　　　 //std::string栈
Stack<float>　　 floatStack;　　　　　//float栈
...
floatStack = stringStack;　　　　　　 //ERROR:std::string并不能
                                      //转换为float
```
可以看到，模板赋值运算符并没有取代缺省赋值运算符。对于相同类型栈之间的赋值，仍然会调用缺省赋值运算符。
同样，在实现中，你可以把内部容器类型实现为一个模板参数；这样就有机会改变内部容器类型：
```cc
//basics/stack6decl.hpp
template <typename T, typename CONT = std::deque<T> >
class Stack {
    private:
        CONT elems;　　　　　　　 // 存储元素的容器
    public:
        void push(T const&);　　　// 压入元素
        void pop();　　　　　　　 // 弹出元素
        T top() const;　　　　　　// 返回栈顶元素
        bool empty() const {　　　// 返回栈是否为空
            return elems.empty();
        }
        // 把元素类型为T2的栈赋值给原栈
        template <typename T2, typename CONT2>
        Stack<T,CONT>& operator= (Stack<T2,CONT2> const&);
};
```
此时，模板赋值运算符的实现如下：
```cc
//basics/stack6assign.hpp
template <typename T, typename CONT>
template <typename T2, typename CONT2>
Stack<T,CONT>&
Stack<T,CONT>::operator= (Stack<T2,CONT2> const& op2)
{
    if ((void*)this == (void*)&op2) {　 // 赋值给自身吗
        return *this;
    }
    Stack<T2,CONT2> tmp(op2);　　　 // 产生一份赋值栈的拷贝
    elems.clear();　　　　　　　　 // 删除现存的所有元素
    while (!tmp.empty()) {　　　　　// 拷贝所有的元素
        elems.push_front(tmp.top());
        tmp.pop();
    }
    return *this;
}
```
需要再次提醒的是：对于类模板而言，只有那些被调用的成员函数才会被实例化。因此，如果在元素类型不同的栈之间没有进行相互赋值，你就可以使用vector来作为内部容器：
```cc
//使用vector作为内部容器的int栈
Stack<int,std::vector<int> > vStack;
...
vStack.push(42);
vStack.push(7);
std::cout << vStack.top() << std::endl;
```
因为自定义的模板赋值运算符并不是必不可少的，所以在不存在push_front()的情况下，某些程序并不会出现错误信息，而且也能正确运行。

> [!NOTE]
> 类成员定义为模板，相当于类模板嵌套函数模板

### 模板的模板参数
有时，让模板参数本身成为模板是很有用的，我们将继续以 stack 类模板作为例子，来说明模板的模板参数的用途。
在 stack 的例子中，如果要使用一个和缺省值不同的内部容器，程序员必须两次指定元素类型。也就是说，为了指定内部容器的类型，你需要同时传递容器的类型和它所含元素的类型。如下：
```cc
Stack<int,std::vector<int> > vStack; //使用vector的int栈
```
然而，借助于模板的模板参数，你可以只指定容器的类型而不需要指定所含元素的类型，就可以声明这个Stack类模板：
```cc
Stack<int,std::vector> vStack;　　　　　　//使用vector的int栈
```
为了获得这个特性，你必须把第2个模板参数指定为模板的模板参数。那么，stack的声明应该如下 ：
```cc
//basics/stack7.decl.hpp
template <typename T,
template <typename ELEM> class CONT = std::deque >
class Stack {
    private:
        CONT<T> elems;　　　　// 保存元素的容器
    public:
        void push(T const&);　// 压入元素
        void pop();　　　　　 // 弹出元素
        T top() const;　　　　// 返回栈顶元素
        bool empty() const {　// 返回栈是否为空
            return elems.empty();
        }
};
```
不同之处在于，第2个模板参数现在被声明为一个类模板：
```cc
template <typename ELEM> class CONT
```
缺省值也从`std::deque<T>`变成`std::deque`。在使用时，第2个参数必须是一个类模板，并且由第一个模板参数传递进来的类型进行实例化：
```cc
CONT<T> elems;
```
这也是这个例子比较特别的地方：使用第1个模板参数作为第2个模板参数的实例化类型。一般地，你可以使用类模板内部的任何类型来实例化模板的模板参数。
我们前面提过：作为模板参数的声明，通常可以使用typename来替换关键字class。
然而，上面的CONT是为了定义一个类，因此只能使用关键字class。因此，下面的程序是正确的：
```cc
template <typename T, template <class ELEM> class CONT = std::deque>
//正确
class Stack {
    ...
};
```
而下面的程序却是错误的：
```cc
template <typename T,
template <typename ELEM> typename CONT = std::deque>
class Stack {　　　　　　　　　　　　　　　//错误
    ...
};
```
由于在这里我们并不会用到“模板的模板参数”的模板参数（即上面的ELEM），所以你可以把该名称省略不写：
```cc
template <typename T,
template <typename> class CONT = std::deque >
class Stack {
    ...
};
```
另外，还必须对成员函数的声明进行相应的修改。你必须把第2个模板参数指定为模板的模板参数；这同样适用于成员函数的实现。例如，成员函数push()的实现如下：
```cc
template <typename T, template <typename> class CONT>
void Stack<T,CONT>::push (T const& elem)
{
    elems.push_back(elem);　　　 //把elem的拷贝附加到末端
}
```
还有一点需要知道：函数模板并不支持模板的模板参数。

> [!NOTE]
> 以上内容就是用 模板作为模板的参数，
> 以前是用类作为模板的参数，所以模板实例化时必须传递 `std::deque<T>`
> 现在使用模板作为模板参数，所以模板实例化时传递 `std::deque`
> 因为模板类定义 `CONT<T> elems` ，即使用第一个参数和第二个参数结合定义类的成员，所以调用者直接传递  `Stack<int, deque> s` 就可以成功实例化模板类。

### 模板的模板实参匹配

如果你尝试使用新版本的Stack，你会获得一个错误信息：缺省值std::deque和模板的模板参数CONT并不匹配。
对于这个结果，你或许会觉得很诧异，但问题在于：模板的模板实参（譬如这里的 std::deque）是一个具有参数 A 的模板，
它将替换模板的模板参数（譬如这里的CONT），而模板的模板参数是一个具有参数B的模板；
匹配过程要求参数A和参数B必须完全匹配；
然而在这里，我们并没有考虑模板的模板实参的缺省模板参数，从而也就使B中缺少了这些缺省参数值，当然就不能获得精确的匹配。

在这个例子中，问题在于标准库中的std::deque模板还具有另一个参数：
即第2个参数（也就是所谓的内存分配器allocator），它有一个缺省值，但在匹配std::deque的参数和CONT的参数时，我们并没有考虑这个缺省值。

然而，解决办法总是有的。我们可以重写类的声明，让CONT的参数期待的是具有两个模板参数的容器：
```cc
template <typename T,
    template <typename ELEM,
    typename ALLOC = std::allocator<ELEM> >
    class CONT = std::deque>
class Stack {
    private:
        CONT<T> elems;　　　 //保存元素的容器
        ...
};
```


同样，你可以略去ALLOC不写，因为实现中不会用到它。
现在，Stack模板（包括为了能够在不同元素类型的栈之间实现相互赋值而定义的成员模板）的最终版本应该如下：
```cc
//basics/stack8.hpp
#ifndef STACK_HPP
#define STACK_HPP

#include <deque>
#include <stdexcept>
#include <memory>

template <typename T,
template <typename ELEM,
typename = std::allocator<ELEM> >
class CONT = std::deque>
class Stack {
    private:
        CONT<T> elems;　　　　// 保存元素的容器
    public:
        void push(T const&);　// 压入元素
        void pop();　　　　　 // 弹出元素
        T top() const;　　　　// 返回栈顶元素
        bool empty() const {　// 返回栈是否为空
            return elems.empty();
        }

        // 使用元素类型为T2的栈对原栈赋值
        template<typename T2,
            template<typename ELEM2, typename = std::allocator<ELEM2>
            >class CONT2>
        Stack<T,CONT>& operator= (Stack<T2,CONT2> const&);
};

template <typename T, template <typename,typename> class CONT>
void Stack<T,CONT>::push (T const& elem)
{
    elems.push_back(elem);　 // 附加传入元素的拷贝
}

template<typename T, template <typename,typename> class CONT>
void Stack<T,CONT>::pop ()
{
    if (elems.empty()) {
        throw std::out_of_range("Stack<>::pop(): empty stack");
    }
    elems.pop_back();　　　　// 删除末端元素
}

template <typename T, template <typename,typename> class CONT>
T Stack<T,CONT>::top () const
{
    if (elems.empty()) {
        throw std::out_of_range("Stack<>::top(): empty stack");
    }
    return elems.back();　　 // 返回末端元素的拷贝
}

template <typename T, template <typename,typename> class CONT>
template <typename T2, template <typename,typename> class CONT2>
Stack<T,CONT>&
Stack<T,CONT>::operator= (Stack<T2,CONT2> const& op2)
{
    if ((void*)this == (void*)&op2) {　 // 赋值给自身吗
        return *this;
    }
    Stack<T2,CONT2> tmp(op2);　　　　　 // 创建一个赋值栈的拷贝
    elems.clear();　　　　　　　　　　　 // 删除现存的所有元素
    while (!tmp.empty()) {　　　　　　　// 拷贝所有的元素
        elems.push_front(tmp.top());
        tmp.pop();
    }
    return *this;
}

#endif // STACK_HPP
```


下面的程序则使用最终版本的所有特性：

```cc
//basics/stack8test.cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <vector>
#include "stack8.hpp"

int main()
{
    try {
        Stack<int>　 intStack;　　　 // int栈
        Stack<float> floatStack;　　// float栈
        // 使用int栈
        intStack.push(42);
        intStack.push(7);
        // 使用float栈
        floatStack.push(7.7);
        // 不同类型的两个栈之间的赋值
        floatStack = intStack;
        // 输出float栈
        std::cout << floatStack.top() << std::endl;
        floatStack.pop();
        std::cout << floatStack.top() << std::endl;
        floatStack.pop();
        std::cout << floatStack.top() << std::endl;
        floatStack.pop();
    }
    catch (std::exception const& ex) {
        std::cerr << "Exception: " << ex.what() << std::endl;
    }
    // 使用vector作为内部容器的int栈
    Stack<int,std::vector> vStack;
    ...
    vStack.push(42);
    vStack.push(7);
    std::cout << vStack.top() << std::endl;
    vStack.pop();
}
```


### 零初始化
对于 int、double 或者指针等基本类型，并不存在“用一个有用的缺省值来对它们进行初始化”的缺省构造函数；
相反，任何未被初始化的局部变量都具有一个不确定（undefined）值：
```cc
void foo()
{
    int x;　　　 //x具有一个不确定值
    int* ptr;　　//ptr指向某块内存（并非无所指）
}
```
现在，假如你在编写模板，并且希望模板类型的变量都已经用缺省值初始化完毕，那么这时你会遇到问题，内建类型并不能满足你的要求：
```cc
template <typename T>
void foo()
{
    T x;//如果T是内建类型，那么x本身是一个不确定值
}
```
由于这个原因，我们就应该显式地调用内建类型的缺省构造函数，并把缺省值设为0（或者false，对于bool类型而言）。
譬如调用int()我们将获得缺省值0。于是，借助如下代码，我们可以确保对象已经执行了适当的缺省初始化，即便对内建类型对象也是如此：
```cc
template <typename T>
void foo()
{
    T x = T();　 //如果T是内建类型，x是零或者false
}
```
对于类模板，在用某种类型实例化该模板后，为了确认它所有的成员都已经初始化完毕，你需要定义一个缺省构造函数，通过一个初始化列表来初始化类模板的成员：
```cc
template <typename T>
class MyClass {
    private:
        T x;
    public:
        MyClass() : x() {//确认x已被初始化，内建类型对象也是如此
        }
        ...
};
```

### 使用字符串作为函数模板的实参
有时，把字符串传递给函数模板的引用参数会导致出人意料的运行结果。考虑下面的程序：
```cc
//basics/max5.cpp
#include <string>

// 注意：引用参数
template <typename T>
inline T const& max (T const& a, T const& b)
{
    return　a < b　?　b : a;
}

int main()
{
    std::string s;
    ::max("apple","peach");　 // OK: 相同类型的实参
    ::max("apple","tomato");　// ERROR: 不同类型的实参
    ::max("apple",s);　　　　 // ERROR: 不同类型的实参
}
```

问题在于：由于长度的区别，这些字符串属于不同的数组类型。
也就是说，‘apple’和‘peach’具有相同的类型`char const[6]`；然而‘tomato’的类型则是：`char const[7]`。
因此，只有第一个调用是合法的，因为该 max()模板期望的是类型完全相同的参数。
然而，如果声明的是非引用参数，你就可以使用长度不同的字符串来作为max()的参数：

```cc
//basics/max6.cpp
#include <string>

// 注意：非引用参数
template <typename T>
inline T max (T a, T b)
{
    return　a < b　?　b : a;
}

int main()
{
    std::string s;
    ::max("apple","peach");　 // OK: 相同的类型
    ::max("apple","tomato");　// OK: 退化（decay）为相同的类型
    ::max("apple",s);　　　　// ERROR: 不同的类型
}
```

产生这种调用结果的原因是：对于非引用类型的参数，在实参演绎的过程中，会出现数组到指针（array-to-pointer）的类型转换（这种转型通常也被称为decay）。
我们可以通过下面的程序来说明这一点：
```cc
//basics/refnonref.cpp
#include <typeinfo>
#include <iostream>

template <typename T>
void ref (T const& x)
{
    std::cout << "x in ref(T const&): "
    << typeid(x).name() << '\n';
}

template <typename T>
void nonref (T x)
{
    std::cout << "x in nonref(T): "
    << typeid(x).name() << '\n';
}

int main()
{
    ref("hello");
    nonref("hello");
}
```
在 main 函数中，分别传递一个字符串给具有引用参数的函数模板和具有非引用参数的函数模板。
两个函数模板都使用了typeid运算符来输出被实例化参数的类型。typeid运算符会返回std::type_info类型的左值（lvalue），
其中std::type_info封装了传递给typeid运算符的表达式的类型表示；而且，调用std::type_info的成员函数name()是为了返回类型的可读文本表示。
虽然C++标准并没有要求name()必须返回一个有意义的值，但对于大多数优秀的C++编译器实现而言，name()会返回一个字符串，清楚地表示传递给typeid的参数（或表达式）的类型（在某些实现中，这个字符串可能不是可读的文本，但存在一个文本转换器，可以把它转换成可读的文本）。
例如，上面程序可能会有如下输出：
```bash
x in ref(T const&):　char[6]
x in nonref(T):　　　const char *
```
如果你遇到一个关于字符数组和字符串指针之间不匹配的问题，你会意外地发现和这个问题会有一定的相似之处。
然而遗憾的是，对于这个问题并没有通用的解决方法。根据不同的情况，你可以：
- 使用非引用参数，取代引用参数（然而，这可能会导致无用的拷贝）。
- 进行重载，编写接收引用参数和非引用参数的两个重载函数（然而，这可能会导致二义性）。
- 对具体类型进行重载（譬如对std::string进行重载）。
- 重载数组类型，譬如：
```cc
template <typename T, int N, int M>
T const* max(T const (&a)[N], T const (&b)[M])
{
    return a < b ? b : a;
}
```
- 强制要求应用程序程序员使用显式类型转换。

对于我们讨论的例子，最好的方法是为字符串重载max()。
无论如何，为字符串提供重载都是有必要的；
因为如果不提供重载，当我们调用max()来比较两个字符串时，操作a<b执行的是指针比较，就是说a<b比较的是两个字符串的地址，而不是它们的字典顺序。
事实上，这也是我们趋向于使用诸如std::string的字符串类，而不使用C风格字符串类的另一个原因。


### 小结
- 如果要访问依赖于模板参数的类型名称，你应该在类型名称前添加关键字typename。
- 嵌套类和成员函数也可以是模板。在本章的例子中，针对元素类型可以进行隐式类型转换的2个栈，我们实现了通用的赋值操作。然而，在这种情况下，类型检查依然是存在的。
- 赋值运算符的模板版本并没有取代缺省赋值运算符。
- 类模板也可以作为模板参数，我们称之为模板的模板参数。
- 模板的模板实参必须精确地匹配。匹配时并不会考虑“模板的模板实参”的缺省模板实参（如std::deque的allocator）。
- 通过显式调用缺省构造函数，可以确保模板的变量和成员都已经用一个缺省值完成初始化，这种方法对内建类型的变量和成员也适用。
- 对于字符串，在实参演绎过程中，当且仅当参数不是引用时，才会出现数组到指针（array-to-pointer）的类型转换（称为decay）。

## 模板实战
模板代码和普通代码是有区别的。从某种意义上讲，模板是位于宏和普通（非模板）声明之间的一种构造。这种说法或许有些过于简单，但当我们使用模板来编写算法和数据结构，或者在日常中表达和分析模板程序的逻辑习以为常的时候，我们可能就会认同这种说法。

在这一章里，我们只给出模板的一些实际应用，并不涉及应用底层的众多技术细节，我们将把大部分细节留到第 10 章讨论。为了使叙述尽量简洁，假设我们的 C++编译系统是由传统的编译器和链接器两者组成的（事实上，几乎所有的C++编译系统都由这两者组成）。

### 包含模型
我们可以用几种方法来组织模板源代码。这一节将给出（在本书编写时）最常用的方法：包含模型（inclusion model）。

### 链接器错误
大多数C和C++程序员会这样组织他们的非模板代码：
- 类（class ）和其他类型(other type)都被放在一个头文件中。通常而言，头文件是一个扩展名为.hpp（或者.H、.h、.hh、hxx）的文件。
- 对于全局变量和（非内联）函数，只有声明放在头文件中，定义则位于dot-C文件。通常而言，dot-C文件是指扩展名为.cpp（或者.C、.c、.cc、.cxx）的文件。

这样一切都可以正常运作了。所需的类型定义在整个程序中都是可见的；并且对于变量和函数而言，链接器也不会给出重复定义的错误。
当牢记了这种约定之后，刚开始接触模板的程序员却总会对这种约定发出抱怨，因为它令链接器产生了一个错误。
我们可以通过下面的（错误）小程序来说明这一点。利用上面针对普通代码的约定，我们应该在一个头文件中声明模板：
```cc
//basics/myfirst.hpp
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

//模板声明
template <typename T>
void print_typeof (T const&)

#endif //MYFIRST_HPP
```
print_typeof()是一个辅助函数模板的声明，它输出某些类型信息。该函数模板的实现被放在下面的dot-C文件里面：
```cc
//basics/myfirst.cpp
#include <iostream>
#include <typeinfo>
#include“myfirst.hpp”

//模板的实现/定义
template <typename T>
void print_typeof (T const& x)
{
    std::cout << typeid(x).name() << std::endl;
}
```
这个例子使用typeid运算符来输出一个字符串，它描述了作为参数传递的表达式的类型（见5.6节）。
最后，我们在另一个dot-C文件里使用这个模板，并且把模板声明包含进这个文件：
```cc
//basics/myfirstmain.cpp
#include“myfirst.hpp”

//使用模板
int main()
{
    double ice = 3.0;
    print_typeof(ice); //调用参数类型为double的函数模板
}
```

大多数C++编译器都会顺利地接受这个程序；但是链接器可能会报错，提示找不到函数print_typeof()的定义。

事实上，这个错误的原因在于：函数模板 print_typeof()的定义还没有被实例化。
为了使模板真正得到实例化，编译器必须知道：应该实例化哪个定义以及要基于哪个模板实参来进行实例化。
遗憾的是，在前面的例子里，这两部分信息位于分开编译的不同文件里面。
因此，当我们的编译器看到print_typeof()调用，但还没有看到基于double实例化的函数定义的时候，它只是假设在别处提供了这个定义，并产生一个指向该定义的引用（让链接器利用该引用来解决这个问题）。
另一方面，当编译器处理文件 myfirst.cpp 的时候，它并没有指出：编译器必须基于特定实参对所包含的模板定义进行实例化。

#### 头文件中的模板
对于前面的问题，我们通常是采取对待宏或内联函数的解决办法：
我们把模板的定义也包含在声明模板的头文件里面，即让定义和声明都位于同一个头文件中。对于上面的例子，我们可以通过把：

```cc
#include“myfirst.cpp”
```
添加到myfirst.hpp 的末尾，或者在每个使用模板的dot-C 文件都包含myfirst.cpp。
显然，第3种方法就是完全不要myfirst.cpp，然后重写myfirst.hpp，让它同时包含模板声明和模板定义：
```cc
//basics/myfirst2.hpp
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

#include <iostream>
#include <typeinfo>

//模板声明
template <typename T>
void print_typeof(T const&);

//模板的实现/定义
template <typename T>
void print_typeof(T const& x)
{
    std::cout << typeid(x).name() << std::endl;
}

#endif //MYFIRST_HPP
```
我们称模板的这种组织方式为包含模型。通过使用这种模型，你会发现前面的程序可以顺利编译、链接和运行。

针对这一点，我们可以得出一些结论：
包含模型明显增加了包含头文件myfirst.hpp的开销，这也正是包含模型最大的不足之处。
在例子中，主要的开销并不是取决于模板定义本身的大小，而在于模板定义中所包含的那些头文件（在我们的例子中是`<iostream>`和`<typeinfo>`）的大小。
你或许已经知道这样会带来成千上万行的代码，因为每个诸如`<iostream>`的头文件本身也都包含了许多类似的模板定义。

在实际应用中，这是一个很严重的问题，因为它大大增加了编译复杂程序所耗费的时间。
因此我们将在后面几节给出几种可能的解决方法。然而，现在的程序大多已经不需要在编译和链接上面花上几个小时，将来就更不用说了
（我们以前确实是耗费了很多时间在这上面，甚至用了几天的时间才从源代码完整地创建出一个程序）。

如果不需要考虑创建期的时间问题，我们建议你尽量使用包含模型来组织模板代码。
我们在后面会考察另外两种组织模板的方式，但就我们的观点看来，另外两种组织方式的实际缺陷往往比这里所讨论的创建期开销更加严重。
当然，这两种组织方式也有其他一些与软件开发的应用方面间接相关的优点。

从包含模型得出的另一个（更微妙的）结论是：
非内联函数模板与“内联函数和宏”有一个很重要的区别，那就是非内联函数模板在调用的位置并不会被扩展，而是当它们基于某种类型进行实例化之后，才产生一份新的（基于该类型的）函数拷贝。
因为这（产生函数拷贝）是一个自动化过程，所以在编译结束的时候，编译器可能会在不同的文件里产生两份拷贝，于是，当链接器发现同一个函数具有两种不同的定义时，就会报告一个错误。
理论上讲，这并不是我们需要关心的问题，它应该由 C++的编译系统来解决。而且，事实上大多数情况下都不会出现这种问题，我们根本没有必要太过于在意这个问题。
但对于需要创建自身代码库的大项目，我们就要充分注意这个问题。我们将在第10章详细讨论C++的实例化机制；仔细学习 C++翻译系统（或者编译器）所附带的随机文档也有助于理解这个问题。

最后，我们需要指出的是：在我们的例子中应用到普通函数模板的所有特性，对类模板的成员函数和静态数据成员、成员函数模板也都是适用的。

### 显式实例化
包含模型能够确保所有需要的模板都已经实例化。
这是因为：当需要进行实例化的时候，C++编译系统会自动产生所对应的实例化体。
另外，C++标准还提供了一种手工实例化模板的机制：显式实例化指示符（explicit instantiation directive）。

#### 显式实例化的例子
为了说明手工实例化，让我们回顾前面那个导致链接器错误的例子。在此，为了避免这个链接期错误，我们可以通过给程序添加下面的文件：

```cc
//basics/myfirstinst.cpp
#include“myfirst.cpp”
//基于类型double显式实例化print_typeof()
template void print_typeof<double>(double const&);
```
显式实例化指示符由关键字template和紧接其后的我们所需要实例化的实体（可以是类、函数、成员函数等）的声明组成，
而且，该声明是一个已经用实参完全替换参数之后的声明。
在我们的例子中，我们针对的是一个普通函数，但该指示符也适用于成员函数和静态数据成员。譬如：
```cc
//基于int显式实例化MyClass<>的构造函数
template MyClass<int>::MyClass();
//基于int显式实例化函数模板max()
template int const& max(int const&, int const&);
```
你还可以显式实例化类模板，这样就可以同时实例化它的所有类成员。但有一点需要注意：对于这些在前面已经实例化过的成员，就不能再次对它们进行实例化：
```cc
//基于int显式实例化类Stack<>
template class Stack<int>
//基于string显式实例化Stack<>的某些成员函数
template Stack<std::string>::Stack();
template void Stack<std::string>::push(std::string const&);
template std::string Stack<std::string>::top()const;
//错误：对于前面已经显式实例化过的成员函数，不能再次对它进行显式实例化
template Stack<int>::Stack();
```
对于每个不同实体，在一个程序中最多只能有一个显式实例化体，换句话说，你可以同时显式实例化 `print_typeof<int>`和 `print_typeof<double>` ，但在同一个程序中每个指示符都只能够出现一次 。如果不遵循这条规则，通常都会导致链接错误，链接器会报告：发现了实例化实体的重复定义。

人工实例化有一个显著的缺点：我们必须仔细跟踪每个需要实例化的实体。对于大项目而言，这种跟踪很快就会带来巨大负担；因此，我们并不建议使用这种方法。事实上，我们曾经在几个大项目刚开始时就低估了这种负担，而等到代码快要完成的时候，我们就为使用人工实例化而后悔不已。

然而，显式实例化还是有它自身的一些优点的，实例化可以在需要的时候才进行。显然，我们因此避免包含庞大头文件的开销，更可以把模板定义的源文件封装起来；但封装之后，客户端程序就不能基于其他类型来进行额外的实例化了。另外，对于某些程序，精确控制模板实例的准确位置也是很有用的，显式实例化就可以做到这一点；而如果使用自动实例化的话，这种精确位置控制是不可能的（细节请参见第10章）。

#### 整合包含模型和显式实例化
为了让程序员能够根据实际情况，自由地选择包含模型或者显式实例化，我们可以把模板的定义和模板的声明放在两个不同的文件中。通常的做法是使用头文件来表示这两个文件（头文件大多是那些希望被#include、具有特定扩展名的文件）；通常而言，遵守这种文件分开约定是明智的（因此，我们最前面例子中的myfirst.cpp文件，现在将命名为myfirstdef.hpp，由预处理器来检测这些被插入的代码）。
```cc
// stack.hpp
#ifndef STACK_HPP
#define STACK_HPP

#include <vector>

template <typename T>
class Stack {
    private:
        std::vector<T> elems;
    public:
        Stack();
        void push (T const &);
        void pop();
        T top() const;
};

#endif
```

```cc
// stackdef.hpp
#ifndef STACKDEF_HPP
#define STACKDEF_HPP

#include "stack.hpp"

template <typename T>
void Stack<T>::push (T const & elem)
{
    elems.push_back(elem);
}

...

#endif
```
现在，如果我们希望使用包含模型，那么只要#include头文件stackdef.hpp就可以了。反之，如果我们希望显式实例化模板，我们就应该#include 头文件 stack.hpp，然后再提供一个含有所需要显式实例化指示符的dot-C文件（见图6.2）。


在拥有两个模板头文件的情况下，进行显式实例化:
```cc
// stacktest1.cpp
#include "stack.hpp"
#include <iostream>
#include <string>

int main() {
    Stack<int> intStack;
    intStack.push(42);
    std::cout << intStack.top() << std::endl;
    intStack.pop();

    Stack<std::string> stringStack;
    stringStack.push("hello");
    std::cout << stringStack.top() << std::endl;
}
```
```cc
// stack_inst.cpp
#include "stackdef.hpp"
#include <string>

// instantiate class Stack<> for int
template Stack<int>;

// instantiate some member functions of Stack<> for strings
template Stack<std::string>::Stack();
template void Stack<std::string>::push(std::string const &);
template std::string Stack<std::string>::top();
```

### 分离模型
我们在上一节给出的两种方法都可以正常地工作，也完全符合C++标准。然而，标准还给出了另一种机制：导出模板（exporting template）。这种机制通常也被称为C++模板的分离模型（separation model）。

#### 关键字export
大体上讲，关键字export的功能使用是非常简单的：在一个文件里面定义模板，并在模板的定义和（非定义的）声明的前面加上关键字export。对于上一节的例子，通过使用export，我们会得到下面的函数模板声明：
```cc
//basics/myfirst3.hpp
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

//模板声明
export
template <typename T>
void print_typeof(T const&);

#endif　//MYFIRST_HPP
```

即使在模板定义不可见的条件下，被导出的模板也可以正常使用。
换句话说，使用模板的位置和模板定义的位置可以在两个不同的翻译单元中。
在我们的例子中，文件myfirst3_hpp现在只是包含类模板的成员函数的声明，但对于使用这些成员已经足够了。
和刚开始导致编译器报错的那个例子相比，我们只是在代码中添加了关键字export，一切就可以顺利通过了。

在一个预处理文件内部（就是指在一个翻译单元内部），我们只需要在第一个声明前面标记export关键字就可以了，后面的重新声明（也包括定义）会隐式地保留这个export特性。
这也是我们不需要修改文件myfirst.cpp的原因所在。
就是说，myfirst.cpp文件里面的这个定义是隐式exported，因为在它#include的头文件myfirst3.hpp里面，该定义所对应的声明已经被限定为export的了。
另一方面，在模板定义中提供一个冗余的export关键字也是可取的，因为这样可以提高代码的可读性。

实际上关键字export可以应用于函数模板、类模板的成员函数、成员函数模板和类模板的静态数据成员。
另外，它还可以用于类模板的声明，这将意味着每个可导出的类成员都被看作可导出实体，但类模板本身实际上却没有被导出（因此，类模板的定义仍然需要出现在头文件中）。
你仍然可以隐式或者显式地定义内联成员函数。然而，内联函数却是不可导出的：
```cc
export template <typename T>
class MyClass {
    public:
        void memfun1();　　　//被导出（exported）的函数
        void memfun2() {　　 //隐式内联不能被导出
        ...
}

void memfun3();　　　//显式内联不能被导出
    ...
};

template <typename T>
inline void MyClass<T>::memfun3()
{
    ...
}
```

另外，export关键不能和inline关键字一起使用；如果用于模板的话，export要位于关键字template的前面，譬如下面的程序就是非法的：
```cc
template <typename T>
class Invalid {
    public:
        export void wrong(T);　　//错误：export没有位于template之前
};

export template<typename T>　　　 //错误：同时使用了export和inline
inline void Invalid<T>::wrong(T)
{
}

export template<typename T>
inline T const& max(T const& a, T const& b)//错误：同时使用了export和inline
{
    return a < b ? b : a;
}
```

#### 分离模型的限制
谈到这里，你可能会觉得奇怪：既然导出模板（exported template）可以很好地解决最初的问题，我们为何仍然建议大家使用包含模型呢。事实上，export 关键字还有其他一些方面的影响。

首先，在C++标准推出4年之后的今天，也就只有一家公司真正提供了对export关键字的支持 。
于是，export这个特性未能像其他C++特性那样广为流传。显然，这就说明程序员使用export的经验是非常有限的，因此我们针对export的讨论到头来也可能会是无济于事。
实际上，我们的这些担忧在将来是很有可能会得到重视的（所以我们才会给出export的这一切，这是为了将来做准备）。

其次，export 虽然看起来几乎是完美无缺的，但它实际上还是有一些缺点的。
在应用分离模型的最后，实例化过程需要处理两个位置：模板被实例化的位置和模板定义出现的位置。
虽然这两个位置在源代码中看起来是完全分离的，但系统却为这两个位置建立了一些看不见的耦合。
就是说，对于我们的例子而言，如果包含模板定义的文件发生了改变，那么不仅该文件需要进行重新编译，所有“对该文件中模板进行实例化的”其他文件都需要进行重新编译。
虽然这种耦合和包含模型的耦合没有本质的区别，但是这里的耦合在源代码中是看不见的。
也正是由于它的不可见性，所以那些基于代码的（诸如常用的make和nmake程序等）依赖性管理工具也将不再适用。
这就意味着编译器需要进行一些额外的处理，来跟踪所有的这些耦合。这也将导致程序的创建时间可能会比包含模型所需要的创建时间还要多。

最后一点，被导出的模板可能会导致出人意料的语义，我们将在第10章讨论这些细节。

我们通常会认为：如果我们实现了export机制，那么即使在模板库不提供源代码定义的情况下，外界也可以访问该库的模板（就像访问只包含非模板实体的程序库一样）；
但实际上这完全是一个误解，因为代码隐藏并不属于语言的范畴，所以也就不是export机制自身提供这种能力。
事实上，要像隐藏被导出（exported）模板定义那样，隐藏被 included 的模板定义也是有可能的，或许也是可行的（但现在的编译器实现并不支持这种模型）；
然而遗憾的是，这样我们将又遇到一个新的挑战：当exported模板遇到编译错误，而且该错误可能提示要引用被隐藏代码的定义的时候，我们要怎么处理呢？

#### 6.3.3 为分离模型做好准备
一个好的办法就是：对于我们预先编写的代码，存在一个可以在包含模型和分离模型之间互相切换的开关；在此，我们使用预处理指示符来获得这种特性。下面就是使用该方法的简单例子：
```cc
//basics/myfirst4.hpp
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

//如果定义了USE_EXPORT,就使用export
#if defined(USE_EXPORT)
#define EXPORT export
#else
#define EXPORT
#endif

//模板声明
EXPORT
template <typename T>
void print_typeof(T const&)；

//如果没有定义USE_EXPORT,就包含模板定义
#if !defined(USE_EXPORT)
#include“myfirst.cpp”
#endif

#endif　//MYFIRST_HPP
```

通过定义或者忽略预处理符号 USE_EXPORT，我们现在就可以在两种模型之间进行选择。如果程序在#include "myfirst.hpp"之前已经定义了 USE_EXPORT，那么将会使用分离模型：
```cc
//使用分离模型
#define USE_EXPORT
#include“myfirst.hpp”
```

如果程序并没有定义 USE_EXPORT，那么将会使用包含模型，因为在这种情况下，myfirst.hpp已经自动#include了myfirst.cpp中的定义：

```cc
//使用包含模型
#include“myfirst.hpp”
...
```
显然，这个方法很灵活。另外，我们需要重申的是：除了明显的逻辑区别之外，这两种模型之间还具有细微的语义区别。

对于被导出的模板，我们仍然可以对它进行显式实例化。
在这个例子中，模板定义也可以位于另一个文件中，只需在程序中#include一个含有显式实例化的.cpp文件。
为了能够在包含模型、分离模型、显式实例化这3种方法中进行选择，我们可以把USE_EXPORT这种控制手段和6.2.2小节所描述的约定结合起来。


### 模板和内联
把短小函数声明为内联函数是提高运行效率所普遍采用的方法。
inline 修饰符表明的是一种实现：在函数的调用处使用函数体（即内容）直接进行内联替换，它的效率要优于普通函数的调用机制（针对短小函数而言）。
然而，标准并没有强制编译器实现这种“在调用处执行内联替换”的机制，实际上，编译器也会根据调用的上下文来决定是否进行替换。

函数模板和内联函数都可以被定义于多个翻译单元中。通常，我们是通过下面途径来获取这个实现：把定义放在一个头文件中，而这个头文件又被多个dot-C文件所包含（#include）。

这种实现会给我们这样一种印象：函数模板缺省情况下是内联的。然而，这种想法是不正确的。
所以，如果你编写需要被实现为内联函数的函数模板，你仍然应该使用 inline 修饰符（除非这个函数由于是在类定义的内部进行定义的而已经被隐式内联了）。

因此，对于许多不属于类定义一部分的短小模板函数，你应该使用关键字 inline来声明它们。

### 预编译头文件
即使不存在模板，C++头文件也可以变得非常巨大，从而需要很长的编译时间。模板更是增加了编译时间。
于是，程序员就呼吁产品厂家实现一种称为预编译头文件（precompiled header）的机制；该机制是位于标准的范围之外的，并且主要依赖于特定产品的实现。
虽然我们会把如何创建和使用预编译头文件的细节留给具有这个特性的C++编译系统的文档，但知道预编译是如何进行的还是很有裨益的。

当翻译一个文件时，编译器是从文件的开头一直进行到文件末端的。
当处理文件中的每个标记（这些标记可能来自于#included的文件）时，编译器会匹配它的内部状态，包括添加入口点到符号表，从而在后面可以查找等。在这个过程中，编译器还会在目标文件中生成代码。

预编译头文件机制主要依赖于下面的事实：我们可以使用某种方式来组织代码，让多个文件中前面的代码都是相同的。
假想有一个例子：由于实参的原因，每个需要编译的文件的前面N行代码都是相同的。于是，我们可以先编译完这N行代码，并把编译器在（编译后）这一点的完整状态储存在一个所谓的预编译头文件中。
因此，对于程序中的剩下文件的编译，我们只需要先加载上面已经保存的状态，然后从第 N+1 行开始编译就可以了（因为前面 N行代码都是相同的）。
此时我们还应该知道：重新加载已保存的状态是一个很快的操作，它要比实际上编译前面的N行程序快得多。
然而，第一次编译并保存这个状态就要比编译这N行代码慢；而增加的时间代价也要根据实际情况在20%～200%不等。

充分利用预处理头文件的关键之处在于：（尽可能地）确认许多文件开始处的相同代码的最大行数。
在实际应用中，这就意味着文件必须以相同的#include指示符开始，因为#include指示符本身耗费了很大一部分的创建时间。因此，对于被包含（included）的众多头文件，注意它们的被包含顺序是相当重要的，譬如：

```cc
#include <iostream>
#include<vector>
#include<list>
...
```
和
```cc
#include<list>
#include<vector>
...

```
就不能使用预编译头文件，因为两者在源代码中没有共同的初始状态。

有些程序员会认为：在使用预编译头文件的时候，允许#include 一部分额外无用的头文件，要比只选择有用的头文件具有更好的编译速度；
这还可以让包含策略的管理变得更加容易。
例如，通常我们会直接创建一个名为std.hpp的头文件，让它包含所有的标准头文件：
```cc
#include <iostream>
#include <string>
#include <vector>
#include <deque>
#include <list>
...
```

然后对std.hpp进行预编译，因此每个使用标准库的程序文件现在只需要这样开始就可以：
```cc
#include“std.hpp”
...
```

通常而言，预编译这个文件需要一段时间；但对于具有足够内存的系统，预编译头文件机制会使得处理速度比编译大多数单个（未经过预编译的）标准头文件快很多。
另外，使用这种方式，我们几乎可以使用所有的标准头文件，因为标准头文件都是很少改变的；因此我们的预编译头文件 std.hpp 就只需要创建一次，就可以在后面多次使用 。
相反，如果不能保证这种稳定性，预编译头文件可能就会因为项目具体情况的变化而不断改变，并成为项目的依赖性配置的一部分（例如，根据需要使用诸如make等工具来进行更新）。

管理预编译头文件的一种可取的方法是：对预编译文件进行分层，即根据头文件的使用频率和稳定性来进行分层。
于是，对于那些不会发生变化的头文件，就很有必要对它们进行预编译。
然而，如果头文件是处于一个大型开发项目中，那么对所有的文件都进行预编译所耗费的时间，可能会比重用预编译头文件所节省的时间还要多。
因此，解决这个问题的关键之处在于：我们应该对那些属于更稳定级别的头文件先进行预编译，然后在不太稳定的头文件中重用这个稳定的预编译头文件，从而提高整个编译效率。
例如，假设除了处理前面介绍的std.hpp头文件之外（我们已经对该它进行预编译了），我们还定义了一个core.hpp头文件，它包含了我们项目特有的额外功能；
可是，core.hpp的稳定性低于std.hpp的稳定性，那么它大体是这样的：
```cc
#include“std.hpp”
#include“core_data_hpp”
#include“core_algos.hpp”
...
```
因为该文件是以 #include "std.hpp"开头的，编译器将会加载相关的预编译头文件，然后从下一行开始编译，而不会重新编译所有的标准头文件。
当文件‘core.hpp’完全经过处理之后，就产生了一个新的预编译头文件。
于是，应用程序可以使用 #include "core.hpp"来提供（比std.hpp）功能更多、速度更快的访问，因为编译器可以直接加载后面这个经过预编译的头文件。


## 调试模板
当需要调试模板的时候，我们将会面临来自两方面的挑战。
一种挑战来自模板的编写者：针对某一个模板，如果它的任何一个模板实参都已经符合文档所编写的要求，那么我们如何才能够保证模板可以正确地运作呢？
另一种挑战正好来自对立的一方（即模板的使用者）：在遇到模板的行为和文档中所描述的情况有差异的时候，模板的用户如何才能发现哪个模板参数违反了文档要求，或者是违反了模板参数的哪条要求呢？

在深入讨论这些话题之前，让我们先来考察可以强加给模板参数的一些约束，这是非常有必要的。
因为在这一节里，我们叙述的大多数编译期错误就是由于违反这些约束而产生的，我们把这些约束称为语法约束（syntactic constraint）。
语法约束可以包括要求某种构造函数必须存在、某个特定函数调用不能产生二义性等。而对于其他的约束，我们称为语义约束（semantic constraint）。
事实上，要想机械地验证某个约束究竟属于哪一类约束是非常困难的；在有些情况下，我们甚至根本就不能够进行这种验证。
例如，我们会要求模板类型参数必须具有 operator<的定义（这是个语法约束），但大多数情况下，我们还要求这个运算符实际上定义的是某种领域下的排序规则（这是语义约束）。

concept这个术语通常被用于表示：在模板库中重复需求的约束集合。
例如，C++标准库就依赖于诸如随机访问选代器（random access iterator）和缺省可构造（default constructible）等concept。
concepts还可以形成体系：就是说，某个concept可以是其他concept的进一步细化（也称为精化），更精化的concept不但具备上层concept的各种约束，而且还增加了一些针对自身的约束。
例如，在C++标准程序库中，concept random access iterator就是concept bidirectional iterator的精化。
有了这些术语之后，在模板实现和模板使用的过程当中，我们可以认为：调试模板代码的主要工作是判断模板实现和模板定义中哪些concept被违反了。

### 理解长段的错误信息
普通的编译错误通常都是相当简洁的，并且也能一针见血地指出问题的所在。
譬如，当编译器给出“class X has no member ‘fun’ ”的错误信息时，我们通常都能很快找出代码中的错误（譬如，我们把fun写成了run）。但是，涉及模板的代码并非如此。
让我们考虑下面摘取自某程序的简单代码，它使用了C++标准程序库。
假设我们在代码中犯了一个很小的错误：首先声明一个 `list<string>`对象，但当我们应该使用 `greater<string>`函数对象来对它进行查找时，我们却错误地写成了`greater<int>`函数对象：

```cc
std::list<std::string> coll;
...
//找到第一个大于‘A’的元素
std::list<std::string>::iterator pos;
pos = std::find_if(coll.begiin(), coll.end(), //查找范围
std::bind2nd(std::greater<int>(),"A") );//查找准则
```
事实上，在我们平常的代码剪切、代码粘贴过程中，就很有可能会忘记修改这些细节，从而就出现类似上面的错误。
譬如，某个常用版本的GNU C++编译器会报告下面的错误：
```bash
❯ g++ main.cc
main.cc: In function ‘int main(int, char**)’:
main.cc:10:17: warning: ‘std::binder2nd<_Operation> std::bind2nd(const _Operation&, const _Tp&) [with _Operation = greater<int>; _Tp = char [2]]’ is deprecated: use 'std::bind' instead [-Wdeprecated-declaration
]
   10 |     std::bind2nd(std::greater<int>(),"A") );//查找准则
      |     ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/13/bits/stl_function.h:1438,
                 from /usr/include/c++/13/string:49,
                 from main.cc:1:
/usr/include/c++/13/backward/binders.h:172:5: note: declared here
  172 |     bind2nd(const _Operation& __fn, const _Tp& __x)
      |     ^~~~~~~
/usr/include/c++/13/backward/binders.h: In instantiation of ‘std::binder2nd<_Operation> std::bind2nd(const _Operation&, const _Tp&) [with _Operation = greater<int>; _Tp = char [2]]’:
main.cc:10:17:   required from here
/usr/include/c++/13/backward/binders.h:175:42: error: cast from ‘const char*’ to ‘_Arg2_type’ {aka ‘int’} loses precision [-fpermissive]
  175 |       return binder2nd<_Operation>(__fn, _Arg2_type(__x));
      |                                          ^~~~~~~~~~~~~~~
In file included from /usr/include/c++/13/bits/stl_algobase.h:71,
                 from /usr/include/c++/13/string:51:
/usr/include/c++/13/bits/predefined_ops.h: In instantiation of ‘bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator) [with _Iterator = std::_List_iterator<std::__cxx11::basic_string<char> >; _Pre
dicate = std::binder2nd<std::greater<int> >]’:
/usr/include/c++/13/bits/stl_algobase.h:2055:42:   required from ‘_InputIterator std::__find_if(_InputIterator, _InputIterator, _Predicate, input_iterator_tag) [with _InputIterator = _List_iterator<__cxx11::basi
c_string<char> >; _Predicate = __gnu_cxx::__ops::_Iter_pred<binder2nd<greater<int> > >]’
/usr/include/c++/13/bits/stl_algobase.h:2117:23:   required from ‘_Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = _List_iterator<__cxx11::basic_string<char> >; _Predicate = __gnu_cxx
::__ops::_Iter_pred<binder2nd<greater<int> > >]’
/usr/include/c++/13/bits/stl_algo.h:3923:28:   required from ‘_IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = _List_iterator<__cxx11::basic_string<char> >; _Predicate = binder2nd<greater<int> >]’
main.cc:9:23:   required from here
/usr/include/c++/13/bits/predefined_ops.h:318:30: error: no match for call to ‘(std::binder2nd<std::greater<int> >) (std::__cxx11::basic_string<char>&)’
  318 |         { return bool(_M_pred(*__it)); }
      |                       ~~~~~~~^~~~~~~
/usr/include/c++/13/backward/binders.h:164:7: note: candidate: ‘typename _Operation::result_type std::binder2nd<_Operation>::operator()(typename _Operation::first_argument_type&) const [with _Operation = std::gr
eater<int>; typename _Operation::result_type = bool; typename _Operation::first_argument_type = int]’
  164 |       operator()(typename _Operation::first_argument_type& __x) const
      |       ^~~~~~~~
/usr/include/c++/13/backward/binders.h:164:60: note:   no known conversion for argument 1 from ‘std::__cxx11::basic_string<char>’ to ‘std::binary_function<int, int, bool>::first_argument_type&’ {aka ‘int&’}
  164 |       operator()(typename _Operation::first_argument_type& __x) const
      |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
/usr/include/c++/13/backward/binders.h:158:7: note: candidate: ‘typename _Operation::result_type std::binder2nd<_Operation>::operator()(const typename _Operation::first_argument_type&) const [with _Operation = s
td::greater<int>; typename _Operation::result_type = bool; typename _Operation::first_argument_type = int]’
  158 |       operator()(const typename _Operation::first_argument_type& __x) const
      |       ^~~~~~~~
/usr/include/c++/13/backward/binders.h:158:66: note:   no known conversion for argument 1 from ‘std::__cxx11::basic_string<char>’ to ‘const std::binary_function<int, int, bool>::first_argument_type&’ {aka ‘const
 int&’}
  158 |       operator()(const typename _Operation::first_argument_type& __x) const
      |                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
```

这个信息看起来更像是一段小说，而不是诊断信息。它会大大打击模板初学者的信心。然而，当有了一定的经验之后，我们就会发现这类信息也是可应付的，也可以比较容易地找出症结所在。

错误信息的第一部分表明：在头文件/local/include/stl/_algo.h 里面的一个函数模板实例（具有一个特别长的名称）中出现了一个错误。接下来，编译器报告它为什么实例化这个特殊的实例。
在这个例子中，所有错误都从testprog.cpp（它是包含我们例子代码的文件）的第18行开始，该行引起_algo.h头文件在115行进行find_if模板的实例化。
编译器报告了所有的这些错误，但我们可能并不期望看到所有被实例化的模板；然而，这样却可以想让我们清楚引起实例化事件的整个过程。

然而，在我们的例子里，我们相信所需要的模板都已经被实例化了，并不知道为什么仍然会出现错误。
事实上，最后一部分信息给出了答案，它说明 ‘no match for call’，这意味着有一个函数调用的实参类型和参数类型不匹配，从而不能被解析。
而且，在这一行的后面，包含‘candidate are’的那一行解释：存在一个单一的候选类型，它期望的是一个整型（即参数类型为const int&）。
再回头看程序的第18行，我们看到`std::bind2nd(std::greater<int>(),“A”)`确实包含了一个整型（即`<int>`），因此可以知道它和我们在例子中要查找的字符串类型是不一致的。
我们把`<int>`替换为`<std::string>`，例子就可以正确运行了。

毫无疑问，这些错误信息可以具有更好的结构，从而就可以在实例化之前发现实际的问题。
首先，我们要使用一种方法来替换完全扩展的模板实例化名称：如`MyTemplate<YourTemplate<int>>`应该分解为`MyTemplate<T>`和`T=YourTemplate<int>`，从而减少名称的长度。
另一方面，在很多情况下，所有的诊断信息都可能是很有用的；
因此如果其他的编译器也提供了类似的诊断信息（尽管采用了上面的结构化信息），那也就不足为奇了。

Leor Zolman编写了一个名为STLFilt的实用程序，它提供了一种方法，用于解读多种编译器输出的STL错误信息（见http://www.bdsoft.com/tools/stlfilt.html）。

> [!NOTE]
> STLFilt的版本太老了，实测无用，可能将报错信息交给AI分析更有效

### 浅式实例化
如果错误是在经过很长的实例化链表之后才被发现的，那么将会出现诸如前面所讨论那些诊断信息。为了说明这个问题，先考虑下面我们自己写的代码：
```cc
template <typename T>
void clear (T const& p)
{
    *p = 0;　　　// clear的实现者需要 p 支持解引用
}

template <typename T>
void core (T const& p)
{
    clear(p);
}

template <typename T>
void middle (typename T::Index p)
{
    core(p);
}

template <typename T>
void shell (T const& env)
{
typename T::Index i;
    middle<T>(i);
}

class Client {
public:
    typedef int Index; // 但使用者并不知道这个 Index 需要支持解引用
};

Client main_client;

int main()
{
    shell(main_client);
}
```
这个例子给出了软件开发中典型的层次结构：诸如 shell()的高层函数模板依赖于诸如middle()的组件，而组件又使用了诸如core()的功能。当我们实例化shell()的时候，它下面层次的函数模板也应该相应地被实例化。
在这个例子里，我们在最底层发现了一个问题：我们用int类型对core()进行实例化（int来自于middle()中Client::Index的使用），并且试图对一个int类型的值解引用（dereference），而这明显是错误的。
另外，一份完整的通用诊断信息应该包含对产生这个问题的所有层次的跟踪信息，但我们往往会发现根本很难准确把握这么多的信息。

在[StroustrupDnE]中我们可以找到一些围绕这个问题的详细讨论，Bjarne Stroustrup提出了两种可以提前验证模板实参是否符合一系列约束的方法：通过语言扩展或者通过提前使用参数。
我们将在13.11节对前一种方法进行介绍；而后一种方法主要在于把模板错误强制在浅式实例化中。我们是通过插入没有被使用的代码来获取这种实现的，这些代码并没有其他的用途，只是在实例化模板代码的高层模板实参不符合低层模板约束时，引发一个错误。

在我们前面的例子中，我们可以在shell()中添加代码，让它试图对T::Index 类型的值进行解引用。例如：
```cc
template <typename T>
inline void ignore(T const&)
{
}

template <typename T>
void shell (T const& env)
{
    class ShallowChecks {
        void deref(T::Index ptr) {
            ignore(*ptr);
        }
    };
    typename T::Index I;
    middle(i);
}
```

如果T是一个使T::Index不能被解引用的类型，那么在局部类ShallowChecks将会引发一个错误。另外我们知道，实际上这个局部类并没有被使用（即哑代码），因此添加的代码并不会影响 shell()函数的运行时间。
但遗憾的是，许多编译器都会对 ShallowChecks 并没有被使用的这个事实（它的成员也没有被使用）提出警告。我们可以使用诸如ignore()模板等tricks 来避免这类警告，但却会增加代码的复杂度。

显然，在我们的例子中所开发的这种哑代码会和实现模板实际功能的代码一样复杂。为了控制这种复杂度，我们需要收集各种哑代码片断来组成一个程序库。
譬如，这样一个程序库应该包含了许多可以扩展成代码的宏，当模板的参数替换违反了参数替换的 concept 时，这些代码就会引发一个错误。
就目前而言，最流行的这类程序库是Concept Check Library，它属于Boost库发布产品的一部分。

遗憾的是，这些技术的可移植性很差（不同的编译器对错误的诊断方法并不一致），而且，有时候还掩饰了一些在更高层次不能被捕获的错误。

> [!NOTE]
> C++20原生支持 concept Check


### 长符号串
我们在 6.6.1 小节分析的错误信息还带来了另一个模板问题：实例化后的模板代码会产生很长的符号串。例如，在实现中使用前面std::string的代码会被扩展成：
```cc
_STL::basic_string<char,_STL::char_traits<char>, _STL::allocator<char> >
```
某些使用C++标准库的程序经常会产生超过10 000个字符的符号串，而这些超长的字符很容易会令编译器、链接器和调试器产生错误或者警告信息。虽然现在的编译器使用压缩技术来减少这种问题，但是在错误信息中，这种压缩技术并不奏效。

### 跟踪程序
到目前为止，我们已经讨论了编译和链接包含模板的程序时所出现的错误。然而，最具挑战性的任务在于：在确认程序可以正确运行之前，我们先要确认程序的创建过程也是成功的。模板通常都会令创建过程更加复杂，因为模板所表示的通用代码还要依赖于使用模板的客户端（这也是比普通类、普通函数多的地方）。跟踪程序（tracer）是一个软件设备，它通过在开发周期的早期检测模板定义中的问题，来减轻调试时各个方面的负担。

跟踪程序可以是一个用户定义的类，可以用做一个测试模板的实参。通常，该类的定义有且仅有满足模板测试的功能。更重要的是，对于跟踪程序所调用的每个操作，该跟踪程序都应该产生一个针对该操作的跟踪。例如，利用跟踪程序，我们可以用实验方法来确认算法的效率和操作的实际调用步骤。

下面是一个利用跟踪程序来测试排序算法的例子：
```cc
//basics/tracer.hpp
#include <iostream>

class SortTracer {
    private:
        int value;　　　　　　　　　　//要被排序的整数值
        int generation;　　　　　　　 //产生拷贝的份数
        static long n_created;　　　 //调用构造函数的次数
        static long n_destroyed;　　 //调用析构函数的次数
        static long n_assigned;　　　//赋值的次数
        static long n_compared;　　　//比较的次数
        static long n_max_live;　　　//现存对象的最大个数

        //重新计算现存对象的最大个数
        static void update_max_live() {
            if(n_created-n_destroyed > n_max_live) {
                n_max_live = n_created – n_destroyed;
            }
        }

    public:
        static long creations() {
            return n_created;
        }
        static long destructions() {
            return n_destroyed;
        }
        static long assignments() {
            return n_assigned;
        }
        static long comparisons() {
            return n_compared;
        }
        static long max_live() {
            return n_max_live;
        }
    public:
        //构造函数
        SortTracer (int v = 0) : value(v), generation(1) {
            ++n_created;
            update_max_live();
            std::cerr <<“SortTracer #“ << n_created
            <<”, created generation“ << generation
            <<“ (total:“ << n_create – n_destroyed
            <<“)\n”;
        }

        //拷贝构造函数
        SortTracer (SortTracer const& b)
        : value(b.value), generation(b.generation + 1) {
            ++n_created;
            update_max_live();
            std::cerr <<“SortTracer #”<< n_created
            <<”, copied as generation“ << generation
            <<“ (total:“ << n_created – n_destroyed
            <<“)\n”;
        }

        //析构函数
        ~SortTracer() {
            ++n_destroyed;
            update_max_live();
            std::cerr <<“SortTracer generation“ << generation
            <<“ destroyed (total:“
            << n_created – n_destroyed <<“)\n”;
        }

        // 赋值运算符
        SortTracer& operator= (SortTracer const& b) {
            ++n_assigned;
            std::cerr << "SortTracer assignment #" << n_assigned
            << " (generation " << generation
            << " = " << b.generation
            << ")\n";
            value = b.value;
            return *this;
        }

        // 比较运算符
        friend bool operator < (SortTracer const& a,
        SortTracer const& b) {
            ++n_compared;
            std::cerr << "SortTracer comparison #" << n_compared
            << " (generation " << a.generation
            << " < " << b.generation
            << ")\n";
            return a.value < b.value;
        }

        int val() const {
            return value;
        }
};
```
除了排序值 value 之外，这个 tracer 类还提供了几个用来跟踪实际排序过程的成员：
generation跟踪原有对象产生了多少份拷贝。
其他的静态成员分别跟踪：
创建的个数（构造函数调用的次数）、析构函数调用的次数、赋值运算符调用的次数、比较的次数以及同一时刻现存对象的最大个数。

下面的静态成员定义在一个分开的dot-C文件中：
```cc
//basics/traler.cpp
#include "tracer.hpp"

long SortTracer::n_created = 0;
long SortTracer::n_destroyed = 0;
long SortTracer::n_max_live = 0;
long SortTracer::n_assigned = 0;
long SortTracer::n_compared = 0;
```
这个特殊的跟踪程序（tracer）类让我们能够跟踪给定模板的模式、实体创建、析构函数、赋值操作和比较操作。
下面的测试程序针对C++标准库的std::sort算法来说明这一系列跟踪：
```cc
//basics/tracertest.cpp
#include <iostream>
#include <algorithm>
#include "tracer.hpp"

int main()
{
    // 准备输入的例子:
    SortTracer input[] = { 7, 3, 5, 6, 4, 2, 0, 1, 9, 8 };

    // 输出初始值:
    for (int i=0; i<10; ++i) {
        std::cerr << input[i].val() << ' ';
    }

    std::cerr << std::endl;

    // 存取初始状态:
    long created_at_start = SortTracer::creations();
    long max_live_at_start = SortTracer::max_live();
    long assigned_at_start = SortTracer::assignments();
    long compared_at_start = SortTracer::comparisons();

    // 执行算法:
    std::cerr << "---[ Start std::sort() ]--------------------\n";
    std::sort<>(&input[0], &input[9]+1);
    std::cerr << "---[ End std::sort() ]----------------------\n";

    // 确认结果:
    for (int i=0; i<10; ++i) {
        std::cerr << input[i].val() << ' ';
    }

    std::cerr << "\n\n";

    // 最后的输出报告:
    std::cerr << "std::sort() of 10 SortTracer's"
    << " was performed by:\n "
    << SortTracer::creations() - created_at_start
    << " temporary tracers\n "
    << "up to "
    << SortTracer::max_live()
    << " tracers at the same time ("
    << max_live_at_start << " before)\n "
    << SortTracer::assignments() - assigned_at_start
    << " assignments\n "
    << SortTracer::comparisons() - compared_at_start
    << " comparisons\n\n";
}
```

运行这个程序我们将会看到多行的输出，但从“最后的输出报告”这一行开始我们可以得到所期望的结论。针对std::sort()函数的实现，我们可以得到下面的输出报告：
```bash
std::sort() of 10 SortTracer’s was performed by:
15 temporary tracers
up to 12 tracers as the same time (10 before)
33 assignments
27 comparisons
```

譬如，我们在例子中可以看到：在排序的时候，虽然创建了15个临时的tracer，但在同一时刻最多只存在两个多余的tracer。

因此，我们的tracer扮演着两种角色：它说明了我们的tracer完全满足标准sort()算法的要求（例如，并不需要运算符 ==和运算符>），另外，它让我们对算法的开销有个大体的把握。
然而，它并没有给出排序模板的正确性究竟如何。


### oracles
使用跟踪程序是相对比较简单和行之有效的技术，但它只能让我们对模板的特定输入和相关功能的特定行为进行跟踪。然而，我们可能会期望跟踪程序能够处理并不局限于这些特定要求的其他情况。
例如，用于排序算法的比较运算符需要具备什么条件，才能够使比较是有效的（或者是正确的）。
但在例子中，我们只是对整数和小于号情况进行了测试，在测试条件下，该比较运算符是有效的，但对其他的情况，该运算符是否仍然有效则一概不知。

在某些领域，tracer的一个扩展版本被称为oracles（或称为run-time analysis oracles）。它们是连接到推理引擎的 tracers——所谓推理引擎（inference engine）是一个程序，它可以记住用来推导出结论的断言和推理。
有一个被应用于标准库某一部分的这种系统，它的名字叫MELAS，[MusserWangDynaVeri] [36] 对它有详细的讨论。

在某些情况下，利用oracles，我们可以动态地验证模板算法，而不需要完全指定作为替换的模板实参（oracles 本身就是实参），也不需要指定输入数据（当程序由于缺少输入数据而不能继续时，推理引擎会请求某种输入假设）。
然而，在这种方式下，对算法复杂度的分析也是相当有限的（由于推理引擎的不足），而且工作量是巨大的。基于这些原因，我们并不深入研究oracles，但是有兴趣的读者可以参考前面所提到的那本书（和书中所列的书目）。

#### archetypes
我们前面提到：tracers通常提供了一个接口，它是所跟踪模板需要具备的最小接口。当“只具备这个接口的tracer”并不产生运行期输出的时候，我们有时把这种tracer称为archetype （原型）。
利用archetype，我们可以验证一个模板实现是否会请求期望之外的语法约束。典型而言，一个模板的实现可能会为模板库中标记的每个concept，都开发一个archetype。

### 本章后记
在头文件和dot-C文件中，所有源代码的组织都是基于一处定义原则（one-definition rule，ODR）的，附录A对这个原则进行深入的讨论。

包含模型和分离模型之间的比较已经成为一个争论性话题。包含模型是实际采用的方法，现在的C++编译器实现采用的大多就是这种方法。
然而，这和首个C++实现是有区别的：在首个实现中，模板定义的包含是隐式的，它会给人一种类似分离模型的错觉（关于这个首次实现的模型，请参照第10章）。

[StroustrupDnE]详细叙述了 Stroustrup 对模板代码的组织和相关实现的挑战的看法。显然，他所提议的并不是包含模型。然而，在标准化的过程中，看起来好像又只有包含模型才是唯一可行的方法。然而，经过了多轮激烈的争论之后，某些人提议了一种具有更低耦合度和高效率的模型，后来演变成分离模型。和包含模型不同，分离模型只是一个理论模型，并没有以现存实现为基础。事实上，之后总共花费了5年的时间才实现出了第1个分离模型（2002年5月）。

我们可能会期望可以扩展预编译头文件的concept，让每次编译可以加载多个头文件。这在原则上将需要一个更细化的预编译方法。然而，这里的主要障碍是预处理程序：在一个头文件中，宏可以改变后面所#include 的头文件的含义。然而，当一个文件经过预编译之后，宏处理也就完成了，这时，对于其他头文件经过预处理程序所获得的结果，要想在该结果中插入一个预编译头文件几乎是不现实的。

有一种尝试提高C++编译器诊断信息的技术，它主要是通过在高层模板插入哑代码来实现的，我们可以参考Jeremy Siek的Concept Check Library（见[BCCL]）——它是Boost库的一部分（见[Boost]）。

### 小结
- 模板给原始的“编译器＋链接器”模型带来挑战，因此，需要使用其他的方法来组织模板代码，这些方法是包含模型、显式实例化和分离模型。
- 在大多数情况下，你应该使用包含模型（就是说，把所有模板代码都放在头文件中）。
- 通过把模板声明代码和模板定义代码放在不同的头文件中，你可以很容易地在包含模型和显式实例化之间做出选择。
- C++标准为模板定义了一个分离的编译模型（使用关键字 export）。然而，该关键字的使用还没有普及，很多编译器也不提供支持。
- 调试模板代码是具有挑战性的。
- 模板实例化体可能会具有很长的名称。
- 为了充分利用预编译代码，要确认#include指示符的顺序是相同的。

# 深入模板
本书的第1部分讲解了有关C++模板的大多数（与语言相关的）概念。日常C++程序设计中所遇到的很多问题，都可以从这部分教程得到解答。
本书的第2部分讨论一些更不常见的问题，也就是当我们深入语言特性，并且希望获得高层次的软件效果时所会遇到的一些问题。
根据自己的阅读习惯，你可以跳过这一部分或者大致浏览一下，而等到后续章节用到这些知识，或者根据书后的索引查找这些知识时，再回来查看这些特定的主题。

我们的目标是让书中的叙述简单且完整，同时尽量保证所讨论的内容准确无误。基于这个目的，我们的例子通常都是简短和人为的；这也确保不会涉及到与所讨论话题无关的内容。

另外，我们还针对C++的模板语言特性，预测了C++模板在将来可能的变化和扩展。简短而言，这一部分的主题包括：
- 基本的模板声明话题。
- 模板中命名机制的含义。
- C++的模板实例化机制。
- 模板实参演绎规则。
- 特化和重载。
- 将来的改变和扩展。

## 深入模板基础
在这一章里，我们将深入回顾在本书第一部分所提到的一些基础知识：模板的声明、模板参数的约束以及模板实参的约束等。

### 参数化声明
C++现今支持两种基本类型的模板：类模板和函数模板，这个分类实际上还包含成员模板。
这些模板的声明和普通类与普通函数的声明很相似，唯一的区别就是模板声明需要引入一个参数化子句，子句的格式大体如下：
```cc
template<...parameters here...>
```
或者
```cc
export template<...parameter here...>
```
我们将在后一节才详细叙述实际中各种模板参数的声明。现在，让我们先来看一个例子，
它给出了函数模板和类模板这两种模板，分别作为类成员的声明和普通名字空间域 的声明：

```cc
template <typename T>
class List {　　　　　　　　　//作为名字空间作用域的类模板
    public:
        template <typename T2>　　　 //成员函数模板
        List (List<T2> const&);　　　//(构造函数)

        ...
};

template <typename T>
template <typename T2>
List<T>::List(List<T2> const& b) //位于类外部的成员
{　　　　　　　　　　　　　　　　　//函数模板定义
    ...
}

template <typename T>
int length(List<T> const&);　　　 //位于外部名字空间

//作用域的函数模板
class Collection {
    template <typename T>　　　　 //位于类内部的成员类模板
    class Node {　　　　　　　　　//该类模板的定义
        ...
    };

    template <typename T>　　　　 //另一个作为成员（即位于外围类的内部）的类模板
    class Handle;　　　　　　　　 //该类模板在此没有定义

    template <typename T>　　//位于类内部的成员函数模板的定义
    T* allco() {　　　　　　　　　//（因此也是一个显式内联函数）
        ...
    }

    ...
};

template <typename T>　　　　　　 //一个在类的外部定义的成员类模板
class Collection::Handle {　　　　//该类模板的定义
    ...
};
```
从上面代码可以看出，在所属外围类的外部进行定义的成员模板可以具有多个模板参数子句 `template<...>`
一个子句用于该模板自身，另一个子句用于外围类模板。
另外，子句的顺序是从最外围的类模板开始，依次到达内部模板。

另外，联合（Union）模板也是允许的（它往往被看作类模板的一种）：
```cc
template <typename T>
union AllocChunk {
    T object;
    unsigned char bytes[sizeof(T)];
};
```
和普通函数声明一样，函数模板声明也可以具有缺省调用实参：
```cc
template <typename T>
void report_top (Stack<T> const&, int number = 10);

template <typename T>
void fill (Array<T>*, T const& = T() );//对于基本类型
                                       //T()为0
```
后一个声明说明了：缺省调用实参可以依赖于模板参数。
显然，当fill()函数被调用时，如果提供了第2个函数调用参数的话，就不会实例化这个缺省实参。
这同时说明了：即使不能基于特定类型T来实例化缺省调用实参 ，也可能不会出现错误。例如：

```cc
class Value {
    public:
        Value(int);　　　　　　　 //不存在缺省构造函数
}；

void init (Array<Value>* array)
{
    Value zero(0);
    fill(array, zero);　　　　　　//正确：没有使用 ＝T()
    fill(array);　　　　　　　　　//错误：使用了=T()，但当T ＝Value时缺省构造函数无效
}
```
除了两种基本类型的模板之外，还可以使用相似的符号来参数化其他的3种声明。这3种声明分别都有与之对应的类模板成员的定义：
- 类模板的成员函数的定义。
- 类模板的嵌套类成员的定义。
- 类模板的静态数据成员的定义。

尽管也可以对这三者进行参数化，但它们的定义使用的都不是自身（first-class，即第一次使用）的模板，而是外围类模板。
它们的参数也都是由外围类模板来决定的。
下面是一个使用这种定义的例子：
```cc
template <int I>
class CupBoard {
    void open();
    class Shelf;
    static double total_weight;
};

template <int I>
void CupBoard<I>::open()
{
...
}

template <int I>
class CupBoard<I>::Shelf {
...
};

template <int I>
double CupBoard<I>::total_weight = 0.0;
```

尽管这种参数化定义通常也被称为模板，但也存在不使用这个概念（即模板）的情况。

#### 虚成员函数
成员函数模板不能被声明为虚函数。这是一种需要强制执行的限制，因为虚函数调用机制的普遍实现都使用了一个大小固定的表，每个虚函数都对应表的一个入口。
然而，成员函数模板的实例化个数，要等到整个程序都翻译完毕才能够确定，这就和表的大小（是固定的）发生了冲突。
因此，如果（将来）要支持虚成员函数模板，将需要一种全新的C++编译器和链接器的机制。

相反，类模板的普通成员可以是虚函数，因为当类被实例化之后，它们的个数是固定的：
```cc
template <typename T>
class Dynamic {
    public:
        virtual ~Dynamic (); //OK：每个Dynamic只对应一个析构函数

        template <typename T2>
        virtual void copy (T2 const&); //错误：在确定Dynamic<T>实例的时候，并不知道copy()的个数
};
```

#### 模板的链接
每个模板都必须有一个名字，而且在它所属的作用域下，该名字必须是唯一的；除非函数模板可以被重载（见第12章）。特别是，类模板不能和另外一个实体共享一个名称，这一点和class类型是不同的：
```cc
int C;
class C;//正确：类名称和非类名称位于不同的名字空间（space）

int X;
template <typename T>
class X;　　 //错误：和变量X冲突

struct S;
template <typename T>
class S;　　 //错误，和struct S冲突
```

模板名字是具有链接的，但它们不能具有C链接。
但我们在大多数情况下所说的是标准的链接，同时也存在非标准的链接，它们可以具有一个依赖于实现的含义（然而，我们还没发现有用于支持非标准模板名字链接的编译器实现）。见下面例子所示：
```cc
extern“C++”template <typename T>
void normal();　　　　　 //这是缺省情况，上面的链接规范可以不写

extern“C”template <typename T>
void invalid();　　　　　//错误的：模板不能具有C链接

extern“Xroma”template <typename T>
void xroma_link();　　　 //非标准的，但某些编译器将来可能支持与
//Xroma语言的链接兼容性
```
模板通常具有外部链接。唯一的例外就是前面有 static 修饰符的名字空间作用域下的函数模板：

```cc
template <typename T>
void external();　　　　 //作为一个声明，引用位于其他文件的、具有
//相同名称的实体；即引用位于其他文件
//的external()函数模板，也称前置声明

template <typaname T>
static void internal();　//与其他文件中具有相同名称的模板没有关系
//即不是外部链接
```

因此我们知道（由于外部链接）：不能在函数内部声明模板

#### 基本模板
如果模板声明的是一个普通声明，我们就称它声明的是一个基本模板。这类模板声明是指：没有在模板名称后面添加一对尖括号（和里面实参）的声明。
```cc
template <typename T> class Box;　　　　　　　//正确：基本模板
template <typename T> class Box<T>;　　　　　 //错误
template <typename T> void translate(T*);　　 //正确：基本模板
template <typename T> void translate<T>(T*);　//错误
```
显然，当声明局部特化的时候，声明的就是非基本模板，我们将在第 12 章进一步讨论局部特化。另外，函数模板必须是基本模板（但13.7节给出了语言将来在这方面可能出现的变化）。

### 模板参数
现今存在3种模板参数：
- 类型参数（它们是使用得最多的）。
- 非类型参数。
- 模板的模板参数。

从前面知道，模板声明要引入参数化子句，模板参数就是在该子句中声明的。这类声明可以把模板参数的名称省略不写（就是说，在后面不会引用该名称的前提下）：
```cc
template <typename, int>　　 //省略不写。 typename后没有写类型参数
class X;
```
显然，如果在模板声明后面需要引用参数名称，那么这些参数名称是一定要写上的。
另外，在同一对尖括号内部，位于后面的模板参数声明可以引用前面的模板参数名称（但前面的不能引用后面的）：
```cc
template <typename T,　　　　//在第2个参数和第3个参数的
T* Root,　　　　 //声明中都使用了第1个参数T
template<T*> class Buf>
class Structure;
```
#### 类型参数
类型参数是通过关键字typename或者class引入的：它们两者几乎是等同的 。
关键字后面必须是一个简单的标识符，后面用逗号来隔开下一个参数声明，等号（＝）代表接下来的是缺省模板实参，一个封闭的尖括号（>）表示参数化子句的结束。

在模板声明内部，类型参数的作用类似于typedef（类型定义）名称。
例如，如果T是一个模板参数，就不能使用诸如class T等形式的修饰名称，即使T是一个要被class类型替换的参数也不可以。
```cc
template <typename Allocator>
class List {
    class Allocator* allocator;　　　 //错误
    friend class Allocator;　　　　　 //错误
    ...
};
```
我们可以设想，这种友元声明机制在将来是有可能被加入标准的。

#### 非类型参数
非类型参数表示的是：在编译期或链接期可以确定的常值 。
这种参数的类型（换句话说，就是这些常值的类型）必须是下面的一种：
- 整型或者枚举类型。
- 指针类型（包含普通对象的指针类型、函数指针类型、指向成员的指针类型）。
- 引用类型（指向对象或者指向函数的引用都是允许的）。

所有其他的类型现今都不允许作为非类型参数使用（但是在将来很可能会增加浮点数类型，参见13.4节）。
或许会令你惊讶的是，在某些情况下，非模板参数的声明也可以使用关键字typename：
```cc
template <typename T,　　　　　　　　　　　　　　　//类型参数
typename T::Allocator* Allocator>　　　//非类型参数
class List;
```

这两种参数的区分很容易：
第 1 个 typename 的后面是一个简单标识符 T，
而第 2 个typename的后面是一个受限的名称（换句话说，是一个包含两个冒号（：：）的名称）。5.1节和9.3.2小节解释了在非类型参数中使用typename关键字的作用。

函数和数组类型也可以被指定为非模板参数，但要把它们先隐式地转换为指针类型，这种转型也称为decay：
```cc
template<int buf[5]> class Lexer;　　 //buf实际上是一个int*类型

template<int* buf> class Lexer;　　　 //正确：这是上面的重新声明
```

非类型模板参数的声明和变量的声明很相似，但它们不能具有static、mutable等修饰符；
只能具有const和volatile限定符。但如果这两个限定符限定的如果是最外层的参数类型，编译器将会忽略它们：
```cc
template<int const length> class Buffer;
//这里的const是没用的，被忽略了

template<int length> class Buffer;　　　　　　//和上面是等同的
```

最后，非类型模板参数只能是右值：它们不能被取址，也不能被赋值。

#### 模板的模板参数
模板的模板参数是代表类模板的占位符（placeholder）。它的声明和类模板的声明很类似，但不能使用关键字struct和union：
```cc
template <template<typename X> class C>　 //正确
void f(C<int>* p);

template <template<typename X> struct C>　//错误
void f(C<int>* p);

template <template<typename X> union C>　 //错误
void f(C<int>* p);
```

在它们声明的作用域中，模板的模板参数的用法和类模板的用法很相似。
模板的模板参数的参数（如下面的A）可以具有缺省模板实参。显然，只有在调用时没有指定该参数的情况下，才会应用缺省模板实参：
```cc
template <template<typename T,
typename A = MyAllocator> class Container>
class Adaptation {
    Container<int> storage;
    //隐式等同于Container<int,MyAllocator>
    ...
};
```

对于模板的模板参数而言，它的参数名称只能被自身其他参数的声明使用。下面的假设例子说明了这一点：
```cc
template <template<typename T, T*> class Buf>
class Lexer {
    static char storage[5];
    Buf<char,&Lexer<Buf>::storage[0]> buf;
};

template <template<typename T> class List>
class Node {
    static T* storage;
    //错误：模板的模板参数的参数在这里不能被使用
    ...
};
```

通常而言，模板的模板参数的参数的名称(如上面例子的T)并不会在后面被用到。因此，该参数也经常被省略不写，即没有命名。例如，前面Adaptation模板的例子可以这样声明：
```cc
template <template <typename, typename = MyAllocator> class Container>
class Adaptation
{
    Container<int> storage;
    //隐式等价于Container<int, MyAllocator>
    ...
};
```

#### 缺省模板实参
现今，只有类模板声明才能具有缺省模板实参（在这方面可能的变化详见 13.3 节）。
从前面我们知道，任何类型的模板参数都可以拥有一个缺省实参，只要该缺省实参能够匹配这个参数就可以。
显然，缺省实参不能依赖于自身的参数；但可以依赖于前面的参数：
```cc
template <typename T, typename Allocator = allocator<T> >
class List;
//就是说，allocator<T>不能依赖于本身参数Allocator,
//但是能依赖于前面参数T
```

与缺省的函数调用参数的约束一样；对于任一个模板参数，只有在之后的模板参数都提供了缺省实参的前提下，才能具有缺省模板实参。
后面的缺省值通常是在同个模板声明中提供的，但也可以在前面的模板声明中提供。下面的例子说明了这一点：
```cc
template <typename T1, typename T2, typename T3,
typename T4 = char, typename T5 = char>
class Quintuple;　　　　 //正确

template <typename T1, typename T2, typename T3 = char,
typename T4, typename T5>
class Quintuple;　　　　 //正确，根据前面的模板声明
                         //T4和T5已经具有缺省值了

template <typename T1 = char, typename T2, typename T3,
typename T4, typename T5>
class Quintuple;　　　　 //错误，T1不能具有缺省实参
                         //因为T2还没有缺省实参
```

另外，缺省实参不能重复声明：
```cc
template <typename T = void>
class Value;

template <typename T = void>
class Value;　　　　 //错误：重复出现的缺省实参
```


### 模板实参
模板实参是指：在实例化模板时，用来替换模板参数的值。我们可以使用下面几种不同的机制来确定这些值：
- 显式模板实参：紧跟在模板名称后面，在一对尖括号内部的显式模板实参值。所组成的整个实体称为template-id。
- 注入式（injected）类名称：对于具有模板参数P1、P2……的类模板X，在它的作用域中，模板名称（即X）等同于template-id：X<P1,P2,……>。
- 缺省模板实参：如果提供缺省模板实参的话，在类模板的实例中就可以省略显式模板实参。然而，即使所有的模板参数都具有缺省值，一对尖括号还是不能省略的（即使尖括号内部为空，也要保留尖括号）。
- 实参演绎：对于不是显式指定的函数模板实参，可以在函数的调用语句中，根据函数调用实参的类型来演绎出函数模板实参。事实上，实参演绎还可以在其他几种情况下出现。另外，如果所有的模板实参都可以通过演绎获得，那么在函数模板名称后面就不需要指定尖括号。

#### 函数模板实参
对于函数模板的模板实参，我们可以显式指定它们，或者借助于模板的使用方式对它们进行实参演绎。例如：
```cc
//details/max.cpp

template <typename T>
inline T const& max(T const& a, T const& b)
{
    return a < b ? b : a;
}

int main()
{
    max<double>(1.0, -3.0);　　　//显式指定模板实参
    max(1.0, -3.0);　　　　　　　 //模板实参被隐式演绎成double
    max<int>(1.0,3.0);　　　　　　//显式的<int>禁止了演绎
                                  //因此返回结果是int类型
}
```
然而，某些模板实参永远也得不到演绎的机会，于是，我们最好把这些实参所对应的参数放在模板参数列表的开始处，从而可以显式指定这些参数，而其他的参数仍然可以进行实参演绎。例如：
```cc
//details/implicit.cpp

template <typename DstT, typename SrcT>
inline DstT implicit_cast (SrcT const& x) //Srct可以被演绎
{　　　　　　　　　　　　　　　　　　　　　　　 //但DstT不可以
    return x;
}

int main()
{
    double value = implicit_cast<double>(-1);
}
```
如果我们调换例子中模板参数的顺序（换句话说，我们把该模板写成：`template<typename SrcT, typename DstT>）`，那么调用implicit_cast就必须显式指定两个模板实参。
由于函数模板可以被重载，所以对于函数模板而言，显式提供所有的实参并不足以标识每一个函数：在一些例子中，它标识的是由许多函数组成的函数集合。下面的例子清楚地说明了这一点：
```cc
template <typename Func, typename T>
void apply (Func func_ptr, T x)
{
    fun_ptr(x);
}

template <typename T> void single(T);
template <typename T> void multi(T);
template <typename T> void multi(T*);

int main()
{
    apply(&single<int>, 3);　　　//正确
    apply(&multi<int>, 7);　　　 //错误：&multi<int>不唯一
}
```
在这个例子中，`apply()`的第一次调用是正确的，因为表达式`&single<int>`的类型是确定的；因此，可以很容易地演绎出Func参数的模板实参值。
然而，在第2次调用中，`&multi<int>`可以是两种函数类型中的任意一种，因此在这种情况下会产生二义性，不能演绎出Func的实参。

另外，在函数模板中，显式指定模板实参可能会试图构造一个无效的C++类型。考虑下面的重载模板函数：
```cc
template<typename T> RT1 test(typename T::X const*);
template<typename T> RT2 test(...);
```
表达式`test<int>`可能会使第1个函数模板毫无意义，因为基本int类型根本就没有成员类型X。
然而，第2个模板就没有这种问题。
因此，表达式`&test<int>`能够标识一个唯一函数的地址（即第2个函数的地址）。
而且，不能用int来替换第1个模板的参数，并不意味着`&test<int>`是非法的（就是下面的SFINAE原则）。实际上，`&test<int>`在这里是有效的，也是合法的。

显然，“替换失败并非错误（substitution-failure-is-not-an-error，SFINAE）”原则是令函数模板可以重载的重要因素。然而，它同时也涉及到值得我们注意的编译期技术。例如，假设类型RT1和RT2的定义如下：
```cc
typedef char RT1;
typedef struct { char a[2];} RT2;
```

于是，我们就可以在编译期检查（也就是说，检查是否可以把它看成一个constant-expression）给定类型T是否具备成员类型X：
```cc
#define type_has_member_type_X(T) (sizeof(test<T>(0)) == 1)
```
为了理解宏中的表达式，采取由外至内的分析方法会比较简单。
首先，对于sizeof表达式，如果选择的是第1个test模板（它返回一个大小为1的char），它将等于1；
而另一个test模板会返回一个大小至少为2的结构（因为它包含一个由两个char组成的数组）。
换句话说，可以把这个宏看成是一个用来确定constant-expression的装置，它可以判断调用`test<T>(0)`时调用的是哪一个test模板。
显然，如果给定的类型T没有成员类型X，那么就不能选择第1个模板。
相反，如果T具有成员类型X，那么根据重载解析规则：从0到空指针常量的类型转换要优先于绑定一个实参给省略号参数（根据重载解析的观点，省略号参数是最弱的绑定类型），将会调用第1个模板。
我们将在第15章讨论类似的技术。

SFINAE 原则保护的只是：允许试图创建无效的类型，但并不允许试图计算无效的表达式。因此，下面的例子是错误的C++例子：
```cc
template<int I> void f(int (&)[24/(4-I)]);
template<int I> void f(int (&)[24/(4+I)]);

int main()
{
    &f<4>;　　　 //错误，替换后第一个除数等于0（不能应用SFINAE）
}
```
即使第2个模板支持这种替换，它的除数也不会为0，但是这个例子是错误的。而且，这种错误只会在表达式自身出现，并不会在模板参数表达式的绑定中出现。因此，下面的例子是合法的：
```cc
template<int N> int g() { return N; }
template<int* P> int g() { return *P;}

int main()
{
    return g<1>();　　　 //虽然数字1不能被绑定到int*参数
}　　　　　　　　　　　　//但是应用了SFINAE原则
```


15.2.2小节和19.3节给出了SFINAE原则的进一步应用。

#### 类型实参
模板的类型实参是一些用来指定模板类型参数的值。我们平时使用的大多数类型都可以被用作模板的类型实参，但有两种情况例外：
- 局部类和局部枚举（换句话说，指在函数定义内部声明的类型）不能作为模板的类型实参。
- 未命名的 class 类型或者未命名的枚举类型1 不能作为模板的类型实参（然而，通过typedef声明给出的未命名类和枚举是可以作为模板类型实参的）。

```cc
struct { int x; } s;
enum { e = 3 } c;
```
s 和 c 具有的就是 unnamed types。

下面的例子很好地说明了这两种例外情况：
```cc
template <typename T> 
class List {
    ...
};

typedef struct {
    double x, y, z;
} Point;

typedef enum { red, green, blue } *ColorPtr;

int main()
{
    struct Association　　　　　　//局部类型
    {
        int* p;
        int* q;
    };

    List<Association*> error1;　 //错误：模板实参中使用了局部类型
    List<ColorPtr> error2;　　　 //错误：模板实参中使用了未命名的
    //类型因为typedef定义的是
    //*ColorPtr，并非ColorPtr
    List<Point> ok;　　　　　　　 //正确：通过使用typedef定义
    //的未命名类型
}
```
通常而言，尽管其他的类型都可以用作模板实参，但前提是该类型替换模板参数之后获得的构造必须是有效的。
```cc
template <typename T>
void clear (T p)
{
    *p = 0;　　　//要求单目运算符*可以用于类型T
}

int main()
{
    int a;
    clear(a);　　//错误：int类型并不支持单目运算符*
}
```

#### 非类型实参
非类型模板实参是那些替换非类型参数的值。这个值必须是以下几种中的一种：
- 某一个具有正确类型的非类型模板参数。
- 一个编译期整型常值（或枚举值）。这只有在参数类型和值的类型能够进行匹配，或者值的类型可以隐式地转换为参数类型（例如，一个char值可以作为int参数的实参）的前提下，才是合法的。
- 前面有单目运算符&（即取址）的外部变量或者函数的名称。对于函数或数组变量，&运算符可以省略。这类模板实参可以匹配指针类型的非类型参数。
- 对于引用类型的非类型模板参数，前面没有&运算符的外部变量和外部函数也是可取的。
- 一个指向成员的指针常量（pointer-to-member constant）；换句话说，类似`&C::m`的表达式，其中C是一个class 类型，m是一个非静态成员（成员变量或者函数）。这类实参只能匹配类型为“成员指针”的非类型参数。

当实参匹配“指针类型或者引用类型的参数”时，用户定义的类型转换（例如单参数的构造函数和重载类型转换运算符）和由派生类到基类的类型转换，都是不会被考虑的；即使在其他的情况下，这些隐式类型转换是有效的，但在这里都是无效的。隐式类型转换的唯一应用只能是：给实参加上关键字const或者volatile。

下面是一些有效的非类型模板实参的例子：
```cc
template <typename T, T nontype_param>
class C;

C<int,33>* c1;　　　　　　　　//整型

int a;

C<int*,&a>* c2;　　　　　　　 //外部变量的地址

void f();

void f(int);

C<void(*)(int),f>* c3;　　　 //函数名称：在这个例子中，重载解析

//会选择f(int),f前面的&隐式省略了
class X {
    Public:
        int n;
        static bool b;
};

C<bool&, X::b>* c4;　　　　　　　 //静态类成员是可取的
                                  //变量（和函数）名称

C<int X::*, &X::n>* c5;　　　//指向成员的指针常量

template<typename T>
void templ_func();

C<void(), &templ_func<double> >* c6;
//函数模板实例同时也是函数
```


模板实参的一个普遍约束是：在程序创建的时候，编译器或者链接器要能够确定实参的值。
如果实参的值要等到程序运行时才能够确定（譬如，局部变量的地址），就不符合“模板是在程序创建的时候进行实例化”的概念了。

另一方面，有些常值不能作为有效的非类型实参，这也许会令你觉得很诧异。这些常值包括：
- 空指针常量。
- 浮点型值。
- 字符串。

有关字符串的一个问题就是：两个完全等同的字符串可以存储在两个不同的地址中。
在此，我们用一种（很笨的）解决方法来表达需要基于字符串进行实例化的模板：引入一个额外的变量来存储这个字符串。
```cc
template <char const* str>
class Message;

extern char const hello[] = ”Hello World!”;
Message<hello>* hello_msg;
```
可以看到，我们使用了关键字extern。因为如果不使用这个关键字，上面的const数组变量将具有内部链接。

下面给出一些错误的例子：
```cc
template<typename T, T nontype_param>
class C;

class Base {
    Public:
    int i;
} base;

class Derived : public Base {
} derived_obj;

C<Base*, &derived_obj>* err1　　　//错误：这里不会考虑
//派生类到基类的类型转换

C<int&, base.i>* err2;　　　　　　//错误：域运算符（.）后面的变量
//不会被看成变量

int a[10];

C<int*, &a[0]>* err3;　　　　　　 //错误：单一数组元素的地址
//并不是可取的
```

#### 模板的模板实参
“模板的模板实参”必须是一个类模板，它本身具有参数，该参数必须精确匹配它“所替换的模板的模板参数”本身的参数。
在匹配过程中，“模板的模板实参”的缺省模板实参 将不会被考虑
（但是如果“模板的模板参数”具有缺省实参，那么模板的实例化过程是会考虑模板的模板参数的缺省实参的）。

因此，下面的例子是错误的：
```cc
#include <list>
//List的声明：
//　namespace std {
//　　　 template <typename T,
//　　　　　　　　　　typename Allocator = allocator<T> >
//　　　 class list;
//　}

template <typename T1,
typename T2,
template<typename> class Container>
//Container期望的是只具有一个参数的模板
class Relation {
    public:
        ...
    private:
        Container<T1> dom1;
        Container<T2> dom2;
};

int main()
{
    Relation<int,double,std::list> rel;
    //错误：std::list是一个具有多个（即2个）参数的模板
    ...
}
```
这里的问题是：标准库中的std::list模板具有两个参数，它的第2个参数（我们称之为内存配置器allocator）具有一个缺省值；
但是当我们匹配std::list和Container参数时，事实上并不会考虑这个缺省值（即认为缺省值并不存在）。

有时，我们可以通过给模板的模板参数添加一个具有缺省值的参数，来解决这个问题。在前面的例子中，我们可以这样改写Relation模板：

```cc
#include <memory>

template <typename T1,
typename T2,
template<typename T,
typename = std::allocator<T> > class Container>
//Container现在就能够接受一个标准容器模板了
class Relation {
    public:
    private:
        Container<T1> dom1;
        container<T2> dom2;
};
```
显然，这并不是一个令人满意的解决方案，但它可以让标准容器模板得到使用。

另外我们注意到了一个事实：
从语法上讲，只有关键字class才能被用来声明模板的模板参数；
但是这并不意味只有用关键字 class 声明的类模板才能作为它的替换实参。
实际上，“struct模板”、“union模板”都可以作为模板的模板参数的有效实参。
这和我们前面所提到的事实很相似：对于用关键字class声明的模板类型参数，我们可以用（满足约束的）任何类型作为它的替换实参。

#### 实参的等价性
当每个对应实参值都相等时，我们就称这两组模板实参是相等的。
对于类型实参，typedef名称并不会对等价性产生影响；就是说，最后比较的还是typedef原本的类型。
对于非类型的整型实参，进行比较的是实参的值；至于这些值是如何表达的，也不会产生影响。
下面的例子说明了这一点：

```cc
template <typename T, int I>
class Mix;

typedef int Int;

Mix<int, 3*3>* p1;
Mix<Int, 4+5>* p2; //p2和p1的类型是相同的
```

另外，从函数模板产生（即实例化出来）的函数一定不会等于普通函数，即便这两个函数具有相同的类型和名称。
这样，针对类成员，我们可以引申出两点结论：

- 从成员函数模板产生的函数永远也不会改写一个虚函数（进一步说明成员函数模板不能是一个虚函数）。
- 从构造函数模板产生的构造函数一定不会是缺省的拷贝构造函数（类似，从赋值运算符模板产生的赋值运算符也一定不会是一个拷贝赋值运算符。但是，后面这种情况通常不会出现问题，因为与拷贝构造函数不同的是：赋值运算符永远也不会被隐式调用）。

### 8.4 友元
友元声明的基本概念是很简单的：授予“某个类或者函数访问友元声明所在的类”的权利。然而，由于以下两个事实，这些简单概念却变得有些复杂：
- 友元声明可能是某个实体的唯一声明。
- 友元函数的声明可以是一个定义。

友元类的声明不能是类定义，因此友元类通常都不会出现问题。在引入模板之后，友元类声明的唯一变化只是：可以命名一个特定的类模板实例为友元。
```cc
template <typename T>
class Node;

template <typename T>
class Tree {
    friend class Node<T>;
    ...
};
```
显然，如果要把类模板的实例声明为其他类（或者类模板）的友元，该类模板在声明的地方必须是可见的。然而，对于一个普通类，就没有这个要求：
```cc
template <typename T>
class Tree {
    friend class Factory;　　//正确：即使这里是Factory的首次声明
    friend class Node<T>;　　//如果Node在此是不可见的
                             //这条语句就是错误的
};
```
#### 友元函数
通过确认紧接在友元函数名称后面的是一对尖括号，我们可以把函数模板的实例声明为友元。
尖括号可以包含模板实参，但也可以通过调用参数来演绎出实参。
如果全部实参都能够通过演绎获得的话，那么尖括号里面可以为空：
```cc
template <typename T1, typename T2>
void combine(T1,T2);

class Mixer {
    friend void combine<>(int&, int&);
    //正确：T1 = int&, T2 = int&

    friend void combine<int, int>(int, int);
    //正确：T1 = int, T2 = int

    friend void combine<char>(char, int);
    //正确：T1 = char, T2 = int

    friend void combine<char>(char&, int);
    //错误：不能匹配上面的combine()模板

    friend void combine<>(long, long) { ...}
    //错误：这里的友元声明不允许出现定义。
};
```
另外应该知道：我们不能在友元声明中定义一个模板实例（我们最多只能定义一个特化）；因此，命名一个实例的友元声明是不能作为定义的。
如果名称后面没有紧跟一对尖括号，那么只有在下面两种情况下是合法的：
- 如果名称不是受限的（就是说，没有包含一个形如双冒号的域运算符），那么该名称一定不是（也不能）引用一个模板实例。如果在友元声明的地方，还看不到所匹配的非模板函数（即普通函数），那么这个友元声明就是函数的首次声明。于是，该声明可以是定义。
- 如果名称是受限的（就是说前面有双冒号::），那么该名称必须引用一个在此之前声明的函数或者函数模板。在匹配的过程中，匹配的函数要优先于匹配的函数模板。然而，这样的友元声明不能是定义。

下面的例子可以说明这些情况：
```cc

void multiply (void*);　　　　　　　　//普通函数

template <typename T>
void multiply(T);　　　　　　　　　　 // 函数模板

class Comrades {
    friend void multiply(int) { }
    //定义了一个新的函数 ：：multiply(int)
    //非受限函数名称，不能引用模板实例

    friend void ::multiply(void*)
    //引用上面的普通函数，
    //不会引用multiply<void*>实例

    friend void ::multiply(int);
    //引用一个模板实例

    friend void ::multiply<double*>(double*)
    //受限名称还可以具有一对尖括号
    //但模板在此必须是可见的

    friend void ::error() { }
    //错误：受限的友元不能是一个定义
};
```

在前面的例子中，我们是在一个普通类里面声明友元函数。
如果需要在类模板里面声明友元函数，前面的这些规则仍然是适用的，唯一的区别就是：可以使用模板参数来标识友元函数。

```cc
template <typename T>
class Node {
    Node<T>* allocate();
    ...
};

template <typename T>
class List {
    friend Node<T>* Node<T>::allocate();
    ...
};
```
然而，如果我们在类模板中定义一个友元函数，那么将会出现一个很有趣的现象。
因为对于任何只在模板内部声明的实体，都要等到模板被实例化之后，才会是一个具体的实体；在这之前该实体是不存在的。类模板的友元函数也是如此。
考虑下面的例子：
```cc
template <typename T>
class Creator {
    friend void appear() {　　　　//一个新函数：：appear()
        ...　　　　　　　　　　   //但要等到Creator被实例化之后
                                  //才存在
    }
};

Creator<void> miracle;　　　　　　//这时才生成：：appear()
Creator<double> oops;　　　　　　 //错误：::appear()第2次被生成
```
在这个例子中，两个不同的实例化过程生成了两个完全相同的定义（即 appear 函数），这违反了ODR原则。

因此，我们必须确定：
在模板内部定义的友元函数的类型定义中，必须包含类模板的模板参数（除非我们希望在一个特定的文件中禁止多于一个的实例被创建，但这种用法很少）。
让我们这样修改前面的例子：
```cc
template <typename T>
class Creator {
    friend void feed(Creator<T>*) {　//每个T都生成一个不同
                                     //的::feed()函数
        ...
    }
};

Creator<void> one;　　　 //生成::feedCreator<void>*）
Creator<double> two;　　 //生成::feed(Creator<double>*)
```
在这个例子中，每个Creator的实例都生成了一个不同的feed()函数。
另外我们应该知道：尽管这些函数是作为模板的一部分被生成的，但函数本身仍然是普通函数，而不是模板的实例。

最后一点就是：由于函数的实体处于类定义的内部，所以这些函数是内联函数。
因此，在两个不同的翻译单元中可以生成相同的函数，具体细节请参见9.2.2小节和11.7节。

#### 友元模板
我们通常声明的友元只是：函数模板的实例或者类模板的实例，我们指定的友元也只是特定的实体。
然而，我们有时候需要让模板的所有实例都成为友元，这就需要声明友元模板。例如：

```cc
class Manager {
    template <typename T>
    friend class Task;

    template <typename T>
    friend void Schedule<T>::dispatch(Task<T>*);

    template <typename T>
    friend int ticket() {
    return ++Manager::counter;
    }

    static int counter;
};
```
和普通友元的声明一样，只有在友元模板声明的是一个非受限的函数名称，并且后面没有紧跟尖括号的情况下，该友元模板声明才能成为定义。

友元模板声明的只是基本模板和基本模板的成员。当进行这些声明之后，与该基本模板相对应的模板局部特化和显式特化都会被自动地看成友元。

### 本章后记
自从20世纪80年代末C++模板的概念提出以来，C++模板的整体概念和语法就保持得比较稳定。类模板和函数模板、类型参数和非类型参数都属于最初功能的一部分。

然而，后来（主要）在C++标准库的推动下，给最初的设计添加了一些很重要的特性。成员模板就是其中一个最重要的补充。有趣的是，C++标准的正式投票只是把成员函数模板加入到标准中，成员类模板则是在后来的编辑勘误表中才被加入标准的。

友元模板、缺省模板实参、模板的模板参数都是不久前才添加进语言的。声明“模板的模板参数”的能力通常被称为更高层次的泛化（higher-order genericity）。最初是为了在C++标准库中支持某种配置器模型，才引入模板的模板参数的；但后来这种配置器模型被一种不需要依赖于模板的模板参数的配置器给取代了。然后，由于模板的模板参数的规范不完整，差一点就要把它（模板的模板参数）从语言中删除了。直到临近标准化过程的时候，这份（模板的模板参数的）规范才算比较完整。最后，委员会成员经过投票表决，通过了保留模板的模板参数的决议，它的规范才得以逐渐走向完整。

## 模板中的名称
在大多数程序设计语言中，名称都是一个很基本的概念。借助名称，程序员可以引用前面已经构造完毕的实体。当C++编译器遇到一个名称时，它会查找该名称，来确认它引用的是哪个实体。从实现者的角度出发，就名称而言，C++是一门相当棘手的语言。譬如 C++语句`x*y`，如果x和y都是变量的名称，那么这个语句代表一个乘积；但如果x是一个类型的名称，那么这个语句声明y是一个指向类型为x的实体的指针。

这个小例子说明了C++（与C一样）是一种上下文相关语言：对于C++的一个构造，我们不能脱离它的上下文来理解它。但这又和模板有哪些联系呢？事实上，模板也是一种构造，它必须处理多种上下文相关信息：
- 模板出现的上下文；
- 模板实例化的上下文；
- 用来实例化模板的模板实参的上下文。
因此，在C++中，小心处理各种（上下文的）名称的做法就不足为奇了。

### 名称的分类
C++使用了多种多样的方法来对名称进行分类。为了有助于理解名称的众多术语，我们给出了表9.1，它描述了这些分类的概念。
幸运的是，你只需要熟悉下面两个主要的命名概念，就可以深入理解大多数模板话题：

- 如果一个名称使用域解析运算符（即::）或者成员访问运算符（即 .或->）来显式表明它所属的作用域，我们就称该名称为**受限名称**。例如，this->count就是一个受限名称，而count则不是（即使前面没有符号，count实际上引用的也是一个类成员）。
- 如果一个名称（以某种方式）依赖于模板参数，我们就称它为**依赖型名称**。例如，如果T是一个模板参数，`std::vector<T>::iterator`就是一个依赖名称；但如果T是一个已知的typedef（类型定义，例如int），那么`std::vector<T>::iterator`就不是一个依赖名称。

### 名称查找
C++中的名称查找会涉及到许多很小的细节，但我们在此只是讨论一些主要的概念。只有在涉及到下面两种情况的时候才会给出名称查找的相关细节：
- 如果以直观的态度来对待会犯错的普通例子；
- C++标准（以某种方式）给出的那些错误的例子。

受限名称的名称查找是在一个受限作用域内部进行的，该受限作用域由一个限定的构造所决定。
如果该作用域是一个类，那么查找范围可以到达它的基类；但不会考虑它的外围作用域。
下面的例子说明了这些基本原则：

```cc
int x;

class B {
    public:
    int i;
};

class D : public B {
};

void f(D* pd)
{
    pd->i = 3;　　　 //找到B::i
    D::x = 2;　　　　//错误：并不能找到外围作用域中的::x
}
```
非受限名称的查找则相反，它可以（由内到外）在所有外围类中逐层地进行查找
（但在某个类内部定义的成员函数定义中，它会先查找该类和基类的作用域，然后才查找外围类的作用域），这种查找方式也被称为普通查找。
下面的例子说明普通查找的一些基本概念：

```cc
extern int count;　　　　　　　  //(1)
int lookup_example (int count)　 //(2)
{
    if(count < 0) {
        int count = 1;　　　　　 //(3)
        lookup_example(count);　 //非受限的count将会引用（3）
    }
    return count + ::count;　　　//第1个（非受限的）count
                                 //引用(2),第2个（受限的）count引用（1）
}
```
对于非受限名称的查找，最近增加了一项新的查找机制——除了前面的普通查找——就是说非受限名称有时可以使用依赖于参数的查找（argument-dependent lookup，ADL）。
在阐述ADL的细节之前，让我们先通过前面的max()模板来说明这种机制的动机：

```cc
template <typename T>
inline T const& max (T const& a, T const& b)
{
    return a < b ? b : a;
}
```
假设我们现在要让“在另一个名字空间中定义的类型”使用这个模板函数：
```cc
namespace BigMath {

    class BigNumber {
        ...
    };
    bool operator < (BigNumber const&, BigNumber const&);
    ...
}

using BigMath::BigNumber;
void g(BigNumber const& a, BigNumber const& b)
{
    ...
    BigNumber x = max(a, b);
    ...
}
```
问题是 max()模板并不知道 BigMath 名字空间，因此普通查找也找不到“应用于BigNumber 类型值的 operator<”。
如果没有特殊规则的话，这种限制将会大大减少 C++名字空间中模板的应用。ADL正是这个特殊规则，也正是解决这种限制的关键之处。

#### Argument-Dependent Lookup（ADL）
ADL只能应用于非受限名称。
在函数调用中，这些名称看起来像是非成员函数。
对于成员函数名称或者类型名称，如果普通查找能找到该名称，那么将不会应用ADL。
如果把被调用函数的名称（如max）用圆括号括起来，也不会使用ADL。

否则，如果名称后面的括号里面有（一个或多个）实参表达式，那么ADL将会查找这些实参的associated class 关联类）和associated namespace（关联名字空间）。
对于associated class和associated namespace的准确定义，我们将留到后面给出。但从直观上来看，我们可以认为是：
与给定类型直接相关的所有namespace和class。
例如，如果某一类型是指向class X的指针，那么它的associated class和associated namespace会包含X和X所属的任何class和namespace.

对于给定类型，对于由associated class和associated namespace所组成的集合的准确定义，我们可以通过下列规则来确定：
- 对于基本类型，该集合为空集。
- 对于指针和数组类型，该集合是所引用类型（譬如对于指针而言，它所引用的类型是“指针所指对象”的类型）的associated class和associated namespace。
- 对于枚举类型，associated namespace指的是枚举声明所在的namespace。对于类成员，associated class指的是它所在的类。
- 对于class类型（包含联合类型），associated class集合包括：该class类型本身、它的外围类型、直接基类和间接基类。associated namespace 集合是每个 associated class 所在的namespace。如果这个类是一个类模板实例化体，那么还包含：模板类型实参本身的类型、声明模板的模板实参所在的class和namespace。
- 对于函数类型，该集合包括所有参数类型和返回类型的associated class 和associated namespace。

对于类X的成员指针类型，除了包括成员相关的associated anmespace和associated calss，该集合还包括与X相关的associated namespace和associated class。

至此，ADL会在所有的associated class和associated namespace中依次地查找，就好像依次地直接使用这些名字空间进行限定一样。
唯一的例外情况是：它会忽略using-directives （using指示符）。下面的例子说明了这一点：
```cc
//details /adl.cpp
#include <iostream>

namespace X {
    template<typename T> void f(T);
}

namespace N {
    using namespace X;

    enum E { e1 };

    void f(E) {
        std::cout << "N::f(N::E) called\n";
    }
}

void f(int)
{
    std::cout << "::f(int) called\n";
}

int main()
{
    // ::f(int) called
    ::f(N::e1);　 // 受限函数名称：不会使用ADL

    // N::f(N::E) called
    f(N::e1);　　 // 普通查找将找到f();　ADL 将找到 N::f(),
}　　　　　　　　 //　将会调用后者
```
我们可以看出：在这里例子中，当执行ADL的时候，名字空间N中的using-directive被忽略了。因此，在这个main()函数内部的调用中，是肯定不会调用X::f()的。


#### 友元名称插入
在类中的友元函数声明可以是该友元函数的首次声明。
在此前提下，对于包含这个友元函数的类，假设它所属的最近名字空间作用域（可能是全局作用域）为作用域A，我们就可以认为该友元函数是在作用域A中声明的。
这里，我们会遇到一个颇有争议的话题：在插入友元声明的（类）作用域中，该友元声明是否应该是可见的呢？
实际上，多数情况下只有在模板中才会出现这个问题，考虑下面的例子：

```cc
template <typename T>
class C {
    ...
    friend void f();
    friend void f(C<T> const&);
    ...
};

void g(C<int>* p)
{
    f();　　　　 //f()在此是可见的吗
    f(*p);　　　 //f(C<int> const&)在此是可见的吗
}
```
这里的问题是：如果友元声明在外围类中是可见的，那么实例化一个类模板可能会使一些普通函数（如 f() ）的声明也成为可见的。
一些程序员会认为这样很出乎意料。因此 C++标准规定：通常而言，友元声明在外围（类）作用域中是不可见的。

然而，存在一个有趣的编程技术，它依赖于只在友元声明中声明（或者定义）某个函数（见11.7节）。
因此C++标准还规定：如果友元函数所在的类属于ADL的关联类集合，那么我们在这个外围类是可以找到该友元声明的。

再次考虑上面的例子。调用f()并没有关联类或者名字空间，因为它没有任何参数，不能利用ADL，因此是一个无效调用。
然而，f(*p)具有关联类`C<int>`（因为*p的类型是`C<int>`）；因此，只要我们在调用之前完全实例化了类`C<int>`，就可以找到第2个友元函数（即f）声明。
为了确保这一点，我们可以假设：对于涉及在关联类中友元查找的调用，实际上会导致该（关联）类被实例化（如果还没有实例化的话）

#### 插入式类名称
如果在类本身的作用域中插入该类的名称，我们就称该名称为插入式类名称。
它可以被看作位于该类作用域中的一个非受限名称，而且是可访问的名称
（然而，如果作为受限名称，该名称是不可访问的，因为我们在此并不是使用该名称来表示构造函数）。例如下面的例子：
```cc
//details/inject.cpp
#include <iostream>

int C;

class C {
    private:
        int i[2];
    public:
        static int f() {
            return sizeof(C);
        }
};

int f()
{
    return sizeof(C);
}

int main()
{
    std::cout << "C::f() = " << C::f() << ","
    << " ::f() = " << ::f() << std::endl;
}
```

从运行结果可以知道：成员函数`C::f()`返回类型C的大小；而函数`::f()`返回变量C的大小（即int对象的大小）。

类模板也可以具有插入式类名称。然而，它们和普通插入式类名称有些区别：
它们的后面可以紧跟模板实参（在这种情况下，它们也被称为插入式类模板名称）。
但是，如果后面没有紧跟模板实参，那么它们代表的就是用参数来代表实参的类（例如，对于局部特化，还可以用特化实参代表对应的模板实参）。
这同时说明了下面的情况：

```cc
template <template<typename> class TT> 
class X {
};

template <typename T> 
class C {
    C* a;　　　　　　//正确：等价于C<T>* a
    C<void> b;　　　 //正确
    X<C> c;　　　　　//错误：后面没有模板实参列表的C不被看作模板
    X<::C> d;　　　　//错误： <: 是 [ 的另一种标记（表示）
    X< ::C> e;　　　 //正确：在 < 和 ：：之间的空格是必需的
};
```

从上面代码我们可以知道如何使用非受限名称来引用插入式名称（即C），如果这些非受限名称的后面没有紧跟模板实参列表，那么是不会被看成模板名称的。
为了避免这种情况，我们可以在（要查找的）模板名称前面加上作用域限定符（::），这样就可以顺利通过编译。
但在这里我们要避免创建一个所谓的连字符（<：）标记，该标记实际上会被解释为一个左括号。
这种情况虽然很少出现，但如果出现的话，编译器给出的诊断信息往往是令人困惑的。

### 解析模板
大多数程序设计语言的编译都包含两个最基本的步骤：符号标记——和解析。扫描过程把源代码当作字符串序列读入，然后根据该序列生成一系列标记。
例如，当看到字符串序列`int* p = 0;`时，扫描器会生成这样标记来描述：
关键字int、一个符号/运算符 *、一个标识符p、一个符号/运算符 ＝、一个整数0和一个符号/运算符 ;（分号）。

接下来，解析器会递归地减少标记，或者把前面已经找到的模式结合成更高层次的构造，从而在标记序列中不断对应已知模式。
例如，标记0是一个有效表达式，*和后面p的组合也是一个有效的声明，而该声明和后面的“=”、再后面的表达式“0”也组成一个更长的有效声明。
最后，关键字int是一个已知的类型名称。因此，当它后面跟随声明 `*p = 0`时，你实际上进行的是：初始化p的声明。

#### 非模板中的上下文相关性
你可能已经知道（或者期望）解析要比扫描困难。幸运的是，解析已经是一门发展得相当成熟的理论，大多数语言在利用这一理论进行解析也不会遇到大的困难。
然而，解析理论主要是面向上下文无关语言的，而我们在前面已经知道C++是上下文相关语言。
为了解决这个相关性，C++编译器会使用一张符号表把扫描器和解析器结合起来。
当解析某个声明的时候，该声明就会添加到表中。
当扫描器找到一个标识符时，它会在符号表中进行查找，如果发现该标识符是一个类型，就会注释这个所获得的标记（标识符）。

例如，如果C++编译器看到：
```cc
x*
```
那么扫描器会查找x，如果它发现x是一个类型，那么解析器接下来会看到：
```cc
identifier, type, x
symbol, *
```
并且可以得出结论：这里开始了一个声明。然而，在上述查找过程中，如果发现x并不是一个类型，解析器就会从扫描器获得以下标记：
```cc
identifier, nontype, x
symbol, *
```

因此这个构造就被有效地解析为一个乘积。这些原则的细节要依赖于编译器的具体实现策略，但大体都是差不多的。

下面的表达式给出了另一个上下文相关的例子：
```cc
X<1>(0)
```
如果X是类模板名称的话，那么这个表达式将会把整数0强制类型转换为（从模板产生的）X<1>类型。如果X不是一个模板，那么该表达式等价于：
```cc
(X < 1) > 0
```
就是说，现在是让X和1先比较大小，然后把比较结果（true或false），显式地转换为1或0，最后再让转换结果和后面的0进行比较大小。
虽然这类C++代码很少使用，但这类代码事实上是有效的（对C语言也是有效的）。
因此，C++解析器会先查找 < 之前的名称，只有在该名称是一个模板名称时，才会把 < 看成左尖括号。其他情况下，都会把 < 看成小于号。

令人感到遗憾的是，这类上下文相关性都是由于选择尖括号来界定模板参数列表所造成的。下面是另一个这种例子：
```cc
template<bool B>
class Invert {
    public:
        static bool const result= !B;
};

void g()
{
    bool test = Invert<(1>0)>::result;　　　　//圆括号是必需的
}
```


如果省略`Invert<（1>0）>`中的圆括号，那么第1个大于号（>）会被错误地理解为模板实参列表的结束标记。这将会令这行代码无效，
因为编译器会等价地把该代码看成`（（Invert <1>））0>::result [20]` 。

尖括号给扫描器带来的问题还不止这些。我们在前面已经提到（见3.2节）：在引入嵌套template-id的时候，要在两个大于号之间添加空格。譬如：
```cc
List<List<int> > a;
//这里的空格是必须的
```

事实上，上面（两个大于号）之间的空格是必须的：如果没有这个空格，那么两个 > 会被组合成一个右移标记>>，从而也就不会被看成两个分开的标记。
这要归因于所谓的maximum munch扫描原则：C++实现应该让一个标记具有尽可能多的字符。

对于模板的初学者而言，这个话题可能会是一块绊脚石。
因此一些C++编译器的实现根据实际情况进行了修改，从而在此特殊条件下，会把 >> 看成两个分开的>（并且给出一个警告说明这种写法并不是有效的C++）。
C++委员会也考虑要在将来C++标准的版本中更正这个问题（见13.1节）。

另一个关于maximum munch的例子，也是一个少有人知的例子。在使用尖括号的时候，当遇到作用域解析运算符（::）的时候要格外小心：
```cc
class X {
    .
};

List<::X> many_X;　　　　//语法错误
```


这个例子的问题是：字符序列 <: 的结果会是一个（所谓的）两字符（digraph），它是符号 [ 的另一种表示方法。
因此，编译器实际上看到的是：`List [:X> many_X`，而这个声明并没有实际意义。于是，我们需要在 < 和 :: 之间添加一些空格：

```cc
List< ::X> many_X;
//这里的空格是必须的
```

#### 依赖型类型名称
有关模板名称的问题主要是：这些名称不能有效地确定。
尤其是模板中不能引用其他模板的名称，因为其他模板的内容可能会由于显式特化（见第12章）而使原来的名称失效。考虑下面我们所假设的例子：
```cc
template <typename T>
class Trap {
    public:
        enum { x };　　　//(1)这里的x不是一个类型
};

template<typename T>
class Victim {
    public:
        int y;
        void poof() {
            Trap<T>::x*y;　　　　//（2）这里究竟是声明还是乘积
        }
};

template<>
class Trap<void> {　　　　　　//会给后面带来麻烦的特化
    public:
        typedef int x;　　　　　 //（3）这里的x是一个类型
};

void boom(Victim<void>& bomb)
{
    bomb.poof();
}
```

当编译器解析（2）时，它必须确定它所看到的是一个声明还是一个乘积，而这个结果要取决于依赖型受限名称`Trap<T>::x`是否是一个类型名称。
编译器这时会查找模板Trap，并且在上面找到这个模板；根据行（1），`Trap<T>::x`并不是一个类型，从而让我们相信行（2）是一个乘积。
然而，在后面T为void的特化中，我们改写了（泛型的）`Trap X<T>::x`，让它变成一个类型，这完全违背了前面的源代码。
因为在这种情况下，类Victim中的`Trap<T>::x`实际上是一个int类型。

C++的语言定义通过下面规定来解决这个问题：通常而言，依赖型受限名称并不会代表一个类型，除非在该名称的前面有关键字typename前缀。
对于类型名称，如果不加上typename前缀，那么在替换模板实参之后，就不会被看成类型名称，从而程序也是无效的，你的C++编译器还会抱怨在实例化过程中发现了错误。
另一方面，我们应该知道typename的这种用法和前面用于表示模板类型参数的用法是不一样的；在这里你不能使用关键字class来等价替换关键字 typename。
总之，当类型名称具有以下性质时，就应该在该名称前面添加 typename前缀：
1. 名称出现在一个模板中。
2. 名称是受限的。
3. 名称不是用于指定基类继承的列表中，也不是位于引入构造函数的成员初始化列表中。
4. 名称依赖于模板参数。

而且，只有当前面3个条件同时满足的情况下，才能使用typename前缀。为了说明这一点，让我们考虑下面这个错误的例子：
```cc
template<typename1 T>
struct S : typename2 X<T>::Base {
    S() : typename3 X<T>::Base(typename4 X<T>::Base(0) ) { }

    typename5 X<T> f() {
        typename6 X<T>::C *p;//指针p的声明
        X<T>::D* q;　　　　　　　 //乘积
    }
    typename7 X<int>::C * s;
};

struct U {
    typename8 X<int>::C * pc;
};
```

在上面的代码中，typename的每次出现（不管正确与否）我们都给出它的下标，这样有利于下面的引用。
第1个typename1 用来引入一个模板参数，因此并不适用前面的规则。
第2个和第3个typename的使用属于前面规则（3）所禁止的用法：在这两种情况下，基类名称都不能添加typename前缀。
然而，第4个typename4 是必不可少的，因为这里的基类名称既不是位于初始化列表，也不是位于派生类的继承约定；而是为了基于实参 0 构造一个临时`X<T>::Base`表达式（也可以是某种强制类型转型）。
第5个typename同样也是禁止的，因为它后面的名称`X<T>`并不是一个受限名称。
对于第6个typename，如果是期望声明一个指针，那么这个 typename 就是必需的。下一行省略了关键字 typename，因此也就被编译器解释为一个乘积。
第7个typename是可选（可有可无）的，因为它符合前面的3条规则，但不符合第4条规则。
最后，第8个typename是禁止的，因为它并不是在模板中使用。

#### 依赖型模板名称
如果一个模板名称是依赖型名称，我们将会遇到与上一小节类似的问题。
通常而言，C++编译器会把模板名称后面的 < 看作模板参数列表的开始；但如果该 < 不是位于模板名称后面，那么编译器将会把它当作小于号处理。
和类型名称一样，要让编译器知道所引用的依赖型名称是一个模板，需要在该名称前面插入template关键字，否则的话编译器将假定它不是一个模板名称：

```cc
template <typename T>
class Shell {
    public:

        template<int N>
        class In {
            public:

                template<int M>
                class Deep {
                    public:
                        virtual void f();
                };

        };
};

template<typename T, int N>
class Weird {
    public:
        void case1(typename Shell<T>::template In<N>::template Deep<N>* p) {
            p->template Deep<N>::f();　　//禁止虚函数调用
        }

        void case2(typename Shell<T>::template In<N>::template Deep<N>& p){
            p.template Deep<N>::f();　　 //禁止虚函数调用
        }
};
```

这个多少有些复杂的例子给出了何时需要在运算符（::，->和.，用于限定一个名称）的后面使用关键字 template。
更明确的说法是：如果限定符号前面的名称（或者表达式）的类型要依赖于某个模板参数，并且紧接在限定符后面的是一个 template-id（就是指一个后面带有尖括号内部实参列表的模板名称），那么就应该使用关键字 typename。例如，在下面的表达式中：
```cc
p.template Deep<N>::f()
```
p的类型要依赖于模板参数T。然而，C++编译器并不会查找Deep来判断它是否是一个模板；
因此我们必须显式指定 Deep 是一个模板名称，这可以通过插入 template 前缀来实现。
如果没有这个前缀的话，`p.Deep<N>::f()`将会被解析为`（（p.Deep）< N）>f()`，这显然并不是我们所期望的。
我们还应该看到：在一个受限名称内部，可能需要多次使用关键字 template，因为限定符本身可能还会受限于外部的依赖型限定符
（我们可以从前面例子中 case1 和 case2的参数中看到这一点）。

如果例子中的关键字template被省略了，那么左尖括号和右尖括号会被解析为小于号和大于号。
然而，如果没有必要，我们并不允许到处使用这个关键字；你也不应该在代码中充斥很多没必要的template限定符。

#### using-declaration中的依赖型名称
using-declaration会从两个位置（即类和名字空间）引入名称。
如果引入的是名字空间，将不会涉及到上下文问题，因为并不存在名字空间模板。
实际上，从类中引入名称的using-declaration 的能力是很有限的：只能把基类中的名称引入到派生类中。
这种using-declaration的行为有些类似于派生类访问基类的符号链接或者快捷方式。
因此，可以让派生类的成员访问被using-declaration的名称，就好像该名称是在派生类中声明的成员一样。
下面用一个非模板例子来说明这个问题：
```cc
class BX {
    public:
        void f(int);
        void f(char const*);
        void g();
};

class DX : private BX {
    public:
        using BX::f;
};
```

上面的using-declaration引入基类（Bx）中的名称f到派生类DX中。
在这个例子中，名称f关联着两个声明，但我们这里强调的是一种名称机制，并不关注该名称是否是一个单一声明。
另外，using-declaration的这种用法可以让以前不能访问的成员现在变成可访问的。
从例子中可以看出，基类（和它的成员）对派生类DX是私有的（因为私有继承），除非DX是在公共接口中引入BX::f，否则DX的客户端是不可以访问BX::f 的。
但是using-declaration使这里的 BX::f 变成可访问的，这就违背了 C++早期的访问级别声明机制
（如public/private/protected，C++的将来版本可能不会包含这个机制）：
```cc
class DX : private BX {
    public:
        BX::f;　　　 //访问声明语法被取代
        //用using BX::f来代替
};
```
现在，当using-declaration是从依赖型类中引入名称的时候，我们虽然知道这个引入的名称，但并不知道该名称究竟是一个类型名称、模板名称、还是一个其他的名称：
```cc
template <typename T>
class BXT {
    public:
        typedef T Mystery;
        template<typename U>
        struct Magic;
};

template <typename T>
class DXTT : private BXT<T> {
    public:
        using typename BXT<T>::Mystery;
        Mystery* p; //如果上面不使用typename，将会是一个语法错误
};
```
而且，如果我们期望使用using-declaration所引入的依赖型名称是一个类型，我们必须插入关键字typename来显式指定。
另一方面，比较奇怪的是，C++标准并没有提供一种相似的机制，来指定依赖型名称是一个模板。下面的代码段说明了这个问题：
```cc
template <typename T>
class DXTM : private BXT<T> {
    public:
        using BXT<T>::template Magic;　　 //错误：非标准的
        Magic<T>* plink;　　　　　　　　　//语法错误：Magic并不是
        //一个已知模板
};
```
这应该是标准规范的一个疏忽，在将来的版本中，上面的构造（指 Magic）可能会是合法的。

#### ADL和显式模板实参
考虑下面的例子：

```cc
namespace N {
    class X {
        ...
    };

    template<int I> void select(X*);
}

void g(N::X* xp)
{
    select<3>(xp);　　　 //错误：没有ADL
}
```
在这个例子中，调用`select<3>(xp)`的时候，我们可能会期望通过ADL来找到模板select()；
然而，实际情况并不是这样的。因为编译器在不知道<3>是一个模板实参列表之前，是无法断定xp是一个函数调用实参的；
反过来，如果要判定<3>是一个模板实参列表，我们需要先知道select()是一个模板。
这种是先有鸡还是先有蛋的问题没法解决，因此编译器只能把上面表达式解析成`(select<3)>(xp)`，但这并不是我们所期望的，也是毫无意义的。

### 派生和类模板
类模板可以继承也可以被继承。
对于大多数情况而言，模板和非模板的继承没有很重要的区别。
然而，要从“依赖型名称所引用的基类”派生一个类模板的情况下，这两者有一个重要而微妙的区别。
让我们先来看一个简单一些的例子，它针对的是非依赖型基类。

#### 非依赖型基类
在一个类模板中，一个非依赖型基类是指：无需知道模板实参就可以完全确定类型的基类。就是说，基类名称是用非依赖型名称来表示的。例如：
```cc
template <typename X>
class Base {
    public:
        int basefield;
        typedef int T;
};

class D1 : public Base<Base<void> > {　　 //实际上不是模板
    public:
        void f() { basefield =3; }
};

template<typename T>
class D2 : public Base<double> { //非依赖型基类
    public:
        void f() { basefield =7; }　 //正常访问继承成员
        T strange;　　　　　　　　　　//T是Base<double>::T，而不是模板参数
};
```
模板中的非依赖型基类的性质和普通非模板类中的基类的性质很相似，但存在一个很细微（会令你感到意外）的区别：
对于模板中的非依赖型基类而言，如果在它的派生类中查找一个非受限名称，那就会先查找这个非依赖型基类，然后才查找模板参数列表。
这就意味着：在前面的例子中，类模板D2的成员strange的类型一直都会是`Base<double>::T`中对应的T类型（也就是int）。
例如，下面的函数是无效的C++代码（假设已经声明了上面的代码）：
```cc
void g (D2<int*>& d2, int* p)
{
    d2.strange = p;　　　//错误，类型不匹配
}
```

这是一个违背直观的查找，编写派生类模板的程序员应该格外注意非依赖型基类中的这些名称；
即使这种派生是间接的，或者这些名称是私有的，也是这样查找。
事实上，在参数化实体（例如上面的D2）的作用域中，如果能够先查找模板参数可能是更加可取的，可惜事实并不如此。

#### 依赖型基类
在前面的例子中，基类是完全确定的，它并不依赖于模板参数。这就意味着：一看到模板的定义，C++编译器就可以在这些基类中查找非依赖型名称。而另一种候选方法（C++标准并不允许这种方法）会延迟这类名称的查找，只有等到进行模板实例化时，才真正查找这类名称。这种候选方法的缺点是：它同时也将诸如漏写某个符号导致的错误信息，延迟到实例化的时候产生。因此，C++标准规定：对于模板中的非依赖型名称，将会在看到的第一时间进行查找。有了这个概念之后，让我们考虑下面的例子：

```cc
template<typename T>
class DD : public Base<T> {　　　　　 //依赖型基类
    public:
        void f() { basefield = 0; }　　　 //(1)problem...
};

template<>　　　 //显式特化
class Base<bool> {
    public:
        enum { basefield = 42 };　　　　　//（2）tricky!
};

void g(DD<bool>& d)
{
    d.f();　　　　　　　　　　　　　　//(3)oops?
}
```

